{"ast":null,"code":"import { convertToPath, Path, Shape } from '@antv/g';\nimport { get } from '@antv/util';\nimport { copyAttributes } from '../utils/helper';\nimport { attributeKeys, attributeOf, GEOMETRY_ATTRIBUTES } from './utils';\nfunction localBBoxOf(shape) {\n  const {\n    min,\n    max\n  } = shape.getLocalBounds();\n  const [x0, y0] = min;\n  const [x1, y1] = max;\n  const height = y1 - y0;\n  const width = x1 - x0;\n  return [x0, y0, width, height];\n}\nfunction d(bbox) {\n  const [x, y, width, height] = bbox;\n  return `\n    M ${x} ${y}\n    L ${x + width} ${y}\n    L ${x + width} ${y + height}\n    L ${x} ${y + height}\n    Z\n  `;\n}\nfunction pack(shape, count) {\n  const [x0, y0, width, height] = localBBoxOf(shape);\n  const aspect = height / width;\n  const col = Math.ceil(Math.sqrt(count / aspect));\n  const row = Math.ceil(count / col);\n  const B = [];\n  const h = height / row;\n  let j = 0;\n  let n = count;\n  while (n > 0) {\n    const c = Math.min(n, col);\n    const w = width / c;\n    for (let i = 0; i < c; i++) {\n      const x = x0 + i * w;\n      const y = y0 + j * h;\n      B.push(d([x, y, w, h]));\n    }\n    n -= c;\n    j += 1;\n  }\n  return B;\n}\nfunction normalizeSplit(split = 'pack') {\n  if (typeof split == 'function') return split;\n  return pack;\n}\n/**\n * Use attributes relative to geometry to do shape to shape animation.\n *\n * For example, the x, y, width, height of `Rect`, the cx, cy, r of `Circle`.\n * And for `Group`, it will use the bbox of the group.\n */\nfunction shapeToShape(from, to, timeEffect) {\n  let {\n    transform: fromTransform\n  } = from.style;\n  const {\n    transform: toTransform\n  } = to.style;\n  // Replace first to get right bbox after mounting.\n  replaceChild(to, from);\n  let keys = attributeKeys;\n  if (from.nodeName === Shape.GROUP) {\n    // Apply translate and scale transform.\n    const [x0, y0, w0, h0] = localBBoxOf(from);\n    const [x1, y1, w1, h1] = localBBoxOf(to);\n    const dx = x0 - x1;\n    const dy = y0 - y1;\n    const sx = w0 / w1;\n    const sy = h0 / h1;\n    fromTransform = `translate(${dx}, ${dy}) scale(${sx}, ${sy})`;\n  } else {\n    keys = keys.concat(GEOMETRY_ATTRIBUTES[from.nodeName] || []);\n  }\n  const keyframes = [Object.assign({\n    transform: fromTransform !== null && fromTransform !== void 0 ? fromTransform : 'none'\n  }, attributeOf(from, keys, true)), Object.assign({\n    transform: toTransform !== null && toTransform !== void 0 ? toTransform : 'none'\n  }, attributeOf(to, keys, true))];\n  const animation = to.animate(keyframes, timeEffect);\n  return animation;\n}\n/**\n * Replace object and copy className and __data__\n */\nfunction replaceChild(newChild, oldChild) {\n  newChild['__data__'] = oldChild['__data__'];\n  newChild.className = oldChild.className;\n  // @ts-ignore\n  newChild.markType = oldChild.markType;\n  oldChild.parentNode.replaceChild(newChild, oldChild);\n}\n/**\n * Replace element with a path shape.\n */\nfunction maybePath(node, d) {\n  const {\n    nodeName\n  } = node;\n  if (nodeName === 'path') return node;\n  const path = new Path({\n    style: Object.assign(Object.assign({}, attributeOf(node, attributeKeys)), {\n      d\n    })\n  });\n  replaceChild(path, node);\n  return path;\n}\nfunction hasUniqueString(search, pattern) {\n  const first = search.indexOf(pattern);\n  const last = search.lastIndexOf(pattern);\n  return first === last;\n}\n// Path definition with multiple m and M command has sub path.\n// eg. 'M10,10...M20,20', 'm10,10...m20,20'\nfunction hasSubPath(path) {\n  return !hasUniqueString(path, 'm') || !hasUniqueString(path, 'M');\n}\nfunction shape2path(shape) {\n  const path = convertToPath(shape);\n  if (!path) return;\n  // Path definition with sub path can't do path morphing animation,\n  // so skip this kind of path.\n  if (hasSubPath(path)) return;\n  return path;\n}\n// Check if the path has a markerEnd | markerStart\nfunction hasMarker(shape) {\n  const {\n    nodeName\n  } = shape;\n  if (nodeName === 'path') {\n    const attributes = get(shape, 'attributes');\n    return attributes.markerEnd || attributes.markerStart;\n  }\n  return false;\n}\nfunction oneToOne(shape, from, to, timeEffect) {\n  // If the nodeTypes of from and to are equal,\n  // or non of them can convert to path,\n  // the apply shape to shape animation.\n  const {\n    nodeName: fromName\n  } = from;\n  const {\n    nodeName: toName\n  } = to;\n  const fromPath = shape2path(from);\n  const toPath = shape2path(to);\n  const isSameNodes = fromName === toName && fromName !== 'path';\n  const hasNonPathNode = fromPath === undefined || toPath === undefined;\n  // Path with mark can not use animate like ordinary path.\n  const isPathWithMarker = hasMarker(from) || hasMarker(to);\n  if (isSameNodes || hasNonPathNode || isPathWithMarker) return shapeToShape(from, to, timeEffect);\n  const pathShape = maybePath(shape, fromPath);\n  // Convert Path will take transform, anchor, etc into account,\n  // so there is no need to specify these attributes in keyframes.\n  const keyframes = [Object.assign({}, attributeOf(from, attributeKeys)), Object.assign({}, attributeOf(to, attributeKeys))];\n  if (fromPath !== toPath) {\n    keyframes[0].d = fromPath;\n    keyframes[1].d = toPath;\n    const animation = pathShape.animate(keyframes, timeEffect);\n    animation.onfinish = () => {\n      // Should keep the original path definition.\n      copyAttributes(pathShape, to);\n      pathShape.style.d = toPath;\n      pathShape.style.transform = 'none';\n    };\n    // Remove transform because it already applied in path\n    // converted by convertToPath.\n    pathShape.style.transform = 'none';\n    return animation;\n  }\n  // No need to apply animation since fromPath equals toPath.\n  return null;\n}\nfunction oneToMultiple(from, to, timeEffect, split) {\n  // Hide the shape to be split before being removing.\n  from.style.visibility = 'hidden';\n  const D = split(from, to.length);\n  return to.map((shape, i) => {\n    const path = new Path({\n      style: Object.assign({\n        d: D[i]\n      }, attributeOf(from, attributeKeys))\n    });\n    return oneToOne(shape, path, shape, timeEffect);\n  });\n}\nfunction multipleToOne(from, to, timeEffect, split) {\n  const D = split(to, from.length);\n  const {\n    fillOpacity = 1,\n    strokeOpacity = 1,\n    opacity = 1\n  } = to.style;\n  const keyframes = [{\n    fillOpacity: 0,\n    strokeOpacity: 0,\n    opacity: 0\n  }, {\n    fillOpacity: 0,\n    strokeOpacity: 0,\n    opacity: 0,\n    offset: 0.99\n  }, {\n    fillOpacity,\n    strokeOpacity,\n    opacity\n  }];\n  const animation = to.animate(keyframes, timeEffect);\n  const animations = from.map((shape, i) => {\n    const path = new Path({\n      style: {\n        d: D[i],\n        fill: to.style.fill\n      }\n    });\n    return oneToOne(shape, shape, path, timeEffect);\n  });\n  return [...animations, animation];\n}\n/**\n * Morphing animations.\n * @todo Support more split function.\n */\nexport const Morphing = options => {\n  return (from, to, defaults) => {\n    const split = normalizeSplit(options.split);\n    const timeEffect = Object.assign(Object.assign({}, defaults), options);\n    const {\n      length: fl\n    } = from;\n    const {\n      length: tl\n    } = to;\n    if (fl === 1 && tl === 1 || fl > 1 && tl > 1) {\n      const [f] = from;\n      const [t] = to;\n      return oneToOne(f, f, t, timeEffect);\n    }\n    if (fl === 1 && tl > 1) {\n      const [f] = from;\n      return oneToMultiple(f, to, timeEffect, split);\n    }\n    if (fl > 1 && tl === 1) {\n      const [t] = to;\n      return multipleToOne(from, t, timeEffect, split);\n    }\n    return null;\n  };\n};\nMorphing.props = {};","map":{"version":3,"names":["convertToPath","Path","Shape","get","copyAttributes","attributeKeys","attributeOf","GEOMETRY_ATTRIBUTES","localBBoxOf","shape","min","max","getLocalBounds","x0","y0","x1","y1","height","width","d","bbox","x","y","pack","count","aspect","col","Math","ceil","sqrt","row","B","h","j","n","c","w","i","push","normalizeSplit","split","shapeToShape","from","to","timeEffect","transform","fromTransform","style","toTransform","replaceChild","keys","nodeName","GROUP","w0","h0","w1","h1","dx","dy","sx","sy","concat","keyframes","animation","animate","newChild","oldChild","className","markType","parentNode","maybePath","node","path","Object","assign","hasUniqueString","search","pattern","first","indexOf","last","lastIndexOf","hasSubPath","shape2path","hasMarker","attributes","markerEnd","markerStart","oneToOne","fromName","toName","fromPath","toPath","isSameNodes","hasNonPathNode","undefined","isPathWithMarker","pathShape","onfinish","oneToMultiple","visibility","D","length","map","multipleToOne","fillOpacity","strokeOpacity","opacity","offset","animations","fill","Morphing","options","defaults","fl","tl","f","t","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/animation/morphing.ts"],"sourcesContent":["import {\n  convertToPath,\n  DisplayObject,\n  IAnimation as GAnimation,\n  Path,\n  Shape,\n} from '@antv/g';\nimport { get } from '@antv/util';\nimport { AnimationComponent as AC } from '../runtime';\nimport { copyAttributes } from '../utils/helper';\nimport { Animation } from './types';\nimport { attributeKeys, attributeOf, GEOMETRY_ATTRIBUTES } from './utils';\n\nexport type MorphingOptions = Animation & { split: 'pack' | SplitFunction };\n\ntype BBox = [number, number, number, number];\n\ntype SplitFunction = (shape: DisplayObject, count: number) => string[];\n\nfunction localBBoxOf(shape: DisplayObject): BBox {\n  const { min, max } = shape.getLocalBounds();\n  const [x0, y0] = min;\n  const [x1, y1] = max;\n  const height = y1 - y0;\n  const width = x1 - x0;\n  return [x0, y0, width, height];\n}\n\nfunction d(bbox: BBox): string {\n  const [x, y, width, height] = bbox;\n  return `\n    M ${x} ${y}\n    L ${x + width} ${y}\n    L ${x + width} ${y + height}\n    L ${x} ${y + height}\n    Z\n  `;\n}\n\nfunction pack(shape: DisplayObject, count: number): string[] {\n  const [x0, y0, width, height] = localBBoxOf(shape);\n  const aspect = height / width;\n  const col = Math.ceil(Math.sqrt(count / aspect));\n  const row = Math.ceil(count / col);\n  const B = [];\n  const h = height / row;\n  let j = 0;\n  let n = count;\n  while (n > 0) {\n    const c = Math.min(n, col);\n    const w = width / c;\n    for (let i = 0; i < c; i++) {\n      const x = x0 + i * w;\n      const y = y0 + j * h;\n      B.push(d([x, y, w, h]));\n    }\n    n -= c;\n    j += 1;\n  }\n  return B;\n}\n\nfunction normalizeSplit(\n  split: MorphingOptions['split'] = 'pack',\n): SplitFunction {\n  if (typeof split == 'function') return split;\n  return pack;\n}\n\n/**\n * Use attributes relative to geometry to do shape to shape animation.\n *\n * For example, the x, y, width, height of `Rect`, the cx, cy, r of `Circle`.\n * And for `Group`, it will use the bbox of the group.\n */\nfunction shapeToShape(\n  from: DisplayObject,\n  to: DisplayObject,\n  timeEffect: Record<string, any>,\n): GAnimation {\n  let { transform: fromTransform } = from.style;\n  const { transform: toTransform } = to.style;\n\n  // Replace first to get right bbox after mounting.\n  replaceChild(to, from);\n\n  let keys = attributeKeys;\n  if (from.nodeName === Shape.GROUP) {\n    // Apply translate and scale transform.\n    const [x0, y0, w0, h0] = localBBoxOf(from);\n    const [x1, y1, w1, h1] = localBBoxOf(to);\n    const dx = x0 - x1;\n    const dy = y0 - y1;\n    const sx = w0 / w1;\n    const sy = h0 / h1;\n    fromTransform = `translate(${dx}, ${dy}) scale(${sx}, ${sy})`;\n  } else {\n    keys = keys.concat(GEOMETRY_ATTRIBUTES[from.nodeName] || []);\n  }\n\n  const keyframes = [\n    {\n      transform: fromTransform ?? 'none',\n      ...attributeOf(from, keys, true),\n    },\n    {\n      transform: toTransform ?? 'none',\n      ...attributeOf(to, keys, true),\n    },\n  ];\n  const animation = to.animate(keyframes, timeEffect);\n  return animation;\n}\n\n/**\n * Replace object and copy className and __data__\n */\nfunction replaceChild(newChild: DisplayObject, oldChild: DisplayObject) {\n  newChild['__data__'] = oldChild['__data__'];\n  newChild.className = oldChild.className;\n  // @ts-ignore\n  newChild.markType = oldChild.markType;\n  oldChild.parentNode.replaceChild(newChild, oldChild);\n}\n\n/**\n * Replace element with a path shape.\n */\nfunction maybePath(node: DisplayObject, d: string): DisplayObject {\n  const { nodeName } = node;\n  if (nodeName === 'path') return node;\n  const path = new Path({\n    style: {\n      ...attributeOf(node, attributeKeys),\n      d,\n    },\n  });\n  replaceChild(path, node);\n  return path;\n}\n\nfunction hasUniqueString(search: string, pattern: string): boolean {\n  const first = search.indexOf(pattern);\n  const last = search.lastIndexOf(pattern);\n  return first === last;\n}\n\n// Path definition with multiple m and M command has sub path.\n// eg. 'M10,10...M20,20', 'm10,10...m20,20'\nfunction hasSubPath(path: string): boolean {\n  return !hasUniqueString(path, 'm') || !hasUniqueString(path, 'M');\n}\n\nfunction shape2path(shape: DisplayObject): string {\n  const path = convertToPath(shape);\n  if (!path) return;\n  // Path definition with sub path can't do path morphing animation,\n  // so skip this kind of path.\n  if (hasSubPath(path)) return;\n  return path;\n}\n// Check if the path has a markerEnd | markerStart\nfunction hasMarker(shape: DisplayObject): boolean {\n  const { nodeName } = shape;\n  if (nodeName === 'path') {\n    const attributes = get(shape, 'attributes');\n    return attributes.markerEnd || attributes.markerStart;\n  }\n  return false;\n}\n\nfunction oneToOne(\n  shape: DisplayObject,\n  from: DisplayObject,\n  to: DisplayObject,\n  timeEffect: Record<string, any>,\n) {\n  // If the nodeTypes of from and to are equal,\n  // or non of them can convert to path,\n  // the apply shape to shape animation.\n  const { nodeName: fromName } = from;\n  const { nodeName: toName } = to;\n  const fromPath = shape2path(from);\n  const toPath = shape2path(to);\n  const isSameNodes = fromName === toName && fromName !== 'path';\n  const hasNonPathNode = fromPath === undefined || toPath === undefined;\n  // Path with mark can not use animate like ordinary path.\n  const isPathWithMarker = hasMarker(from) || hasMarker(to);\n  if (isSameNodes || hasNonPathNode || isPathWithMarker)\n    return shapeToShape(from, to, timeEffect);\n  const pathShape = maybePath(shape, fromPath);\n  // Convert Path will take transform, anchor, etc into account,\n  // so there is no need to specify these attributes in keyframes.\n  const keyframes: Keyframe[] = [\n    {\n      ...attributeOf(from, attributeKeys),\n    },\n    {\n      ...attributeOf(to, attributeKeys),\n    },\n  ];\n  if (fromPath !== toPath) {\n    keyframes[0].d = fromPath;\n    keyframes[1].d = toPath;\n\n    const animation = pathShape.animate(keyframes, timeEffect);\n    animation.onfinish = () => {\n      // Should keep the original path definition.\n      copyAttributes(pathShape, to);\n      pathShape.style.d = toPath;\n      pathShape.style.transform = 'none';\n    };\n\n    // Remove transform because it already applied in path\n    // converted by convertToPath.\n    pathShape.style.transform = 'none';\n    return animation;\n  }\n\n  // No need to apply animation since fromPath equals toPath.\n  return null;\n}\n\nfunction oneToMultiple(\n  from: DisplayObject,\n  to: DisplayObject[],\n  timeEffect: Record<string, any>,\n  split: SplitFunction,\n) {\n  // Hide the shape to be split before being removing.\n  from.style.visibility = 'hidden';\n  const D = split(from, to.length);\n  return to.map((shape, i) => {\n    const path = new Path({\n      style: {\n        d: D[i],\n        ...attributeOf(from, attributeKeys),\n      },\n    });\n    return oneToOne(shape, path, shape, timeEffect);\n  });\n}\n\nfunction multipleToOne(\n  from: DisplayObject[],\n  to: DisplayObject,\n  timeEffect: Record<string, any>,\n  split: SplitFunction,\n) {\n  const D = split(to, from.length);\n  const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = to.style;\n  const keyframes = [\n    { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },\n    { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },\n    {\n      fillOpacity,\n      strokeOpacity,\n      opacity,\n    },\n  ];\n  const animation = to.animate(keyframes, timeEffect);\n  const animations = from.map((shape, i) => {\n    const path = new Path({\n      style: {\n        d: D[i],\n        fill: to.style.fill,\n      },\n    });\n    return oneToOne(shape, shape, path, timeEffect);\n  });\n  return [...animations, animation];\n}\n\n/**\n * Morphing animations.\n * @todo Support more split function.\n */\nexport const Morphing: AC<MorphingOptions> = (options) => {\n  return (from, to, defaults) => {\n    const split = normalizeSplit(options.split);\n    const timeEffect = { ...defaults, ...options };\n    const { length: fl } = from;\n    const { length: tl } = to;\n    if ((fl === 1 && tl === 1) || (fl > 1 && tl > 1)) {\n      const [f] = from;\n      const [t] = to;\n      return oneToOne(f, f, t, timeEffect);\n    }\n    if (fl === 1 && tl > 1) {\n      const [f] = from;\n      return oneToMultiple(f, to, timeEffect, split);\n    }\n    if (fl > 1 && tl === 1) {\n      const [t] = to;\n      return multipleToOne(from, t, timeEffect, split);\n    }\n    return null;\n  };\n};\n\nMorphing.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}