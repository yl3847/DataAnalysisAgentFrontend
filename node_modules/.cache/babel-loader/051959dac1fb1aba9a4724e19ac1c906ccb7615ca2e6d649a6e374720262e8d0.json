{"ast":null,"code":"import { isTranspose } from '../../utils/coordinate';\nimport { Funnel } from './funnel';\n/**\n * Adjust and return the new `points`.\n */\nfunction getPyramidPoints(points, nextPoints, coordinate) {\n  const [p0, p1, p2, p3] = points;\n  if (isTranspose(coordinate)) {\n    const newP1 = [nextPoints ? nextPoints[0][0] : (p1[0] + p2[0]) / 2, p1[1]];\n    const newP2 = [nextPoints ? nextPoints[3][0] : (p1[0] + p2[0]) / 2, p2[1]];\n    return [p0, newP1, newP2, p3];\n  }\n  const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : (p1[1] + p2[1]) / 2];\n  const newP2 = [p2[0], nextPoints ? nextPoints[3][1] : (p1[1] + p2[1]) / 2];\n  return [p0, newP1, newP2, p3];\n}\n/**\n * Render pyramid in different coordinate and using color channel for stroke and fill attribute.\n */\nexport const Pyramid = (options, context) => {\n  return Funnel(Object.assign({\n    adjustPoints: getPyramidPoints\n  }, options), context);\n};\nPyramid.props = {\n  defaultMarker: 'square'\n};","map":{"version":3,"names":["isTranspose","Funnel","getPyramidPoints","points","nextPoints","coordinate","p0","p1","p2","p3","newP1","newP2","Pyramid","options","context","Object","assign","adjustPoints","props","defaultMarker"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/interval/pyramid.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { isTranspose } from '../../utils/coordinate';\nimport { ShapeComponent as SC, Vector2 } from '../../runtime';\nimport { Funnel } from './funnel';\n\nexport type PyramidOptions = Record<string, any>;\n\n/**\n * Adjust and return the new `points`.\n */\nfunction getPyramidPoints(\n  points: Vector2[],\n  nextPoints: Vector2[],\n  coordinate: Coordinate,\n) {\n  const [p0, p1, p2, p3] = points;\n\n  if (isTranspose(coordinate)) {\n    const newP1: Vector2 = [\n      nextPoints ? nextPoints[0][0] : (p1[0] + p2[0]) / 2,\n      p1[1],\n    ];\n    const newP2: Vector2 = [\n      nextPoints ? nextPoints[3][0] : (p1[0] + p2[0]) / 2,\n      p2[1],\n    ];\n    return [p0, newP1, newP2, p3];\n  }\n  const newP1: Vector2 = [\n    p1[0],\n    nextPoints ? nextPoints[0][1] : (p1[1] + p2[1]) / 2,\n  ];\n  const newP2: Vector2 = [\n    p2[0],\n    nextPoints ? nextPoints[3][1] : (p1[1] + p2[1]) / 2,\n  ];\n  return [p0, newP1, newP2, p3];\n}\n\n/**\n * Render pyramid in different coordinate and using color channel for stroke and fill attribute.\n */\nexport const Pyramid: SC<PyramidOptions> = (options, context) => {\n  return Funnel({ adjustPoints: getPyramidPoints, ...options }, context);\n};\n\nPyramid.props = {\n  defaultMarker: 'square',\n};\n"],"mappings":"AACA,SAASA,WAAW,QAAQ,wBAAwB;AAEpD,SAASC,MAAM,QAAQ,UAAU;AAIjC;;;AAGA,SAASC,gBAAgBA,CACvBC,MAAiB,EACjBC,UAAqB,EACrBC,UAAsB;EAEtB,MAAM,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGN,MAAM;EAE/B,IAAIH,WAAW,CAACK,UAAU,CAAC,EAAE;IAC3B,MAAMK,KAAK,GAAY,CACrBN,UAAU,GAAGA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAACG,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,EACnDD,EAAE,CAAC,CAAC,CAAC,CACN;IACD,MAAMI,KAAK,GAAY,CACrBP,UAAU,GAAGA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAACG,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,EACnDA,EAAE,CAAC,CAAC,CAAC,CACN;IACD,OAAO,CAACF,EAAE,EAAEI,KAAK,EAAEC,KAAK,EAAEF,EAAE,CAAC;;EAE/B,MAAMC,KAAK,GAAY,CACrBH,EAAE,CAAC,CAAC,CAAC,EACLH,UAAU,GAAGA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAACG,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CACpD;EACD,MAAMG,KAAK,GAAY,CACrBH,EAAE,CAAC,CAAC,CAAC,EACLJ,UAAU,GAAGA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAACG,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CACpD;EACD,OAAO,CAACF,EAAE,EAAEI,KAAK,EAAEC,KAAK,EAAEF,EAAE,CAAC;AAC/B;AAEA;;;AAGA,OAAO,MAAMG,OAAO,GAAuBA,CAACC,OAAO,EAAEC,OAAO,KAAI;EAC9D,OAAOb,MAAM,CAAAc,MAAA,CAAAC,MAAA;IAAGC,YAAY,EAAEf;EAAgB,GAAKW,OAAO,GAAIC,OAAO,CAAC;AACxE,CAAC;AAEDF,OAAO,CAACM,KAAK,GAAG;EACdC,aAAa,EAAE;CAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}