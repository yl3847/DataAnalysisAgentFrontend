{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix } from '@antv/util';\nimport { max as d3Max, mean as d3Mean, sum as d3Sum, min as d3Min, median as d3Median } from '@antv/vendor/d3-array';\nimport { indexOf } from '../utils/array';\nimport { columnOf, column, nonConstantColumn } from './utils/helper';\nfunction builtinFormatter(summary) {\n  return d => d === null ? summary : `${summary} of ${d}`;\n}\nfunction normalizeReducer(reducer) {\n  if (typeof reducer === 'function') return [reducer, null];\n  const registry = {\n    mean,\n    max,\n    count,\n    first,\n    last,\n    sum,\n    min,\n    median\n  };\n  const reducerFunction = registry[reducer];\n  if (!reducerFunction) throw new Error(`Unknown reducer: ${reducer}.`);\n  return reducerFunction();\n}\nfunction mean() {\n  const reducer = (I, V) => d3Mean(I, i => +V[i]);\n  const formatter = builtinFormatter('mean');\n  return [reducer, formatter];\n}\nfunction median() {\n  const reducer = (I, V) => d3Median(I, i => +V[i]);\n  const formatter = builtinFormatter('median');\n  return [reducer, formatter];\n}\nfunction max() {\n  const reducer = (I, V) => d3Max(I, i => +V[i]);\n  const formatter = builtinFormatter('max');\n  return [reducer, formatter];\n}\nfunction min() {\n  const reducer = (I, V) => d3Min(I, i => +V[i]);\n  const formatter = builtinFormatter('min');\n  return [reducer, formatter];\n}\nfunction count() {\n  const reducer = (I, V) => I.length;\n  const formatter = builtinFormatter('count');\n  return [reducer, formatter];\n}\nfunction sum() {\n  const reducer = (I, V) => d3Sum(I, i => +V[i]);\n  const formatter = builtinFormatter('sum');\n  return [reducer, formatter];\n}\nfunction first() {\n  const reducer = (I, V) => V[I[0]];\n  const formatter = builtinFormatter('first');\n  return [reducer, formatter];\n}\nfunction last() {\n  const reducer = (I, V) => V[I[I.length - 1]];\n  const formatter = builtinFormatter('last');\n  return [reducer, formatter];\n}\n/**\n * The Group transform group data by x and y channels, and aggregate.\n */\nexport const GroupN = (options = {}) => {\n  const {\n      groupBy\n    } = options,\n    rest = __rest(options, [\"groupBy\"]);\n  return (I, mark) => {\n    const {\n      data,\n      encode\n    } = mark;\n    const groups = groupBy(I, mark);\n    if (!groups) return [I, mark];\n    // Extract field from from channel\n    // x1 from x, y1 from y, etc,.\n    const maybeFrom = (field, reducer) => {\n      if (field) return field;\n      const {\n        from\n      } = reducer;\n      if (!from) return field;\n      const [, field1] = columnOf(encode, from);\n      return field1;\n    };\n    const outputs = Object.entries(rest).map(([channel, reducer]) => {\n      const [reducerFunction, formatter] = normalizeReducer(reducer);\n      const [V, field] = columnOf(encode, channel);\n      const field1 = maybeFrom(field, reducer);\n      const RV = groups.map(I => reducerFunction(I, V !== null && V !== void 0 ? V : data));\n      return [channel, Object.assign(Object.assign({}, nonConstantColumn(RV, (formatter === null || formatter === void 0 ? void 0 : formatter(field1)) || field1)), {\n        aggregate: true\n      })];\n    });\n    const reducedColumns = Object.keys(encode).map(key => {\n      const [V, fv] = columnOf(encode, key);\n      const GV = groups.map(I => V[I[0]]);\n      return [key, column(GV, fv)];\n    });\n    const GD = groups.map(I => data[I[0]]);\n    const GI = indexOf(groups);\n    return [GI, deepMix({}, mark, {\n      data: GD,\n      encode: Object.fromEntries([...reducedColumns, ...outputs])\n    })];\n  };\n};\nGroupN.props = {};","map":{"version":3,"names":["deepMix","max","d3Max","mean","d3Mean","sum","d3Sum","min","d3Min","median","d3Median","indexOf","columnOf","column","nonConstantColumn","builtinFormatter","summary","d","normalizeReducer","reducer","registry","count","first","last","reducerFunction","Error","I","V","i","formatter","length","GroupN","options","groupBy","rest","__rest","mark","data","encode","groups","maybeFrom","field","from","field1","outputs","Object","entries","map","channel","RV","aggregate","reducedColumns","keys","key","fv","GV","GD","GI","fromEntries","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/groupN.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport {\n  max as d3Max,\n  mean as d3Mean,\n  sum as d3Sum,\n  min as d3Min,\n  median as d3Median,\n} from '@antv/vendor/d3-array';\nimport { TransformComponent as TC, Primitive, G2Mark } from '../runtime';\nimport { GroupTransform, Reducer } from '../spec';\nimport { indexOf } from '../utils/array';\nimport { columnOf, column, nonConstantColumn } from './utils/helper';\n\nexport type GroupNOptions = Omit<\n  GroupTransform & {\n    groupBy?: (\n      I: number[],\n      mark: G2Mark,\n      options?: Record<string, any>,\n    ) => number[][];\n  },\n  'type' | 'channels'\n>;\n\ntype ReducerFunction = (I: number[], V: Primitive[]) => Primitive;\n\ntype Formatter = (d: Primitive) => string;\n\nfunction builtinFormatter(summary: string) {\n  return (d: string) => (d === null ? summary : `${summary} of ${d}`);\n}\n\nfunction normalizeReducer(reducer: Reducer): [ReducerFunction, Formatter] {\n  if (typeof reducer === 'function') return [reducer, null];\n  const registry = { mean, max, count, first, last, sum, min, median };\n  const reducerFunction = registry[reducer];\n  if (!reducerFunction) throw new Error(`Unknown reducer: ${reducer}.`);\n  return reducerFunction();\n}\n\nfunction mean(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Mean(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('mean');\n  return [reducer, formatter];\n}\n\nfunction median(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Median(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('median');\n  return [reducer, formatter];\n}\n\nfunction max(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Max(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('max');\n  return [reducer, formatter];\n}\n\nfunction min(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Min(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('min');\n  return [reducer, formatter];\n}\n\nfunction count(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => I.length;\n  const formatter: Formatter = builtinFormatter('count');\n  return [reducer, formatter];\n}\n\nfunction sum(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => d3Sum(I, (i) => +V[i]);\n  const formatter: Formatter = builtinFormatter('sum');\n  return [reducer, formatter];\n}\n\nfunction first(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => V[I[0]];\n  const formatter: Formatter = builtinFormatter('first');\n  return [reducer, formatter];\n}\n\nfunction last(): [ReducerFunction, Formatter] {\n  const reducer: ReducerFunction = (I, V) => V[I[I.length - 1]];\n  const formatter: Formatter = builtinFormatter('last');\n  return [reducer, formatter];\n}\n\n/**\n * The Group transform group data by x and y channels, and aggregate.\n */\nexport const GroupN: TC<GroupNOptions> = (options = {}) => {\n  const { groupBy, ...rest } = options;\n  return (I, mark) => {\n    const { data, encode } = mark;\n    const groups = groupBy(I, mark);\n    if (!groups) return [I, mark];\n\n    // Extract field from from channel\n    // x1 from x, y1 from y, etc,.\n    const maybeFrom = (field, reducer) => {\n      if (field) return field;\n      const { from } = reducer;\n      if (!from) return field;\n      const [, field1] = columnOf(encode, from);\n      return field1;\n    };\n    const outputs = Object.entries(rest).map(([channel, reducer]) => {\n      const [reducerFunction, formatter] = normalizeReducer(reducer);\n      const [V, field] = columnOf(encode, channel);\n      const field1 = maybeFrom(field, reducer);\n      const RV = groups.map((I) => reducerFunction(I, V ?? data));\n      return [\n        channel,\n        {\n          ...nonConstantColumn(RV, formatter?.(field1) || field1),\n          aggregate: true,\n        },\n      ];\n    });\n    const reducedColumns = Object.keys(encode).map((key) => {\n      const [V, fv] = columnOf(encode, key);\n      const GV = groups.map((I) => V[I[0]]);\n      return [key, column(GV, fv)];\n    });\n    const GD = groups.map((I) => data[I[0]]);\n    const GI = indexOf(groups);\n    return [\n      GI,\n      deepMix({}, mark, {\n        data: GD,\n        encode: Object.fromEntries([...reducedColumns, ...outputs]),\n      }),\n    ];\n  };\n};\n\nGroupN.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}