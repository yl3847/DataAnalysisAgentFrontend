{"ast":null,"code":"import { isBoolean, isEmpty, isEqual, isFunction } from '@antv/util';\nimport { groupByChangeType, reduceDataChanges } from '../utils/change';\nimport { idOf } from '../utils/id';\nimport { BaseTransform } from './base-transform';\nimport { getEdgeEndsContext } from './get-edge-actual-ends';\nimport { isStyleEqual, reassignTo } from './utils';\nconst CUBIC_EDGE_TYPE = 'quadratic';\nconst CUBIC_LOOP_PLACEMENTS = ['top', 'top-right', 'right', 'right-bottom', 'bottom', 'bottom-left', 'left', 'left-top'];\n/**\n * <zh/> 处理平行边，即多条边共享同一源节点和目标节点\n *\n * <en/> Process parallel edges which share the same source and target nodes\n * @remarks\n * <zh/> 平行边（Parallel Edges）是指在图结构中，两个节点之间存在多条边。这些边共享相同的源节点和目标节点，但可能代表不同的关系或属性。为了避免边的重叠和混淆，提供了两种处理平行边的方式：(1) 捆绑模式（bundle）：将平行边捆绑在一起，通过改变曲率与其他边分开；(2) 合并模式（merge）：将平行边合并为一条聚合。\n *\n * <en/> Parallel Edges refer to multiple edges existing between two nodes in a graph structure. These edges share the same source and target nodes but may represent different relationships or attributes. To avoid edge overlap and confusion, two methods are provided for handling parallel edges: (1) Bundle Mode: Bundles parallel edges together and separates them from other edges by altering their curvature; (2) Merge Mode: Merges parallel edges into a single aggregated edge.\n */\nexport class ProcessParallelEdges extends BaseTransform {\n  constructor(context, options) {\n    super(context, Object.assign({}, ProcessParallelEdges.defaultOptions, options));\n    this.cacheMergeStyle = new Map();\n    /**\n     * <zh/> 获取受影响的平行边\n     *\n     * <en/> Get affected parallel edges\n     * @param input\n     */\n    this.getAffectedParallelEdges = input => {\n      const {\n        add: {\n          edges: edgesToAdd\n        },\n        update: {\n          nodes: nodesToUpdate,\n          edges: edgesToUpdate,\n          combos: combosToUpdate\n        },\n        remove: {\n          edges: edgesToRemove\n        }\n      } = input;\n      const {\n        model\n      } = this.context;\n      const edges = new Map();\n      const addRelatedEdges = (_, id) => {\n        const relatedEdgesData = model.getRelatedEdgesData(id);\n        relatedEdgesData.forEach(edge => !edges.has(idOf(edge)) && edges.set(idOf(edge), edge));\n      };\n      nodesToUpdate.forEach(addRelatedEdges);\n      combosToUpdate.forEach(addRelatedEdges);\n      const pushParallelEdges = edge => {\n        const edgeData = model.getEdgeData().map(edge => getEdgeEndsContext(model, edge));\n        const parallelEdges = getParallelEdges(edge, edgeData, true);\n        parallelEdges.forEach(e => !edges.has(idOf(e)) && edges.set(idOf(e), e));\n      };\n      if (edgesToRemove.size) edgesToRemove.forEach(pushParallelEdges);\n      if (edgesToAdd.size) edgesToAdd.forEach(pushParallelEdges);\n      if (edgesToUpdate.size) {\n        const changes = groupByChangeType(reduceDataChanges(model.getChanges())).update.edges;\n        edgesToUpdate.forEach(edge => {\n          var _a;\n          pushParallelEdges(edge);\n          // 当边的端点发生变化时，将原始边及其平行边一并添加到更新列表 | Add the original edge and its parallel edges to the update list when the endpoints of the edge change\n          const originalEdge = (_a = changes.find(e => idOf(e.value) === idOf(edge))) === null || _a === void 0 ? void 0 : _a.original;\n          if (originalEdge && !isParallelEdges(edge, originalEdge)) {\n            pushParallelEdges(originalEdge);\n          }\n        });\n      }\n      if (!isEmpty(this.options.edges)) {\n        edges.forEach((_, id) => !this.options.edges.includes(id) && edges.delete(id));\n      }\n      // 按照用户指定的顺序排序，防止捆绑时的抖动\n      // Sort by user-set order to prevent jitter during bundling\n      const edgeIds = model.getEdgeData().map(idOf);\n      return new Map([...edges].sort((a, b) => edgeIds.indexOf(a[0]) - edgeIds.indexOf(b[0])));\n    };\n    this.applyBundlingStyle = (input, edges, distance) => {\n      const {\n        edgeMap,\n        reverses\n      } = groupByEndpoints(edges);\n      edgeMap.forEach(arcEdges => {\n        arcEdges.forEach((edge, i, edgeArr) => {\n          var _a;\n          const length = edgeArr.length;\n          const style = edge.style || {};\n          if (edge.source === edge.target) {\n            const len = CUBIC_LOOP_PLACEMENTS.length;\n            style.loopPlacement = CUBIC_LOOP_PLACEMENTS[i % len];\n            style.loopDist = Math.floor(i / len) * distance + 50;\n          } else if (length === 1) {\n            style.curveOffset = 0;\n          } else {\n            const sign = (i % 2 === 0 ? 1 : -1) * (reverses[`${edge.source}|${edge.target}|${i}`] ? -1 : 1);\n            style.curveOffset = length % 2 === 1 ? sign * Math.ceil(i / 2) * distance * 2 : sign * (Math.floor(i / 2) * distance * 2 + distance);\n          }\n          const mergedEdgeData = Object.assign(edge, {\n            type: CUBIC_EDGE_TYPE,\n            style\n          });\n          const element = (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElement(idOf(edge));\n          if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {\n            reassignTo(input, element ? 'update' : 'add', 'edge', mergedEdgeData, true);\n          }\n        });\n      });\n    };\n    this.resetEdgeStyle = edge => {\n      const style = edge.style || {};\n      const cacheStyle = this.cacheMergeStyle.get(idOf(edge)) || {};\n      Object.keys(cacheStyle).forEach(key => {\n        if (isEqual(style[key], cacheStyle[key])) {\n          if (edge[key]) {\n            style[key] = edge[key];\n          } else {\n            delete style[key];\n          }\n        }\n      });\n      return Object.assign(edge, {\n        style\n      });\n    };\n    this.applyMergingStyle = (input, edges) => {\n      const {\n        edgeMap,\n        reverses\n      } = groupByEndpoints(edges);\n      edgeMap.forEach(edges => {\n        var _a;\n        if (edges.length === 1) {\n          const edge = edges[0];\n          const element = (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElement(idOf(edge));\n          const edgeStyle = this.resetEdgeStyle(edge);\n          if (!element || !isStyleEqual(edgeStyle, element.attributes)) {\n            reassignTo(input, element ? 'update' : 'add', 'edge', edgeStyle);\n          }\n          return;\n        }\n        const mergedStyle = edges.map(({\n          source,\n          target,\n          style = {}\n        }, i) => {\n          const {\n            startArrow,\n            endArrow\n          } = style;\n          const newStyle = {};\n          const [start, end] = reverses[`${source}|${target}|${i}`] ? ['endArrow', 'startArrow'] : ['startArrow', 'endArrow'];\n          if (isBoolean(startArrow)) newStyle[start] = startArrow;\n          if (isBoolean(endArrow)) newStyle[end] = endArrow;\n          return newStyle;\n        }).reduce((acc, style) => Object.assign(Object.assign({}, acc), style), {});\n        edges.forEach((edge, i, edges) => {\n          var _a;\n          if (i !== 0) {\n            reassignTo(input, 'remove', 'edge', edge);\n            return;\n          }\n          const parsedStyle = Object.assign({}, isFunction(this.options.style) ? this.options.style(edges) : this.options.style, {\n            childrenData: edges\n          });\n          this.cacheMergeStyle.set(idOf(edge), parsedStyle);\n          const mergedEdgeData = Object.assign(Object.assign({}, edge), {\n            type: 'line',\n            style: Object.assign(Object.assign(Object.assign({}, edge.style), mergedStyle), parsedStyle)\n          });\n          const element = (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElement(idOf(edge));\n          if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {\n            reassignTo(input, element ? 'update' : 'add', 'edge', mergedEdgeData, true);\n          }\n        });\n      });\n    };\n  }\n  /**\n   * <zh/> 在每次绘制前处理平行边\n   *\n   * <en/> Process parallel edges before each drawing\n   * @param input\n   */\n  beforeDraw(input) {\n    const edges = this.getAffectedParallelEdges(input);\n    if (edges.size === 0) return input;\n    this.options.mode === 'bundle' ? this.applyBundlingStyle(input, edges, this.options.distance) : this.applyMergingStyle(input, edges);\n    return input;\n  }\n}\nProcessParallelEdges.defaultOptions = {\n  mode: 'bundle',\n  distance: 15 // only valid for bundling mode\n};\n/**\n * <zh/> 优化的按照端点分组方法，时间复杂度O(n)\n *\n * <en/> Optimized method to group by endpoints, time complexity O(n)\n * @param edges - <zh/> 边集合 | <en/> Edges\n * @returns <zh/> 端点分组后的边集合 | <en/> Edges grouped by endpoints\n */\nexport const groupByEndpoints = edges => {\n  const edgeMap = new Map();\n  const processedEdgesSet = new Set();\n  const reverses = {};\n  const includedEdgesInGroup = new Map();\n  for (const [id, edge] of edges) {\n    if (processedEdgesSet.has(id)) continue;\n    const {\n      source,\n      target\n    } = edge;\n    const sourceTarget = `${source}-${target}`;\n    if (!edgeMap.has(sourceTarget)) {\n      edgeMap.set(sourceTarget, []);\n      includedEdgesInGroup.set(sourceTarget, new Set());\n    }\n    const sourceTargetEdges = edgeMap.get(sourceTarget);\n    const includedEdges = includedEdgesInGroup.get(sourceTarget);\n    if (sourceTargetEdges && includedEdges && !includedEdges.has(id)) {\n      sourceTargetEdges.push(edge);\n      includedEdges.add(id);\n      processedEdgesSet.add(id);\n    }\n    for (const [otherId, sedge] of edges) {\n      if (processedEdgesSet.has(otherId) || otherId === id) continue;\n      if (isParallelEdges(edge, sedge)) {\n        const groupEdges = edgeMap.get(sourceTarget);\n        const includedGroupEdges = includedEdgesInGroup.get(sourceTarget);\n        if (groupEdges && includedGroupEdges && !includedGroupEdges.has(otherId)) {\n          groupEdges.push(sedge);\n          includedGroupEdges.add(otherId);\n          if (source === sedge.target && target === sedge.source) {\n            reverses[`${sedge.source}|${sedge.target}|${groupEdges.length - 1}`] = true;\n          }\n          processedEdgesSet.add(otherId);\n        }\n      }\n    }\n  }\n  return {\n    edgeMap,\n    reverses\n  };\n};\n/**\n * <zh/> 获取平行边\n *\n * <en/> Get parallel edges\n * @param edge - <zh/> 目标边 | <en/> Target edge\n * @param edges - <zh/> 边集合 | <en/> Edges\n * @param containsSelf - <zh/> 输出结果是否包含目标边 | <en/> Whether the output result contains the target edge\n * @returns <zh/> 平行边集合 | <en/> Parallel edges\n */\nexport const getParallelEdges = (edge, edges, containsSelf) => {\n  return edges.filter(e => (containsSelf || idOf(e) !== idOf(edge)) && isParallelEdges(e, edge));\n};\n/**\n * <zh/> 判断两条边是否平行\n *\n * <en/> Determine whether two edges are parallel\n * @param edge1 - <zh/> 边1 | <en/> Edge 1\n * @param edge2 - <zh/> 边2 | <en/> Edge 2\n * @returns <zh/> 是否平行 | <en/> Whether is parallel\n */\nexport const isParallelEdges = (edge1, edge2) => {\n  const {\n    sourceNode: src1,\n    targetNode: tgt1\n  } = edge1.style || {};\n  const {\n    sourceNode: src2,\n    targetNode: tgt2\n  } = edge2.style || {};\n  return src1 === src2 && tgt1 === tgt2 || src1 === tgt2 && tgt1 === src2;\n};","map":{"version":3,"names":["isBoolean","isEmpty","isEqual","isFunction","groupByChangeType","reduceDataChanges","idOf","BaseTransform","getEdgeEndsContext","isStyleEqual","reassignTo","CUBIC_EDGE_TYPE","CUBIC_LOOP_PLACEMENTS","ProcessParallelEdges","constructor","context","options","Object","assign","defaultOptions","cacheMergeStyle","Map","getAffectedParallelEdges","input","add","edges","edgesToAdd","update","nodes","nodesToUpdate","edgesToUpdate","combos","combosToUpdate","remove","edgesToRemove","model","addRelatedEdges","_","id","relatedEdgesData","getRelatedEdgesData","forEach","edge","has","set","pushParallelEdges","edgeData","getEdgeData","map","parallelEdges","getParallelEdges","e","size","changes","getChanges","originalEdge","_a","find","value","original","isParallelEdges","includes","delete","edgeIds","sort","a","b","indexOf","applyBundlingStyle","distance","edgeMap","reverses","groupByEndpoints","arcEdges","i","edgeArr","length","style","source","target","len","loopPlacement","loopDist","Math","floor","curveOffset","sign","ceil","mergedEdgeData","type","element","getElement","attributes","resetEdgeStyle","cacheStyle","get","keys","key","applyMergingStyle","edgeStyle","mergedStyle","startArrow","endArrow","newStyle","start","end","reduce","acc","parsedStyle","childrenData","beforeDraw","mode","processedEdgesSet","Set","includedEdgesInGroup","sourceTarget","sourceTargetEdges","includedEdges","push","otherId","sedge","groupEdges","includedGroupEdges","containsSelf","filter","edge1","edge2","sourceNode","src1","targetNode","tgt1","src2","tgt2"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/transforms/process-parallel-edges.ts"],"sourcesContent":["import type { PathStyleProps } from '@antv/g';\nimport { isBoolean, isEmpty, isEqual, isFunction } from '@antv/util';\nimport type { RuntimeContext } from '../runtime/types';\nimport type { EdgeData } from '../spec';\nimport type { EdgeStyle } from '../spec/element/edge';\nimport type { ID, LoopPlacement, NodeLikeData } from '../types';\nimport { groupByChangeType, reduceDataChanges } from '../utils/change';\nimport { idOf } from '../utils/id';\nimport type { BaseTransformOptions } from './base-transform';\nimport { BaseTransform } from './base-transform';\nimport { getEdgeEndsContext } from './get-edge-actual-ends';\nimport type { DrawData } from './types';\nimport { isStyleEqual, reassignTo } from './utils';\n\nconst CUBIC_EDGE_TYPE = 'quadratic';\n\nconst CUBIC_LOOP_PLACEMENTS: LoopPlacement[] = [\n  'top',\n  'top-right',\n  'right',\n  'right-bottom',\n  'bottom',\n  'bottom-left',\n  'left',\n  'left-top',\n];\n\nexport interface ProcessParallelEdgesOptions extends BaseTransformOptions {\n  /**\n   * <zh/> 处理模式\n   * - `'merge'`: 将平行边合并为一条边，适用于不需要区分平行边的情况\n   * - '`bundle`': 每条边都会与其他所有平行边捆绑在一起，并通过改变曲率与其他边分开。如果一组平行边的数量是奇数，那么中心的边将被绘制为直线，其他的边将被绘制为曲线\n   *\n   * <en/> Processing mode\n   * - '`merge`': Merge parallel edges into one edge which is suitable for cases where parallel edges do not need to be distinguished\n   * - '`bundle`': Each edge will be bundled with all other parallel edges and separated from them by varying the curvature. If the number of parallel edges in a group is odd, the central edge will be drawn as a straight line, and the others will be drawn as curves\n   * @defaultValue 'bundle'\n   */\n  mode: 'bundle' | 'merge';\n  /**\n   * <zh/> 考虑要处理的边，默认为全部边\n   *\n   * <en/> The edges to be handled, all edges by default\n   */\n  edges?: ID[];\n  /**\n   * <zh/> 边之间的距离，仅在捆绑模式下有效\n   *\n   * <en/> The distance between edges, only valid for bundling mode\n   */\n  distance?: number;\n  /**\n   * <zh/> 合并边的样式，仅在合并模式下有效\n   *\n   * <en/> The style of the merged edge, only valid for merging mode\n   */\n  style?: PathStyleProps | ((prev: EdgeData[]) => PathStyleProps);\n}\n\n/**\n * <zh/> 处理平行边，即多条边共享同一源节点和目标节点\n *\n * <en/> Process parallel edges which share the same source and target nodes\n * @remarks\n * <zh/> 平行边（Parallel Edges）是指在图结构中，两个节点之间存在多条边。这些边共享相同的源节点和目标节点，但可能代表不同的关系或属性。为了避免边的重叠和混淆，提供了两种处理平行边的方式：(1) 捆绑模式（bundle）：将平行边捆绑在一起，通过改变曲率与其他边分开；(2) 合并模式（merge）：将平行边合并为一条聚合。\n *\n * <en/> Parallel Edges refer to multiple edges existing between two nodes in a graph structure. These edges share the same source and target nodes but may represent different relationships or attributes. To avoid edge overlap and confusion, two methods are provided for handling parallel edges: (1) Bundle Mode: Bundles parallel edges together and separates them from other edges by altering their curvature; (2) Merge Mode: Merges parallel edges into a single aggregated edge.\n */\nexport class ProcessParallelEdges extends BaseTransform<ProcessParallelEdgesOptions> {\n  static defaultOptions: Partial<ProcessParallelEdgesOptions> = {\n    mode: 'bundle',\n    distance: 15, // only valid for bundling mode\n  };\n\n  private cacheMergeStyle: Map<ID, PathStyleProps> = new Map();\n\n  constructor(context: RuntimeContext, options: ProcessParallelEdgesOptions) {\n    super(context, Object.assign({}, ProcessParallelEdges.defaultOptions, options));\n  }\n\n  /**\n   * <zh/> 在每次绘制前处理平行边\n   *\n   * <en/> Process parallel edges before each drawing\n   * @param input\n   */\n  public beforeDraw(input: DrawData): DrawData {\n    const edges = this.getAffectedParallelEdges(input);\n\n    if (edges.size === 0) return input;\n\n    this.options.mode === 'bundle'\n      ? this.applyBundlingStyle(input, edges, this.options.distance)\n      : this.applyMergingStyle(input, edges);\n\n    return input;\n  }\n\n  /**\n   * <zh/> 获取受影响的平行边\n   *\n   * <en/> Get affected parallel edges\n   * @param input\n   */\n  private getAffectedParallelEdges = (input: DrawData): Map<ID, EdgeData> => {\n    const {\n      add: { edges: edgesToAdd },\n      update: { nodes: nodesToUpdate, edges: edgesToUpdate, combos: combosToUpdate },\n      remove: { edges: edgesToRemove },\n    } = input;\n\n    const { model } = this.context;\n    const edges: Map<ID, EdgeData> = new Map();\n\n    const addRelatedEdges = (_: NodeLikeData, id: ID) => {\n      const relatedEdgesData = model.getRelatedEdgesData(id);\n      relatedEdgesData.forEach((edge) => !edges.has(idOf(edge)) && edges.set(idOf(edge), edge));\n    };\n\n    nodesToUpdate.forEach(addRelatedEdges);\n    combosToUpdate.forEach(addRelatedEdges);\n\n    const pushParallelEdges = (edge: EdgeData) => {\n      const edgeData = model.getEdgeData().map((edge) => getEdgeEndsContext(model, edge));\n      const parallelEdges = getParallelEdges(edge, edgeData, true);\n      parallelEdges.forEach((e) => !edges.has(idOf(e)) && edges.set(idOf(e), e));\n    };\n\n    if (edgesToRemove.size) edgesToRemove.forEach(pushParallelEdges);\n\n    if (edgesToAdd.size) edgesToAdd.forEach(pushParallelEdges);\n\n    if (edgesToUpdate.size) {\n      const changes = groupByChangeType(reduceDataChanges(model.getChanges())).update.edges;\n      edgesToUpdate.forEach((edge) => {\n        pushParallelEdges(edge);\n        // 当边的端点发生变化时，将原始边及其平行边一并添加到更新列表 | Add the original edge and its parallel edges to the update list when the endpoints of the edge change\n        const originalEdge = changes.find((e) => idOf(e.value) === idOf(edge))?.original;\n        if (originalEdge && !isParallelEdges(edge, originalEdge)) {\n          pushParallelEdges(originalEdge);\n        }\n      });\n    }\n\n    if (!isEmpty(this.options.edges)) {\n      edges.forEach((_: EdgeData, id: ID) => !this.options.edges.includes(id) && edges.delete(id));\n    }\n\n    // 按照用户指定的顺序排序，防止捆绑时的抖动\n    // Sort by user-set order to prevent jitter during bundling\n    const edgeIds = model.getEdgeData().map(idOf);\n    return new Map([...edges].sort((a, b) => edgeIds.indexOf(a[0]) - edgeIds.indexOf(b[0])));\n  };\n\n  protected applyBundlingStyle = (input: DrawData, edges: Map<ID, EdgeData>, distance: number) => {\n    const { edgeMap, reverses } = groupByEndpoints(edges);\n\n    edgeMap.forEach((arcEdges) => {\n      arcEdges.forEach((edge, i, edgeArr) => {\n        const length = edgeArr.length;\n        const style: EdgeStyle = edge.style || {};\n        if (edge.source === edge.target) {\n          const len = CUBIC_LOOP_PLACEMENTS.length;\n          style.loopPlacement = CUBIC_LOOP_PLACEMENTS[i % len];\n          style.loopDist = Math.floor(i / len) * distance + 50;\n        } else if (length === 1) {\n          style.curveOffset = 0;\n        } else {\n          const sign = (i % 2 === 0 ? 1 : -1) * (reverses[`${edge.source}|${edge.target}|${i}`] ? -1 : 1);\n          style.curveOffset =\n            length % 2 === 1\n              ? sign * Math.ceil(i / 2) * distance * 2\n              : sign * (Math.floor(i / 2) * distance * 2 + distance);\n        }\n        const mergedEdgeData = Object.assign(edge, { type: CUBIC_EDGE_TYPE, style });\n\n        const element = this.context.element?.getElement(idOf(edge));\n\n        if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {\n          reassignTo(input, element ? 'update' : 'add', 'edge', mergedEdgeData, true);\n        }\n      });\n    });\n  };\n\n  private resetEdgeStyle = (edge: EdgeData) => {\n    const style = edge.style || {};\n    const cacheStyle = this.cacheMergeStyle.get(idOf(edge)) || {};\n    Object.keys(cacheStyle).forEach((key) => {\n      if (isEqual(style[key], (cacheStyle as any)[key])) {\n        if (edge[key]) {\n          style[key] = edge[key];\n        } else {\n          delete style[key];\n        }\n      }\n    });\n    return Object.assign(edge, { style });\n  };\n\n  protected applyMergingStyle = (input: DrawData, edges: Map<ID, EdgeData>) => {\n    const { edgeMap, reverses } = groupByEndpoints(edges);\n\n    edgeMap.forEach((edges) => {\n      if (edges.length === 1) {\n        const edge = edges[0];\n        const element = this.context.element?.getElement(idOf(edge));\n        const edgeStyle = this.resetEdgeStyle(edge);\n        if (!element || !isStyleEqual(edgeStyle, element.attributes)) {\n          reassignTo(input, element ? 'update' : 'add', 'edge', edgeStyle);\n        }\n        return;\n      }\n\n      const mergedStyle = edges\n        .map(({ source, target, style = {} }, i) => {\n          const { startArrow, endArrow } = style;\n          const newStyle: EdgeData['style'] = {};\n          const [start, end] = reverses[`${source}|${target}|${i}`]\n            ? ['endArrow', 'startArrow']\n            : ['startArrow', 'endArrow'];\n          if (isBoolean(startArrow)) newStyle[start] = startArrow;\n          if (isBoolean(endArrow)) newStyle[end] = endArrow;\n          return newStyle;\n        })\n        .reduce((acc, style) => ({ ...acc, ...style }), {});\n\n      edges.forEach((edge, i, edges) => {\n        if (i !== 0) {\n          reassignTo(input, 'remove', 'edge', edge);\n          return;\n        }\n        const parsedStyle = Object.assign(\n          {},\n          isFunction(this.options.style) ? this.options.style(edges) : this.options.style,\n          { childrenData: edges },\n        );\n        this.cacheMergeStyle.set(idOf(edge), parsedStyle);\n        const mergedEdgeData = {\n          ...edge,\n          type: 'line',\n          style: { ...edge.style, ...mergedStyle, ...parsedStyle },\n        };\n\n        const element = this.context.element?.getElement(idOf(edge));\n        if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {\n          reassignTo(input, element ? 'update' : 'add', 'edge', mergedEdgeData, true);\n        }\n      });\n    });\n  };\n}\n\n/**\n * <zh/> 优化的按照端点分组方法，时间复杂度O(n)\n *\n * <en/> Optimized method to group by endpoints, time complexity O(n)\n * @param edges - <zh/> 边集合 | <en/> Edges\n * @returns <zh/> 端点分组后的边集合 | <en/> Edges grouped by endpoints\n */\nexport const groupByEndpoints = (edges: Map<ID, EdgeData>) => {\n  const edgeMap = new Map<string, EdgeData[]>();\n  const processedEdgesSet = new Set<ID>();\n  const reverses: Record<string, boolean> = {};\n  const includedEdgesInGroup = new Map<string, Set<ID>>();\n\n  for (const [id, edge] of edges) {\n    if (processedEdgesSet.has(id)) continue;\n\n    const { source, target } = edge;\n    const sourceTarget = `${source}-${target}`;\n\n    if (!edgeMap.has(sourceTarget)) {\n      edgeMap.set(sourceTarget, []);\n      includedEdgesInGroup.set(sourceTarget, new Set<ID>());\n    }\n\n    const sourceTargetEdges = edgeMap.get(sourceTarget);\n    const includedEdges = includedEdgesInGroup.get(sourceTarget);\n\n    if (sourceTargetEdges && includedEdges && !includedEdges.has(id)) {\n      sourceTargetEdges.push(edge);\n      includedEdges.add(id);\n      processedEdgesSet.add(id);\n    }\n\n    for (const [otherId, sedge] of edges) {\n      if (processedEdgesSet.has(otherId) || otherId === id) continue;\n\n      if (isParallelEdges(edge, sedge)) {\n        const groupEdges = edgeMap.get(sourceTarget);\n        const includedGroupEdges = includedEdgesInGroup.get(sourceTarget);\n\n        if (groupEdges && includedGroupEdges && !includedGroupEdges.has(otherId)) {\n          groupEdges.push(sedge);\n          includedGroupEdges.add(otherId);\n\n          if (source === sedge.target && target === sedge.source) {\n            reverses[`${sedge.source}|${sedge.target}|${groupEdges.length - 1}`] = true;\n          }\n\n          processedEdgesSet.add(otherId);\n        }\n      }\n    }\n  }\n\n  return { edgeMap, reverses };\n};\n\n/**\n * <zh/> 获取平行边\n *\n * <en/> Get parallel edges\n * @param edge - <zh/> 目标边 | <en/> Target edge\n * @param edges - <zh/> 边集合 | <en/> Edges\n * @param containsSelf - <zh/> 输出结果是否包含目标边 | <en/> Whether the output result contains the target edge\n * @returns <zh/> 平行边集合 | <en/> Parallel edges\n */\nexport const getParallelEdges = (edge: EdgeData, edges: EdgeData[], containsSelf?: boolean): EdgeData[] => {\n  return edges.filter((e) => (containsSelf || idOf(e) !== idOf(edge)) && isParallelEdges(e, edge));\n};\n\n/**\n * <zh/> 判断两条边是否平行\n *\n * <en/> Determine whether two edges are parallel\n * @param edge1 - <zh/> 边1 | <en/> Edge 1\n * @param edge2 - <zh/> 边2 | <en/> Edge 2\n * @returns <zh/> 是否平行 | <en/> Whether is parallel\n */\nexport const isParallelEdges = (edge1: EdgeData, edge2: EdgeData) => {\n  const { sourceNode: src1, targetNode: tgt1 } = edge1.style || {};\n  const { sourceNode: src2, targetNode: tgt2 } = edge2.style || {};\n  return (src1 === src2 && tgt1 === tgt2) || (src1 === tgt2 && tgt1 === src2);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}