{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { bin as d3Bin, group, thresholdScott, extent } from '@antv/vendor/d3-array';\nimport { defined, subObject } from '../utils/helper';\nimport { GroupN } from './groupN';\nimport { columnOf } from './utils/helper';\nconst THRESHOLD = 'thresholds';\n/**\n * @see https://github.com/observablehq/plot/blob/main/src/transforms/bin.js\n */\nfunction thresholdAuto(values) {\n  const [min, max] = extent(values);\n  return Math.min(200, thresholdScott(values, min, max));\n}\n/**\n * The Bin aggregate data.\n * @todo More threshold method.\n * @todo Performance.\n */\nexport const Bin = (options = {}) => {\n  const {\n      groupChannels = ['color'],\n      binChannels = ['x', 'y']\n    } = options,\n    rest = __rest(options, [\"groupChannels\", \"binChannels\"]);\n  const channelIndexKey = {};\n  // Group indexes and update channelIndexKey.\n  const groupBy = (I, mark) => {\n    const {\n      encode\n    } = mark;\n    const binValues = binChannels.map(channel => {\n      const [V] = columnOf(encode, channel);\n      return V;\n    });\n    const thresholds = subObject(rest, THRESHOLD);\n    const DI = I.filter(i => binValues.every(V => defined(V[i])));\n    // Group indexes by both discrete and quantitative channels.\n    const groupKeys = [\n    // For discrete channels, use value as group key.\n    ...groupChannels.map(d => {\n      const [V] = columnOf(encode, d);\n      return V;\n    }).filter(defined).map(V => i => V[i]),\n    // For quantitative channels, use extent of bin as group key.\n    ...binChannels.map((d, i) => {\n      const V = binValues[i];\n      const t = thresholds[d] || thresholdAuto(V);\n      const bins = d3Bin().thresholds(t).value(i => +V[i])(DI);\n      const indexKey = new Map(bins.flatMap(bin => {\n        const {\n          x0,\n          x1\n        } = bin;\n        const key = `${x0},${x1}`;\n        return bin.map(i => [i, key]);\n      }));\n      channelIndexKey[d] = indexKey;\n      return i => indexKey.get(i);\n    })];\n    // Group by indexes by channel keys.\n    const key = i => groupKeys.map(key => key(i)).join('-');\n    return Array.from(group(DI, key).values());\n  };\n  return GroupN(Object.assign(Object.assign(Object.assign({}, Object.fromEntries(Object.entries(rest).filter(([k]) => !k.startsWith(THRESHOLD)))), Object.fromEntries(binChannels.flatMap(channel => {\n    const start = ([i]) => +channelIndexKey[channel].get(i).split(',')[0];\n    const end = ([i]) => +channelIndexKey[channel].get(i).split(',')[1];\n    end.from = channel;\n    return [[channel, start], [`${channel}1`, end]];\n  }))), {\n    groupBy\n  }));\n};\nBin.props = {};","map":{"version":3,"names":["bin","d3Bin","group","thresholdScott","extent","defined","subObject","GroupN","columnOf","THRESHOLD","thresholdAuto","values","min","max","Math","Bin","options","groupChannels","binChannels","rest","__rest","channelIndexKey","groupBy","I","mark","encode","binValues","map","channel","V","thresholds","DI","filter","i","every","groupKeys","d","t","bins","value","indexKey","Map","flatMap","x0","x1","key","get","join","Array","from","Object","assign","fromEntries","entries","k","startsWith","start","split","end","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/bin.ts"],"sourcesContent":["import {\n  bin as d3Bin,\n  group,\n  thresholdScott,\n  extent,\n} from '@antv/vendor/d3-array';\nimport { defined, subObject } from '../utils/helper';\nimport { TransformComponent as TC } from '../runtime';\nimport { BinTransform } from '../spec';\nimport { GroupN } from './groupN';\nimport { columnOf } from './utils/helper';\n\nexport type BinOptions = Omit<BinTransform, 'type'> & {\n  groupChannels?: string[];\n  binChannels?: string[];\n};\n\nconst THRESHOLD = 'thresholds';\n\n/**\n * @see https://github.com/observablehq/plot/blob/main/src/transforms/bin.js\n */\nfunction thresholdAuto(values: number[]) {\n  const [min, max] = extent(values);\n  return Math.min(200, thresholdScott(values, min, max));\n}\n\n/**\n * The Bin aggregate data.\n * @todo More threshold method.\n * @todo Performance.\n */\nexport const Bin: TC<BinOptions> = (options = {}) => {\n  const {\n    groupChannels = ['color'],\n    binChannels = ['x', 'y'],\n    ...rest\n  } = options;\n  const channelIndexKey = {};\n\n  // Group indexes and update channelIndexKey.\n  const groupBy = (I, mark): number[][] => {\n    const { encode } = mark;\n    const binValues = binChannels.map((channel) => {\n      const [V] = columnOf(encode, channel);\n      return V;\n    });\n    const thresholds = subObject(rest, THRESHOLD);\n    const DI = I.filter((i) => binValues.every((V) => defined(V[i])));\n\n    // Group indexes by both discrete and quantitative channels.\n    const groupKeys = [\n      // For discrete channels, use value as group key.\n      ...groupChannels\n        .map((d) => {\n          const [V] = columnOf(encode, d);\n          return V;\n        })\n        .filter(defined)\n        .map((V) => (i) => V[i]),\n\n      // For quantitative channels, use extent of bin as group key.\n      ...binChannels.map((d, i) => {\n        const V = binValues[i];\n        const t = thresholds[d] || thresholdAuto(V as number[]);\n        const bins = d3Bin()\n          .thresholds(t)\n          .value((i) => +V[i])(DI);\n        const indexKey = new Map(\n          bins.flatMap((bin) => {\n            const { x0, x1 } = bin;\n            const key = `${x0},${x1}`;\n            return bin.map((i) => [i, key]);\n          }),\n        );\n        channelIndexKey[d] = indexKey;\n        return (i) => indexKey.get(i);\n      }),\n    ];\n\n    // Group by indexes by channel keys.\n    const key = (i: number) => groupKeys.map((key) => key(i)).join('-');\n    return Array.from(group(DI, key).values()) as number[][];\n  };\n\n  return GroupN({\n    // Non-bin channel and reducer.\n    ...Object.fromEntries(\n      Object.entries(rest).filter(([k]) => !k.startsWith(THRESHOLD)),\n    ),\n    // Bin channel and reducer.\n    ...Object.fromEntries(\n      binChannels.flatMap((channel) => {\n        const start = ([i]) => +channelIndexKey[channel].get(i).split(',')[0];\n        const end = ([i]) => +channelIndexKey[channel].get(i).split(',')[1];\n        end.from = channel;\n        return [\n          [channel, start],\n          [`${channel}1`, end],\n        ];\n      }),\n    ),\n    groupBy,\n  });\n};\n\nBin.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}