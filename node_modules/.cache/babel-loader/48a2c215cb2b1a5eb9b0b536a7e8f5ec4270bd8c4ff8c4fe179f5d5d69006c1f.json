{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Rect } from '@antv/g';\nimport { deepMix, upperFirst, isArray } from '@antv/util';\nimport { group, groups } from '@antv/vendor/d3-array';\nimport { format } from '@antv/vendor/d3-format';\nimport { mapObject } from '../utils/array';\nimport { ChartEvent } from '../utils/event';\nimport { isStrictObject, appendTransform, compose, copyAttributes, defined, error, maybeSubObject, subObject, useMemo } from '../utils/helper';\nimport { select, Selection } from '../utils/selection';\nimport { groupComponents, inferComponent, normalizeComponents, renderComponent } from './component';\nimport { AREA_CLASS_NAME, COMPONENT_CLASS_NAME, ELEMENT_CLASS_NAME, LABEL_CLASS_NAME, LABEL_LAYER_CLASS_NAME, MAIN_LAYER_CLASS_NAME, PLOT_CLASS_NAME, VIEW_CLASS_NAME } from './constant';\nimport { coordinate2Transform, createCoordinate } from './coordinate';\nimport { computeLayout, computeRoughPlotSize, placeComponents, processAxisZ } from './layout';\nimport { documentOf, useLibrary } from './library';\nimport { initializeMark } from './mark';\nimport { applyScale, assignScale, collectScales, inferScale, syncFacetsScales, useRelationScale, groupTransform } from './scale';\nimport { applyDataTransform } from './transform';\nexport function plot(options, selection, context) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      library\n    } = context;\n    const [useComposition] = useLibrary('composition', library);\n    const [useInteraction] = useLibrary('interaction', library);\n    // Some helper functions.\n    const marks = new Set(Object.keys(library).map(d => {\n      var _a;\n      return (_a = /mark\\.(.*)/.exec(d)) === null || _a === void 0 ? void 0 : _a[1];\n    }).filter(defined));\n    const staticMarks = new Set(Object.keys(library).map(d => {\n      var _a;\n      return (_a = /component\\.(.*)/.exec(d)) === null || _a === void 0 ? void 0 : _a[1];\n    }).filter(defined));\n    const typeOf = node => {\n      const {\n        type\n      } = node;\n      if (typeof type === 'function') {\n        // @ts-ignore\n        const {\n          props = {}\n        } = type;\n        const {\n          composite = true\n        } = props;\n        if (composite) return 'mark';\n      }\n      if (typeof type !== 'string') return type;\n      if (marks.has(type) || staticMarks.has(type)) return 'mark';\n      return type;\n    };\n    const isMark = node => typeOf(node) === 'mark';\n    const isStandardView = node => typeOf(node) === 'standardView';\n    const isStaticMark = node => {\n      const {\n        type\n      } = node;\n      if (typeof type !== 'string') return false;\n      if (staticMarks.has(type)) return true;\n      return false;\n    };\n    const transform = node => {\n      if (isStandardView(node)) return [node];\n      const type = typeOf(node);\n      const composition = useComposition({\n        type,\n        static: isStaticMark(node)\n      });\n      return composition(node);\n    };\n    // Some temporary variables help parse the view tree.\n    const views = [];\n    const viewNode = new Map();\n    const nodeState = new Map();\n    const discovered = [options];\n    const nodeGenerators = [];\n    while (discovered.length) {\n      const node = discovered.shift();\n      if (isStandardView(node)) {\n        // Initialize view to get data to be visualized. If the marks\n        // of the view have already been initialized (facet view),\n        // initialize the view based on the initialized mark states,\n        // otherwise initialize it from beginning.\n        const state = nodeState.get(node);\n        const [view, children] = state ? initializeState(state, node, library) : yield initializeView(node, context);\n        viewNode.set(view, node);\n        views.push(view);\n        // Transform children, they will be transformed into\n        // standardView if they are mark or view node.\n        const transformedNodes = children.flatMap(transform).map(d => coordinate2Transform(d, library));\n        discovered.push(...transformedNodes);\n        // Only StandardView can be treated as facet and it\n        // should sync position scales among facets normally.\n        if (transformedNodes.every(isStandardView)) {\n          const states = yield Promise.all(transformedNodes.map(d => initializeMarks(d, context)));\n          // Note!!!\n          // This will mutate scales for marks.\n          syncFacetsScales(states);\n          for (let i = 0; i < transformedNodes.length; i++) {\n            const nodeT = transformedNodes[i];\n            const state = states[i];\n            nodeState.set(nodeT, state);\n          }\n        }\n      } else {\n        // Apply transform to get data in advance for non-mark composition\n        // node, which makes sure that composition node can preprocess the\n        // data to produce more nodes based on it.\n        const n = isMark(node) ? node : yield applyTransform(node, context);\n        const N = transform(n);\n        if (Array.isArray(N)) discovered.push(...N);else if (typeof N === 'function') nodeGenerators.push(N());\n      }\n    }\n    context.emitter.emit(ChartEvent.BEFORE_PAINT);\n    // Plot chart.\n    const enterContainer = new Map();\n    const updateContainer = new Map();\n    const transitions = [];\n    selection.selectAll(className(VIEW_CLASS_NAME)).data(views, d => d.key).join(enter => enter.append('g').attr('className', VIEW_CLASS_NAME).attr('id', view => view.key).call(applyTranslate).each(function (view, i, element) {\n      plotView(view, select(element), transitions, context);\n      enterContainer.set(view, element);\n    }), update => update.call(applyTranslate).each(function (view, i, element) {\n      plotView(view, select(element), transitions, context);\n      updateContainer.set(view, element);\n    }), exit => exit.each(function (d, i, element) {\n      // Remove existed interactions.\n      const interactions = element['nameInteraction'].values();\n      for (const interaction of interactions) {\n        interaction.destroy();\n      }\n    }).remove());\n    // Apply interactions.\n    const viewInstanceof = (viewContainer, updateInteractions, oldStore) => {\n      return Array.from(viewContainer.entries()).map(([view, container]) => {\n        // Index state by component or interaction name,\n        // such as legend, scrollbar, brushFilter.\n        // Each state transform options to another options.\n        const store = oldStore || new Map();\n        const setState = (key, reducer = x => x) => store.set(key, reducer);\n        const options = viewNode.get(view);\n        const update = createUpdateView(select(container), options, context);\n        return {\n          view,\n          container,\n          options,\n          setState,\n          update: (from, updateTypes) => __awaiter(this, void 0, void 0, function* () {\n            // Apply all state functions to get new options.\n            const reducer = compose(Array.from(store.values()));\n            const newOptions = reducer(options);\n            return yield update(newOptions, from, () => {\n              if (isArray(updateTypes)) {\n                updateInteractions(viewContainer, updateTypes, store);\n              }\n            });\n          })\n        };\n      });\n    };\n    const updateInteractions = (container = updateContainer, updateType, oldStore) => {\n      var _a;\n      // Interactions for update views.\n      const updateViewInstances = viewInstanceof(container, updateInteractions, oldStore);\n      for (const target of updateViewInstances) {\n        const {\n          options,\n          container\n        } = target;\n        const nameInteraction = container['nameInteraction'];\n        let typeOptions = inferInteraction(options);\n        if (updateType) {\n          typeOptions = typeOptions.filter(v => updateType.includes(v[0]));\n        }\n        for (const typeOption of typeOptions) {\n          const [type, option] = typeOption;\n          // Remove interaction for existed views.\n          const prevInteraction = nameInteraction.get(type);\n          if (prevInteraction) (_a = prevInteraction.destroy) === null || _a === void 0 ? void 0 : _a.call(prevInteraction);\n          // Apply new interaction.\n          if (option) {\n            const interaction = useThemeInteraction(target.view, type, option, useInteraction);\n            const destroy = interaction(target, updateViewInstances, context.emitter);\n            nameInteraction.set(type, {\n              destroy\n            });\n          }\n        }\n      }\n    };\n    // Interactions for enter views.\n    const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);\n    for (const target of enterViewInstances) {\n      const {\n        options\n      } = target;\n      // A Map index interaction by interaction name.\n      const nameInteraction = new Map();\n      target.container['nameInteraction'] = nameInteraction;\n      // Apply interactions.\n      for (const typeOption of inferInteraction(options)) {\n        const [type, option] = typeOption;\n        if (option) {\n          const interaction = useThemeInteraction(target.view, type, option, useInteraction);\n          const destroy = interaction(target, enterViewInstances, context.emitter);\n          nameInteraction.set(type, {\n            destroy\n          });\n        }\n      }\n    }\n    updateInteractions();\n    // Author animations.\n    const {\n      width,\n      height\n    } = options;\n    const keyframes = [];\n    for (const nodeGenerator of nodeGenerators) {\n      // Delay the rendering of animation keyframe. Different animation\n      // created by different nodeGenerator will play in the same time.\n      // eslint-disable-next-line no-async-promise-executor\n      const keyframe = new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n        for (const node of nodeGenerator) {\n          const sizedNode = Object.assign({\n            width,\n            height\n          }, node);\n          yield plot(sizedNode, selection, context);\n        }\n        resolve();\n      }));\n      keyframes.push(keyframe);\n    }\n    context.views = views;\n    // Clear and update animation.\n    (_a = context.animations) === null || _a === void 0 ? void 0 : _a.forEach(animation => animation === null || animation === void 0 ? void 0 : animation.cancel());\n    context.animations = transitions;\n    context.emitter.emit(ChartEvent.AFTER_PAINT);\n    // Note!!!\n    // The returned promise will never resolved if one of nodeGenerator\n    // never stop to yield node, which may created by a keyframe composition\n    // with iteration count set to infinite.\n    const finished = transitions.filter(defined).map(cancel).map(d => d.finished);\n    return Promise.all([...finished, ...keyframes]);\n  });\n}\nfunction applyTranslate(selection) {\n  selection.style('transform', d => `translate(${d.layout.x}, ${d.layout.y})`);\n}\nfunction definedInteraction(library) {\n  const [, createInteraction] = useLibrary('interaction', library);\n  return d => {\n    const [name, options] = d;\n    try {\n      return [name, createInteraction(name)];\n    } catch (_a) {\n      return [name, options.type];\n    }\n  };\n}\nfunction createUpdateView(selection, options, context) {\n  const {\n    library\n  } = context;\n  const createDefinedInteraction = definedInteraction(library);\n  const filter = d => d[1] && d[1].props && d[1].props.reapplyWhenUpdate;\n  const interactions = inferInteraction(options);\n  const updates = interactions.map(createDefinedInteraction).filter(filter).map(d => d[0]);\n  return (newOptions, source, callback) => __awaiter(this, void 0, void 0, function* () {\n    const transitions = [];\n    const [newView, newChildren] = yield initializeView(newOptions, context);\n    plotView(newView, selection, transitions, context);\n    // Update interaction need to reapply when update.\n    for (const name of updates.filter(d => d !== source)) {\n      updateInteraction(name, selection, newOptions, newView, context);\n    }\n    for (const child of newChildren) {\n      plot(child, selection, context);\n    }\n    callback();\n    return {\n      options: newOptions,\n      view: newView\n    };\n  });\n}\nfunction updateInteraction(name, selection, options, view, context) {\n  var _a;\n  const {\n    library\n  } = context;\n  const [useInteraction] = useLibrary('interaction', library);\n  // Instances for interaction.\n  const container = selection.node();\n  const nameInteraction = container['nameInteraction'];\n  const interactionOptions = inferInteraction(options).find(([d]) => d === name);\n  // Destroy older interaction.\n  const interaction = nameInteraction.get(name);\n  if (!interaction) return;\n  (_a = interaction.destroy) === null || _a === void 0 ? void 0 : _a.call(interaction);\n  if (!interactionOptions[1]) return;\n  // Apply new interaction.\n  const applyInteraction = useThemeInteraction(view, name, interactionOptions[1], useInteraction);\n  const target = {\n    options,\n    view,\n    container: selection.node(),\n    update: options => Promise.resolve(options)\n  };\n  const destroy = applyInteraction(target, [], context.emitter);\n  nameInteraction.set(name, {\n    destroy\n  });\n}\nfunction initializeView(options, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      library\n    } = context;\n    const flattenOptions = yield transformMarks(options, context);\n    const mergedOptions = bubbleOptions(flattenOptions);\n    // @todo Remove this.\n    // !!! NOTE: Mute original view options.\n    // Update interaction and coordinate for this view.\n    options.interaction = mergedOptions.interaction;\n    options.coordinate = mergedOptions.coordinate;\n    // @ts-ignore\n    options.marks = [...mergedOptions.marks, ...mergedOptions.components];\n    const transformedOptions = coordinate2Transform(mergedOptions, library);\n    const state = yield initializeMarks(transformedOptions, context);\n    return initializeState(state, transformedOptions, library);\n  });\n}\nfunction bubbleOptions(options) {\n  const {\n      coordinate: viewCoordinate = {},\n      interaction: viewInteraction = {},\n      style: viewStyle = {},\n      marks\n    } = options,\n    rest = __rest(options, [\"coordinate\", \"interaction\", \"style\", \"marks\"]);\n  const markCoordinates = marks.map(d => d.coordinate || {});\n  const markInteractions = marks.map(d => d.interaction || {});\n  const markViewStyles = marks.map(d => d.viewStyle || {});\n  const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight((prev, cur) => deepMix(prev, cur), {});\n  const newInteraction = [viewInteraction, ...markInteractions].reduce((prev, cur) => deepMix(prev, cur), {});\n  const newStyle = [...markViewStyles, viewStyle].reduce((prev, cur) => deepMix(prev, cur), {});\n  return Object.assign(Object.assign({}, rest), {\n    marks,\n    coordinate: newCoordinate,\n    interaction: newInteraction,\n    style: newStyle\n  });\n}\nfunction transformMarks(options, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      library\n    } = context;\n    const [useMark, createMark] = useLibrary('mark', library);\n    const staticMarks = new Set(Object.keys(library).map(d => {\n      var _a;\n      return (_a = /component\\.(.*)/.exec(d)) === null || _a === void 0 ? void 0 : _a[1];\n    }).filter(defined));\n    const {\n      marks\n    } = options;\n    const flattenMarks = [];\n    const components = [];\n    const discovered = [...marks];\n    const {\n      width,\n      height\n    } = computeRoughPlotSize(options);\n    const markOptions = {\n      options,\n      width,\n      height\n    };\n    // Pre order traversal.\n    while (discovered.length) {\n      const [node] = discovered.splice(0, 1);\n      // Apply data transform to get data.\n      const mark = yield applyTransform(node, context);\n      const {\n        type = error('G2Mark type is required.'),\n        key\n      } = mark;\n      // For components.\n      if (staticMarks.has(type)) components.push(mark);else {\n        const {\n          props = {}\n        } = createMark(type);\n        const {\n          composite = true\n        } = props;\n        if (!composite) flattenMarks.push(mark);else {\n          // Unwrap data from { value: data } to data,\n          // then the composite mark can process the normalized data.\n          const {\n            data\n          } = mark;\n          const newMark = Object.assign(Object.assign({}, mark), {\n            data: data ? Array.isArray(data) ? data : data.value : data\n          });\n          // Convert composite mark to marks.\n          const marks = yield useMark(newMark, markOptions);\n          const M = Array.isArray(marks) ? marks : [marks];\n          discovered.unshift(...M.map((d, i) => Object.assign(Object.assign({}, d), {\n            key: `${key}-${i}`\n          })));\n        }\n      }\n    }\n    return Object.assign(Object.assign({}, options), {\n      marks: flattenMarks,\n      components\n    });\n  });\n}\nfunction initializeMarks(options, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      library\n    } = context;\n    const [useTheme] = useLibrary('theme', library);\n    const [, createMark] = useLibrary('mark', library);\n    const {\n      theme: partialTheme,\n      marks: partialMarks,\n      coordinates = []\n    } = options;\n    const theme = useTheme(inferTheme(partialTheme));\n    const markState = new Map();\n    // Initialize channels for marks.\n    for (const markOptions of partialMarks) {\n      const {\n        type\n      } = markOptions;\n      const {\n        props = {}\n      } = createMark(type);\n      const markAndState = yield initializeMark(markOptions, props, context);\n      if (markAndState) {\n        const [initializedMark, state] = markAndState;\n        markState.set(initializedMark, state);\n      }\n    }\n    // Group channels by scale key, each group has scale.\n    const scaleChannels = group(Array.from(markState.values()).flatMap(d => d.channels), ({\n      scaleKey\n    }) => scaleKey);\n    // Infer scale for each channel groups.\n    for (const channels of scaleChannels.values()) {\n      // Merge scale options for these channels.\n      const scaleOptions = channels.reduce((total, {\n        scale\n      }) => deepMix(total, scale), {});\n      const {\n        scaleKey\n      } = channels[0];\n      // Use the fields of the first channel as the title.\n      const {\n        values: FV\n      } = channels[0];\n      const fields = Array.from(new Set(FV.map(d => d.field).filter(defined)));\n      const options = deepMix({\n        guide: {\n          title: fields.length === 0 ? undefined : fields\n        },\n        field: fields[0]\n      }, scaleOptions);\n      // Use the name of the first channel as the scale name.\n      const {\n        name\n      } = channels[0];\n      const values = channels.flatMap(({\n        values\n      }) => values.map(d => d.value));\n      const scale = Object.assign(Object.assign({}, inferScale(name, values, options, coordinates, theme, library)), {\n        uid: Symbol('scale'),\n        key: scaleKey\n      });\n      channels.forEach(channel => channel.scale = scale);\n    }\n    return markState;\n  });\n}\nfunction useThemeInteraction(view, type, option, useInteraction) {\n  const theme = view.theme;\n  const defaults = typeof type === 'string' ? theme[type] || {} : {};\n  const interaction = useInteraction(deepMix(defaults, Object.assign({\n    type\n  }, option)));\n  return interaction;\n}\nfunction initializeState(markState, options, library) {\n  var _a;\n  const [useMark] = useLibrary('mark', library);\n  const [useTheme] = useLibrary('theme', library);\n  const [useLabelTransform] = useLibrary('labelTransform', library);\n  const {\n    key,\n    frame = false,\n    theme: partialTheme,\n    clip,\n    style = {},\n    labelTransform = []\n  } = options;\n  const theme = useTheme(inferTheme(partialTheme));\n  // Infer components and compute layout.\n  const states = Array.from(markState.values());\n  const scales = collectScales(states, options);\n  const components = normalizeComponents(inferComponent(inferComponentScales(Array.from(scales), states, markState), options, library));\n  const layout = computeLayout(components, options, theme, library);\n  const coordinate = createCoordinate(layout, options, library);\n  const framedStyle = frame ? deepMix({\n    mainLineWidth: 1,\n    mainStroke: '#000'\n  }, style) : style;\n  // Place components and mutate their bbox.\n  placeComponents(groupComponents(components), coordinate, layout);\n  // AxisZ need a copy of axisX and axisY to show grids in X-Z & Y-Z planes.\n  processAxisZ(components);\n  // Index scale instance by uid.\n  const uidScale = new Map(Array.from(markState.values()).flatMap(state => {\n    const {\n      channels\n    } = state;\n    return channels.map(({\n      scale\n    }) => [scale.uid, useRelationScale(scale, library)]);\n  }));\n  groupTransform(markState, uidScale);\n  // Scale from marks and components.\n  const scaleInstance = {};\n  // Initialize scale from components.\n  for (const component of components) {\n    const {\n      scales: scaleDescriptors = []\n    } = component;\n    const scales = [];\n    for (const descriptor of scaleDescriptors) {\n      const {\n        name,\n        uid\n      } = descriptor;\n      const scale = (_a = uidScale.get(uid)) !== null && _a !== void 0 ? _a : useRelationScale(descriptor, library);\n      scales.push(scale);\n      // Delivery the scale of axisX to the AxisY,\n      // in order to calculate the angle of axisY component when rendering radar chart.\n      if (name === 'y') {\n        scale.update(Object.assign(Object.assign({}, scale.getOptions()), {\n          xScale: scaleInstance.x\n        }));\n      }\n      assignScale(scaleInstance, {\n        [name]: scale\n      });\n    }\n    component.scaleInstances = scales;\n  }\n  // Calc data to be rendered for each mark.\n  // @todo More readable APIs for Container which stays\n  // the same style with JS standard and lodash APIs.\n  // @todo More proper way to index scale for different marks.\n  const children = [];\n  const dataMap = new Map();\n  for (const [mark, state] of markState.entries()) {\n    const {\n      // scale,\n      // Callback to create children options based on this mark.\n      children: createChildren,\n      // The total count of data (both show and hide)for this facet.\n      // This is for unit visualization to sync data domain.\n      dataDomain,\n      modifier,\n      key: markKey,\n      data\n    } = mark;\n    dataMap.set(markKey, data);\n    const {\n      index,\n      channels,\n      tooltip\n    } = state;\n    const scale = Object.fromEntries(channels.map(({\n      name,\n      scale\n    }) => [name, scale]));\n    // Transform abstract value to visual value by scales.\n    const markScaleInstance = mapObject(scale, ({\n      uid\n    }) => uidScale.get(uid));\n    assignScale(scaleInstance, markScaleInstance);\n    const value = applyScale(channels, markScaleInstance);\n    // Calc points and transformation for each data,\n    // and then transform visual value to visual data.\n    const calcPoints = useMark(mark);\n    const [I, P, S] = filterValid(calcPoints(index, markScaleInstance, value, coordinate));\n    const count = dataDomain || I.length;\n    const T = modifier ? modifier(P, count, layout) : [];\n    const titleOf = i => {\n      var _a, _b;\n      return (_b = (_a = tooltip.title) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.value;\n    };\n    const itemsOf = i => tooltip.items.map(V => V[i]);\n    const visualData = I.map((d, i) => {\n      const datum = Object.assign({\n        points: P[i],\n        transform: T[i],\n        index: d,\n        markKey,\n        viewKey: key,\n        data: data[d]\n      }, tooltip && {\n        title: titleOf(d),\n        items: itemsOf(d)\n      });\n      for (const [k, V] of Object.entries(value)) {\n        datum[k] = V[d];\n        if (S) datum[`series${upperFirst(k)}`] = S[i].map(i => V[i]);\n      }\n      if (S) datum['seriesIndex'] = S[i];\n      if (S && tooltip) {\n        datum['seriesItems'] = S[i].map(si => itemsOf(si));\n        datum['seriesTitle'] = S[i].map(si => titleOf(si));\n      }\n      return datum;\n    });\n    state.data = visualData;\n    state.index = I;\n    // Create children options by children callback,\n    // and then propagate data to each child.\n    const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);\n    children.push(...(markChildren || []));\n  }\n  const view = {\n    layout,\n    theme,\n    coordinate,\n    markState,\n    key,\n    clip,\n    scale: scaleInstance,\n    style: framedStyle,\n    components,\n    data: dataMap,\n    labelTransform: compose(labelTransform.map(useLabelTransform))\n  };\n  return [view, children];\n}\nfunction plotView(view, selection, transitions, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      library\n    } = context;\n    const {\n      components,\n      theme,\n      layout,\n      markState,\n      coordinate,\n      key,\n      style,\n      clip,\n      scale\n    } = view;\n    // Render background for the different areas.\n    const {\n        x,\n        y,\n        width,\n        height\n      } = layout,\n      rest = __rest(layout, [\"x\", \"y\", \"width\", \"height\"]);\n    const areaKeys = ['view', 'plot', 'main', 'content'];\n    const I = areaKeys.map((_, i) => i);\n    const sizeKeys = ['a', 'margin', 'padding', 'inset'];\n    const areaStyles = areaKeys.map(d => maybeSubObject(Object.assign({}, theme.view, style), d));\n    const areaSizes = sizeKeys.map(d => subObject(rest, d));\n    const styleArea = selection => selection.style('x', i => areaLayouts[i].x).style('y', i => areaLayouts[i].y).style('width', i => areaLayouts[i].width).style('height', i => areaLayouts[i].height).each(function (i, d, element) {\n      applyStyle(select(element), areaStyles[i]);\n    });\n    let px = 0;\n    let py = 0;\n    let pw = width;\n    let ph = height;\n    const areaLayouts = I.map(i => {\n      const size = areaSizes[i];\n      const {\n        left = 0,\n        top = 0,\n        bottom = 0,\n        right = 0\n      } = size;\n      px += left;\n      py += top;\n      pw -= left + right;\n      ph -= top + bottom;\n      return {\n        x: px,\n        y: py,\n        width: pw,\n        height: ph\n      };\n    });\n    selection.selectAll(className(AREA_CLASS_NAME)).data(\n    // Only render area with defined style.\n    I.filter(i => defined(areaStyles[i])), i => areaKeys[i]).join(enter => enter.append('rect').attr('className', AREA_CLASS_NAME).style('zIndex', -2).call(styleArea), update => update.call(styleArea), exit => exit.remove());\n    const animationExtent = computeAnimationExtent(markState);\n    const componentAnimateOptions = animationExtent ? {\n      duration: animationExtent[1]\n    } : false;\n    // Render components.\n    // @todo renderComponent return ctor and options.\n    // Key for each type of component.\n    // Index them grouped by position.\n    for (const [, C] of groups(components, d => `${d.type}-${d.position}`)) {\n      C.forEach((d, i) => d.index = i);\n    }\n    const componentsTransitions = selection.selectAll(className(COMPONENT_CLASS_NAME)).data(components, d => `${d.type}-${d.position}-${d.index}`).join(enter => enter.append('g').style('zIndex', ({\n      zIndex\n    }) => zIndex || -1).attr('className', COMPONENT_CLASS_NAME).append(options => renderComponent(deepMix({\n      animate: componentAnimateOptions,\n      scale\n    }, options), coordinate, theme, library, markState)), update => update.transition(function (options, i, element) {\n      const {\n        preserve = false\n      } = options;\n      if (preserve) return;\n      const newComponent = renderComponent(deepMix({\n        animate: componentAnimateOptions,\n        scale\n      }, options), coordinate, theme, library, markState);\n      const {\n        attributes\n      } = newComponent;\n      const [node] = element.childNodes;\n      return node.update(attributes, false);\n    })).transitions();\n    transitions.push(...componentsTransitions.flat().filter(defined));\n    // Main layer is for showing the main visual representation such as marks. There\n    // may be multiple main layers for a view, each main layer correspond to one of marks.\n    // @todo Test DOM structure.\n    const T = selection.selectAll(className(PLOT_CLASS_NAME)).data([layout], () => key).join(enter => enter\n    // Make this layer interactive, such as click and mousemove events.\n    .append('rect').style('zIndex', 0).style('fill', 'transparent').attr('className', PLOT_CLASS_NAME).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), update => update.call(updateLayers, Array.from(markState.keys())).call(selection => {\n      return animationExtent ? animateBBox(selection, animationExtent) : updateBBox(selection);\n    }).call(applyClip, clip)).transitions();\n    transitions.push(...T.flat());\n    // Render marks with corresponding data.\n    for (const [mark, state] of markState.entries()) {\n      const {\n        data\n      } = state;\n      const {\n        key,\n        class: cls,\n        type\n      } = mark;\n      const viewNode = selection.select(`#${key}`);\n      const shapeFunction = createMarkShapeFunction(mark, state, view, context);\n      const enterFunction = createEnterFunction(mark, state, view, library);\n      const updateFunction = createUpdateFunction(mark, state, view, library);\n      const exitFunction = createExitFunction(mark, state, view, library);\n      const facetElements = selectFacetElements(selection, viewNode, cls, 'element');\n      const T = viewNode.selectAll(className(ELEMENT_CLASS_NAME)).selectFacetAll(facetElements).data(data, d => d.key, d => d.groupKey).join(enter => enter.append(shapeFunction)\n      // Note!!! Only one className can be set.\n      // Using attribute as alternative for other classNames.\n      .attr('className', ELEMENT_CLASS_NAME).attr('markType', type).transition(function (data, i, element) {\n        return enterFunction(data, [element]);\n      }), update => update.call(selection => {\n        const parent = selection.parent();\n        const origin = useMemo(node => {\n          const [x, y] = node.getBounds().min;\n          return [x, y];\n        });\n        selection.transition(function (data, index, element) {\n          maybeFacetElement(element, parent, origin);\n          const node = shapeFunction(data, index);\n          const animation = updateFunction(data, [element], [node]);\n          if (animation === null || animation === void 0 ? void 0 : animation.length) return animation;\n          if (element.nodeName === node.nodeName && node.nodeName !== 'g') {\n            copyAttributes(element, node);\n          } else {\n            element.parentNode.replaceChild(node, element);\n            node.className = ELEMENT_CLASS_NAME;\n            // @ts-ignore\n            node.markType = type;\n            // @ts-ignore\n            node.__data__ = element.__data__;\n          }\n          return animation;\n        }).attr('markType', type).attr('className', ELEMENT_CLASS_NAME);\n      }), exit => {\n        return exit.each(function (d, i, element) {\n          element.__removed__ = true;\n        }).transition(function (data, i, element) {\n          return exitFunction(data, [element]);\n        }).remove();\n      }, merge => merge\n      // Append elements to be merged.\n      .append(shapeFunction).attr('className', ELEMENT_CLASS_NAME).attr('markType', type).transition(function (data, i, element) {\n        // Remove merged elements after animation finishing.\n        const {\n          __fromElements__: fromElements\n        } = element;\n        const transition = updateFunction(data, fromElements, [element]);\n        const exit = new Selection(fromElements, null, element.parentNode);\n        exit.transition(transition).remove();\n        return transition;\n      }), split => split.transition(function (data, i, element) {\n        // Append splitted shapes.\n        const enter = new Selection([], element.__toData__, element.parentNode);\n        const toElements = enter.append(shapeFunction).attr('className', ELEMENT_CLASS_NAME).attr('markType', type).nodes();\n        return updateFunction(data, [element], toElements);\n      })\n      // Remove elements to be splitted after animation finishing.\n      .remove()).transitions();\n      transitions.push(...T.flat());\n    }\n    // Plot label for this view.\n    plotLabel(view, selection, transitions, library, context);\n  });\n}\n/**\n * Auto hide labels be specify label layout.\n */\nfunction plotLabel(view, selection, transitions, library, context) {\n  const [useLabelTransform] = useLibrary('labelTransform', library);\n  const {\n    markState,\n    labelTransform\n  } = view;\n  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();\n  // A Map index shapeFunction by label.\n  const labelShapeFunction = new Map();\n  // A Map index options by label.\n  const labelDescriptor = new Map();\n  // Get all labels for this view.\n  const labels = Array.from(markState.entries()).flatMap(([mark, state]) => {\n    const {\n      labels: labelOptions = [],\n      key\n    } = mark;\n    const shapeFunction = createLabelShapeFunction(mark, state, view, library, context);\n    const elements = selection.select(`#${key}`).selectAll(className(ELEMENT_CLASS_NAME)).nodes()\n    // Only select the valid element.\n    .filter(n => !n.__removed__);\n    return labelOptions.flatMap((labelOption, i) => {\n      const {\n          transform = []\n        } = labelOption,\n        options = __rest(labelOption, [\"transform\"]);\n      return elements.flatMap(e => {\n        const L = getLabels(options, i, e);\n        L.forEach(l => {\n          labelShapeFunction.set(l, data => shapeFunction(Object.assign(Object.assign({}, data), {\n            element: e\n          })));\n          labelDescriptor.set(l, labelOption);\n        });\n        return L;\n      });\n    });\n  });\n  // Render all labels.\n  const labelShapes = select(labelLayer).selectAll(className(LABEL_CLASS_NAME)).data(labels, d => d.key).join(enter => enter.append(d => labelShapeFunction.get(d)(d)).attr('className', LABEL_CLASS_NAME), update => update.each(function (d, i, element) {\n    // @todo Handle Label with different type.\n    const shapeFunction = labelShapeFunction.get(d);\n    const node = shapeFunction(d);\n    copyAttributes(element, node);\n  }), exit => exit.remove()).nodes();\n  // Apply group-level transforms.\n  const labelGroups = group(labelShapes, d => labelDescriptor.get(d.__data__));\n  const {\n    coordinate,\n    layout\n  } = view;\n  const labelTransformContext = {\n    canvas: context.canvas,\n    coordinate,\n    layout\n  };\n  for (const [label, shapes] of labelGroups) {\n    const {\n      transform = []\n    } = label;\n    const transformFunction = compose(transform.map(useLabelTransform));\n    transformFunction(shapes, labelTransformContext);\n  }\n  // Apply view-level transform.\n  if (labelTransform) {\n    labelTransform(labelShapes, labelTransformContext);\n  }\n}\nfunction getLabels(label, labelIndex, element) {\n  const {\n    seriesIndex: SI,\n    seriesKey,\n    points,\n    key,\n    index\n  } = element.__data__;\n  const bounds = getLocalBounds(element);\n  if (!SI) {\n    return [Object.assign(Object.assign({}, label), {\n      key: `${key}-${labelIndex}`,\n      bounds,\n      index,\n      points,\n      dependentElement: element\n    })];\n  }\n  const selector = normalizeLabelSelector(label);\n  const F = SI.map((index, i) => Object.assign(Object.assign({}, label), {\n    key: `${seriesKey[i]}-${labelIndex}`,\n    bounds: [points[i]],\n    index,\n    points,\n    dependentElement: element\n  }));\n  return selector ? selector(F) : F;\n}\nfunction filterValid([I, P, S]) {\n  if (S) return [I, P, S];\n  const definedIndex = [];\n  const definedPoints = [];\n  for (let i = 0; i < I.length; i++) {\n    const d = I[i];\n    const p = P[i];\n    if (p.every(([x, y]) => defined(x) && defined(y))) {\n      definedIndex.push(d);\n      definedPoints.push(p);\n    }\n  }\n  return [definedIndex, definedPoints];\n}\nfunction normalizeLabelSelector(label) {\n  const {\n    selector\n  } = label;\n  if (!selector) return null;\n  if (typeof selector === 'function') return selector;\n  if (selector === 'first') return I => [I[0]];\n  if (selector === 'last') return I => [I[I.length - 1]];\n  throw new Error(`Unknown selector: ${selector}`);\n}\n/**\n * Avoid getting error bounds caused by element animations.\n * @todo Remove this temporary handle method, if runtime supports\n * correct process: drawElement, do label layout and then do\n * transitions together.\n */\nfunction getLocalBounds(element) {\n  const cloneElement = element.cloneNode(true);\n  const animations = element.getAnimations();\n  cloneElement.style.visibility = 'hidden';\n  animations.forEach(animation => {\n    const keyframes = animation.effect.getKeyframes();\n    cloneElement.attr(keyframes[keyframes.length - 1]);\n  });\n  element.parentNode.appendChild(cloneElement);\n  const bounds = cloneElement.getLocalBounds();\n  cloneElement.destroy();\n  const {\n    min,\n    max\n  } = bounds;\n  return [min, max];\n}\nfunction createLabelShapeFunction(mark, state, view, library, context) {\n  const [useShape] = useLibrary('shape', library);\n  const {\n    data: abstractData,\n    encode\n  } = mark;\n  const {\n    data: visualData,\n    defaultLabelShape\n  } = state;\n  const point2d = visualData.map(d => d.points);\n  const channel = mapObject(encode, d => d.value);\n  // Assemble Context.\n  const {\n    theme,\n    coordinate\n  } = view;\n  const shapeContext = Object.assign(Object.assign({}, context), {\n    document: documentOf(context),\n    theme,\n    coordinate\n  });\n  return options => {\n    // Computed values from data and styles.\n    const {\n      index,\n      points\n    } = options;\n    const datum = abstractData[index];\n    const {\n        formatter = d => `${d}`,\n        transform,\n        style: abstractStyle,\n        render,\n        selector,\n        element\n      } = options,\n      abstractOptions = __rest(options, [\"formatter\", \"transform\", \"style\", \"render\", \"selector\", \"element\"]);\n    const visualOptions = mapObject(Object.assign(Object.assign({}, abstractOptions), abstractStyle), d => valueOf(d, datum, index, abstractData, {\n      channel,\n      element\n    }));\n    const {\n        shape = defaultLabelShape,\n        text\n      } = visualOptions,\n      style = __rest(visualOptions, [\"shape\", \"text\"]);\n    const f = typeof formatter === 'string' ? format(formatter) : formatter;\n    const value = Object.assign(Object.assign({}, style), {\n      text: f(text, datum, index, abstractData),\n      datum\n    });\n    // Params for create shape.\n    const shapeOptions = Object.assign({\n      type: `label.${shape}`,\n      render\n    }, style);\n    const shapeFunction = useShape(shapeOptions, shapeContext);\n    const defaults = getDefaultsStyle(theme, 'label', shape, 'label');\n    return shapeFunction(points, value, defaults, point2d);\n  };\n}\nfunction valueOf(value, datum, i, data, options) {\n  if (typeof value === 'function') return value(datum, i, data, options);\n  if (typeof value !== 'string') return value;\n  if (isStrictObject(datum) && datum[value] !== undefined) return datum[value];\n  return value;\n}\n/**\n * Compute max duration for this frame.\n */\nfunction computeAnimationExtent(markState) {\n  let maxDuration = -Infinity;\n  let minDelay = Infinity;\n  for (const [mark, state] of markState) {\n    const {\n      animate = {}\n    } = mark;\n    const {\n      data\n    } = state;\n    const {\n      enter = {},\n      update = {},\n      exit = {}\n    } = animate;\n    const {\n      type: defaultUpdateType,\n      duration: defaultUpdateDuration = 300,\n      delay: defaultUpdateDelay = 0\n    } = update;\n    const {\n      type: defaultEnterType,\n      duration: defaultEnterDuration = 300,\n      delay: defaultEnterDelay = 0\n    } = enter;\n    const {\n      type: defaultExitType,\n      duration: defaultExitDuration = 300,\n      delay: defaultExitDelay = 0\n    } = exit;\n    for (const d of data) {\n      const {\n        updateType = defaultUpdateType,\n        updateDuration = defaultUpdateDuration,\n        updateDelay = defaultUpdateDelay,\n        enterType = defaultEnterType,\n        enterDuration = defaultEnterDuration,\n        enterDelay = defaultEnterDelay,\n        exitDuration = defaultExitDuration,\n        exitDelay = defaultExitDelay,\n        exitType = defaultExitType\n      } = d;\n      if (updateType === undefined || updateType) {\n        maxDuration = Math.max(maxDuration, updateDuration + updateDelay);\n        minDelay = Math.min(minDelay, updateDelay);\n      }\n      if (exitType === undefined || exitType) {\n        maxDuration = Math.max(maxDuration, exitDuration + exitDelay);\n        minDelay = Math.min(minDelay, exitDelay);\n      }\n      if (enterType === undefined || enterType) {\n        maxDuration = Math.max(maxDuration, enterDuration + enterDelay);\n        minDelay = Math.min(minDelay, enterDelay);\n      }\n    }\n  }\n  if (maxDuration === -Infinity) return null;\n  return [minDelay, maxDuration - minDelay];\n}\nfunction selectFacetElements(selection, current, facetClassName, elementClassName) {\n  const group = selection.node().parentElement;\n  if (!group || typeof group.findAll !== 'function') return [];\n  return group.findAll(node => node.style.facet !== undefined && node.style.facet === facetClassName && node !== current.node()).flatMap(node => node.getElementsByClassName(elementClassName));\n}\n/**\n * Update the parent of element and apply transform to make it\n * stay in original position.\n */\nfunction maybeFacetElement(element, parent, originOf) {\n  if (!element.__facet__) return;\n  // element -> g#main -> rect#plot\n  const prePlot = element.parentNode.parentNode;\n  // g#main -> rect#plot\n  const newPlot = parent.parentNode;\n  const [px, py] = originOf(prePlot);\n  const [x, y] = originOf(newPlot);\n  const translate = `translate(${px - x}, ${py - y})`;\n  appendTransform(element, translate);\n  parent.append(element);\n}\nfunction createMarkShapeFunction(mark, state, view, context) {\n  const {\n    library\n  } = context;\n  const [useShape] = useLibrary('shape', library);\n  const {\n    data: abstractData,\n    encode\n  } = mark;\n  const {\n    defaultShape,\n    data,\n    shape: shapeLibrary\n  } = state;\n  const channel = mapObject(encode, d => d.value);\n  const point2d = data.map(d => d.points);\n  const {\n    theme,\n    coordinate\n  } = view;\n  const {\n    type: markType,\n    style = {}\n  } = mark;\n  const shapeContext = Object.assign(Object.assign({}, context), {\n    document: documentOf(context),\n    coordinate,\n    theme\n  });\n  return data => {\n    const {\n      shape: styleShape = defaultShape\n    } = style;\n    const {\n        shape = styleShape,\n        points,\n        seriesIndex,\n        index: i\n      } = data,\n      v = __rest(data, [\"shape\", \"points\", \"seriesIndex\", \"index\"]);\n    const value = Object.assign(Object.assign({}, v), {\n      index: i\n    });\n    // Get data-driven style.\n    // If it is a series shape, such as area and line,\n    // provides the series of abstract data and indices\n    // for this shape, otherwise the single datum and\n    // index.\n    const abstractDatum = seriesIndex ? seriesIndex.map(i => abstractData[i]) : abstractData[i];\n    const I = seriesIndex ? seriesIndex : i;\n    const visualStyle = mapObject(style, d => valueOf(d, abstractDatum, I, abstractData, {\n      channel\n    }));\n    // Try get shape from mark first, then from library.\n    const shapeFunction = shapeLibrary[shape] ? shapeLibrary[shape](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), {\n      type: shapeName(mark, shape)\n    }), shapeContext);\n    const defaults = getDefaultsStyle(theme, markType, shape, defaultShape);\n    return shapeFunction(points, value, defaults, point2d);\n  };\n}\nfunction getDefaultsStyle(theme, mark, shape, defaultShape) {\n  if (typeof mark !== 'string') return;\n  const {\n    color\n  } = theme;\n  const markTheme = theme[mark] || {};\n  const shapeTheme = markTheme[shape] || markTheme[defaultShape];\n  return Object.assign({\n    color\n  }, shapeTheme);\n}\nfunction createAnimationFunction(type, mark, state, view, library) {\n  var _a, _b;\n  const [, createShape] = useLibrary('shape', library);\n  const [useAnimation] = useLibrary('animation', library);\n  const {\n    defaultShape,\n    shape: shapeLibrary\n  } = state;\n  const {\n    theme,\n    coordinate\n  } = view;\n  const upperType = upperFirst(type);\n  const key = `default${upperType}Animation`;\n  // Get shape from mark first, then from library.\n  const {\n    [key]: defaultAnimation\n  } = ((_a = shapeLibrary[defaultShape]) === null || _a === void 0 ? void 0 : _a.props) || createShape(shapeName(mark, defaultShape)).props;\n  const {\n    [type]: defaultEffectTiming = {}\n  } = theme;\n  const animate = ((_b = mark.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};\n  const context = {\n    coordinate\n  };\n  return (data, from, to) => {\n    const {\n      [`${type}Type`]: animation,\n      [`${type}Delay`]: delay,\n      [`${type}Duration`]: duration,\n      [`${type}Easing`]: easing\n    } = data;\n    const options = Object.assign({\n      type: animation || defaultAnimation\n    }, animate);\n    if (!options.type) return null;\n    const animateFunction = useAnimation(options, context);\n    const value = {\n      delay,\n      duration,\n      easing\n    };\n    const A = animateFunction(from, to, deepMix(defaultEffectTiming, value));\n    let an = [];\n    if (!Array.isArray(A)) {\n      an = [A];\n    } else {\n      an = A;\n    }\n    return an.filter(Boolean);\n  };\n}\nfunction createEnterFunction(mark, state, view, library) {\n  return createAnimationFunction('enter', mark, state, view, library);\n}\n/**\n * Animation will not cancel automatically, it should be canceled\n * manually. This is very important for performance.\n */\nfunction cancel(animation) {\n  animation.finished.then(() => {\n    animation.cancel();\n  });\n  return animation;\n}\nfunction createUpdateFunction(mark, state, view, library) {\n  return createAnimationFunction('update', mark, state, view, library);\n}\nfunction createExitFunction(mark, state, view, library) {\n  return createAnimationFunction('exit', mark, state, view, library);\n}\nfunction inferTheme(theme = {}) {\n  if (typeof theme === 'string') return {\n    type: theme\n  };\n  const {\n      type = 'light'\n    } = theme,\n    rest = __rest(theme, [\"type\"]);\n  return Object.assign(Object.assign({}, rest), {\n    type\n  });\n}\n/**\n * @todo Infer builtin tooltips.\n */\nfunction inferInteraction(view) {\n  const defaults = {\n    event: true,\n    tooltip: true,\n    // @todo Inferred by slider self.\n    sliderFilter: true,\n    legendFilter: true,\n    scrollbarFilter: true\n  };\n  const {\n    interaction = {}\n  } = view;\n  return Object.entries(deepMix(defaults, interaction)).reverse();\n}\nfunction applyTransform(node, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n        data\n      } = node,\n      rest = __rest(node, [\"data\"]);\n    if (data == undefined) return node;\n    const [, {\n      data: newData\n    }] = yield applyDataTransform([], {\n      data\n    }, context);\n    return Object.assign({\n      data: newData\n    }, rest);\n  });\n}\nfunction updateBBox(selection) {\n  selection.style('transform', d => `translate(${d.paddingLeft + d.marginLeft}, ${d.paddingTop + d.marginTop})`).style('width', d => d.innerWidth).style('height', d => d.innerHeight);\n}\nfunction animateBBox(selection, extent) {\n  const [delay, duration] = extent;\n  selection.transition(function (data, i, element) {\n    const {\n      transform,\n      width,\n      height\n    } = element.style;\n    const {\n      paddingLeft,\n      paddingTop,\n      innerWidth,\n      innerHeight,\n      marginLeft,\n      marginTop\n    } = data;\n    const keyframes = [{\n      transform,\n      width,\n      height\n    }, {\n      transform: `translate(${paddingLeft + marginLeft}, ${paddingTop + marginTop})`,\n      width: innerWidth,\n      height: innerHeight\n    }];\n    return element.animate(keyframes, {\n      delay,\n      duration,\n      fill: 'both'\n    });\n  });\n}\nfunction shapeName(mark, name) {\n  const {\n    type\n  } = mark;\n  if (typeof name === 'string') return `${type}.${name}`;\n  return name;\n}\n/**\n * Create and update layer for each mark.\n * All the layers created here are treated as main layers.\n */\nfunction updateLayers(selection, marks) {\n  const facet = d => d.class !== undefined ? `${d.class}` : '';\n  // Skip for empty selection, it can't append nodes.\n  const nodes = selection.nodes();\n  if (nodes.length === 0) return;\n  selection.selectAll(className(MAIN_LAYER_CLASS_NAME)).data(marks, d => d.key).join(enter => enter.append('g').attr('className', MAIN_LAYER_CLASS_NAME).attr('id', d => d.key).style('facet', facet).style('fill', 'transparent').style('zIndex', d => {\n    var _a;\n    return (_a = d.zIndex) !== null && _a !== void 0 ? _a : 0;\n  }), update => update.style('facet', facet).style('fill', 'transparent').style('zIndex', d => {\n    var _a;\n    return (_a = d.zIndex) !== null && _a !== void 0 ? _a : 0;\n  }), exit => exit.remove());\n  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();\n  if (labelLayer) return;\n  selection.append('g').attr('className', LABEL_LAYER_CLASS_NAME).style('zIndex', 0);\n}\nfunction className(...names) {\n  return names.map(d => `.${d}`).join('');\n}\nfunction applyClip(selection, clip) {\n  if (!selection.node()) return;\n  selection.style('clipPath', data => {\n    if (!clip) return null;\n    const {\n      paddingTop: y,\n      paddingLeft: x,\n      marginLeft: x1,\n      marginTop: y1,\n      innerWidth: width,\n      innerHeight: height\n    } = data;\n    return new Rect({\n      style: {\n        x: x + x1,\n        y: y + y1,\n        width,\n        height\n      }\n    });\n  });\n}\nfunction inferComponentScales(scales, states, markState) {\n  // add shape scale to state.\n  var _a;\n  // for cell, omit shape scale.\n  // @todo support shape scale for cell.\n  for (const [key] of markState.entries()) {\n    if (key.type === 'cell') {\n      return scales.filter(scale => scale.name !== 'shape');\n    }\n  }\n  // can't infer shape scale if there are multiple states.\n  if (states.length !== 1 || scales.some(scale => scale.name === 'shape')) {\n    return scales;\n  }\n  const {\n    defaultShape: shape\n  } = states[0];\n  const acceptMarkTypes = ['point', 'line', 'rect', 'hollow'];\n  if (!acceptMarkTypes.includes(shape)) return scales;\n  const shapeMap = {\n    point: 'point',\n    line: 'hyphen',\n    rect: 'square',\n    hollow: 'hollow'\n  };\n  // create shape scale\n  const field = ((_a = scales.find(scale => scale.name === 'color')) === null || _a === void 0 ? void 0 : _a.field) || null;\n  const shapeScale = {\n    field,\n    name: 'shape',\n    type: 'constant',\n    domain: [],\n    range: [shapeMap[shape]]\n  };\n  return [...scales, shapeScale];\n}\nexport function applyStyle(selection, style) {\n  for (const [key, value] of Object.entries(style)) {\n    selection.style(key, value);\n  }\n}","map":{"version":3,"names":["Rect","deepMix","upperFirst","isArray","group","groups","format","mapObject","ChartEvent","isStrictObject","appendTransform","compose","copyAttributes","defined","error","maybeSubObject","subObject","useMemo","select","Selection","groupComponents","inferComponent","normalizeComponents","renderComponent","AREA_CLASS_NAME","COMPONENT_CLASS_NAME","ELEMENT_CLASS_NAME","LABEL_CLASS_NAME","LABEL_LAYER_CLASS_NAME","MAIN_LAYER_CLASS_NAME","PLOT_CLASS_NAME","VIEW_CLASS_NAME","coordinate2Transform","createCoordinate","computeLayout","computeRoughPlotSize","placeComponents","processAxisZ","documentOf","useLibrary","initializeMark","applyScale","assignScale","collectScales","inferScale","syncFacetsScales","useRelationScale","groupTransform","applyDataTransform","plot","options","selection","context","library","useComposition","useInteraction","marks","Set","Object","keys","map","d","_a","exec","filter","staticMarks","typeOf","node","type","props","composite","has","isMark","isStandardView","isStaticMark","transform","composition","static","views","viewNode","Map","nodeState","discovered","nodeGenerators","length","shift","state","get","view","children","initializeState","initializeView","set","push","transformedNodes","flatMap","every","states","Promise","all","initializeMarks","i","nodeT","n","applyTransform","N","Array","emitter","emit","BEFORE_PAINT","enterContainer","updateContainer","transitions","selectAll","className","data","key","join","enter","append","attr","call","applyTranslate","each","element","plotView","update","exit","interactions","values","interaction","destroy","remove","viewInstanceof","viewContainer","updateInteractions","oldStore","from","entries","container","store","setState","reducer","x","createUpdateView","updateTypes","__awaiter","newOptions","updateType","updateViewInstances","target","nameInteraction","typeOptions","inferInteraction","v","includes","typeOption","option","prevInteraction","useThemeInteraction","enterViewInstances","width","height","keyframes","nodeGenerator","keyframe","resolve","sizedNode","assign","animations","forEach","animation","cancel","AFTER_PAINT","finished","style","layout","y","definedInteraction","createInteraction","name","createDefinedInteraction","reapplyWhenUpdate","updates","source","callback","newView","newChildren","updateInteraction","child","interactionOptions","find","applyInteraction","flattenOptions","transformMarks","mergedOptions","bubbleOptions","coordinate","components","transformedOptions","viewCoordinate","viewInteraction","viewStyle","rest","__rest","markCoordinates","markInteractions","markViewStyles","newCoordinate","reduceRight","prev","cur","newInteraction","reduce","newStyle","useMark","createMark","flattenMarks","markOptions","splice","mark","newMark","value","M","unshift","useTheme","theme","partialTheme","partialMarks","coordinates","inferTheme","markState","markAndState","initializedMark","scaleChannels","channels","scaleKey","scaleOptions","total","scale","FV","fields","field","guide","title","undefined","uid","Symbol","channel","defaults","useLabelTransform","frame","clip","labelTransform","scales","inferComponentScales","framedStyle","mainLineWidth","mainStroke","uidScale","scaleInstance","component","scaleDescriptors","descriptor","getOptions","xScale","scaleInstances","dataMap","createChildren","dataDomain","modifier","markKey","index","tooltip","fromEntries","markScaleInstance","calcPoints","I","P","S","filterValid","count","T","titleOf","_b","itemsOf","items","V","visualData","datum","points","viewKey","k","si","markChildren","areaKeys","_","sizeKeys","areaStyles","areaSizes","styleArea","areaLayouts","applyStyle","px","py","pw","ph","size","left","top","bottom","right","animationExtent","computeAnimationExtent","componentAnimateOptions","duration","C","position","componentsTransitions","zIndex","animate","transition","preserve","newComponent","attributes","childNodes","flat","updateBBox","updateLayers","applyClip","animateBBox","class","cls","shapeFunction","createMarkShapeFunction","enterFunction","createEnterFunction","updateFunction","createUpdateFunction","exitFunction","createExitFunction","facetElements","selectFacetElements","selectFacetAll","groupKey","parent","origin","getBounds","min","maybeFacetElement","nodeName","parentNode","replaceChild","markType","__data__","__removed__","merge","__fromElements__","fromElements","split","__toData__","toElements","nodes","plotLabel","labelLayer","labelShapeFunction","labelDescriptor","labels","labelOptions","createLabelShapeFunction","elements","labelOption","e","L","getLabels","l","labelShapes","labelGroups","labelTransformContext","canvas","label","shapes","transformFunction","labelIndex","seriesIndex","SI","seriesKey","bounds","getLocalBounds","dependentElement","selector","normalizeLabelSelector","F","definedIndex","definedPoints","p","Error","cloneElement","cloneNode","getAnimations","visibility","effect","getKeyframes","appendChild","max","useShape","abstractData","encode","defaultLabelShape","point2d","shapeContext","document","formatter","abstractStyle","render","abstractOptions","visualOptions","valueOf","shape","text","f","shapeOptions","getDefaultsStyle","maxDuration","Infinity","minDelay","defaultUpdateType","defaultUpdateDuration","delay","defaultUpdateDelay","defaultEnterType","defaultEnterDuration","defaultEnterDelay","defaultExitType","defaultExitDuration","defaultExitDelay","updateDuration","updateDelay","enterType","enterDuration","enterDelay","exitDuration","exitDelay","exitType","Math","current","facetClassName","elementClassName","parentElement","findAll","facet","getElementsByClassName","originOf","__facet__","prePlot","newPlot","translate","defaultShape","shapeLibrary","styleShape","abstractDatum","visualStyle","shapeName","color","markTheme","shapeTheme","createAnimationFunction","createShape","useAnimation","upperType","defaultAnimation","defaultEffectTiming","to","easing","animateFunction","A","an","Boolean","then","event","sliderFilter","legendFilter","scrollbarFilter","reverse","newData","paddingLeft","marginLeft","paddingTop","marginTop","innerWidth","innerHeight","extent","fill","names","x1","y1","some","acceptMarkTypes","shapeMap","point","line","rect","hollow","shapeScale","domain","range"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/runtime/plot.ts"],"sourcesContent":["import { Vector2 } from '@antv/coord';\nimport { DisplayObject, IAnimation as GAnimation, Rect } from '@antv/g';\nimport { deepMix, upperFirst, isArray } from '@antv/util';\nimport { group, groups } from '@antv/vendor/d3-array';\nimport { format } from '@antv/vendor/d3-format';\nimport { mapObject } from '../utils/array';\nimport { ChartEvent } from '../utils/event';\nimport {\n  isStrictObject,\n  appendTransform,\n  compose,\n  copyAttributes,\n  defined,\n  error,\n  maybeSubObject,\n  subObject,\n  useMemo,\n} from '../utils/helper';\nimport { G2Element, select, Selection } from '../utils/selection';\nimport {\n  groupComponents,\n  inferComponent,\n  normalizeComponents,\n  renderComponent,\n} from './component';\nimport {\n  AREA_CLASS_NAME,\n  COMPONENT_CLASS_NAME,\n  ELEMENT_CLASS_NAME,\n  LABEL_CLASS_NAME,\n  LABEL_LAYER_CLASS_NAME,\n  MAIN_LAYER_CLASS_NAME,\n  PLOT_CLASS_NAME,\n  VIEW_CLASS_NAME,\n} from './constant';\nimport { coordinate2Transform, createCoordinate } from './coordinate';\nimport {\n  computeLayout,\n  computeRoughPlotSize,\n  placeComponents,\n  processAxisZ,\n} from './layout';\nimport { documentOf, useLibrary } from './library';\nimport { initializeMark } from './mark';\nimport {\n  applyScale,\n  assignScale,\n  collectScales,\n  inferScale,\n  syncFacetsScales,\n  useRelationScale,\n  groupTransform,\n} from './scale';\nimport { applyDataTransform } from './transform';\nimport {\n  G2MarkState,\n  G2Theme,\n  G2ViewDescriptor,\n  G2ViewInstance,\n  Primitive,\n} from './types/common';\nimport {\n  Animation,\n  AnimationComponent,\n  Composition,\n  CompositionComponent,\n  Interaction,\n  InteractionComponent,\n  LabelTransform,\n  LabelTransformComponent,\n  Scale,\n  Shape,\n  ShapeComponent,\n  Theme,\n  ThemeComponent,\n} from './types/component';\nimport { Mark, MarkComponent, SingleMark } from './types/mark';\nimport {\n  G2AnimationOptions,\n  G2CompositionOptions,\n  G2Context,\n  G2GuideComponentOptions,\n  G2InteractionOptions,\n  G2LabelTransformOptions,\n  G2Library,\n  G2Mark,\n  G2MarkOptions,\n  G2ScaleOptions,\n  G2ShapeOptions,\n  G2ThemeOptions,\n  G2View,\n  G2ViewTree,\n} from './types/options';\n\ntype Store = Map<any, (options: G2ViewTree) => G2ViewTree>;\n\nexport async function plot<T extends G2ViewTree>(\n  options: T,\n  selection: Selection,\n  context: G2Context,\n): Promise<any> {\n  const { library } = context;\n\n  const [useComposition] = useLibrary<\n    G2CompositionOptions,\n    CompositionComponent,\n    Composition\n  >('composition', library);\n  const [useInteraction] = useLibrary<\n    G2InteractionOptions,\n    InteractionComponent,\n    Interaction\n  >('interaction', library);\n\n  // Some helper functions.\n  const marks = new Set(\n    Object.keys(library)\n      .map((d) => /mark\\.(.*)/.exec(d)?.[1])\n      .filter(defined),\n  );\n  const staticMarks = new Set(\n    Object.keys(library)\n      .map((d) => /component\\.(.*)/.exec(d)?.[1])\n      .filter(defined),\n  );\n\n  const typeOf = (node: G2ViewTree) => {\n    const { type } = node;\n    if (typeof type === 'function') {\n      // @ts-ignore\n      const { props = {} } = type;\n      const { composite = true } = props;\n      if (composite) return 'mark';\n    }\n    if (typeof type !== 'string') return type;\n    if (marks.has(type) || staticMarks.has(type)) return 'mark';\n    return type;\n  };\n\n  const isMark = (node: G2ViewTree) => typeOf(node) === 'mark';\n  const isStandardView = (node: G2ViewTree) => typeOf(node) === 'standardView';\n  const isStaticMark = (node: G2ViewTree) => {\n    const { type } = node;\n    if (typeof type !== 'string') return false;\n    if (staticMarks.has(type)) return true;\n    return false;\n  };\n\n  const transform = (node: G2ViewTree) => {\n    if (isStandardView(node)) return [node];\n    const type = typeOf(node);\n    const composition = useComposition({ type, static: isStaticMark(node) });\n    return composition(node);\n  };\n\n  // Some temporary variables help parse the view tree.\n  const views: G2ViewDescriptor[] = [];\n  const viewNode = new Map<G2ViewDescriptor, G2ViewTree>();\n  const nodeState = new Map<G2ViewTree, Map<G2Mark, G2MarkState>>();\n  const discovered: G2ViewTree[] = [options];\n  const nodeGenerators: Generator<G2ViewTree, void, void>[] = [];\n\n  while (discovered.length) {\n    const node = discovered.shift();\n    if (isStandardView(node)) {\n      // Initialize view to get data to be visualized. If the marks\n      // of the view have already been initialized (facet view),\n      // initialize the view based on the initialized mark states,\n      // otherwise initialize it from beginning.\n      const state = nodeState.get(node);\n      const [view, children] = state\n        ? initializeState(state, node, library)\n        : await initializeView(node, context);\n      viewNode.set(view, node);\n      views.push(view);\n\n      // Transform children, they will be transformed into\n      // standardView if they are mark or view node.\n      const transformedNodes = children\n        .flatMap(transform)\n        .map((d) => coordinate2Transform(d, library));\n      discovered.push(...transformedNodes);\n\n      // Only StandardView can be treated as facet and it\n      // should sync position scales among facets normally.\n      if (transformedNodes.every(isStandardView)) {\n        const states = await Promise.all(\n          transformedNodes.map((d) => initializeMarks(d, context)),\n        );\n        // Note!!!\n        // This will mutate scales for marks.\n        syncFacetsScales(states);\n        for (let i = 0; i < transformedNodes.length; i++) {\n          const nodeT = transformedNodes[i];\n          const state = states[i];\n          nodeState.set(nodeT, state);\n        }\n      }\n    } else {\n      // Apply transform to get data in advance for non-mark composition\n      // node, which makes sure that composition node can preprocess the\n      // data to produce more nodes based on it.\n      const n = isMark(node) ? node : await applyTransform(node, context);\n      const N = transform(n);\n      if (Array.isArray(N)) discovered.push(...N);\n      else if (typeof N === 'function') nodeGenerators.push(N());\n    }\n  }\n\n  context.emitter.emit(ChartEvent.BEFORE_PAINT);\n\n  // Plot chart.\n  const enterContainer = new Map<G2ViewDescriptor, DisplayObject>();\n  const updateContainer = new Map<G2ViewDescriptor, DisplayObject>();\n  const transitions: GAnimation[] = [];\n  selection\n    .selectAll(className(VIEW_CLASS_NAME))\n    .data(views, (d) => d.key)\n    .join(\n      (enter) =>\n        enter\n          .append('g')\n          .attr('className', VIEW_CLASS_NAME)\n          .attr('id', (view) => view.key)\n          .call(applyTranslate)\n          .each(function (view, i, element) {\n            plotView(view, select(element), transitions, context);\n            enterContainer.set(view, element);\n          }),\n      (update) =>\n        update.call(applyTranslate).each(function (view, i, element) {\n          plotView(view, select(element), transitions, context);\n          updateContainer.set(view, element);\n        }),\n      (exit) =>\n        exit\n          .each(function (d, i, element) {\n            // Remove existed interactions.\n            const interactions = element['nameInteraction'].values();\n            for (const interaction of interactions) {\n              interaction.destroy();\n            }\n          })\n          .remove(),\n    );\n\n  // Apply interactions.\n  const viewInstanceof = (\n    viewContainer: Map<G2ViewDescriptor, DisplayObject>,\n    updateInteractions?: (\n      container: Map<G2ViewDescriptor, DisplayObject>,\n      updateTypes?: string[],\n      store?: Store,\n    ) => void,\n    oldStore?: Store,\n  ) => {\n    return Array.from(viewContainer.entries()).map(([view, container]) => {\n      // Index state by component or interaction name,\n      // such as legend, scrollbar, brushFilter.\n      // Each state transform options to another options.\n      const store =\n        oldStore || new Map<any, (options: G2ViewTree) => G2ViewTree>();\n      const setState = (key, reducer = (x) => x) => store.set(key, reducer);\n      const options = viewNode.get(view);\n      const update = createUpdateView(select(container), options, context);\n      return {\n        view,\n        container,\n        options,\n        setState,\n        update: async (from, updateTypes) => {\n          // Apply all state functions to get new options.\n          const reducer = compose(Array.from(store.values()));\n          const newOptions = reducer(options);\n          return await update(newOptions, from, () => {\n            if (isArray(updateTypes)) {\n              updateInteractions(viewContainer, updateTypes, store);\n            }\n          });\n        },\n      };\n    });\n  };\n\n  const updateInteractions = (\n    container = updateContainer,\n    updateType?: string[],\n    oldStore?: Map<any, (options: G2ViewTree) => G2ViewTree>,\n  ) => {\n    // Interactions for update views.\n    const updateViewInstances = viewInstanceof(\n      container,\n      updateInteractions,\n      oldStore,\n    );\n\n    for (const target of updateViewInstances) {\n      const { options, container } = target;\n      const nameInteraction = container['nameInteraction'];\n      let typeOptions = inferInteraction(options);\n\n      if (updateType) {\n        typeOptions = typeOptions.filter((v) => updateType.includes(v[0]));\n      }\n\n      for (const typeOption of typeOptions) {\n        const [type, option] = typeOption;\n        // Remove interaction for existed views.\n        const prevInteraction = nameInteraction.get(type);\n        if (prevInteraction) prevInteraction.destroy?.();\n\n        // Apply new interaction.\n        if (option) {\n          const interaction = useThemeInteraction(\n            target.view,\n            type,\n            option as Record<string, any>,\n            useInteraction,\n          );\n          const destroy = interaction(\n            target,\n            updateViewInstances,\n            context.emitter,\n          );\n          nameInteraction.set(type, { destroy });\n        }\n      }\n    }\n  };\n\n  // Interactions for enter views.\n  const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);\n  for (const target of enterViewInstances) {\n    const { options } = target;\n\n    // A Map index interaction by interaction name.\n    const nameInteraction = new Map();\n    target.container['nameInteraction'] = nameInteraction;\n\n    // Apply interactions.\n    for (const typeOption of inferInteraction(options)) {\n      const [type, option] = typeOption;\n      if (option) {\n        const interaction = useThemeInteraction(\n          target.view,\n          type,\n          option as Record<string, any>,\n          useInteraction,\n        );\n        const destroy = interaction(\n          target,\n          enterViewInstances,\n          context.emitter,\n        );\n        nameInteraction.set(type, { destroy });\n      }\n    }\n  }\n\n  updateInteractions();\n\n  // Author animations.\n  const { width, height } = options;\n  const keyframes = [];\n  for (const nodeGenerator of nodeGenerators) {\n    // Delay the rendering of animation keyframe. Different animation\n    // created by different nodeGenerator will play in the same time.\n    // eslint-disable-next-line no-async-promise-executor\n    const keyframe = new Promise<void>(async (resolve) => {\n      for (const node of nodeGenerator) {\n        const sizedNode = { width, height, ...node };\n        await plot(sizedNode, selection, context);\n      }\n      resolve();\n    });\n    keyframes.push(keyframe);\n  }\n\n  context.views = views;\n\n  // Clear and update animation.\n  context.animations?.forEach((animation) => animation?.cancel());\n  context.animations = transitions;\n\n  context.emitter.emit(ChartEvent.AFTER_PAINT);\n\n  // Note!!!\n  // The returned promise will never resolved if one of nodeGenerator\n  // never stop to yield node, which may created by a keyframe composition\n  // with iteration count set to infinite.\n  const finished = transitions\n    .filter(defined)\n    .map(cancel)\n    .map((d) => d.finished);\n  return Promise.all([...finished, ...keyframes]);\n}\n\nfunction applyTranslate(selection: Selection) {\n  selection.style(\n    'transform',\n    (d) => `translate(${d.layout.x}, ${d.layout.y})`,\n  );\n}\n\nfunction definedInteraction(library: G2Library) {\n  const [, createInteraction] = useLibrary<\n    G2InteractionOptions,\n    InteractionComponent,\n    Interaction\n  >('interaction', library);\n  return (d) => {\n    const [name, options] = d;\n    try {\n      return [name, createInteraction(name)] as const;\n    } catch {\n      return [name, options.type] as const;\n    }\n  };\n}\n\nfunction createUpdateView(\n  selection: Selection,\n  options: G2ViewTree,\n  context: G2Context,\n): G2ViewInstance['update'] {\n  const { library } = context;\n  const createDefinedInteraction = definedInteraction(library);\n  const filter = (d) => d[1] && d[1].props && d[1].props.reapplyWhenUpdate;\n  const interactions = inferInteraction(options);\n  const updates = interactions\n    .map(createDefinedInteraction)\n    .filter(filter)\n    .map((d) => d[0]);\n\n  return async (newOptions, source, callback) => {\n    const transitions = [];\n    const [newView, newChildren] = await initializeView(newOptions, context);\n    plotView(newView, selection, transitions, context);\n\n    // Update interaction need to reapply when update.\n    for (const name of updates.filter((d) => d !== source)) {\n      updateInteraction(name, selection, newOptions, newView, context);\n    }\n\n    for (const child of newChildren) {\n      plot(child, selection, context);\n    }\n    callback();\n    return { options: newOptions, view: newView };\n  };\n}\n\nfunction updateInteraction(\n  name: string,\n  selection: Selection,\n  options: G2ViewTree,\n  view: G2ViewDescriptor,\n  context: G2Context,\n) {\n  const { library } = context;\n\n  const [useInteraction] = useLibrary<\n    G2InteractionOptions,\n    InteractionComponent,\n    Interaction\n  >('interaction', library);\n\n  // Instances for interaction.\n  const container = selection.node();\n  const nameInteraction = container['nameInteraction'];\n  const interactionOptions = inferInteraction(options).find(\n    ([d]) => d === name,\n  );\n\n  // Destroy older interaction.\n  const interaction = nameInteraction.get(name);\n  if (!interaction) return;\n  interaction.destroy?.();\n\n  if (!interactionOptions[1]) return;\n\n  // Apply new interaction.\n  const applyInteraction = useThemeInteraction(\n    view,\n    name,\n    interactionOptions[1] as any,\n    useInteraction,\n  );\n  const target = {\n    options,\n    view,\n    container: selection.node(),\n    update: (options) => Promise.resolve(options),\n  };\n  const destroy = applyInteraction(target, [], context.emitter);\n  nameInteraction.set(name, { destroy });\n}\n\nasync function initializeView(\n  options: G2View,\n  context: G2Context,\n): Promise<[G2ViewDescriptor, G2ViewTree[]]> {\n  const { library } = context;\n\n  const flattenOptions = await transformMarks(options, context);\n\n  const mergedOptions = bubbleOptions(flattenOptions);\n\n  // @todo Remove this.\n  // !!! NOTE: Mute original view options.\n  // Update interaction and coordinate for this view.\n  options.interaction = mergedOptions.interaction;\n  options.coordinate = mergedOptions.coordinate;\n  // @ts-ignore\n  options.marks = [...mergedOptions.marks, ...mergedOptions.components];\n\n  const transformedOptions = coordinate2Transform(mergedOptions, library);\n  const state = await initializeMarks(transformedOptions, context);\n  return initializeState(state, transformedOptions, library);\n}\n\nfunction bubbleOptions(options: G2View): G2View {\n  const {\n    coordinate: viewCoordinate = {},\n    interaction: viewInteraction = {},\n    style: viewStyle = {},\n    marks,\n    ...rest\n  } = options;\n  const markCoordinates = marks.map((d) => d.coordinate || {});\n  const markInteractions = marks.map((d) => d.interaction || {});\n  const markViewStyles = marks.map((d) => d.viewStyle || {});\n  const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight(\n    (prev, cur) => deepMix(prev, cur),\n    {},\n  );\n  const newInteraction = [viewInteraction, ...markInteractions].reduce(\n    (prev, cur) => deepMix(prev, cur),\n    {},\n  );\n  const newStyle = [...markViewStyles, viewStyle].reduce(\n    (prev, cur) => deepMix(prev, cur),\n    {},\n  );\n  return {\n    ...rest,\n    marks,\n    coordinate: newCoordinate,\n    interaction: newInteraction,\n    style: newStyle,\n  };\n}\n\nasync function transformMarks(\n  options: G2View,\n  context: G2Context,\n): Promise<G2View> {\n  const { library } = context;\n\n  const [useMark, createMark] = useLibrary<G2MarkOptions, MarkComponent, Mark>(\n    'mark',\n    library,\n  );\n\n  const staticMarks = new Set(\n    Object.keys(library)\n      .map((d) => /component\\.(.*)/.exec(d)?.[1])\n      .filter(defined),\n  );\n  const { marks } = options;\n  const flattenMarks = [];\n  const components = [];\n  const discovered = [...marks];\n  const { width, height } = computeRoughPlotSize(options);\n  const markOptions = { options, width, height };\n\n  // Pre order traversal.\n  while (discovered.length) {\n    const [node] = discovered.splice(0, 1);\n    // Apply data transform to get data.\n    const mark = (await applyTransform(node, context)) as G2Mark;\n    const { type = error('G2Mark type is required.'), key } = mark;\n\n    // For components.\n    if (staticMarks.has(type as string)) components.push(mark);\n    else {\n      const { props = {} } = createMark(type);\n      const { composite = true } = props;\n      if (!composite) flattenMarks.push(mark);\n      else {\n        // Unwrap data from { value: data } to data,\n        // then the composite mark can process the normalized data.\n        const { data } = mark;\n        const newMark = {\n          ...mark,\n          data: data ? (Array.isArray(data) ? data : data.value) : data,\n        };\n\n        // Convert composite mark to marks.\n        const marks = await useMark(newMark, markOptions);\n        const M = Array.isArray(marks) ? marks : [marks];\n        discovered.unshift(...M.map((d, i) => ({ ...d, key: `${key}-${i}` })));\n      }\n    }\n  }\n\n  return { ...options, marks: flattenMarks, components };\n}\n\nasync function initializeMarks(\n  options: G2View,\n  context: G2Context,\n): Promise<Map<G2Mark, G2MarkState>> {\n  const { library } = context;\n\n  const [useTheme] = useLibrary<G2ThemeOptions, ThemeComponent, Theme>(\n    'theme',\n    library,\n  );\n  const [, createMark] = useLibrary<G2MarkOptions, MarkComponent, Mark>(\n    'mark',\n    library,\n  );\n\n  const {\n    theme: partialTheme,\n    marks: partialMarks,\n    coordinates = [],\n  } = options;\n  const theme = useTheme(inferTheme(partialTheme));\n  const markState = new Map<G2Mark, G2MarkState>();\n\n  // Initialize channels for marks.\n  for (const markOptions of partialMarks) {\n    const { type } = markOptions;\n    const { props = {} } = createMark(type);\n    const markAndState = await initializeMark(markOptions, props, context);\n    if (markAndState) {\n      const [initializedMark, state] = markAndState;\n      markState.set(initializedMark, state);\n    }\n  }\n\n  // Group channels by scale key, each group has scale.\n  const scaleChannels = group(\n    Array.from(markState.values()).flatMap((d) => d.channels),\n    ({ scaleKey }) => scaleKey,\n  );\n\n  // Infer scale for each channel groups.\n  for (const channels of scaleChannels.values()) {\n    // Merge scale options for these channels.\n    const scaleOptions = channels.reduce(\n      (total, { scale }) => deepMix(total, scale),\n      {},\n    );\n    const { scaleKey } = channels[0];\n\n    // Use the fields of the first channel as the title.\n    const { values: FV } = channels[0];\n    const fields = Array.from(new Set(FV.map((d) => d.field).filter(defined)));\n    const options = deepMix(\n      {\n        guide: { title: fields.length === 0 ? undefined : fields },\n        field: fields[0],\n      },\n      scaleOptions,\n    );\n\n    // Use the name of the first channel as the scale name.\n    const { name } = channels[0];\n    const values = channels.flatMap(({ values }) => values.map((d) => d.value));\n    const scale = {\n      ...inferScale(name, values, options, coordinates, theme, library),\n      uid: Symbol('scale'),\n      key: scaleKey,\n    };\n    channels.forEach((channel) => (channel.scale = scale));\n  }\n\n  return markState;\n}\n\nfunction useThemeInteraction(\n  view: G2ViewDescriptor,\n  type: string,\n  option: Record<string, any>,\n  useInteraction: (options: G2InteractionOptions, context?: any) => Interaction,\n): Interaction {\n  const theme = view.theme;\n  const defaults = typeof type === 'string' ? theme[type] || {} : {};\n  const interaction = useInteraction(\n    deepMix(defaults, { type, ...(option as any) }),\n  );\n  return interaction;\n}\n\nfunction initializeState(\n  markState: Map<G2Mark, G2MarkState>,\n  options: G2View,\n  library: G2Library,\n): [G2ViewDescriptor, G2ViewTree[]] {\n  const [useMark] = useLibrary<G2MarkOptions, MarkComponent, Mark>(\n    'mark',\n    library,\n  );\n  const [useTheme] = useLibrary<G2ThemeOptions, ThemeComponent, Theme>(\n    'theme',\n    library,\n  );\n  const [useLabelTransform] = useLibrary<\n    G2LabelTransformOptions,\n    LabelTransformComponent,\n    LabelTransform\n  >('labelTransform', library);\n\n  const {\n    key,\n    frame = false,\n    theme: partialTheme,\n    clip,\n    style = {},\n    labelTransform = [],\n  } = options;\n\n  const theme = useTheme(inferTheme(partialTheme));\n\n  // Infer components and compute layout.\n  const states = Array.from(markState.values());\n  const scales = collectScales(states, options);\n  const components = normalizeComponents(\n    inferComponent(\n      inferComponentScales(Array.from(scales), states, markState),\n      options,\n      library,\n    ),\n  );\n  const layout = computeLayout(components, options, theme, library);\n  const coordinate = createCoordinate(layout, options, library);\n  const framedStyle = frame\n    ? deepMix({ mainLineWidth: 1, mainStroke: '#000' }, style)\n    : style;\n\n  // Place components and mutate their bbox.\n  placeComponents(groupComponents(components), coordinate, layout);\n\n  // AxisZ need a copy of axisX and axisY to show grids in X-Z & Y-Z planes.\n  processAxisZ(components);\n\n  // Index scale instance by uid.\n  const uidScale = new Map(\n    Array.from(markState.values()).flatMap((state) => {\n      const { channels } = state;\n      return channels.map(({ scale }) => [\n        scale.uid,\n        useRelationScale(scale, library),\n      ]);\n    }),\n  );\n\n  groupTransform(markState, uidScale);\n\n  // Scale from marks and components.\n  const scaleInstance: Record<string, Scale> = {};\n\n  // Initialize scale from components.\n  for (const component of components) {\n    const { scales: scaleDescriptors = [] } = component;\n    const scales = [];\n    for (const descriptor of scaleDescriptors) {\n      const { name, uid } = descriptor;\n      const scale = uidScale.get(uid) ?? useRelationScale(descriptor, library);\n      scales.push(scale);\n      // Delivery the scale of axisX to the AxisY,\n      // in order to calculate the angle of axisY component when rendering radar chart.\n      if (name === 'y') {\n        scale.update({\n          ...scale.getOptions(),\n          xScale: scaleInstance.x,\n        });\n      }\n      assignScale(scaleInstance, { [name]: scale });\n    }\n    component.scaleInstances = scales;\n  }\n\n  // Calc data to be rendered for each mark.\n  // @todo More readable APIs for Container which stays\n  // the same style with JS standard and lodash APIs.\n  // @todo More proper way to index scale for different marks.\n  const children = [];\n  const dataMap = new Map();\n  for (const [mark, state] of markState.entries()) {\n    const {\n      // scale,\n      // Callback to create children options based on this mark.\n      children: createChildren,\n      // The total count of data (both show and hide)for this facet.\n      // This is for unit visualization to sync data domain.\n      dataDomain,\n      modifier,\n      key: markKey,\n      data,\n    } = mark;\n    dataMap.set(markKey, data);\n    const { index, channels, tooltip } = state;\n    const scale = Object.fromEntries(\n      channels.map(({ name, scale }) => [name, scale]),\n    );\n    // Transform abstract value to visual value by scales.\n    const markScaleInstance = mapObject(scale, ({ uid }) => uidScale.get(uid));\n    assignScale(scaleInstance, markScaleInstance);\n    const value = applyScale(channels, markScaleInstance);\n\n    // Calc points and transformation for each data,\n    // and then transform visual value to visual data.\n    const calcPoints = (useMark as (options: G2MarkOptions) => SingleMark)(\n      mark,\n    );\n    const [I, P, S] = filterValid(\n      calcPoints(index, markScaleInstance, value, coordinate),\n    );\n    const count = dataDomain || I.length;\n    const T = modifier ? modifier(P, count, layout) : [];\n    const titleOf = (i) => tooltip.title?.[i]?.value;\n    const itemsOf = (i) => tooltip.items.map((V) => V[i]);\n    const visualData: Record<string, any>[] = I.map((d, i) => {\n      const datum = {\n        points: P[i],\n        transform: T[i],\n        index: d,\n        markKey,\n        viewKey: key,\n        data: data[d],\n        ...(tooltip && {\n          title: titleOf(d),\n          items: itemsOf(d),\n        }),\n      };\n      for (const [k, V] of Object.entries(value)) {\n        datum[k] = V[d];\n        if (S) datum[`series${upperFirst(k)}`] = S[i].map((i) => V[i]);\n      }\n      if (S) datum['seriesIndex'] = S[i];\n      if (S && tooltip) {\n        datum['seriesItems'] = S[i].map((si) => itemsOf(si));\n        datum['seriesTitle'] = S[i].map((si) => titleOf(si));\n      }\n      return datum;\n    });\n    state.data = visualData;\n    state.index = I;\n\n    // Create children options by children callback,\n    // and then propagate data to each child.\n    const markChildren = createChildren?.(\n      visualData,\n      markScaleInstance,\n      layout,\n    );\n    children.push(...(markChildren || []));\n  }\n\n  const view = {\n    layout,\n    theme,\n    coordinate,\n    markState,\n    key,\n    clip,\n    scale: scaleInstance,\n    style: framedStyle,\n    components,\n    data: dataMap,\n    labelTransform: compose(labelTransform.map(useLabelTransform)),\n  };\n\n  return [view, children];\n}\n\nasync function plotView(\n  view: G2ViewDescriptor,\n  selection: Selection,\n  transitions: GAnimation[],\n  context: G2Context,\n): Promise<void> {\n  const { library } = context;\n  const {\n    components,\n    theme,\n    layout,\n    markState,\n    coordinate,\n    key,\n    style,\n    clip,\n    scale,\n  } = view;\n\n  // Render background for the different areas.\n  const { x, y, width, height, ...rest } = layout;\n  const areaKeys = ['view', 'plot', 'main', 'content'];\n  const I = areaKeys.map((_, i) => i);\n  const sizeKeys = ['a', 'margin', 'padding', 'inset'];\n  const areaStyles = areaKeys.map((d) =>\n    maybeSubObject(Object.assign({}, theme.view, style), d),\n  );\n  const areaSizes = sizeKeys.map((d) => subObject(rest, d));\n  const styleArea = (selection) =>\n    selection\n      .style('x', (i) => areaLayouts[i].x)\n      .style('y', (i) => areaLayouts[i].y)\n      .style('width', (i) => areaLayouts[i].width)\n      .style('height', (i) => areaLayouts[i].height)\n      .each(function (i, d, element) {\n        applyStyle(select(element), areaStyles[i]);\n      });\n  let px = 0;\n  let py = 0;\n  let pw = width;\n  let ph = height;\n  const areaLayouts = I.map((i) => {\n    const size = areaSizes[i];\n    const { left = 0, top = 0, bottom = 0, right = 0 } = size;\n    px += left;\n    py += top;\n    pw -= left + right;\n    ph -= top + bottom;\n    return {\n      x: px,\n      y: py,\n      width: pw,\n      height: ph,\n    };\n  });\n  selection\n    .selectAll(className(AREA_CLASS_NAME))\n    .data(\n      // Only render area with defined style.\n      I.filter((i) => defined(areaStyles[i])),\n      (i) => areaKeys[i],\n    )\n    .join(\n      (enter) =>\n        enter\n          .append('rect')\n          .attr('className', AREA_CLASS_NAME)\n          .style('zIndex', -2)\n          .call(styleArea),\n      (update) => update.call(styleArea),\n      (exit) => exit.remove(),\n    );\n\n  const animationExtent = computeAnimationExtent(markState);\n\n  const componentAnimateOptions = animationExtent\n    ? { duration: animationExtent[1] }\n    : false;\n\n  // Render components.\n  // @todo renderComponent return ctor and options.\n  // Key for each type of component.\n  // Index them grouped by position.\n  for (const [, C] of groups(components, (d) => `${d.type}-${d.position}`)) {\n    C.forEach((d, i) => (d.index = i));\n  }\n\n  const componentsTransitions = selection\n    .selectAll(className(COMPONENT_CLASS_NAME))\n    .data(components, (d) => `${d.type}-${d.position}-${d.index}`)\n    .join(\n      (enter) =>\n        enter\n          .append('g')\n          .style('zIndex', ({ zIndex }) => zIndex || -1)\n          .attr('className', COMPONENT_CLASS_NAME)\n          .append((options) =>\n            renderComponent(\n              deepMix({ animate: componentAnimateOptions, scale }, options),\n              coordinate,\n              theme,\n              library,\n              markState,\n            ),\n          ),\n      (update) =>\n        update.transition(function (\n          options: G2GuideComponentOptions,\n          i,\n          element,\n        ) {\n          const { preserve = false } = options;\n          if (preserve) return;\n          const newComponent = renderComponent(\n            deepMix({ animate: componentAnimateOptions, scale }, options),\n            coordinate,\n            theme,\n            library,\n            markState,\n          );\n          const { attributes } = newComponent;\n          const [node] = element.childNodes;\n          return node.update(attributes, false);\n        }),\n    )\n    .transitions();\n\n  transitions.push(...componentsTransitions.flat().filter(defined));\n\n  // Main layer is for showing the main visual representation such as marks. There\n  // may be multiple main layers for a view, each main layer correspond to one of marks.\n  // @todo Test DOM structure.\n  const T = selection\n    .selectAll(className(PLOT_CLASS_NAME))\n    .data([layout], () => key)\n    .join(\n      (enter) =>\n        enter\n          // Make this layer interactive, such as click and mousemove events.\n          .append('rect')\n          .style('zIndex', 0)\n          .style('fill', 'transparent')\n          .attr('className', PLOT_CLASS_NAME)\n          .call(updateBBox)\n          .call(updateLayers, Array.from(markState.keys()))\n          .call(applyClip, clip),\n      (update) =>\n        update\n          .call(updateLayers, Array.from(markState.keys()))\n          .call((selection) => {\n            return animationExtent\n              ? animateBBox(selection, animationExtent)\n              : updateBBox(selection);\n          })\n          .call(applyClip, clip),\n    )\n    .transitions();\n  transitions.push(...T.flat());\n\n  // Render marks with corresponding data.\n  for (const [mark, state] of markState.entries()) {\n    const { data } = state;\n    const { key, class: cls, type } = mark;\n    const viewNode = selection.select(`#${key}`);\n    const shapeFunction = createMarkShapeFunction(mark, state, view, context);\n    const enterFunction = createEnterFunction(mark, state, view, library);\n    const updateFunction = createUpdateFunction(mark, state, view, library);\n    const exitFunction = createExitFunction(mark, state, view, library);\n    const facetElements = selectFacetElements(\n      selection,\n      viewNode,\n      cls,\n      'element',\n    );\n    const T = viewNode\n      .selectAll(className(ELEMENT_CLASS_NAME))\n      .selectFacetAll(facetElements)\n      .data(\n        data,\n        (d) => d.key,\n        (d) => d.groupKey,\n      )\n      .join(\n        (enter) =>\n          enter\n            .append(shapeFunction)\n            // Note!!! Only one className can be set.\n            // Using attribute as alternative for other classNames.\n            .attr('className', ELEMENT_CLASS_NAME)\n            .attr('markType', type)\n            .transition(function (data, i, element) {\n              return enterFunction(data, [element]);\n            }),\n        (update) =>\n          update.call((selection) => {\n            const parent = selection.parent();\n            const origin = useMemo<DisplayObject, [number, number]>((node) => {\n              const [x, y] = node.getBounds().min;\n              return [x, y];\n            });\n            selection\n              .transition(function (data, index, element) {\n                maybeFacetElement(element, parent, origin);\n                const node = shapeFunction(data, index);\n                const animation = updateFunction(data, [element], [node]);\n                if (animation?.length) return animation;\n                if (\n                  element.nodeName === node.nodeName &&\n                  node.nodeName !== 'g'\n                ) {\n                  copyAttributes(element, node);\n                } else {\n                  element.parentNode.replaceChild(node, element);\n                  node.className = ELEMENT_CLASS_NAME;\n                  // @ts-ignore\n                  node.markType = type;\n                  // @ts-ignore\n                  node.__data__ = element.__data__;\n                }\n                return animation;\n              })\n              .attr('markType', type)\n              .attr('className', ELEMENT_CLASS_NAME);\n          }),\n        (exit) => {\n          return exit\n            .each(function (d, i, element) {\n              element.__removed__ = true;\n            })\n            .transition(function (data, i, element) {\n              return exitFunction(data, [element]);\n            })\n            .remove();\n        },\n        (merge) =>\n          merge\n            // Append elements to be merged.\n            .append(shapeFunction)\n            .attr('className', ELEMENT_CLASS_NAME)\n            .attr('markType', type)\n            .transition(function (data, i, element) {\n              // Remove merged elements after animation finishing.\n              const { __fromElements__: fromElements } = element;\n              const transition = updateFunction(data, fromElements, [element]);\n              const exit = new Selection(\n                fromElements,\n                null,\n                element.parentNode,\n              );\n              exit.transition(transition).remove();\n              return transition;\n            }),\n        (split) =>\n          split\n            .transition(function (data, i, element) {\n              // Append splitted shapes.\n              const enter = new Selection(\n                [],\n                element.__toData__,\n                element.parentNode,\n              );\n              const toElements = enter\n                .append(shapeFunction)\n                .attr('className', ELEMENT_CLASS_NAME)\n                .attr('markType', type)\n                .nodes();\n              return updateFunction(data, [element], toElements);\n            })\n            // Remove elements to be splitted after animation finishing.\n            .remove(),\n      )\n      .transitions();\n    transitions.push(...T.flat());\n  }\n\n  // Plot label for this view.\n  plotLabel(view, selection, transitions, library, context);\n}\n\n/**\n * Auto hide labels be specify label layout.\n */\nfunction plotLabel(\n  view: G2ViewDescriptor,\n  selection: Selection,\n  transitions: GAnimation[],\n  library: G2Library,\n  context: G2Context,\n) {\n  const [useLabelTransform] = useLibrary<\n    G2LabelTransformOptions,\n    LabelTransformComponent,\n    LabelTransform\n  >('labelTransform', library);\n  const { markState, labelTransform } = view;\n  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();\n\n  // A Map index shapeFunction by label.\n  const labelShapeFunction = new Map();\n\n  // A Map index options by label.\n  const labelDescriptor = new Map();\n\n  // Get all labels for this view.\n  const labels = Array.from(markState.entries()).flatMap(([mark, state]) => {\n    const { labels: labelOptions = [], key } = mark;\n    const shapeFunction = createLabelShapeFunction(\n      mark,\n      state,\n      view,\n      library,\n      context,\n    );\n    const elements = selection\n      .select(`#${key}`)\n      .selectAll(className(ELEMENT_CLASS_NAME))\n      .nodes()\n      // Only select the valid element.\n      .filter((n) => !n.__removed__);\n    return labelOptions.flatMap((labelOption, i) => {\n      const { transform = [], ...options } = labelOption;\n      return elements.flatMap((e) => {\n        const L = getLabels(options, i, e);\n        L.forEach((l) => {\n          labelShapeFunction.set(l, (data) =>\n            shapeFunction({ ...data, element: e }),\n          );\n          labelDescriptor.set(l, labelOption);\n        });\n        return L;\n      });\n    });\n  });\n\n  // Render all labels.\n  const labelShapes = select(labelLayer)\n    .selectAll(className(LABEL_CLASS_NAME))\n    .data(labels, (d) => d.key)\n    .join(\n      (enter) =>\n        enter\n          .append((d) => labelShapeFunction.get(d)(d))\n          .attr('className', LABEL_CLASS_NAME),\n      (update) =>\n        update.each(function (d, i, element) {\n          // @todo Handle Label with different type.\n          const shapeFunction = labelShapeFunction.get(d);\n          const node = shapeFunction(d);\n          copyAttributes(element, node);\n        }),\n      (exit) => exit.remove(),\n    )\n    .nodes();\n\n  // Apply group-level transforms.\n  const labelGroups = group(labelShapes, (d) =>\n    labelDescriptor.get(d.__data__),\n  );\n  const { coordinate, layout } = view;\n\n  const labelTransformContext = {\n    canvas: context.canvas,\n    coordinate,\n    layout,\n  };\n  for (const [label, shapes] of labelGroups) {\n    const { transform = [] } = label;\n    const transformFunction = compose(transform.map(useLabelTransform));\n    transformFunction(shapes, labelTransformContext);\n  }\n\n  // Apply view-level transform.\n  if (labelTransform) {\n    labelTransform(labelShapes, labelTransformContext);\n  }\n}\n\nfunction getLabels(\n  label: Record<string, any>,\n  labelIndex: number,\n  element: G2Element,\n): Record<string, any>[] {\n  const { seriesIndex: SI, seriesKey, points, key, index } = element.__data__;\n  const bounds = getLocalBounds(element);\n  if (!SI) {\n    return [\n      {\n        ...label,\n        key: `${key}-${labelIndex}`,\n        bounds,\n        index,\n        points,\n        dependentElement: element,\n      },\n    ];\n  }\n  const selector = normalizeLabelSelector(label);\n  const F = SI.map((index: number, i: number) => ({\n    ...label,\n    key: `${seriesKey[i]}-${labelIndex}`,\n    bounds: [points[i]],\n    index,\n    points,\n    dependentElement: element,\n  }));\n  return selector ? selector(F) : F;\n}\n\nfunction filterValid([I, P, S]: [number[], Vector2[][], number[][]?]): [\n  number[],\n  Vector2[][],\n  number[][]?,\n] {\n  if (S) return [I, P, S];\n  const definedIndex = [];\n  const definedPoints = [];\n  for (let i = 0; i < I.length; i++) {\n    const d = I[i];\n    const p = P[i];\n    if (p.every(([x, y]) => defined(x) && defined(y))) {\n      definedIndex.push(d);\n      definedPoints.push(p);\n    }\n  }\n  return [definedIndex, definedPoints];\n}\n\nfunction normalizeLabelSelector(\n  label: Record<string, any>,\n): (I: number[]) => number[] {\n  const { selector } = label;\n  if (!selector) return null;\n  if (typeof selector === 'function') return selector;\n  if (selector === 'first') return (I) => [I[0]];\n  if (selector === 'last') return (I) => [I[I.length - 1]];\n  throw new Error(`Unknown selector: ${selector}`);\n}\n\n/**\n * Avoid getting error bounds caused by element animations.\n * @todo Remove this temporary handle method, if runtime supports\n * correct process: drawElement, do label layout and then do\n * transitions together.\n */\nfunction getLocalBounds(element: DisplayObject) {\n  const cloneElement = element.cloneNode(true);\n  const animations = element.getAnimations();\n  cloneElement.style.visibility = 'hidden';\n  animations.forEach((animation) => {\n    const keyframes = animation.effect.getKeyframes();\n    cloneElement.attr(keyframes[keyframes.length - 1]);\n  });\n  element.parentNode.appendChild(cloneElement);\n  const bounds = cloneElement.getLocalBounds();\n  cloneElement.destroy();\n  const { min, max } = bounds;\n  return [min, max];\n}\n\nfunction createLabelShapeFunction(\n  mark: G2Mark,\n  state: G2MarkState,\n  view: G2ViewDescriptor,\n  library: G2Library,\n  context: G2Context,\n): (options: Record<string, any>) => DisplayObject {\n  const [useShape] = useLibrary<G2ShapeOptions, ShapeComponent, Shape>(\n    'shape',\n    library,\n  );\n  const { data: abstractData, encode } = mark;\n  const { data: visualData, defaultLabelShape } = state;\n  const point2d = visualData.map((d) => d.points);\n  const channel = mapObject(encode, (d) => d.value);\n\n  // Assemble Context.\n  const { theme, coordinate } = view;\n  const shapeContext = {\n    ...context,\n    document: documentOf(context),\n    theme,\n    coordinate,\n  };\n\n  return (options) => {\n    // Computed values from data and styles.\n    const { index, points } = options;\n    const datum = abstractData[index];\n    const {\n      formatter = (d) => `${d}`,\n      transform,\n      style: abstractStyle,\n      render,\n      selector,\n      element,\n      ...abstractOptions\n    } = options;\n\n    const visualOptions = mapObject(\n      { ...abstractOptions, ...abstractStyle } as Record<string, any>,\n      (d) =>\n        valueOf(d, datum, index, abstractData, {\n          channel,\n          element,\n        }),\n    );\n    const { shape = defaultLabelShape, text, ...style } = visualOptions;\n    const f = typeof formatter === 'string' ? format(formatter) : formatter;\n    const value = {\n      ...style,\n      text: f(text, datum, index, abstractData),\n      datum,\n    };\n\n    // Params for create shape.\n    const shapeOptions = { type: `label.${shape}`, render, ...style };\n    const shapeFunction = useShape(shapeOptions, shapeContext);\n    const defaults = getDefaultsStyle(theme, 'label', shape, 'label');\n\n    return shapeFunction(points, value, defaults, point2d);\n  };\n}\n\nfunction valueOf(\n  value: Primitive | ((d: any, i: number, array: any, channel: any) => any),\n  datum: Record<string, any>,\n  i: number,\n  data: Record<string, any>,\n  options: { channel: Record<string, any>; element?: G2Element },\n) {\n  if (typeof value === 'function') return value(datum, i, data, options);\n  if (typeof value !== 'string') return value;\n  if (isStrictObject(datum) && datum[value] !== undefined) return datum[value];\n  return value;\n}\n\n/**\n * Compute max duration for this frame.\n */\nfunction computeAnimationExtent(markState): [number, number] {\n  let maxDuration = -Infinity;\n  let minDelay = Infinity;\n  for (const [mark, state] of markState) {\n    const { animate = {} } = mark;\n    const { data } = state;\n    const { enter = {}, update = {}, exit = {} } = animate;\n    const {\n      type: defaultUpdateType,\n      duration: defaultUpdateDuration = 300,\n      delay: defaultUpdateDelay = 0,\n    } = update;\n    const {\n      type: defaultEnterType,\n      duration: defaultEnterDuration = 300,\n      delay: defaultEnterDelay = 0,\n    } = enter;\n    const {\n      type: defaultExitType,\n      duration: defaultExitDuration = 300,\n      delay: defaultExitDelay = 0,\n    } = exit;\n    for (const d of data) {\n      const {\n        updateType = defaultUpdateType,\n        updateDuration = defaultUpdateDuration,\n        updateDelay = defaultUpdateDelay,\n        enterType = defaultEnterType,\n        enterDuration = defaultEnterDuration,\n        enterDelay = defaultEnterDelay,\n        exitDuration = defaultExitDuration,\n        exitDelay = defaultExitDelay,\n        exitType = defaultExitType,\n      } = d;\n\n      if (updateType === undefined || updateType) {\n        maxDuration = Math.max(maxDuration, updateDuration + updateDelay);\n        minDelay = Math.min(minDelay, updateDelay);\n      }\n      if (exitType === undefined || exitType) {\n        maxDuration = Math.max(maxDuration, exitDuration + exitDelay);\n        minDelay = Math.min(minDelay, exitDelay);\n      }\n      if (enterType === undefined || enterType) {\n        maxDuration = Math.max(maxDuration, enterDuration + enterDelay);\n        minDelay = Math.min(minDelay, enterDelay);\n      }\n    }\n  }\n  if (maxDuration === -Infinity) return null;\n  return [minDelay, maxDuration - minDelay];\n}\n\nfunction selectFacetElements(\n  selection: Selection,\n  current: Selection,\n  facetClassName: string,\n  elementClassName: string,\n): DisplayObject[] {\n  const group = selection.node().parentElement;\n  if (!group || typeof group.findAll !== 'function') return [];\n  return group\n    .findAll(\n      (node) =>\n        node.style.facet !== undefined &&\n        node.style.facet === facetClassName &&\n        node !== current.node(), // Exclude current view.\n    )\n    .flatMap((node) => node.getElementsByClassName(elementClassName));\n}\n\n/**\n * Update the parent of element and apply transform to make it\n * stay in original position.\n */\nfunction maybeFacetElement(\n  element: G2Element,\n  parent: DisplayObject,\n  originOf: (node: DisplayObject) => [number, number],\n): void {\n  if (!element.__facet__) return;\n  // element -> g#main -> rect#plot\n  const prePlot = element.parentNode.parentNode as DisplayObject;\n  // g#main -> rect#plot\n  const newPlot = parent.parentNode as DisplayObject;\n  const [px, py] = originOf(prePlot);\n  const [x, y] = originOf(newPlot);\n  const translate = `translate(${px - x}, ${py - y})`;\n  appendTransform(element, translate);\n  parent.append(element);\n}\n\nfunction createMarkShapeFunction(\n  mark: G2Mark,\n  state: G2MarkState,\n  view: G2ViewDescriptor,\n  context: G2Context,\n): (\n  data: Record<string, any>,\n  index: number,\n  element?: DisplayObject,\n) => DisplayObject {\n  const { library } = context;\n\n  const [useShape] = useLibrary<G2ShapeOptions, ShapeComponent, Shape>(\n    'shape',\n    library,\n  );\n  const { data: abstractData, encode } = mark;\n  const { defaultShape, data, shape: shapeLibrary } = state;\n  const channel = mapObject(encode, (d) => d.value);\n  const point2d = data.map((d) => d.points);\n  const { theme, coordinate } = view;\n  const { type: markType, style = {} } = mark;\n  const shapeContext = {\n    ...context,\n    document: documentOf(context),\n    coordinate,\n    theme,\n  };\n  return (data) => {\n    const { shape: styleShape = defaultShape } = style;\n    const { shape = styleShape, points, seriesIndex, index: i, ...v } = data;\n    const value = { ...v, index: i };\n\n    // Get data-driven style.\n    // If it is a series shape, such as area and line,\n    // provides the series of abstract data and indices\n    // for this shape, otherwise the single datum and\n    // index.\n    const abstractDatum = seriesIndex\n      ? seriesIndex.map((i) => abstractData[i])\n      : abstractData[i];\n\n    const I = seriesIndex ? seriesIndex : i;\n    const visualStyle = mapObject(style, (d) =>\n      valueOf(d, abstractDatum, I, abstractData, { channel }),\n    );\n\n    // Try get shape from mark first, then from library.\n    const shapeFunction = shapeLibrary[shape]\n      ? shapeLibrary[shape](visualStyle, shapeContext)\n      : useShape(\n          { ...visualStyle, type: shapeName(mark, shape) },\n          shapeContext,\n        );\n\n    const defaults = getDefaultsStyle(theme, markType, shape, defaultShape);\n    return shapeFunction(points, value, defaults, point2d);\n  };\n}\n\nfunction getDefaultsStyle(\n  theme: G2Theme,\n  mark: string | MarkComponent,\n  shape: string,\n  defaultShape: string,\n) {\n  if (typeof mark !== 'string') return;\n  const { color } = theme;\n  const markTheme = theme[mark] || {};\n  const shapeTheme = markTheme[shape] || markTheme[defaultShape];\n  return Object.assign({ color }, shapeTheme);\n}\n\nfunction createAnimationFunction(\n  type: 'enter' | 'exit' | 'update',\n  mark: G2Mark,\n  state: G2MarkState,\n  view: G2ViewDescriptor,\n  library: G2Library,\n): (\n  data: Record<string, any>,\n  from: DisplayObject[],\n  to: DisplayObject[],\n) => GAnimation[] {\n  const [, createShape] = useLibrary<G2ShapeOptions, ShapeComponent, Shape>(\n    'shape',\n    library,\n  );\n  const [useAnimation] = useLibrary<\n    G2AnimationOptions,\n    AnimationComponent,\n    Animation\n  >('animation', library);\n  const { defaultShape, shape: shapeLibrary } = state;\n  const { theme, coordinate } = view;\n\n  const upperType = upperFirst(type) as 'Enter' | 'Exit' | 'Update';\n  const key:\n    | 'defaultEnterAnimation'\n    | 'defaultExitAnimation'\n    | 'defaultUpdateAnimation' = `default${upperType}Animation`;\n\n  // Get shape from mark first, then from library.\n  const { [key]: defaultAnimation } =\n    shapeLibrary[defaultShape]?.props ||\n    createShape(shapeName(mark, defaultShape)).props;\n\n  const { [type]: defaultEffectTiming = {} } = theme;\n  const animate = mark.animate?.[type] || {};\n  const context = { coordinate };\n\n  return (data, from, to) => {\n    const {\n      [`${type}Type`]: animation,\n      [`${type}Delay`]: delay,\n      [`${type}Duration`]: duration,\n      [`${type}Easing`]: easing,\n    } = data;\n\n    const options = {\n      type: animation || defaultAnimation,\n      ...animate,\n    };\n    if (!options.type) return null;\n\n    const animateFunction = useAnimation(options, context);\n    const value = { delay, duration, easing };\n    const A = animateFunction(from, to, deepMix(defaultEffectTiming, value));\n    let an: GAnimation[] = [];\n    if (!Array.isArray(A)) {\n      an = [A];\n    } else {\n      an = A;\n    }\n    return an.filter(Boolean);\n  };\n}\n\nfunction createEnterFunction(\n  mark: G2Mark,\n  state: G2MarkState,\n  view: G2ViewDescriptor,\n  library: G2Library,\n): (\n  data: Record<string, any>,\n  from?: DisplayObject[],\n  to?: DisplayObject[],\n) => GAnimation[] {\n  return createAnimationFunction('enter', mark, state, view, library);\n}\n\n/**\n * Animation will not cancel automatically, it should be canceled\n * manually. This is very important for performance.\n */\nfunction cancel(animation: GAnimation): GAnimation {\n  animation.finished.then(() => {\n    animation.cancel();\n  });\n  return animation;\n}\n\nfunction createUpdateFunction(\n  mark: G2Mark,\n  state: G2MarkState,\n  view: G2ViewDescriptor,\n  library: G2Library,\n): (\n  data: Record<string, any>,\n  from?: DisplayObject[],\n  to?: DisplayObject[],\n) => GAnimation[] {\n  return createAnimationFunction('update', mark, state, view, library);\n}\n\nfunction createExitFunction(\n  mark: G2Mark,\n  state: G2MarkState,\n  view: G2ViewDescriptor,\n  library: G2Library,\n): (\n  data: Record<string, any>,\n  from?: DisplayObject[],\n  to?: DisplayObject[],\n) => GAnimation[] {\n  return createAnimationFunction('exit', mark, state, view, library);\n}\n\nfunction inferTheme(theme: G2ThemeOptions = {}): G2ThemeOptions {\n  if (typeof theme === 'string') return { type: theme };\n  const { type = 'light', ...rest } = theme;\n  return { ...rest, type };\n}\n\n/**\n * @todo Infer builtin tooltips.\n */\nfunction inferInteraction(\n  view: G2View,\n): [string, boolean | Omit<G2InteractionOptions, 'type'>][] {\n  const defaults = {\n    event: true,\n    tooltip: true,\n    // @todo Inferred by slider self.\n    sliderFilter: true,\n    legendFilter: true,\n    scrollbarFilter: true,\n  };\n  const { interaction = {} } = view;\n  return Object.entries(deepMix(defaults, interaction)).reverse();\n}\n\nasync function applyTransform<T extends G2ViewTree>(\n  node: T,\n  context: G2Context,\n): Promise<G2ViewTree> {\n  const { data, ...rest } = node;\n  if (data == undefined) return node;\n  const [, { data: newData }] = await applyDataTransform([], { data }, context);\n  return { data: newData, ...rest };\n}\n\nfunction updateBBox(selection: Selection) {\n  selection\n    .style(\n      'transform',\n      (d) =>\n        `translate(${d.paddingLeft + d.marginLeft}, ${\n          d.paddingTop + d.marginTop\n        })`,\n    )\n    .style('width', (d) => d.innerWidth)\n    .style('height', (d) => d.innerHeight);\n}\n\nfunction animateBBox(selection: Selection, extent: [number, number]) {\n  const [delay, duration] = extent;\n  selection.transition(function (data, i, element) {\n    const { transform, width, height } = element.style;\n    const {\n      paddingLeft,\n      paddingTop,\n      innerWidth,\n      innerHeight,\n      marginLeft,\n      marginTop,\n    } = data;\n    const keyframes = [\n      {\n        transform,\n        width,\n        height,\n      },\n      {\n        transform: `translate(${paddingLeft + marginLeft}, ${\n          paddingTop + marginTop\n        })`,\n        width: innerWidth,\n        height: innerHeight,\n      },\n    ];\n    return element.animate(keyframes, { delay, duration, fill: 'both' });\n  });\n}\n\nfunction shapeName(mark, name) {\n  const { type } = mark;\n  if (typeof name === 'string') return `${type}.${name}`;\n  return name;\n}\n\n/**\n * Create and update layer for each mark.\n * All the layers created here are treated as main layers.\n */\nfunction updateLayers(selection: Selection, marks: G2Mark[]) {\n  const facet = (d) => (d.class !== undefined ? `${d.class}` : '');\n\n  // Skip for empty selection, it can't append nodes.\n  const nodes = selection.nodes();\n  if (nodes.length === 0) return;\n\n  selection\n    .selectAll(className(MAIN_LAYER_CLASS_NAME))\n    .data(marks, (d) => d.key)\n    .join(\n      (enter) =>\n        enter\n          .append('g')\n          .attr('className', MAIN_LAYER_CLASS_NAME)\n          .attr('id', (d) => d.key)\n          .style('facet', facet)\n          .style('fill', 'transparent')\n          .style('zIndex', (d) => d.zIndex ?? 0),\n      (update) =>\n        update\n          .style('facet', facet)\n          .style('fill', 'transparent')\n          .style('zIndex', (d) => d.zIndex ?? 0),\n      (exit) => exit.remove(),\n    );\n\n  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();\n  if (labelLayer) return;\n  selection\n    .append('g')\n    .attr('className', LABEL_LAYER_CLASS_NAME)\n    .style('zIndex', 0);\n}\n\nfunction className(...names: string[]): string {\n  return names.map((d) => `.${d}`).join('');\n}\n\nfunction applyClip(selection, clip?: boolean) {\n  if (!selection.node()) return;\n  selection.style('clipPath', (data) => {\n    if (!clip) return null;\n    const {\n      paddingTop: y,\n      paddingLeft: x,\n      marginLeft: x1,\n      marginTop: y1,\n      innerWidth: width,\n      innerHeight: height,\n    } = data;\n    return new Rect({ style: { x: x + x1, y: y + y1, width, height } });\n  });\n}\n\nfunction inferComponentScales(\n  scales: G2ScaleOptions[],\n  states: G2MarkState[],\n  markState: Map<G2Mark, G2MarkState>,\n): G2ScaleOptions[] {\n  // add shape scale to state.\n\n  // for cell, omit shape scale.\n  // @todo support shape scale for cell.\n  for (const [key] of markState.entries()) {\n    if (key.type === 'cell') {\n      return scales.filter((scale) => scale.name !== 'shape');\n    }\n  }\n\n  // can't infer shape scale if there are multiple states.\n  if (states.length !== 1 || scales.some((scale) => scale.name === 'shape')) {\n    return scales;\n  }\n\n  const { defaultShape: shape } = states[0];\n  const acceptMarkTypes = ['point', 'line', 'rect', 'hollow'];\n  if (!acceptMarkTypes.includes(shape)) return scales;\n  const shapeMap = {\n    point: 'point',\n    line: 'hyphen',\n    rect: 'square',\n    hollow: 'hollow',\n  };\n\n  // create shape scale\n  const field = scales.find((scale) => scale.name === 'color')?.field || null;\n  const shapeScale = {\n    field,\n    name: 'shape',\n    type: 'constant',\n    domain: [],\n    range: [shapeMap[shape]],\n  };\n  return [...scales, shapeScale];\n}\n\nexport function applyStyle(\n  selection: Selection,\n  style: Record<string, Primitive>,\n) {\n  for (const [key, value] of Object.entries(style)) {\n    selection.style(key, value);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}