{"ast":null,"code":"import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { getEdgesByNodeId } from './util';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n  // 从nodes[0]开始\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode);\n  // 用二叉堆维护距已加入节点的其他节点的边的权值\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n    return 0;\n  };\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n  // 若指定weight，则将所有的边按权值从小到大排序\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n  var disjointSet = new UnionFind(nodes.map(function (n) {\n    return n.id;\n  }));\n  // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\nexport default minimumSpanningTree;","map":{"version":3,"names":["UnionFind","MinBinaryHeap","getEdgesByNodeId","primMST","graphData","weight","selectedEdges","_a","nodes","_b","edges","length","currNode","visited","Set","add","compareWeight","a","b","edgeQueue","id","forEach","edge","insert","isEmpty","currEdge","delMin","source","target","has","push","kruskalMST","weightEdges","map","sort","disjointSet","n","curEdge","shift","connected","union","minimumSpanningTree","algo","algos","prim","kruskal"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/algorithm/es/mts.js"],"sourcesContent":["import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { getEdgesByNodeId } from './util';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n  // 从nodes[0]开始\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode);\n  // 用二叉堆维护距已加入节点的其他节点的边的权值\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n    return 0;\n  };\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n  // 若指定weight，则将所有的边按权值从小到大排序\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n  var disjointSet = new UnionFind(nodes.map(function (n) {\n    return n.id;\n  }));\n  // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\nexport default minimumSpanningTree;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}