{"ast":null,"code":"import { __assign, __extends, __read, __spreadArray } from \"tslib\";\nimport { CustomEvent } from '@antv/g';\nimport { Linear } from '@antv/scale';\nimport { clamp, isUndefined } from '@antv/util';\nimport { Component } from '../../core';\nimport { BBox, deepAssign, getEventPos, hide, ifShow, select, show, subStyleProps, superStyleProps, toPrecision } from '../../util';\nimport { Axis } from '../axis';\nimport { CLASS_NAMES as AXIS_CLASS_NAMES } from '../axis/constant';\nimport { Indicator } from '../indicator';\nimport { Handle as SliderHandle } from '../slider/handle';\nimport { Title } from '../title';\nimport { CLASS_NAMES, CONTINUOUS_DEFAULT_OPTIONS, STEP_RATIO } from './constant';\nimport { Handle } from './continuous/handle';\nimport { Ribbon } from './continuous/ribbon';\nimport { getNextTickValue } from './continuous/utils';\nimport { getSafetySelections, getStepValueByValue, ifHorizontal } from './utils';\nfunction getMinMax(data) {\n  return {\n    min: Math.min.apply(Math, __spreadArray([], __read(data.map(function (d) {\n      return d.value;\n    })), false)),\n    max: Math.max.apply(Math, __spreadArray([], __read(data.map(function (d) {\n      return d.value;\n    })), false))\n  };\n}\nvar Continuous = /** @class */function (_super) {\n  __extends(Continuous, _super);\n  function Continuous(options) {\n    var _this = _super.call(this, options, CONTINUOUS_DEFAULT_OPTIONS) || this;\n    _this.eventToOffsetScale = new Linear({});\n    _this.innerRibbonScale = new Linear({});\n    _this.cacheLabelBBox = null;\n    _this.cacheHandleBBox = null;\n    _this.onHovering = function (e) {\n      var _a = _this.attributes,\n        data = _a.data,\n        block = _a.block;\n      e.stopPropagation();\n      var value = _this.getValueByCanvasPoint(e);\n      if (block) {\n        var range = getNextTickValue(data.map(function (_a) {\n          var value = _a.value;\n          return value;\n        }), value).range;\n        var selection = _this.getRealSelection(range);\n        _this.showIndicator((range[0] + range[1]) / 2, \"\".concat(selection[0], \"-\").concat(selection[1]));\n        _this.dispatchIndicated(value, range);\n      } else {\n        var safetyValue = _this.getTickValue(value);\n        _this.showIndicator(safetyValue, \"\".concat(_this.getRealValue(safetyValue)));\n        _this.dispatchIndicated(safetyValue);\n      }\n    };\n    _this.onDragStart = function (target) {\n      return function (e) {\n        e.stopPropagation();\n        // 关闭滑动\n        if (!_this.attributes.slidable) return;\n        _this.target = target;\n        _this.prevValue = _this.getTickValue(_this.getValueByCanvasPoint(e));\n        document.addEventListener('mousemove', _this.onDragging);\n        document.addEventListener('touchmove', _this.onDragging);\n        document.addEventListener('mouseleave', _this.onDragEnd);\n        document.addEventListener('mouseup', _this.onDragEnd);\n        document.addEventListener('mouseup', _this.onDragEnd);\n        document.addEventListener('touchend', _this.onDragEnd);\n      };\n    };\n    _this.onDragging = function (e) {\n      var target = _this.target;\n      _this.updateMouse();\n      var _a = __read(_this.selection, 2),\n        start = _a[0],\n        end = _a[1];\n      var currValue = _this.getTickValue(_this.getValueByCanvasPoint(e));\n      var diffValue = currValue - _this.prevValue;\n      if (target === 'start') start !== currValue && _this.updateSelection(currValue, end);else if (target === 'end') end !== currValue && _this.updateSelection(start, currValue);else if (target === 'ribbon' && diffValue !== 0) {\n        _this.prevValue = currValue;\n        _this.updateSelection(diffValue, diffValue, true);\n      }\n    };\n    _this.onDragEnd = function () {\n      _this.style.cursor = 'pointer';\n      document.removeEventListener('mousemove', _this.onDragging);\n      document.removeEventListener('touchmove', _this.onDragging);\n      document.removeEventListener('mouseup', _this.onDragEnd);\n      document.removeEventListener('touchend', _this.onDragEnd);\n    };\n    return _this;\n  }\n  Object.defineProperty(Continuous.prototype, \"handleOffsetRatio\", {\n    get: function () {\n      return this.ifHorizontal(0.5, 0.5);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Continuous.prototype.getBBox = function () {\n    var _a = this.attributes,\n      width = _a.width,\n      height = _a.height;\n    return new BBox(0, 0, width, height);\n  };\n  Continuous.prototype.render = function (attributes, container) {\n    var _this = this;\n    // 渲染顺序\n    // 1. 绘制 title, 获得可用空间\n    // 2. 绘制 label, handle\n    // 3. 基于可用空间、label高度、handle 宽高，计算 ribbon 宽高\n    // 4. 绘制 ribbon\n    // 5. 调整 label、handle 位置\n    var showLabel = attributes.showLabel;\n    /** title */\n    this.renderTitle(select(container));\n    var _a = this.availableSpace,\n      x = _a.x,\n      y = _a.y;\n    /** label */\n    /** content */\n    var contentGroup = select(container).maybeAppendByClassName(CLASS_NAMES.contentGroup, 'g').styles({\n      transform: \"translate(\".concat(x, \", \").concat(y, \")\")\n    });\n    var labelGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES.labelGroup, 'g').styles({\n      zIndex: 1\n    });\n    ifShow(!!showLabel, labelGroup, function (group) {\n      _this.renderLabel(group);\n    });\n    var ribbonGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES.ribbonGroup, 'g').styles({\n      zIndex: 0\n    });\n    /** handle */\n    this.handlesGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES.handlesGroup, 'g').styles({\n      zIndex: 2\n    });\n    this.renderHandles();\n    /** ribbon */\n    this.renderRibbon(ribbonGroup);\n    this.renderIndicator(contentGroup);\n    /** adjust */\n    this.adjustLabel();\n    this.adjustHandles();\n    // this.adjustTitle();\n  };\n  Object.defineProperty(Continuous.prototype, \"range\", {\n    get: function () {\n      var _a = this.attributes,\n        data = _a.data,\n        domain = _a.domain;\n      return domain ? {\n        min: domain[0],\n        max: domain[1]\n      } : getMinMax(data);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"ribbonScale\", {\n    get: function () {\n      var _a = this.range,\n        min = _a.min,\n        max = _a.max;\n      this.innerRibbonScale.update({\n        domain: [min, max],\n        range: [0, 1]\n      });\n      return this.innerRibbonScale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"ribbonRange\", {\n    get: function () {\n      var _a = __read(this.selection, 2),\n        min = _a[0],\n        max = _a[1];\n      var scale = this.ribbonScale;\n      return [scale.map(min), scale.map(max)];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"selection\", {\n    get: function () {\n      var _a = this.range,\n        min = _a.min,\n        max = _a.max;\n      var _b = this.attributes.defaultValue,\n        _c = _b === void 0 ? [min, max] : _b,\n        _d = __read(_c, 2),\n        start = _d[0],\n        end = _d[1];\n      return [start, end];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Continuous.prototype.ifHorizontal = function (a, b) {\n    return ifHorizontal(this.attributes.orientation, typeof a === 'function' ? a() : a, typeof b === 'function' ? b() : b);\n  };\n  Continuous.prototype.renderTitle = function (container) {\n    var _a = this.attributes,\n      showTitle = _a.showTitle,\n      titleText = _a.titleText,\n      width = _a.width,\n      height = _a.height;\n    var style = subStyleProps(this.attributes, 'title');\n    var finalTitleStyle = __assign(__assign({}, style), {\n      width: width,\n      height: height,\n      text: titleText\n    });\n    var that = this;\n    container.selectAll(CLASS_NAMES.title.class).data(showTitle ? [titleText] : []).join(function (enter) {\n      return enter.append(function () {\n        return new Title({\n          style: finalTitleStyle\n        });\n      }).attr('className', CLASS_NAMES.title.name).each(function () {\n        that.title = this;\n      });\n    }, function (update) {\n      return update.update(finalTitleStyle);\n    }, function (exit) {\n      return exit.each(function () {\n        that.title = undefined;\n      }).remove();\n    });\n  };\n  Object.defineProperty(Continuous.prototype, \"availableSpace\", {\n    get: function () {\n      if (this.title) return this.title.getAvailableSpace();\n      var _a = this.attributes,\n        width = _a.width,\n        height = _a.height;\n      return new BBox(0, 0, width, height);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"labelFixedSpacing\", {\n    get: function () {\n      var showTick = this.attributes.showTick;\n      return showTick ? 5 : 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"labelPosition\", {\n    get: function () {\n      var _a = this.attributes,\n        orientation = _a.orientation,\n        labelDirection = _a.labelDirection;\n      var positions = {\n        vertical: {\n          positive: 'right',\n          negative: 'left'\n        },\n        horizontal: {\n          positive: 'bottom',\n          negative: 'top'\n        }\n      };\n      return positions[orientation][labelDirection];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"labelBBox\", {\n    get: function () {\n      var _a;\n      var showLabel = this.attributes.showLabel;\n      if (!showLabel) return new BBox(0, 0, 0, 0);\n      if (this.cacheLabelBBox) return this.cacheLabelBBox;\n      var _b = ((_a = this.label.querySelector(AXIS_CLASS_NAMES.labelGroup.class)) === null || _a === void 0 ? void 0 : _a.children.slice(-1)[0]).getBBox(),\n        width = _b.width,\n        height = _b.height;\n      this.cacheLabelBBox = new BBox(0, 0, width, height);\n      return this.cacheLabelBBox;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"labelShape\", {\n    get: function () {\n      var _a = this.attributes,\n        showLabel = _a.showLabel,\n        _b = _a.labelSpacing,\n        labelSpacing = _b === void 0 ? 0 : _b;\n      if (!showLabel) return {\n        width: 0,\n        height: 0,\n        size: 0,\n        length: 0\n      };\n      var _c = this.labelBBox,\n        width = _c.width,\n        height = _c.height;\n      var size = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;\n      var length = this.ifHorizontal(width, height);\n      return {\n        width: width,\n        height: height,\n        size: size,\n        length: length\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"ribbonBBox\", {\n    get: function () {\n      var _a = this.attributes,\n        showHandle = _a.showHandle,\n        userDefinedRibbonSize = _a.ribbonSize;\n      var _b = this.availableSpace,\n        availableWidth = _b.width,\n        availableHeight = _b.height;\n      var _c = this.labelShape,\n        labelSize = _c.size,\n        labelLength = _c.length;\n      var _d = __read(this.ifHorizontal([availableHeight, availableWidth], [availableWidth, availableHeight]), 2),\n        availableSize = _d[0],\n        availableLength = _d[1];\n      var _e = showHandle ? this.handleShape : {\n          size: 0,\n          length: 0\n        },\n        handleSize = _e.size,\n        handleLength = _e.length;\n      var handleRatio = this.handleOffsetRatio;\n      var ribbonSize = 0;\n      var labelPosition = this.labelPosition;\n      if (userDefinedRibbonSize) {\n        ribbonSize = userDefinedRibbonSize;\n      } else if (['bottom', 'right'].includes(labelPosition)) {\n        ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);\n      } else if (availableSize * (1 - handleRatio) > handleSize) {\n        ribbonSize = Math.max(availableSize - labelSize, 0);\n      } else ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);\n      var edgeLength = Math.max(handleLength, labelLength);\n      var ribbonLength = availableLength - edgeLength;\n      var _f = __read(this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]), 2),\n        width = _f[0],\n        height = _f[1];\n      // 需要考虑 handle 的占用空间\n      // todo 为了防止因为 handle 文本变化导致的 ribbon 位置变化，handle size 取最大值\n      var finalLabelOccupy = ['top', 'left'].includes(labelPosition) ? labelSize : 0;\n      var _g = __read(this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]), 2),\n        x = _g[0],\n        y = _g[1];\n      return new BBox(x, y, width, height);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"ribbonShape\", {\n    get: function () {\n      var _a = this.ribbonBBox,\n        width = _a.width,\n        height = _a.height;\n      return this.ifHorizontal({\n        size: height,\n        length: width\n      }, {\n        size: width,\n        length: height\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Continuous.prototype.renderRibbon = function (container) {\n    var _a = this.attributes,\n      data = _a.data,\n      type = _a.type,\n      orientation = _a.orientation,\n      color = _a.color,\n      block = _a.block;\n    var ribbonStyle = subStyleProps(this.attributes, 'ribbon');\n    var _b = this.range,\n      min = _b.min,\n      max = _b.max;\n    var _c = this.ribbonBBox,\n      x = _c.x,\n      y = _c.y;\n    var _d = this.ribbonShape,\n      length = _d.length,\n      size = _d.size;\n    var style = deepAssign({\n      transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n      length: length,\n      size: size,\n      type: type,\n      orientation: orientation,\n      color: color,\n      block: block,\n      partition: data.map(function (d) {\n        return (d.value - min) / (max - min);\n      }),\n      range: this.ribbonRange\n    }, ribbonStyle);\n    this.ribbon = container.maybeAppendByClassName(CLASS_NAMES.ribbon, function () {\n      return new Ribbon({\n        style: style\n      });\n    }).update(style);\n  };\n  Continuous.prototype.getHandleClassName = function (type) {\n    // @ts-ignore\n    return \"\".concat(CLASS_NAMES.prefix(\"\".concat(type, \"-handle\")));\n  };\n  Continuous.prototype.renderHandles = function () {\n    var _a = this.attributes,\n      showHandle = _a.showHandle,\n      orientation = _a.orientation;\n    var handleStyle = subStyleProps(this.attributes, 'handle');\n    var _b = __read(this.selection, 2),\n      min = _b[0],\n      max = _b[1];\n    var style = __assign(__assign({}, handleStyle), {\n      orientation: orientation\n    });\n    var _c = handleStyle.shape,\n      shape = _c === void 0 ? 'slider' : _c;\n    var HandleCtor = shape === 'basic' ? Handle : SliderHandle;\n    var that = this;\n    this.handlesGroup.selectAll(CLASS_NAMES.handle.class).data(showHandle ? [{\n      value: min,\n      type: 'start'\n    }, {\n      value: max,\n      type: 'end'\n    }] : [], function (d) {\n      return d.type;\n    }).join(function (enter) {\n      return enter.append(function () {\n        return new HandleCtor({\n          style: style\n        });\n      }).attr('className', function (_a) {\n        var type = _a.type;\n        return \"\".concat(CLASS_NAMES.handle, \" \").concat(that.getHandleClassName(type));\n      }).each(function (_a) {\n        var type = _a.type,\n          labelText = _a.value;\n        this.update({\n          labelText: labelText\n        });\n        var name = \"\".concat(type, \"Handle\");\n        that[name] = this;\n        this.addEventListener('pointerdown', that.onDragStart(type));\n      });\n    }, function (update) {\n      return update.update(style).each(function (_a) {\n        var labelText = _a.value;\n        this.update({\n          labelText: labelText\n        });\n      });\n    }, function (exit) {\n      return exit.each(function (_a) {\n        var type = _a.type;\n        var name = \"\".concat(type, \"Handle\");\n        that[name] = undefined;\n      }).remove();\n    });\n  };\n  Continuous.prototype.adjustHandles = function () {\n    var _a = __read(this.selection, 2),\n      min = _a[0],\n      max = _a[1];\n    this.setHandlePosition('start', min);\n    this.setHandlePosition('end', max);\n  };\n  Object.defineProperty(Continuous.prototype, \"handleBBox\", {\n    get: function () {\n      if (this.cacheHandleBBox) return this.cacheHandleBBox;\n      if (!this.attributes.showHandle) return new BBox(0, 0, 0, 0);\n      var _a = this.startHandle.getBBox(),\n        startHandleWidth = _a.width,\n        startHandleHeight = _a.height;\n      var _b = this.endHandle.getBBox(),\n        endHandleWidth = _b.width,\n        endHandleHeight = _b.height;\n      var _c = __read([Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)], 2),\n        width = _c[0],\n        height = _c[1];\n      this.cacheHandleBBox = new BBox(0, 0, width, height);\n      return this.cacheHandleBBox;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"handleShape\", {\n    /**\n     *  因为 handle label 的宽高是动态的，所以 handle bbox 是第一次渲染时的 bbox\n     */\n    get: function () {\n      var _a = this.handleBBox,\n        width = _a.width,\n        height = _a.height;\n      var _b = __read(this.ifHorizontal([height, width], [width, height]), 2),\n        size = _b[0],\n        length = _b[1];\n      return {\n        width: width,\n        height: height,\n        size: size,\n        length: length\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Continuous.prototype.setHandlePosition = function (type, value) {\n    var handleFormatter = this.attributes.handleFormatter;\n    var _a = this.ribbonBBox,\n      ribbonX = _a.x,\n      ribbonY = _a.y;\n    var ribbonSize = this.ribbonShape.size;\n    var offset = this.getOffset(value);\n    var _b = __read(this.ifHorizontal([ribbonX + offset, ribbonY + ribbonSize * this.handleOffsetRatio], [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset]), 2),\n      x = _b[0],\n      y = _b[1];\n    var handle = this.handlesGroup.select(\".\".concat(this.getHandleClassName(type))).node();\n    handle === null || handle === void 0 ? void 0 : handle.update({\n      transform: \"translate(\".concat(x, \", \").concat(y, \")\"),\n      formatter: handleFormatter\n    });\n  };\n  Continuous.prototype.renderIndicator = function (container) {\n    var style = subStyleProps(this.attributes, 'indicator');\n    this.indicator = container.maybeAppendByClassName(CLASS_NAMES.indicator, function () {\n      return new Indicator({});\n    }).update(style);\n    // this.hideIndicator();\n  };\n  Object.defineProperty(Continuous.prototype, \"labelData\", {\n    get: function () {\n      var _this = this;\n      var data = this.attributes.data;\n      return data.reduce(function (acc, curr, index, arr) {\n        var _a, _b;\n        var id = (_a = curr === null || curr === void 0 ? void 0 : curr.id) !== null && _a !== void 0 ? _a : index.toString();\n        acc.push(__assign(__assign({}, curr), {\n          id: id,\n          index: index,\n          type: 'value',\n          label: (_b = curr === null || curr === void 0 ? void 0 : curr.label) !== null && _b !== void 0 ? _b : curr.value.toString(),\n          value: _this.ribbonScale.map(curr.value)\n        }));\n        if (index < arr.length - 1) {\n          var next = arr[index + 1];\n          var _c = __read([curr.value, next.value], 2),\n            cr = _c[0],\n            nx = _c[1];\n          var midVal = (cr + nx) / 2;\n          acc.push(__assign(__assign({}, curr), {\n            id: id,\n            index: index,\n            type: 'range',\n            range: [cr, nx],\n            label: [cr, nx].join('~'),\n            value: _this.ribbonScale.map(midVal)\n          }));\n        }\n        return acc;\n      }, []);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Continuous.prototype, \"labelStyle\", {\n    get: function () {\n      var _a = __read(['center', 'middle'], 2),\n        labelTextAlign = _a[0],\n        labelTextBaseline = _a[1];\n      var labelPosition = this.labelPosition;\n      if (labelPosition === 'top') labelTextBaseline = 'bottom';else if (labelPosition === 'bottom') labelTextBaseline = 'top';else if (labelPosition === 'left') labelTextAlign = 'end';else if (labelPosition === 'right') labelTextAlign = 'start';\n      return {\n        labelTextAlign: labelTextAlign,\n        labelTextBaseline: labelTextBaseline\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Continuous.prototype.renderLabel = function (container) {\n    var _a = this.attributes,\n      _b = _a.showTick,\n      showTick = _b === void 0 ? false : _b,\n      labelFilter = _a.labelFilter,\n      labelFormatter = _a.labelFormatter;\n    var tickStyle = subStyleProps(this.attributes, 'tick');\n    var labelStyle = subStyleProps(this.attributes, 'label');\n    var align = labelStyle.align;\n    var style = deepAssign(__assign({\n      showLine: false,\n      showGrid: false,\n      showTick: showTick,\n      type: 'linear',\n      startPos: [0, 0],\n      endPos: [0, 0],\n      tickDirection: 'negative',\n      labelTransform: 'rotate(0)'\n    }, this.labelStyle), superStyleProps(tickStyle, 'tick'), superStyleProps(labelStyle, 'label'), {\n      data: this.labelData\n    });\n    var functionStyle = {\n      tickFilter: function (datum, index, data) {\n        if ((datum === null || datum === void 0 ? void 0 : datum.type) !== 'value') return false;\n        if (labelFilter) return labelFilter(datum, datum.index, data.filter(function (d) {\n          return d.type !== 'value';\n        }));\n        return true;\n      },\n      labelFilter: function (datum, index, data) {\n        if ((datum === null || datum === void 0 ? void 0 : datum.type) !== align) return false;\n        if (labelFilter) return labelFilter(datum, datum.index, data.filter(function (d) {\n          return d.type === align;\n        }));\n        return true;\n      },\n      labelFormatter: labelFormatter\n    };\n    var finalLabelStyle = __assign(__assign(__assign({}, style), functionStyle), {\n      labelOverlap: [{\n        type: 'hide'\n      }]\n    });\n    this.label = container.maybeAppendByClassName(CLASS_NAMES.label, function () {\n      return new Axis({\n        style: finalLabelStyle\n      });\n    }).node();\n    this.label.update(finalLabelStyle, false);\n  };\n  Object.defineProperty(Continuous.prototype, \"labelAxisStyle\", {\n    get: function () {\n      // @ts-ignore\n      var _a = this.attributes,\n        showTick = _a.showTick,\n        labelDirection = _a.labelDirection,\n        labelSpacing = _a.labelSpacing,\n        definedTickLength = _a.tickLength;\n      var ribbonSize = this.ribbonShape.size;\n      var labelPosition = this.labelPosition;\n      var labelFixedSpacing = this.labelFixedSpacing;\n      var _b = __read([0, 0, 0], 3),\n        offset = _b[0],\n        spacing = _b[1],\n        tickLength = _b[2];\n      var internalVal = definedTickLength !== null && definedTickLength !== void 0 ? definedTickLength : ribbonSize;\n      if (showTick) {\n        tickLength = internalVal;\n        spacing = labelFixedSpacing;\n        if (labelDirection === 'positive') {\n          if (labelPosition === 'right') {\n            offset = internalVal;\n            tickLength = internalVal;\n          } else if (labelPosition === 'bottom') offset = tickLength;\n        } else if (labelDirection === 'negative') {\n          if (labelPosition === 'top') offset = ribbonSize;else if (labelPosition === 'left') offset = ribbonSize;\n        }\n      } else if (labelDirection === 'positive') {\n        if (labelPosition === 'right') spacing = internalVal;else if (labelPosition === 'bottom') {\n          offset = ribbonSize + labelFixedSpacing;\n          spacing = labelSpacing;\n        }\n      } else if (labelDirection === 'negative') {\n        if (labelPosition === 'left') spacing = labelSpacing;else if (labelPosition === 'top') spacing = labelSpacing;\n      }\n      return {\n        offset: offset,\n        spacing: spacing,\n        tickLength: tickLength\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Continuous.prototype.adjustLabel = function () {\n    var showLabel = this.attributes.showLabel;\n    if (!showLabel) return;\n    var _a = this.ribbonBBox,\n      x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height;\n    var _b = this.labelAxisStyle,\n      axisOffset = _b.offset,\n      axisSpacing = _b.spacing,\n      axisTickLength = _b.tickLength;\n    var _c = __read(this.ifHorizontal([[x, y + axisOffset], [x + width, y + axisOffset]], [[x + axisOffset, y + height], [x + axisOffset, y]]), 2),\n      startPos = _c[0],\n      endPos = _c[1];\n    this.label.update({\n      startPos: startPos,\n      endPos: endPos,\n      tickLength: axisTickLength,\n      labelSpacing: axisSpacing\n    }, false);\n  };\n  Continuous.prototype.bindEvents = function () {\n    this.style.cursor = 'pointer';\n    // 绑定 drag 开始事件\n    this.ribbon.on('pointerdown', this.onDragStart('ribbon'));\n    this.ribbon.on('pointermove', this.onHovering);\n    this.addEventListener('pointerout', this.hideIndicator);\n  };\n  Continuous.prototype.showIndicator = function (value, text) {\n    if (text === void 0) {\n      text = \"\".concat(value);\n    }\n    var showIndicator = this.attributes.showIndicator;\n    if (!showIndicator || typeof value !== 'number') {\n      this.hideIndicator();\n      return;\n    }\n    var _a = this.range,\n      min = _a.min,\n      max = _a.max;\n    var _b = this.ribbonBBox,\n      x = _b.x,\n      y = _b.y;\n    var safeValue = clamp(value, min, max);\n    var offset = this.getOffset(safeValue);\n    var pos = this.ifHorizontal([offset + x, y], [x, offset + y]);\n    this.indicator.update({\n      x: pos[0],\n      y: pos[1],\n      position: this.ifHorizontal('top', 'left'),\n      labelText: text\n    });\n    show(this.indicator.node());\n  };\n  Continuous.prototype.hideIndicator = function () {\n    hide(this.indicator.node());\n  };\n  Continuous.prototype.updateMouse = function () {\n    if (this.attributes.slidable) this.style.cursor = 'grabbing';\n  };\n  Continuous.prototype.setSelection = function (start, end) {\n    this.updateSelection(start, end);\n  };\n  Continuous.prototype.updateSelection = function (stVal, endVal, isOffset) {\n    var _a;\n    if (isOffset === void 0) {\n      isOffset = false;\n    }\n    var _b = __read(this.selection, 2),\n      currSt = _b[0],\n      currEnd = _b[1];\n    var _c = __read([stVal, endVal], 2),\n      start = _c[0],\n      end = _c[1];\n    if (isOffset) {\n      // 获取当前值\n      start += currSt;\n      end += currEnd;\n    }\n    // 值校验\n    var _d = this.range,\n      min = _d.min,\n      max = _d.max;\n    _a = __read(getSafetySelections([min, max], [start, end], this.selection), 2), start = _a[0], end = _a[1];\n    this.update({\n      defaultValue: [start, end]\n    });\n    this.dispatchSelection();\n  };\n  Object.defineProperty(Continuous.prototype, \"step\", {\n    get: function () {\n      var _a = this.attributes.step,\n        step = _a === void 0 ? 1 : _a;\n      var _b = this.range,\n        min = _b.min,\n        max = _b.max;\n      if (isUndefined(step)) return toPrecision((max - min) * STEP_RATIO, 0);\n      return step;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Continuous.prototype.getTickValue = function (value) {\n    var _a = this.attributes,\n      data = _a.data,\n      block = _a.block;\n    var min = this.range.min;\n    if (block) return getNextTickValue(data.map(function (_a) {\n      var value = _a.value;\n      return value;\n    }), value).tick;\n    return getStepValueByValue(value, this.step, min);\n  };\n  /**\n   * 事件触发的位置对应的value值\n   */\n  Continuous.prototype.getValueByCanvasPoint = function (e) {\n    var _a = this.range,\n      min = _a.min,\n      max = _a.max;\n    var _b = __read(this.ribbon.node().getPosition(), 2),\n      x = _b[0],\n      y = _b[1];\n    var startPos = this.ifHorizontal(x, y);\n    var currValue = this.ifHorizontal.apply(this, __spreadArray([], __read(getEventPos(e)), false));\n    var offset = currValue - startPos;\n    var value = clamp(this.getOffset(offset, true), min, max);\n    return value;\n  };\n  /** reverse: 屏幕偏移量 -> 值 */\n  Continuous.prototype.getOffset = function (value, reverse) {\n    if (reverse === void 0) {\n      reverse = false;\n    }\n    var _a = this.range,\n      min = _a.min,\n      max = _a.max;\n    var ribbonLen = this.ribbonShape.length;\n    var scale = this.eventToOffsetScale;\n    scale.update({\n      domain: [min, max],\n      range: [0, ribbonLen]\n    });\n    if (reverse) return scale.invert(value);\n    return scale.map(value);\n  };\n  Continuous.prototype.getRealSelection = function (range) {\n    var max = this.range.max;\n    var _a = __read(range, 2),\n      start = _a[0],\n      end = _a[1];\n    return this.ifHorizontal([start, end], [max - end, max - start]);\n  };\n  Continuous.prototype.getRealValue = function (value) {\n    var max = this.range.max;\n    return this.ifHorizontal(value, max - value);\n  };\n  Continuous.prototype.dispatchSelection = function () {\n    var selection = this.getRealSelection(this.selection);\n    var evt = new CustomEvent('valuechange', {\n      detail: {\n        value: selection\n      }\n    });\n    this.dispatchEvent(evt);\n  };\n  Continuous.prototype.dispatchIndicated = function (value, range) {\n    var _this = this;\n    var max = this.range.max;\n    var detail = this.ifHorizontal(function () {\n      return {\n        value: value,\n        range: range\n      };\n    }, function () {\n      return {\n        value: max - value,\n        range: range ? _this.getRealSelection(range) : undefined\n      };\n    });\n    var evt = new CustomEvent('indicate', {\n      detail: detail\n    });\n    this.dispatchEvent(evt);\n  };\n  return Continuous;\n}(Component);\nexport { Continuous };","map":{"version":3,"names":["CustomEvent","Linear","clamp","isUndefined","Component","BBox","deepAssign","getEventPos","hide","ifShow","select","show","subStyleProps","superStyleProps","toPrecision","Axis","CLASS_NAMES","AXIS_CLASS_NAMES","Indicator","Handle","SliderHandle","Title","CONTINUOUS_DEFAULT_OPTIONS","STEP_RATIO","Ribbon","getNextTickValue","getSafetySelections","getStepValueByValue","ifHorizontal","getMinMax","data","min","Math","apply","__spreadArray","__read","map","d","value","max","Continuous","_super","__extends","options","_this","call","eventToOffsetScale","innerRibbonScale","cacheLabelBBox","cacheHandleBBox","onHovering","e","_a","attributes","block","stopPropagation","getValueByCanvasPoint","range","selection","getRealSelection","showIndicator","concat","dispatchIndicated","safetyValue","getTickValue","getRealValue","onDragStart","target","slidable","prevValue","document","addEventListener","onDragging","onDragEnd","updateMouse","start","end","currValue","diffValue","updateSelection","style","cursor","removeEventListener","Object","defineProperty","prototype","get","getBBox","width","height","render","container","showLabel","renderTitle","availableSpace","x","y","contentGroup","maybeAppendByClassName","styles","transform","labelGroup","zIndex","group","renderLabel","ribbonGroup","handlesGroup","renderHandles","renderRibbon","renderIndicator","adjustLabel","adjustHandles","domain","update","scale","ribbonScale","_b","defaultValue","_c","_d","a","b","orientation","showTitle","titleText","finalTitleStyle","__assign","text","that","selectAll","title","class","join","enter","append","attr","name","each","exit","undefined","remove","getAvailableSpace","showTick","labelDirection","positions","vertical","positive","negative","horizontal","label","querySelector","children","slice","labelSpacing","size","length","labelBBox","labelFixedSpacing","showHandle","userDefinedRibbonSize","ribbonSize","availableWidth","availableHeight","labelShape","labelSize","labelLength","availableSize","availableLength","_e","handleShape","handleSize","handleLength","handleRatio","handleOffsetRatio","labelPosition","includes","edgeLength","ribbonLength","_f","finalLabelOccupy","_g","ribbonBBox","type","color","ribbonStyle","ribbonShape","partition","ribbonRange","ribbon","getHandleClassName","prefix","handleStyle","shape","HandleCtor","handle","labelText","setHandlePosition","startHandle","startHandleWidth","startHandleHeight","endHandle","endHandleWidth","endHandleHeight","handleBBox","handleFormatter","ribbonX","ribbonY","offset","getOffset","node","formatter","indicator","reduce","acc","curr","index","arr","id","toString","push","next","cr","nx","midVal","labelTextAlign","labelTextBaseline","labelFilter","labelFormatter","tickStyle","labelStyle","align","showLine","showGrid","startPos","endPos","tickDirection","labelTransform","labelData","functionStyle","tickFilter","datum","filter","finalLabelStyle","labelOverlap","definedTickLength","tickLength","spacing","internalVal","labelAxisStyle","axisOffset","axisSpacing","axisTickLength","bindEvents","on","hideIndicator","safeValue","pos","position","setSelection","stVal","endVal","isOffset","currSt","currEnd","dispatchSelection","step","tick","getPosition","reverse","ribbonLen","invert","evt","detail","dispatchEvent"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/component/src/ui/legend/continuous.ts"],"sourcesContent":["import { CustomEvent } from '@antv/g';\nimport { Linear } from '@antv/scale';\nimport { clamp, isUndefined } from '@antv/util';\nimport { Component } from '../../core';\nimport type { DisplayObject, TextStyleProps } from '../../shapes';\nimport { Group } from '../../shapes';\nimport { Point } from '../../types';\nimport {\n  BBox,\n  Selection,\n  deepAssign,\n  getEventPos,\n  hide,\n  ifShow,\n  select,\n  show,\n  subStyleProps,\n  superStyleProps,\n  toPrecision,\n} from '../../util';\nimport type { LinearAxisStyleProps } from '../axis';\nimport { Axis } from '../axis';\nimport { CLASS_NAMES as AXIS_CLASS_NAMES } from '../axis/constant';\nimport type { IndicatorStyleProps } from '../indicator';\nimport { Indicator } from '../indicator';\nimport { Handle as SliderHandle } from '../slider/handle';\nimport { Title } from '../title';\nimport { CLASS_NAMES, CONTINUOUS_DEFAULT_OPTIONS, STEP_RATIO } from './constant';\nimport type { HandleStyleProps, HandleType } from './continuous/handle';\nimport { Handle } from './continuous/handle';\nimport type { RibbonStyleProps } from './continuous/ribbon';\nimport { Ribbon } from './continuous/ribbon';\nimport { getNextTickValue } from './continuous/utils';\nimport { ContinuousDatum, ContinuousOptions, ContinuousStyleProps } from './types';\nimport { getSafetySelections, getStepValueByValue, ifHorizontal } from './utils';\n\nexport type { ContinuousOptions, ContinuousStyleProps };\n\nfunction getMinMax(data: ContinuousDatum[]) {\n  return {\n    min: Math.min(...data.map((d) => d.value)),\n    max: Math.max(...data.map((d) => d.value)),\n  };\n}\n\nexport class Continuous extends Component<ContinuousStyleProps> {\n  constructor(options: ContinuousOptions) {\n    super(options, CONTINUOUS_DEFAULT_OPTIONS);\n  }\n\n  protected eventToOffsetScale = new Linear({});\n\n  protected innerRibbonScale = new Linear({});\n\n  protected title?: Title;\n\n  protected label!: Axis;\n\n  protected ribbon!: Selection;\n\n  protected indicator!: Selection;\n\n  protected get handleOffsetRatio() {\n    return this.ifHorizontal(0.5, 0.5);\n  }\n\n  protected handlesGroup!: Selection;\n\n  protected startHandle?: Handle;\n\n  protected endHandle?: Handle;\n\n  public getBBox(): DOMRect {\n    const { width, height } = this.attributes;\n    return new BBox(0, 0, width, height);\n  }\n\n  public render(attributes: Required<ContinuousStyleProps>, container: Group) {\n    // 渲染顺序\n    // 1. 绘制 title, 获得可用空间\n    // 2. 绘制 label, handle\n    // 3. 基于可用空间、label高度、handle 宽高，计算 ribbon 宽高\n    // 4. 绘制 ribbon\n    // 5. 调整 label、handle 位置\n    const { showLabel } = attributes;\n\n    /** title */\n    this.renderTitle(select(container));\n\n    const { x, y } = this.availableSpace;\n\n    /** label */\n\n    /** content */\n    const contentGroup = select(container)\n      .maybeAppendByClassName(CLASS_NAMES.contentGroup, 'g')\n      .styles({ transform: `translate(${x}, ${y})` });\n\n    const labelGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES.labelGroup, 'g').styles({ zIndex: 1 });\n    ifShow(!!showLabel, labelGroup, (group) => {\n      this.renderLabel(group);\n    });\n\n    const ribbonGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES.ribbonGroup, 'g').styles({ zIndex: 0 });\n\n    /** handle */\n    this.handlesGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES.handlesGroup, 'g').styles({ zIndex: 2 });\n    this.renderHandles();\n\n    /** ribbon */\n    this.renderRibbon(ribbonGroup);\n\n    this.renderIndicator(contentGroup);\n\n    /** adjust */\n    this.adjustLabel();\n    this.adjustHandles();\n    // this.adjustTitle();\n  }\n\n  private get range() {\n    const { data, domain } = this.attributes;\n    return domain ? { min: domain[0], max: domain[1] } : getMinMax(data);\n  }\n\n  private get ribbonScale() {\n    const { min, max } = this.range;\n    this.innerRibbonScale.update({\n      domain: [min, max],\n      range: [0, 1],\n    });\n    return this.innerRibbonScale;\n  }\n\n  private get ribbonRange() {\n    const [min, max] = this.selection;\n    const scale = this.ribbonScale;\n    return [scale.map(min), scale.map(max)];\n  }\n\n  public get selection() {\n    const { min, max } = this.range;\n    const { defaultValue: [start, end] = [min, max] } = this.attributes;\n    return [start, end] as [number, number];\n  }\n\n  protected ifHorizontal<T>(a: T, b: T): T {\n    return ifHorizontal(\n      this.attributes.orientation,\n      typeof a === 'function' ? a() : a,\n      typeof b === 'function' ? b() : b\n    );\n  }\n\n  private renderTitle(container: Selection) {\n    const { showTitle, titleText, width, height } = this.attributes;\n    const style = subStyleProps<TextStyleProps>(this.attributes, 'title');\n    const finalTitleStyle = { ...style, width, height, text: titleText };\n    const that = this;\n    container\n      .selectAll(CLASS_NAMES.title.class)\n      .data(showTitle ? [titleText] : [])\n      .join(\n        (enter) =>\n          enter\n            .append(() => new Title({ style: finalTitleStyle }))\n            .attr('className', CLASS_NAMES.title.name)\n            .each(function () {\n              that.title = this;\n            }),\n        (update) => update.update(finalTitleStyle),\n        (exit) =>\n          exit\n            .each(() => {\n              that.title = undefined;\n            })\n            .remove()\n      );\n  }\n\n  private get availableSpace() {\n    if (this.title) return this.title.getAvailableSpace();\n    const { width, height } = this.attributes;\n    return new BBox(0, 0, width, height);\n  }\n\n  private get labelFixedSpacing() {\n    const { showTick } = this.attributes;\n    return showTick ? 5 : 0;\n  }\n\n  private get labelPosition() {\n    const { orientation, labelDirection } = this.attributes;\n    const positions = {\n      vertical: { positive: 'right', negative: 'left' },\n      horizontal: { positive: 'bottom', negative: 'top' },\n    } as const;\n    return positions[orientation][labelDirection];\n  }\n\n  private cacheLabelBBox: DOMRect | null = null;\n\n  private get labelBBox() {\n    const { showLabel } = this.attributes;\n    if (!showLabel) return new BBox(0, 0, 0, 0);\n    if (this.cacheLabelBBox) return this.cacheLabelBBox;\n    const { width, height } = (\n      this.label.querySelector(AXIS_CLASS_NAMES.labelGroup.class)?.children.slice(-1)[0] as DisplayObject\n    ).getBBox();\n    this.cacheLabelBBox = new BBox(0, 0, width, height);\n    return this.cacheLabelBBox;\n  }\n\n  private get labelShape() {\n    const { showLabel, labelSpacing = 0 } = this.attributes;\n    if (!showLabel) return { width: 0, height: 0, size: 0, length: 0 };\n    const { width, height } = this.labelBBox;\n    const size = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;\n    const length = this.ifHorizontal(width, height);\n    return { width, height, size, length };\n  }\n\n  private get ribbonBBox(): DOMRect {\n    const { showHandle, ribbonSize: userDefinedRibbonSize } = this.attributes;\n    const { width: availableWidth, height: availableHeight } = this.availableSpace;\n\n    const { size: labelSize, length: labelLength } = this.labelShape;\n\n    const [availableSize, availableLength] = this.ifHorizontal(\n      [availableHeight, availableWidth],\n      [availableWidth, availableHeight]\n    );\n    const { size: handleSize, length: handleLength } = showHandle ? this.handleShape : { size: 0, length: 0 };\n    const handleRatio = this.handleOffsetRatio;\n\n    let ribbonSize = 0;\n    const labelPosition = this.labelPosition;\n    if (userDefinedRibbonSize) {\n      ribbonSize = userDefinedRibbonSize;\n    } else if (['bottom', 'right'].includes(labelPosition)) {\n      ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);\n    } else if (availableSize * (1 - handleRatio) > handleSize) {\n      ribbonSize = Math.max(availableSize - labelSize, 0);\n    } else ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);\n\n    const edgeLength = Math.max(handleLength, labelLength);\n    const ribbonLength = availableLength - edgeLength;\n\n    const [width, height] = this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]);\n\n    // 需要考虑 handle 的占用空间\n    // todo 为了防止因为 handle 文本变化导致的 ribbon 位置变化，handle size 取最大值\n    const finalLabelOccupy = ['top', 'left'].includes(labelPosition) ? labelSize : 0;\n\n    const [x, y] = this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]);\n\n    return new BBox(x, y, width, height);\n  }\n\n  private get ribbonShape() {\n    const { width, height } = this.ribbonBBox;\n    return this.ifHorizontal({ size: height, length: width }, { size: width, length: height });\n  }\n\n  private renderRibbon(container: Selection) {\n    const { data, type, orientation, color, block } = this.attributes;\n    const ribbonStyle = subStyleProps(this.attributes, 'ribbon');\n    const { min, max } = this.range;\n    const { x, y } = this.ribbonBBox;\n    const { length, size } = this.ribbonShape;\n    const style: Required<RibbonStyleProps> = deepAssign(\n      {\n        transform: `translate(${x}, ${y})`,\n        length,\n        size,\n        type,\n        orientation,\n        color,\n        block,\n        partition: data.map((d) => (d.value - min) / (max - min)),\n        range: this.ribbonRange,\n      },\n      ribbonStyle\n    );\n\n    this.ribbon = container.maybeAppendByClassName(CLASS_NAMES.ribbon, () => new Ribbon({ style })).update(style);\n  }\n\n  private getHandleClassName(type: HandleType) {\n    // @ts-ignore\n    return `${CLASS_NAMES.prefix(`${type}-handle`)}`;\n  }\n\n  private renderHandles() {\n    const { showHandle, orientation } = this.attributes;\n    const handleStyle = subStyleProps<HandleStyleProps>(this.attributes, 'handle');\n    const [min, max] = this.selection;\n    const style = { ...handleStyle, orientation };\n    const { shape = 'slider' } = handleStyle;\n    const HandleCtor = shape === 'basic' ? Handle : SliderHandle;\n\n    const that = this;\n    this.handlesGroup\n      .selectAll(CLASS_NAMES.handle.class)\n      .data(\n        showHandle\n          ? [\n              { value: min, type: 'start' },\n              { value: max, type: 'end' },\n            ]\n          : [],\n        (d) => d.type\n      )\n      .join(\n        (enter) =>\n          enter\n            .append(() => new HandleCtor({ style }))\n            .attr(\n              'className',\n              ({ type }: any) => `${CLASS_NAMES.handle} ${that.getHandleClassName(type as HandleType)}`\n            )\n            .each(function ({ type, value: labelText }) {\n              this.update({ labelText });\n              const name = `${type}Handle` as `${HandleType}Handle`;\n              that[name] = this;\n              this.addEventListener('pointerdown', that.onDragStart(type));\n            }),\n        (update) =>\n          update.update(style).each(function ({ value: labelText }) {\n            this.update({ labelText });\n          }),\n        (exit) =>\n          exit\n            .each(({ type }) => {\n              const name = `${type}Handle` as `${HandleType}Handle`;\n              that[name] = undefined;\n            })\n            .remove()\n      );\n  }\n\n  private adjustHandles() {\n    const [min, max] = this.selection;\n    this.setHandlePosition('start', min);\n    this.setHandlePosition('end', max);\n  }\n\n  private cacheHandleBBox: DOMRect | null = null;\n\n  private get handleBBox() {\n    if (this.cacheHandleBBox) return this.cacheHandleBBox;\n    if (!this.attributes.showHandle) return new BBox(0, 0, 0, 0);\n    const { width: startHandleWidth, height: startHandleHeight } = this.startHandle!.getBBox();\n    const { width: endHandleWidth, height: endHandleHeight } = this.endHandle!.getBBox();\n    const [width, height] = [Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)];\n    this.cacheHandleBBox = new BBox(0, 0, width, height);\n    return this.cacheHandleBBox;\n  }\n\n  /**\n   *  因为 handle label 的宽高是动态的，所以 handle bbox 是第一次渲染时的 bbox\n   */\n  private get handleShape() {\n    const { width, height } = this.handleBBox;\n    const [size, length] = this.ifHorizontal([height, width], [width, height]);\n    return { width, height, size, length };\n  }\n\n  private setHandlePosition(type: HandleType, value: number) {\n    const { handleFormatter } = this.attributes;\n    const { x: ribbonX, y: ribbonY } = this.ribbonBBox;\n    const { size: ribbonSize } = this.ribbonShape;\n    const offset = this.getOffset(value);\n    const [x, y] = this.ifHorizontal(\n      [ribbonX + offset, ribbonY + ribbonSize * this.handleOffsetRatio],\n      [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset]\n    );\n    const handle: Handle = this.handlesGroup.select(`.${this.getHandleClassName(type)}`).node();\n    handle?.update({ transform: `translate(${x}, ${y})`, formatter: handleFormatter });\n  }\n\n  private renderIndicator(container: Selection) {\n    const style = subStyleProps<IndicatorStyleProps>(this.attributes, 'indicator');\n    this.indicator = container.maybeAppendByClassName(CLASS_NAMES.indicator, () => new Indicator({})).update(style);\n    // this.hideIndicator();\n  }\n\n  private get labelData(): ContinuousDatum[] {\n    const { data } = this.attributes;\n    return data.reduce((acc, curr, index, arr) => {\n      const id = curr?.id ?? index.toString();\n      acc.push({\n        ...curr,\n        id,\n        index,\n        type: 'value',\n        label: curr?.label ?? curr.value.toString(),\n        value: this.ribbonScale.map(curr.value),\n      });\n      if (index < arr.length - 1) {\n        const next = arr[index + 1];\n        const [cr, nx] = [curr.value, next.value];\n        const midVal = (cr + nx) / 2;\n        acc.push({\n          ...curr,\n          id,\n          index,\n          type: 'range',\n          range: [cr, nx],\n          label: [cr, nx].join('~'),\n          value: this.ribbonScale.map(midVal),\n        });\n      }\n      return acc;\n    }, [] as ContinuousDatum[]);\n  }\n\n  private get labelStyle() {\n    let [labelTextAlign, labelTextBaseline] = ['center', 'middle'];\n\n    const labelPosition = this.labelPosition;\n    if (labelPosition === 'top') labelTextBaseline = 'bottom';\n    else if (labelPosition === 'bottom') labelTextBaseline = 'top';\n    else if (labelPosition === 'left') labelTextAlign = 'end';\n    else if (labelPosition === 'right') labelTextAlign = 'start';\n\n    return {\n      labelTextAlign,\n      labelTextBaseline,\n    };\n  }\n\n  private renderLabel(container: Selection) {\n    const { showTick = false, labelFilter, labelFormatter } = this.attributes;\n    const tickStyle = subStyleProps(this.attributes, 'tick');\n    const labelStyle = subStyleProps(this.attributes, 'label');\n    const { align } = labelStyle;\n\n    const style = deepAssign(\n      {\n        showLine: false,\n        showGrid: false,\n        showTick,\n        type: 'linear',\n        startPos: [0, 0],\n        endPos: [0, 0],\n        tickDirection: 'negative',\n        labelTransform: 'rotate(0)',\n        ...this.labelStyle,\n      },\n      superStyleProps(tickStyle, 'tick'),\n      superStyleProps(labelStyle, 'label'),\n      { data: this.labelData }\n    ) as LinearAxisStyleProps;\n\n    const functionStyle = {\n      tickFilter: (datum: ContinuousDatum, index: number, data: ContinuousDatum[]) => {\n        if (datum?.type !== 'value') return false;\n        if (labelFilter)\n          return labelFilter(\n            datum,\n            datum.index,\n            data.filter((d) => d.type !== 'value')\n          );\n        return true;\n      },\n      labelFilter: (datum: ContinuousDatum, index: number, data: ContinuousDatum[]) => {\n        if (datum?.type !== align) return false;\n        if (labelFilter)\n          return labelFilter(\n            datum,\n            datum.index,\n            data.filter((d) => d.type === align)\n          );\n        return true;\n      },\n      labelFormatter,\n    };\n\n    const finalLabelStyle = { ...style, ...functionStyle, labelOverlap: [{ type: 'hide' }] } as LinearAxisStyleProps;\n\n    this.label = container.maybeAppendByClassName(CLASS_NAMES.label, () => new Axis({ style: finalLabelStyle })).node();\n    this.label.update(finalLabelStyle, false);\n  }\n\n  private get labelAxisStyle() {\n    // @ts-ignore\n    const { showTick, labelDirection, labelSpacing, tickLength: definedTickLength } = this.attributes;\n\n    const { size: ribbonSize } = this.ribbonShape;\n    const labelPosition = this.labelPosition;\n    const labelFixedSpacing = this.labelFixedSpacing;\n    let [offset, spacing, tickLength] = [0, 0, 0];\n\n    const internalVal = definedTickLength ?? ribbonSize;\n\n    if (showTick) {\n      tickLength = internalVal;\n      spacing = labelFixedSpacing;\n      if (labelDirection === 'positive') {\n        if (labelPosition === 'right') {\n          offset = internalVal;\n          tickLength = internalVal;\n        } else if (labelPosition === 'bottom') offset = tickLength;\n      } else if (labelDirection === 'negative') {\n        if (labelPosition === 'top') offset = ribbonSize;\n        else if (labelPosition === 'left') offset = ribbonSize;\n      }\n    } else if (labelDirection === 'positive') {\n      if (labelPosition === 'right') spacing = internalVal;\n      else if (labelPosition === 'bottom') {\n        offset = ribbonSize + labelFixedSpacing;\n        spacing = labelSpacing;\n      }\n    } else if (labelDirection === 'negative') {\n      if (labelPosition === 'left') spacing = labelSpacing;\n      else if (labelPosition === 'top') spacing = labelSpacing;\n    }\n\n    return { offset, spacing, tickLength };\n  }\n\n  private adjustLabel() {\n    const { showLabel } = this.attributes as Required<ContinuousStyleProps>;\n    if (!showLabel) return;\n    const { x, y, width, height } = this.ribbonBBox;\n    const { offset: axisOffset, spacing: axisSpacing, tickLength: axisTickLength } = this.labelAxisStyle;\n    const [startPos, endPos]: [[number, number], [number, number]] = this.ifHorizontal(\n      [\n        [x, y + axisOffset],\n        [x + width, y + axisOffset],\n      ],\n      [\n        [x + axisOffset, y + height],\n        [x + axisOffset, y],\n      ]\n    );\n\n    this.label.update(\n      {\n        startPos,\n        endPos,\n        tickLength: axisTickLength,\n        labelSpacing: axisSpacing,\n      },\n      false\n    );\n  }\n\n  /** 当前交互的对象 */\n  private target!: string | undefined;\n\n  /** 上次鼠标事件的位置 */\n  private prevValue!: number;\n\n  public bindEvents() {\n    this.style.cursor = 'pointer';\n    // 绑定 drag 开始事件\n    this.ribbon.on('pointerdown', this.onDragStart('ribbon'));\n    this.ribbon.on('pointermove', this.onHovering);\n    this.addEventListener('pointerout', this.hideIndicator);\n  }\n\n  private onHovering = (e: any) => {\n    const { data, block } = this.attributes;\n    e.stopPropagation();\n    const value = this.getValueByCanvasPoint(e);\n    if (block) {\n      const { range } = getNextTickValue(\n        data.map(({ value }) => value),\n        value\n      );\n\n      const selection = this.getRealSelection(range);\n      this.showIndicator((range[0] + range[1]) / 2, `${selection[0]}-${selection[1]}`);\n      this.dispatchIndicated(value, range);\n    } else {\n      const safetyValue = this.getTickValue(value);\n      this.showIndicator(safetyValue, `${this.getRealValue(safetyValue)}`);\n      this.dispatchIndicated(safetyValue);\n    }\n  };\n\n  public showIndicator(value: number, text = `${value}`) {\n    const { showIndicator } = this.attributes;\n    if (!showIndicator || typeof value !== 'number') {\n      this.hideIndicator();\n      return;\n    }\n    const { min, max } = this.range;\n    const { x, y } = this.ribbonBBox;\n    const safeValue = clamp(value, min, max);\n    const offset = this.getOffset(safeValue);\n    const pos: Point = this.ifHorizontal([offset + x, y], [x, offset + y]);\n\n    this.indicator.update({\n      x: pos[0],\n      y: pos[1],\n      position: this.ifHorizontal('top', 'left'),\n      labelText: text,\n    });\n    show(this.indicator.node());\n  }\n\n  private hideIndicator() {\n    hide(this.indicator.node());\n  }\n\n  private onDragStart = (target: string) => (e: any) => {\n    e.stopPropagation();\n\n    // 关闭滑动\n    if (!this.attributes.slidable) return;\n    this.target = target;\n\n    this.prevValue = this.getTickValue(this.getValueByCanvasPoint(e));\n    document.addEventListener('mousemove', this.onDragging);\n    document.addEventListener('touchmove', this.onDragging);\n    document.addEventListener('mouseleave', this.onDragEnd);\n    document.addEventListener('mouseup', this.onDragEnd);\n    document.addEventListener('mouseup', this.onDragEnd);\n    document.addEventListener('touchend', this.onDragEnd);\n  };\n\n  private onDragging = (e: any) => {\n    const { target } = this;\n    this.updateMouse();\n    const [start, end] = this.selection;\n    const currValue = this.getTickValue(this.getValueByCanvasPoint(e));\n    const diffValue = currValue - this.prevValue;\n\n    if (target === 'start') start !== currValue && this.updateSelection(currValue, end);\n    else if (target === 'end') end !== currValue && this.updateSelection(start, currValue);\n    else if (target === 'ribbon' && diffValue !== 0) {\n      this.prevValue = currValue;\n      this.updateSelection(diffValue, diffValue, true);\n    }\n  };\n\n  private onDragEnd = () => {\n    this.style.cursor = 'pointer';\n    document.removeEventListener('mousemove', this.onDragging);\n    document.removeEventListener('touchmove', this.onDragging);\n    document.removeEventListener('mouseup', this.onDragEnd);\n    document.removeEventListener('touchend', this.onDragEnd);\n  };\n\n  private updateMouse() {\n    if (this.attributes.slidable) this.style.cursor = 'grabbing';\n  }\n\n  public setSelection(start: number, end: number) {\n    this.updateSelection(start, end);\n  }\n\n  private updateSelection(stVal: number, endVal: number, isOffset: boolean = false) {\n    const [currSt, currEnd] = this.selection;\n\n    let [start, end] = [stVal, endVal];\n    if (isOffset) {\n      // 获取当前值\n      start += currSt;\n      end += currEnd;\n    }\n    // 值校验\n    const { min, max } = this.range;\n    [start, end] = getSafetySelections([min, max], [start, end], this.selection);\n    this.update({ defaultValue: [start, end] });\n    this.dispatchSelection();\n  }\n\n  private get step(): number {\n    const { step = 1 } = this.attributes;\n    const { min, max } = this.range;\n    if (isUndefined(step)) return toPrecision((max - min) * STEP_RATIO, 0);\n    return step;\n  }\n\n  private getTickValue(value: number): number {\n    const { data, block } = this.attributes;\n    const { min } = this.range;\n    if (block)\n      return getNextTickValue(\n        data.map(({ value }) => value),\n        value\n      ).tick;\n    return getStepValueByValue(value, this.step, min);\n  }\n\n  /**\n   * 事件触发的位置对应的value值\n   */\n  private getValueByCanvasPoint(e: any) {\n    const { min, max } = this.range;\n    const [x, y] = this.ribbon.node().getPosition();\n    const startPos = this.ifHorizontal(x, y);\n    const currValue = this.ifHorizontal(...getEventPos(e));\n    const offset = currValue - startPos;\n    const value = clamp(this.getOffset(offset, true), min, max);\n    return value;\n  }\n\n  /** reverse: 屏幕偏移量 -> 值 */\n  private getOffset(value: number, reverse = false) {\n    const { min, max } = this.range;\n    const { length: ribbonLen } = this.ribbonShape;\n    const scale = this.eventToOffsetScale;\n    scale.update({ domain: [min, max], range: [0, ribbonLen] });\n    if (reverse) return scale.invert(value);\n    return scale.map(value);\n  }\n\n  private getRealSelection(range: number[]) {\n    const { max } = this.range;\n    const [start, end] = range;\n\n    return this.ifHorizontal([start, end], [max - end, max - start]);\n  }\n\n  private getRealValue(value: number) {\n    const { max } = this.range;\n\n    return this.ifHorizontal(value, max - value);\n  }\n\n  private dispatchSelection() {\n    const selection = this.getRealSelection(this.selection);\n\n    const evt = new CustomEvent('valuechange', {\n      detail: {\n        value: selection,\n      },\n    });\n    this.dispatchEvent(evt as any);\n  }\n\n  private dispatchIndicated(value: number, range?: number[]) {\n    const { max } = this.range;\n\n    const detail = this.ifHorizontal(\n      () => {\n        return {\n          value,\n          range,\n        };\n      },\n      () => {\n        return {\n          value: max - value,\n          range: range ? this.getRealSelection(range) : undefined,\n        };\n      }\n    );\n\n    const evt = new CustomEvent('indicate', {\n      detail,\n    });\n    this.dispatchEvent(evt as any);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}