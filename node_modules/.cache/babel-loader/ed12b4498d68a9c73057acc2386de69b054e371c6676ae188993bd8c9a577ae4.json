{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Image, Path } from '@antv/g';\nimport { isFunction, pick } from '@antv/util';\nimport { getBBoxHeight, getBBoxWidth, getNodeBBox } from '../../utils/bbox';\nimport { getArrowSize, getBadgePositionStyle, getCubicLoopPath, getLabelPositionStyle } from '../../utils/edge';\nimport { findPorts, getConnectionPoint, getPortPosition, isSameNode } from '../../utils/element';\nimport { subStyleProps } from '../../utils/prefix';\nimport { parseSize } from '../../utils/size';\nimport { mergeOptions } from '../../utils/style';\nimport * as Symbol from '../../utils/symbol';\nimport { getWordWrapWidthByEnds } from '../../utils/text';\nimport { BaseElement } from '../base-element';\nimport { Badge, Label } from '../shapes';\n/**\n * <zh/> 边元素基类\n *\n * <en/> Base class of the edge\n */\nexport class BaseEdge extends BaseElement {\n  constructor(options) {\n    super(mergeOptions({\n      style: BaseEdge.defaultStyleProps\n    }, options));\n    this.type = 'edge';\n  }\n  get sourceNode() {\n    const {\n      sourceNode: source\n    } = this.parsedAttributes;\n    return this.context.element.getElement(source);\n  }\n  get targetNode() {\n    const {\n      targetNode: target\n    } = this.parsedAttributes;\n    return this.context.element.getElement(target);\n  }\n  getKeyStyle(attributes) {\n    const _a = this.getGraphicStyle(attributes),\n      {\n        loop\n      } = _a,\n      style = __rest(_a, [\"loop\"]);\n    const {\n      sourceNode,\n      targetNode\n    } = this;\n    const d = loop && isSameNode(sourceNode, targetNode) ? this.getLoopPath(attributes) : this.getKeyPath(attributes);\n    const keyStyle = {\n      d\n    };\n    Path.PARSED_STYLE_LIST.forEach(key => {\n      // @ts-expect-error skip type error\n      if (key in style) keyStyle[key] = style[key];\n    });\n    return keyStyle;\n  }\n  getLoopPath(attributes) {\n    const {\n      sourcePort,\n      targetPort\n    } = attributes;\n    const node = this.sourceNode;\n    const bbox = getNodeBBox(node);\n    const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox));\n    const {\n      placement,\n      clockwise,\n      dist = defaultDist\n    } = subStyleProps(this.getGraphicStyle(attributes), 'loop');\n    return getCubicLoopPath(node, placement, clockwise, dist, sourcePort, targetPort);\n  }\n  getEndpoints(attributes, optimize = true, controlPoints = []) {\n    const {\n      sourcePort: sourcePortKey,\n      targetPort: targetPortKey\n    } = attributes;\n    const {\n      sourceNode,\n      targetNode\n    } = this;\n    const [sourcePort, targetPort] = findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey);\n    if (!optimize) {\n      const sourcePoint = sourcePort ? getPortPosition(sourcePort) : sourceNode.getCenter();\n      const targetPoint = targetPort ? getPortPosition(targetPort) : targetNode.getCenter();\n      return [sourcePoint, targetPoint];\n    }\n    const _controlPoints = typeof controlPoints === 'function' ? controlPoints() : controlPoints;\n    const sourcePoint = getConnectionPoint(sourcePort || sourceNode, _controlPoints[0] || targetPort || targetNode);\n    const targetPoint = getConnectionPoint(targetPort || targetNode, _controlPoints[_controlPoints.length - 1] || sourcePort || sourceNode);\n    return [sourcePoint, targetPoint];\n  }\n  getHaloStyle(attributes) {\n    if (attributes.halo === false) return false;\n    const keyStyle = this.getKeyStyle(attributes);\n    const haloStyle = subStyleProps(this.getGraphicStyle(attributes), 'halo');\n    return Object.assign(Object.assign({}, keyStyle), haloStyle);\n  }\n  getLabelStyle(attributes) {\n    if (attributes.label === false || !attributes.labelText) return false;\n    const labelStyle = subStyleProps(this.getGraphicStyle(attributes), 'label');\n    const {\n        placement,\n        offsetX,\n        offsetY,\n        autoRotate,\n        maxWidth\n      } = labelStyle,\n      restStyle = __rest(labelStyle, [\"placement\", \"offsetX\", \"offsetY\", \"autoRotate\", \"maxWidth\"]);\n    const labelPositionStyle = getLabelPositionStyle(this.shapeMap.key, placement, autoRotate, offsetX, offsetY);\n    const bbox = this.shapeMap.key.getLocalBounds();\n    const wordWrapWidth = getWordWrapWidthByEnds([bbox.min, bbox.max], maxWidth);\n    return Object.assign({\n      wordWrapWidth\n    }, labelPositionStyle, restStyle);\n  }\n  getBadgeStyle(attributes) {\n    if (attributes.badge === false || !attributes.badgeText) return false;\n    const _a = subStyleProps(attributes, 'badge'),\n      {\n        offsetX,\n        offsetY,\n        placement\n      } = _a,\n      badgeStyle = __rest(_a, [\"offsetX\", \"offsetY\", \"placement\"]);\n    return Object.assign(badgeStyle, getBadgePositionStyle(this.shapeMap, placement, attributes.labelPlacement, offsetX, offsetY));\n  }\n  drawArrow(attributes, type) {\n    var _a;\n    const isStart = type === 'start';\n    const arrowType = type === 'start' ? 'startArrow' : 'endArrow';\n    const enable = attributes[arrowType];\n    const keyShape = this.shapeMap.key;\n    if (enable) {\n      const arrowStyle = this.getArrowStyle(attributes, isStart);\n      const [marker, markerOffset, arrowOffset] = isStart ? ['markerStart', 'markerStartOffset', 'startArrowOffset'] : ['markerEnd', 'markerEndOffset', 'endArrowOffset'];\n      const arrow = keyShape.parsedStyle[marker];\n      // update\n      if (arrow) arrow.attr(arrowStyle);\n      // create\n      else {\n        const Ctor = arrowStyle.src ? Image : Path;\n        const arrowShape = new Ctor({\n          style: arrowStyle\n        });\n        keyShape.style[marker] = arrowShape;\n      }\n      keyShape.style[markerOffset] = attributes[arrowOffset] || arrowStyle.width / 2 + +arrowStyle.lineWidth;\n    } else {\n      // destroy\n      const marker = isStart ? 'markerStart' : 'markerEnd';\n      (_a = keyShape.style[marker]) === null || _a === void 0 ? void 0 : _a.destroy();\n      keyShape.style[marker] = null;\n    }\n  }\n  getArrowStyle(attributes, isStart) {\n    const keyStyle = this.getShape('key').attributes;\n    const arrowType = isStart ? 'startArrow' : 'endArrow';\n    const _a = subStyleProps(this.getGraphicStyle(attributes), arrowType),\n      {\n        size,\n        type\n      } = _a,\n      arrowStyle = __rest(_a, [\"size\", \"type\"]);\n    const [width, height] = parseSize(getArrowSize(keyStyle.lineWidth, size));\n    const arrowFn = isFunction(type) ? type : Symbol[type] || Symbol.triangle;\n    const d = arrowFn(width, height);\n    return Object.assign(pick(keyStyle, ['stroke', 'strokeOpacity', 'fillOpacity']), {\n      width,\n      height\n    }, Object.assign({}, d && {\n      d,\n      fill: type === 'simple' ? '' : keyStyle.stroke\n    }), arrowStyle);\n  }\n  drawLabelShape(attributes, container) {\n    const style = this.getLabelStyle(attributes);\n    this.upsert('label', Label, style, container);\n  }\n  drawHaloShape(attributes, container) {\n    const style = this.getHaloStyle(attributes);\n    this.upsert('halo', Path, style, container);\n  }\n  drawBadgeShape(attributes, container) {\n    const style = this.getBadgeStyle(attributes);\n    this.upsert('badge', Badge, style, container);\n  }\n  drawSourceArrow(attributes) {\n    this.drawArrow(attributes, 'start');\n  }\n  drawTargetArrow(attributes) {\n    this.drawArrow(attributes, 'end');\n  }\n  drawKeyShape(attributes, container) {\n    const style = this.getKeyStyle(attributes);\n    return this.upsert('key', Path, style, container);\n  }\n  render(attributes = this.parsedAttributes, container = this) {\n    // 1. key shape\n    this.drawKeyShape(attributes, container);\n    if (!this.getShape('key')) return;\n    // 2. arrows\n    this.drawSourceArrow(attributes);\n    this.drawTargetArrow(attributes);\n    // 3. label\n    this.drawLabelShape(attributes, container);\n    // 4. halo\n    this.drawHaloShape(attributes, container);\n    // 5. badges\n    this.drawBadgeShape(attributes, container);\n  }\n  onframe() {\n    this.drawKeyShape(this.parsedAttributes, this);\n    this.drawSourceArrow(this.parsedAttributes);\n    this.drawTargetArrow(this.parsedAttributes);\n    this.drawHaloShape(this.parsedAttributes, this);\n    this.drawLabelShape(this.parsedAttributes, this);\n    this.drawBadgeShape(this.parsedAttributes, this);\n  }\n  animate(keyframes, options) {\n    const animation = super.animate(keyframes, options);\n    if (!animation) return animation;\n    // 设置 currentTime 时触发更新\n    // Trigger update when setting currentTime\n    return new Proxy(animation, {\n      set: (target, propKey, value) => {\n        // 需要推迟 onframe 调用时机，等待节点位置更新完成\n        // Need to delay the timing of the onframe call, wait for the node position update to complete\n        if (propKey === 'currentTime') Promise.resolve().then(() => this.onframe());\n        return Reflect.set(target, propKey, value);\n      }\n    });\n  }\n}\nBaseEdge.defaultStyleProps = {\n  badge: true,\n  badgeOffsetX: 0,\n  badgeOffsetY: 0,\n  badgePlacement: 'suffix',\n  isBillboard: true,\n  label: true,\n  labelAutoRotate: true,\n  labelIsBillboard: true,\n  labelMaxWidth: '80%',\n  labelOffsetX: 4,\n  labelOffsetY: 0,\n  labelPlacement: 'center',\n  labelTextBaseline: 'middle',\n  labelWordWrap: false,\n  halo: false,\n  haloDroppable: false,\n  haloLineDash: 0,\n  haloLineWidth: 12,\n  haloPointerEvents: 'none',\n  haloStrokeOpacity: 0.25,\n  haloZIndex: -1,\n  loop: true,\n  startArrow: false,\n  startArrowLineDash: 0,\n  startArrowLineJoin: 'round',\n  startArrowLineWidth: 1,\n  startArrowTransformOrigin: 'center',\n  startArrowType: 'vee',\n  endArrow: false,\n  endArrowLineDash: 0,\n  endArrowLineJoin: 'round',\n  endArrowLineWidth: 1,\n  endArrowTransformOrigin: 'center',\n  endArrowType: 'vee',\n  loopPlacement: 'top',\n  loopClockwise: true\n};","map":{"version":3,"names":["Image","Path","isFunction","pick","getBBoxHeight","getBBoxWidth","getNodeBBox","getArrowSize","getBadgePositionStyle","getCubicLoopPath","getLabelPositionStyle","findPorts","getConnectionPoint","getPortPosition","isSameNode","subStyleProps","parseSize","mergeOptions","Symbol","getWordWrapWidthByEnds","BaseElement","Badge","Label","BaseEdge","constructor","options","style","defaultStyleProps","type","sourceNode","source","parsedAttributes","context","element","getElement","targetNode","target","getKeyStyle","attributes","_a","getGraphicStyle","loop","__rest","d","getLoopPath","getKeyPath","keyStyle","PARSED_STYLE_LIST","forEach","key","sourcePort","targetPort","node","bbox","defaultDist","Math","max","placement","clockwise","dist","getEndpoints","optimize","controlPoints","sourcePortKey","targetPortKey","sourcePoint","getCenter","targetPoint","_controlPoints","length","getHaloStyle","halo","haloStyle","Object","assign","getLabelStyle","label","labelText","labelStyle","offsetX","offsetY","autoRotate","maxWidth","restStyle","labelPositionStyle","shapeMap","getLocalBounds","wordWrapWidth","min","getBadgeStyle","badge","badgeText","badgeStyle","labelPlacement","drawArrow","isStart","arrowType","enable","keyShape","arrowStyle","getArrowStyle","marker","markerOffset","arrowOffset","arrow","parsedStyle","attr","Ctor","src","arrowShape","width","lineWidth","destroy","getShape","size","height","arrowFn","triangle","fill","stroke","drawLabelShape","container","upsert","drawHaloShape","drawBadgeShape","drawSourceArrow","drawTargetArrow","drawKeyShape","render","onframe","animate","keyframes","animation","Proxy","set","propKey","value","Promise","resolve","then","Reflect","badgeOffsetX","badgeOffsetY","badgePlacement","isBillboard","labelAutoRotate","labelIsBillboard","labelMaxWidth","labelOffsetX","labelOffsetY","labelTextBaseline","labelWordWrap","haloDroppable","haloLineDash","haloLineWidth","haloPointerEvents","haloStrokeOpacity","haloZIndex","startArrow","startArrowLineDash","startArrowLineJoin","startArrowLineWidth","startArrowTransformOrigin","startArrowType","endArrow","endArrowLineDash","endArrowLineJoin","endArrowLineWidth","endArrowTransformOrigin","endArrowType","loopPlacement","loopClockwise"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/elements/edges/base-edge.ts"],"sourcesContent":["import type { DisplayObject, DisplayObjectConfig, Group, LineStyleProps, PathStyleProps } from '@antv/g';\nimport { Image, Path } from '@antv/g';\nimport type { PathArray } from '@antv/util';\nimport { isFunction, pick } from '@antv/util';\nimport type {\n  Edge,\n  EdgeArrowStyleProps,\n  EdgeBadgeStyleProps,\n  EdgeKey,\n  EdgeLabelStyleProps,\n  ID,\n  Keyframe,\n  LoopStyleProps,\n  Node,\n  Point,\n  Prefix,\n} from '../../types';\nimport { getBBoxHeight, getBBoxWidth, getNodeBBox } from '../../utils/bbox';\nimport { getArrowSize, getBadgePositionStyle, getCubicLoopPath, getLabelPositionStyle } from '../../utils/edge';\nimport { findPorts, getConnectionPoint, getPortPosition, isSameNode } from '../../utils/element';\nimport { subStyleProps } from '../../utils/prefix';\nimport { parseSize } from '../../utils/size';\nimport { mergeOptions } from '../../utils/style';\nimport * as Symbol from '../../utils/symbol';\nimport { getWordWrapWidthByEnds } from '../../utils/text';\nimport { BaseElement } from '../base-element';\nimport type { BadgeStyleProps, BaseShapeStyleProps, LabelStyleProps } from '../shapes';\nimport { Badge, Label } from '../shapes';\n\n/**\n * <zh/> 边的通用样式属性\n *\n * <en/> Base style properties of the edge\n */\nexport interface BaseEdgeStyleProps\n  extends BaseShapeStyleProps,\n    Prefix<'label', EdgeLabelStyleProps>,\n    Prefix<'halo', PathStyleProps>,\n    Prefix<'badge', EdgeBadgeStyleProps>,\n    Prefix<'startArrow', EdgeArrowStyleProps>,\n    Prefix<'endArrow', EdgeArrowStyleProps>,\n    Prefix<'loop', LoopStyleProps> {\n  /**\n   * <zh/> 是否显示边的标签\n   *\n   * <en/> Whether to display the label of the edge\n   * @defaultValue true\n   */\n  label?: boolean;\n  /**\n   * <zh/> 是否启用自环边\n   *\n   * <en/> Whether to enable self-loop edge\n   * @defaultValue true\n   */\n  loop?: boolean;\n  /**\n   * <zh/> 是否显示边的光晕\n   *\n   * <en/> Whether to display the halo of the edge\n   * @defaultValue false\n   */\n  halo?: boolean;\n  /**\n   * <zh/> 是否显示边的徽标\n   *\n   * <en/> Whether to display the badge of the edge\n   * @defaultValue true\n   */\n  badge?: boolean;\n  /**\n   * <zh/> 是否显示边的起始箭头\n   *\n   * <en/> Whether to display the start arrow of the edge\n   * @defaultValue false\n   */\n  startArrow?: boolean;\n  /**\n   * <zh/> 是否显示边的结束箭头\n   *\n   * <en/> Whether to display the end arrow of the edge\n   * @defaultValue false\n   */\n  endArrow?: boolean;\n  /**\n   * <zh/> 起始箭头的偏移量\n   *\n   * <en/> Offset of the start arrow\n   */\n  startArrowOffset?: number;\n  /**\n   * <zh/> 结束箭头的偏移量\n   *\n   * <en/> Offset of the end arrow\n   */\n  endArrowOffset?: number;\n  /**\n   * <zh/> 边的起点 ID\n   *\n   * <en/> The ID of the source node\n   * @remarks\n   * <zh/> 该属性指向物理意义上的起点，由 G6 内部维护，用户无需过多关注。通常情况下，`sourceNode` 与上一级的 `source` 属性一致。但在某些情况下，`sourceNode` 可能会被 G6 内部转换，例如在 Combo 收起时内部节点上的边会自动连接到父 Combo，此时 `sourceNode` 会变更为父 Combo 的 ID。\n   *\n   * <en/> This property concerning the physical origin, maintained internally by G6. In general, `sourceNode` corresponds to the `source` attribute of the parent level. However, in certain cases, such as when a Combo is collapsed and internal nodes are destroyed, corresponding edges will automatically connect to the parent Combo. At this point, `sourceNode` will be changed to the ID of the parent Combo\n   */\n  sourceNode: ID;\n  /**\n   * <zh/> 边的终点 shape\n   *\n   * <en/> The source shape. Represents the start of the edge\n   */\n  targetNode: ID;\n  /**\n   * <zh/> 边起始连接的 port\n   *\n   * <en/> The Port of the source node\n   */\n  sourcePort?: string;\n  /**\n   * <zh/> 边终点连接的 port\n   *\n   * <en/> The Port of the target node\n   */\n  targetPort?: string;\n  /**\n   * <zh/> 在 “起点” 处添加一个标记图形，其中 “起始点” 为边与起始节点的交点\n   *\n   * <en/> Add a marker at the \"start point\", where the \"start point\" is the intersection of the edge and the source node\n   */\n  markerStart?: DisplayObject | null;\n  /**\n   * <zh/> 调整 “起点” 处标记图形的位置，正偏移量向内，负偏移量向外\n   *\n   * <en/> Adjust the position of the marker at the \"start point\", positive offset inward, negative offset outward\n   * @defaultValue 0\n   */\n  markerStartOffset?: number;\n  /**\n   * <zh/> 在 “终点” 处添加一个标记图形，其中 “终点” 为边与终止节点的交点\n   *\n   * <en/> Add a marker at the \"end point\", where the \"end point\" is the intersection of the edge and the target node\n   */\n  markerEnd?: DisplayObject | null;\n  /**\n   * <zh/> 调整 “终点” 处标记图形的位置，正偏移量向内，负偏移量向外\n   *\n   * <en/> Adjust the position of the marker at the \"end point\", positive offset inward, negative offset outward\n   * @defaultValue 0\n   */\n  markerEndOffset?: number;\n  /**\n   * <zh/> 在路径除了 “起点” 和 “终点” 之外的每一个顶点上放置标记图形。在内部实现中，由于我们会把路径中部分命令转换成 C 命令，因此这些顶点实际是三阶贝塞尔曲线的控制点\n   *\n   * <en/> Place a marker on each vertex of the path except for the \"start point\" and \"end point\". In the internal implementation, because we will convert some commands in the path to C commands, these controlPoints are actually the control points of the cubic Bezier curve\n   */\n  markerMid?: DisplayObject | null;\n  /**\n   * <zh/> 3D 场景中生效，始终朝向屏幕，因此线宽不受透视投影影像\n   *\n   * <en/> Effective in 3D scenes, always facing the screen, so the line width is not affected by the perspective projection image\n   * @defaultValue true\n   */\n  isBillboard?: boolean;\n}\n\ntype ParsedBaseEdgeStyleProps = Required<BaseEdgeStyleProps>;\n\n/**\n * <zh/> 边元素基类\n *\n * <en/> Base class of the edge\n */\nexport abstract class BaseEdge extends BaseElement<BaseEdgeStyleProps> implements Edge {\n  public type = 'edge';\n\n  static defaultStyleProps: Partial<BaseEdgeStyleProps> = {\n    badge: true,\n    badgeOffsetX: 0,\n    badgeOffsetY: 0,\n    badgePlacement: 'suffix',\n    isBillboard: true,\n    label: true,\n    labelAutoRotate: true,\n    labelIsBillboard: true,\n    labelMaxWidth: '80%',\n    labelOffsetX: 4,\n    labelOffsetY: 0,\n    labelPlacement: 'center',\n    labelTextBaseline: 'middle',\n    labelWordWrap: false,\n    halo: false,\n    haloDroppable: false,\n    haloLineDash: 0,\n    haloLineWidth: 12,\n    haloPointerEvents: 'none',\n    haloStrokeOpacity: 0.25,\n    haloZIndex: -1,\n    loop: true,\n    startArrow: false,\n    startArrowLineDash: 0,\n    startArrowLineJoin: 'round',\n    startArrowLineWidth: 1,\n    startArrowTransformOrigin: 'center',\n    startArrowType: 'vee',\n    endArrow: false,\n    endArrowLineDash: 0,\n    endArrowLineJoin: 'round',\n    endArrowLineWidth: 1,\n    endArrowTransformOrigin: 'center',\n    endArrowType: 'vee',\n    loopPlacement: 'top',\n    loopClockwise: true,\n  };\n\n  constructor(options: DisplayObjectConfig<BaseEdgeStyleProps>) {\n    super(mergeOptions({ style: BaseEdge.defaultStyleProps }, options));\n  }\n\n  protected get sourceNode() {\n    const { sourceNode: source } = this.parsedAttributes;\n    return this.context.element!.getElement<Node>(source)!;\n  }\n\n  protected get targetNode() {\n    const { targetNode: target } = this.parsedAttributes;\n    return this.context.element!.getElement<Node>(target)!;\n  }\n\n  protected getKeyStyle(attributes: ParsedBaseEdgeStyleProps): PathStyleProps {\n    const { loop, ...style } = this.getGraphicStyle(attributes);\n    const { sourceNode, targetNode } = this;\n\n    const d = loop && isSameNode(sourceNode, targetNode) ? this.getLoopPath(attributes) : this.getKeyPath(attributes);\n\n    const keyStyle: PathStyleProps = { d };\n\n    Path.PARSED_STYLE_LIST.forEach((key) => {\n      // @ts-expect-error skip type error\n      if (key in style) keyStyle[key] = style[key];\n    });\n\n    return keyStyle;\n  }\n\n  protected abstract getKeyPath(attributes: ParsedBaseEdgeStyleProps): PathArray;\n\n  protected getLoopPath(attributes: ParsedBaseEdgeStyleProps): PathArray {\n    const { sourcePort, targetPort } = attributes;\n    const node = this.sourceNode;\n\n    const bbox = getNodeBBox(node);\n    const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox));\n\n    const {\n      placement,\n      clockwise,\n      dist = defaultDist,\n    } = subStyleProps<Required<LoopStyleProps>>(this.getGraphicStyle(attributes), 'loop');\n\n    return getCubicLoopPath(node, placement, clockwise, dist, sourcePort, targetPort);\n  }\n\n  protected getEndpoints(\n    attributes: ParsedBaseEdgeStyleProps,\n    optimize = true,\n    controlPoints: Point[] | (() => Point[]) = [],\n  ): [Point, Point] {\n    const { sourcePort: sourcePortKey, targetPort: targetPortKey } = attributes;\n    const { sourceNode, targetNode } = this;\n\n    const [sourcePort, targetPort] = findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey);\n\n    if (!optimize) {\n      const sourcePoint = sourcePort ? getPortPosition(sourcePort) : sourceNode.getCenter();\n      const targetPoint = targetPort ? getPortPosition(targetPort) : targetNode.getCenter();\n      return [sourcePoint, targetPoint];\n    }\n\n    const _controlPoints = typeof controlPoints === 'function' ? controlPoints() : controlPoints;\n    const sourcePoint = getConnectionPoint(sourcePort || sourceNode, _controlPoints[0] || targetPort || targetNode);\n    const targetPoint = getConnectionPoint(\n      targetPort || targetNode,\n      _controlPoints[_controlPoints.length - 1] || sourcePort || sourceNode,\n    );\n\n    return [sourcePoint, targetPoint];\n  }\n\n  protected getHaloStyle(attributes: ParsedBaseEdgeStyleProps): false | PathStyleProps {\n    if (attributes.halo === false) return false;\n\n    const keyStyle = this.getKeyStyle(attributes);\n    const haloStyle = subStyleProps<LineStyleProps>(this.getGraphicStyle(attributes), 'halo');\n\n    return { ...keyStyle, ...haloStyle };\n  }\n\n  protected getLabelStyle(attributes: ParsedBaseEdgeStyleProps): false | LabelStyleProps {\n    if (attributes.label === false || !attributes.labelText) return false;\n\n    const labelStyle = subStyleProps<Required<EdgeLabelStyleProps>>(this.getGraphicStyle(attributes), 'label');\n    const { placement, offsetX, offsetY, autoRotate, maxWidth, ...restStyle } = labelStyle;\n    const labelPositionStyle = getLabelPositionStyle(\n      this.shapeMap.key as EdgeKey,\n      placement,\n      autoRotate,\n      offsetX,\n      offsetY,\n    );\n\n    const bbox = this.shapeMap.key.getLocalBounds();\n    const wordWrapWidth = getWordWrapWidthByEnds([bbox.min, bbox.max], maxWidth);\n\n    return Object.assign({ wordWrapWidth }, labelPositionStyle, restStyle);\n  }\n\n  protected getBadgeStyle(attributes: ParsedBaseEdgeStyleProps): false | BadgeStyleProps {\n    if (attributes.badge === false || !attributes.badgeText) return false;\n\n    const { offsetX, offsetY, placement, ...badgeStyle } = subStyleProps<Required<EdgeBadgeStyleProps>>(\n      attributes,\n      'badge',\n    );\n\n    return Object.assign(\n      badgeStyle,\n      getBadgePositionStyle(this.shapeMap, placement, attributes.labelPlacement, offsetX, offsetY),\n    );\n  }\n\n  protected drawArrow(attributes: ParsedBaseEdgeStyleProps, type: 'start' | 'end') {\n    const isStart = type === 'start';\n    const arrowType = type === 'start' ? 'startArrow' : 'endArrow';\n    const enable = attributes[arrowType];\n\n    const keyShape = this.shapeMap.key as Path;\n\n    if (enable) {\n      const arrowStyle = this.getArrowStyle(attributes, isStart);\n\n      const [marker, markerOffset, arrowOffset] = isStart\n        ? (['markerStart', 'markerStartOffset', 'startArrowOffset'] as const)\n        : (['markerEnd', 'markerEndOffset', 'endArrowOffset'] as const);\n\n      const arrow = keyShape.parsedStyle[marker];\n      // update\n      if (arrow) arrow.attr(arrowStyle);\n      // create\n      else {\n        const Ctor = arrowStyle.src ? Image : Path;\n        const arrowShape = new Ctor({ style: arrowStyle });\n        keyShape.style[marker] = arrowShape;\n      }\n      keyShape.style[markerOffset] = attributes[arrowOffset] || arrowStyle.width / 2 + +arrowStyle.lineWidth;\n    } else {\n      // destroy\n      const marker = isStart ? 'markerStart' : 'markerEnd';\n      keyShape.style[marker]?.destroy();\n      keyShape.style[marker] = null;\n    }\n  }\n\n  private getArrowStyle(attributes: ParsedBaseEdgeStyleProps, isStart: boolean) {\n    const keyStyle = this.getShape('key')!.attributes;\n    const arrowType = isStart ? 'startArrow' : 'endArrow';\n    const { size, type, ...arrowStyle } = subStyleProps<Required<EdgeArrowStyleProps>>(\n      this.getGraphicStyle(attributes),\n      arrowType,\n    );\n    const [width, height] = parseSize(getArrowSize(keyStyle.lineWidth, size));\n    const arrowFn = isFunction(type) ? type : Symbol[type] || Symbol.triangle;\n    const d = arrowFn(width, height);\n\n    return Object.assign(\n      pick(keyStyle, ['stroke', 'strokeOpacity', 'fillOpacity']),\n      { width, height },\n      { ...(d && { d, fill: type === 'simple' ? '' : keyStyle.stroke }) },\n      arrowStyle,\n    );\n  }\n\n  protected drawLabelShape(attributes: ParsedBaseEdgeStyleProps, container: Group) {\n    const style = this.getLabelStyle(attributes);\n    this.upsert('label', Label, style, container);\n  }\n\n  protected drawHaloShape(attributes: ParsedBaseEdgeStyleProps, container: Group) {\n    const style = this.getHaloStyle(attributes);\n    this.upsert('halo', Path, style, container);\n  }\n\n  protected drawBadgeShape(attributes: ParsedBaseEdgeStyleProps, container: Group) {\n    const style = this.getBadgeStyle(attributes);\n    this.upsert('badge', Badge, style, container);\n  }\n\n  protected drawSourceArrow(attributes: ParsedBaseEdgeStyleProps) {\n    this.drawArrow(attributes, 'start');\n  }\n\n  protected drawTargetArrow(attributes: ParsedBaseEdgeStyleProps) {\n    this.drawArrow(attributes, 'end');\n  }\n\n  protected drawKeyShape(attributes: ParsedBaseEdgeStyleProps, container: Group): Path | undefined {\n    const style = this.getKeyStyle(attributes);\n    return this.upsert('key', Path, style, container);\n  }\n\n  public render(attributes = this.parsedAttributes, container: Group = this): void {\n    // 1. key shape\n    this.drawKeyShape(attributes, container);\n    if (!this.getShape('key')) return;\n\n    // 2. arrows\n    this.drawSourceArrow(attributes);\n    this.drawTargetArrow(attributes);\n\n    // 3. label\n    this.drawLabelShape(attributes, container);\n\n    // 4. halo\n    this.drawHaloShape(attributes, container);\n\n    // 5. badges\n    this.drawBadgeShape(attributes, container);\n  }\n\n  protected onframe() {\n    this.drawKeyShape(this.parsedAttributes, this);\n    this.drawSourceArrow(this.parsedAttributes);\n    this.drawTargetArrow(this.parsedAttributes);\n    this.drawHaloShape(this.parsedAttributes, this);\n    this.drawLabelShape(this.parsedAttributes, this);\n    this.drawBadgeShape(this.parsedAttributes, this);\n  }\n\n  public animate(keyframes: Keyframe[], options?: number | KeyframeAnimationOptions) {\n    const animation = super.animate(keyframes, options);\n\n    if (!animation) return animation;\n\n    // 设置 currentTime 时触发更新\n    // Trigger update when setting currentTime\n    return new Proxy(animation, {\n      set: (target, propKey, value) => {\n        // 需要推迟 onframe 调用时机，等待节点位置更新完成\n        // Need to delay the timing of the onframe call, wait for the node position update to complete\n        if (propKey === 'currentTime') Promise.resolve().then(() => this.onframe());\n        return Reflect.set(target, propKey, value);\n      },\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}