{"ast":null,"code":"import { Graph } from '@antv/graphlib';\nimport { minBy } from '../util';\nimport { slack } from './util';\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nconst feasibleTree = g => {\n  const t = new Graph({\n    tree: []\n  });\n  // Choose arbitrary node from which to start our tree\n  const start = g.getAllNodes()[0];\n  const size = g.getAllNodes().length;\n  t.addNode(start);\n  let edge;\n  let delta;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.source) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n  return t;\n};\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nconst tightTree = (t, g) => {\n  const dfs = v => {\n    g.getRelatedEdges(v, 'both').forEach(e => {\n      const edgeV = e.source;\n      const w = v === edgeV ? e.target : edgeV;\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.addNode({\n          id: w,\n          data: {}\n        });\n        t.addEdge({\n          id: e.id,\n          source: v,\n          target: w,\n          data: {}\n        });\n        dfs(w);\n      }\n    });\n  };\n  t.getAllNodes().forEach(n => dfs(n.id));\n  return t.getAllNodes().length;\n};\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nconst feasibleTreeWithLayer = g => {\n  const t = new Graph({\n    tree: []\n  });\n  // Choose arbitrary node from which to start our tree\n  const start = g.getAllNodes()[0];\n  const size = g.getAllNodes().length;\n  t.addNode(start);\n  let edge;\n  let delta;\n  while (tightTreeWithLayer(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.source) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n  return t;\n};\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nconst tightTreeWithLayer = (t, g) => {\n  const dfs = v => {\n    var _a;\n    (_a = g.getRelatedEdges(v, 'both')) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      const edgeV = e.source;\n      const w = v === edgeV ? e.target : edgeV;\n      // 对于指定layer的，直接加入tight-tree，不参与调整\n      if (!t.hasNode(w) && (g.getNode(w).data.layer !== undefined || !slack(g, e))) {\n        t.addNode({\n          id: w,\n          data: {}\n        });\n        t.addEdge({\n          id: e.id,\n          source: v,\n          target: w,\n          data: {}\n        });\n        dfs(w);\n      }\n    });\n  };\n  t.getAllNodes().forEach(n => dfs(n.id));\n  return t.getAllNodes().length;\n};\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nconst findMinSlackEdge = (t, g) => {\n  return minBy(g.getAllEdges(), e => {\n    if (t.hasNode(e.source) !== t.hasNode(e.target)) {\n      return slack(g, e);\n    }\n    return Infinity;\n  });\n};\nconst shiftRanks = (t, g, delta) => {\n  t.getAllNodes().forEach(tn => {\n    const v = g.getNode(tn.id);\n    if (!v.data.rank) v.data.rank = 0;\n    v.data.rank += delta;\n  });\n};\nexport { feasibleTree, feasibleTreeWithLayer };","map":{"version":3,"names":["Graph","minBy","slack","feasibleTree","g","t","tree","start","getAllNodes","size","length","addNode","edge","delta","tightTree","findMinSlackEdge","hasNode","source","shiftRanks","dfs","v","getRelatedEdges","forEach","e","edgeV","w","target","id","data","addEdge","n","feasibleTreeWithLayer","tightTreeWithLayer","_a","getNode","layer","undefined","getAllEdges","Infinity","tn","rank"],"sources":["../../../src/antv-dagre/rank/feasible-tree.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}