{"ast":null,"code":"import { findShortestPath, pageRank } from '@antv/algorithm';\nimport { idOf } from './id';\nexport const getNodeCentralities = (graphData, getRelatedEdgesData, centrality) => {\n  var _a;\n  switch (centrality.type) {\n    case 'degree':\n      {\n        const centralityResult = new Map();\n        (_a = graphData.nodes) === null || _a === void 0 ? void 0 : _a.forEach(node => {\n          const degree = getRelatedEdgesData(idOf(node), centrality.direction).length;\n          centralityResult.set(idOf(node), degree);\n        });\n        return centralityResult;\n      }\n    case 'betweenness':\n      return computeNodeBetweennessCentrality(graphData, centrality.directed, centrality.weightPropertyName);\n    case 'closeness':\n      return computeNodeClosenessCentrality(graphData, centrality.directed, centrality.weightPropertyName);\n    case 'eigenvector':\n      return computeNodeEigenvectorCentrality(graphData, centrality.directed);\n    case 'pagerank':\n      return computeNodePageRankCentrality(graphData, centrality.epsilon, centrality.linkProb);\n    default:\n      return initCentralityResult(graphData);\n  }\n};\nexport const initCentralityResult = graphData => {\n  var _a;\n  const centralityResult = new Map();\n  (_a = graphData.nodes) === null || _a === void 0 ? void 0 : _a.forEach(node => {\n    centralityResult.set(idOf(node), 0);\n  });\n  return centralityResult;\n};\n/**\n * <zh/> 计算图中每个节点的中介中心性\n *\n * <en/> Calculate the betweenness centrality for each node in the graph\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param directed - <zh/> 是否为有向图 | <en/>Whether the graph is directed\n * @param weightPropertyName - <zh/> 边的权重属性名 | <en/>The weight property name of the edge\n * @returns <zh/> 每个节点的中介中心性值 | <en/>The betweenness centrality for each node\n */\nexport const computeNodeBetweennessCentrality = (graphData, directed, weightPropertyName) => {\n  const centralityResult = initCentralityResult(graphData);\n  const {\n    nodes = []\n  } = graphData;\n  nodes.forEach(source => {\n    nodes.forEach(target => {\n      if (source !== target) {\n        const {\n          allPath\n        } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);\n        const pathCount = allPath.length;\n        allPath.flat().forEach(nodeId => {\n          if (nodeId !== idOf(source) && nodeId !== idOf(target)) {\n            centralityResult.set(nodeId, centralityResult.get(nodeId) + 1 / pathCount);\n          }\n        });\n      }\n    });\n  });\n  return centralityResult;\n};\n/**\n * <zh/> 计算图中每个节点的接近中心性\n *\n * <en/> Calculate the closeness centrality for each node in the graph\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param directed - <zh/> 是否为有向图 | <en/>Whether the graph is directed\n * @param weightPropertyName - <zh/> 边的权重属性名 | <en/>The weight property name of the edge\n * @returns <zh/> 每个节点的接近中心性值 | <en/>The closeness centrality for each node\n */\nexport const computeNodeClosenessCentrality = (graphData, directed, weightPropertyName) => {\n  const centralityResult = new Map();\n  const {\n    nodes = []\n  } = graphData;\n  nodes.forEach(source => {\n    const totalLength = nodes.reduce((acc, target) => {\n      if (source !== target) {\n        const {\n          length\n        } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);\n        acc += length;\n      }\n      return acc;\n    }, 0);\n    centralityResult.set(idOf(source), 1 / totalLength);\n  });\n  return centralityResult;\n};\n/**\n * <zh/> 计算图中每个节点的 PageRank 中心性\n *\n * <en/> Calculate the PageRank centrality for each node in the graph\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param epsilon - <zh/> PageRank 算法的收敛容差 | <en/>The convergence tolerance of the PageRank algorithm\n * @param linkProb - <zh/> PageRank 算法的阻尼系数，指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85 | <en/>The damping factor of the PageRank algorithm, which refers to the probability that a user will continue to visit the next node linked to a node at any time, with an empirical value of 0.85\n * @returns <zh/> 每个节点的 PageRank 中心性值 | <en/>The PageRank centrality for each node\n */\nexport const computeNodePageRankCentrality = (graphData, epsilon, linkProb) => {\n  var _a;\n  const centralityResult = new Map();\n  const data = pageRank(graphData, epsilon, linkProb);\n  (_a = graphData.nodes) === null || _a === void 0 ? void 0 : _a.forEach(node => {\n    centralityResult.set(idOf(node), data[idOf(node)]);\n  });\n  return centralityResult;\n};\n/**\n * <zh/> 计算图中每个节点的特征向量中心性\n *\n * <en/> Calculate the eigenvector centrality for each node in the graph.\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param directed - <zh/> 是否为有向图 | <en/>Whether the graph is directed\n * @returns 每个节点的特征向量中心性值 The eigenvector centrality for each node.\n */\nexport const computeNodeEigenvectorCentrality = (graphData, directed) => {\n  const {\n    nodes = []\n  } = graphData;\n  const adjacencyMatrix = createAdjacencyMatrix(graphData, directed);\n  const eigenvector = powerIteration(adjacencyMatrix, nodes.length);\n  const centralityResult = new Map();\n  nodes.forEach((node, index) => {\n    centralityResult.set(idOf(node), eigenvector[index]);\n  });\n  return centralityResult;\n};\n/**\n * <zh/> 创建图的邻接矩阵\n *\n * <en/> Create the adjacency matrix for the graph.\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param directed - <zh/> 是否为有向图 | <en/>Whether the graph is directed\n * @returns <zh/> 邻接矩阵 | <en/>The adjacency matrix\n */\nexport const createAdjacencyMatrix = (graphData, directed) => {\n  const {\n    nodes = [],\n    edges = []\n  } = graphData;\n  const matrix = Array(nodes.length).fill(null).map(() => Array(nodes.length).fill(0));\n  edges.forEach(({\n    source,\n    target\n  }) => {\n    const uIndex = nodes.findIndex(node => idOf(node) === source);\n    const vIndex = nodes.findIndex(node => idOf(node) === target);\n    if (directed) {\n      matrix[uIndex][vIndex] = 1;\n    } else {\n      matrix[uIndex][vIndex] = 1;\n      matrix[vIndex][uIndex] = 1;\n    }\n  });\n  return matrix;\n};\n/**\n * <zh/> 使用幂迭代法计算主特征向量\n *\n * <en/> Calculate the principal eigenvector using the power iteration method\n * @see https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors\n * @param matrix - <zh/> 邻接矩阵 | <en/> The adjacency matrix\n * @param numNodes - <zh/> 节点数量 | <en/> The number of nodes\n * @param maxIterations - <zh/> 最大迭代次数 | <en/> The maximum number of iterations\n * @param tolerance - <zh/> 收敛容差 | <en/> The convergence tolerance\n * @returns <zh/> 主特征向量 | <en/> The principal eigenvector\n */\nconst powerIteration = (matrix, numNodes, maxIterations = 100, tolerance = 1e-6) => {\n  let eigenvector = Array(numNodes).fill(1);\n  let diff = Infinity;\n  for (let iter = 0; iter < maxIterations && diff > tolerance; iter++) {\n    const newEigenvector = Array(numNodes).fill(0);\n    for (let i = 0; i < numNodes; i++) {\n      for (let j = 0; j < numNodes; j++) {\n        newEigenvector[i] += matrix[i][j] * eigenvector[j];\n      }\n    }\n    const norm = Math.sqrt(newEigenvector.reduce((sum, val) => sum + val * val, 0));\n    for (let i = 0; i < numNodes; i++) {\n      newEigenvector[i] /= norm;\n    }\n    diff = Math.sqrt(newEigenvector.reduce((sum, val, index) => sum + (val - eigenvector[index]) * val, 0));\n    eigenvector = newEigenvector;\n  }\n  return eigenvector;\n};","map":{"version":3,"names":["findShortestPath","pageRank","idOf","getNodeCentralities","graphData","getRelatedEdgesData","centrality","type","centralityResult","Map","_a","nodes","forEach","node","degree","direction","length","set","computeNodeBetweennessCentrality","directed","weightPropertyName","computeNodeClosenessCentrality","computeNodeEigenvectorCentrality","computeNodePageRankCentrality","epsilon","linkProb","initCentralityResult","source","target","allPath","pathCount","flat","nodeId","get","totalLength","reduce","acc","data","adjacencyMatrix","createAdjacencyMatrix","eigenvector","powerIteration","index","edges","matrix","Array","fill","map","uIndex","findIndex","vIndex","numNodes","maxIterations","tolerance","diff","Infinity","iter","newEigenvector","i","j","norm","Math","sqrt","sum","val"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/centrality.ts"],"sourcesContent":["import { findShortestPath, pageRank } from '@antv/algorithm';\nimport type { EdgeData, GraphData } from '../spec';\nimport type { EdgeDirection, ID, NodeCentralityOptions } from '../types';\nimport { idOf } from './id';\n\nexport type CentralityResult = Map<ID, number>;\n\nexport const getNodeCentralities = (\n  graphData: GraphData,\n  getRelatedEdgesData: (id: ID, direction?: EdgeDirection) => EdgeData[],\n  centrality: NodeCentralityOptions,\n) => {\n  switch (centrality.type) {\n    case 'degree': {\n      const centralityResult = new Map<ID, number>();\n      graphData.nodes?.forEach((node) => {\n        const degree = getRelatedEdgesData(idOf(node), centrality.direction).length;\n        centralityResult.set(idOf(node), degree);\n      });\n      return centralityResult;\n    }\n    case 'betweenness':\n      return computeNodeBetweennessCentrality(graphData, centrality.directed, centrality.weightPropertyName);\n    case 'closeness':\n      return computeNodeClosenessCentrality(graphData, centrality.directed, centrality.weightPropertyName);\n    case 'eigenvector':\n      return computeNodeEigenvectorCentrality(graphData, centrality.directed);\n    case 'pagerank':\n      return computeNodePageRankCentrality(graphData, centrality.epsilon, centrality.linkProb);\n    default:\n      return initCentralityResult(graphData);\n  }\n};\n\nexport const initCentralityResult = (graphData: GraphData): CentralityResult => {\n  const centralityResult = new Map<ID, number>();\n  graphData.nodes?.forEach((node) => {\n    centralityResult.set(idOf(node), 0);\n  });\n  return centralityResult;\n};\n\n/**\n * <zh/> 计算图中每个节点的中介中心性\n *\n * <en/> Calculate the betweenness centrality for each node in the graph\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param directed - <zh/> 是否为有向图 | <en/>Whether the graph is directed\n * @param weightPropertyName - <zh/> 边的权重属性名 | <en/>The weight property name of the edge\n * @returns <zh/> 每个节点的中介中心性值 | <en/>The betweenness centrality for each node\n */\nexport const computeNodeBetweennessCentrality = (\n  graphData: GraphData,\n  directed?: boolean,\n  weightPropertyName?: string,\n): CentralityResult => {\n  const centralityResult = initCentralityResult(graphData);\n  const { nodes = [] } = graphData;\n  nodes.forEach((source) => {\n    nodes.forEach((target) => {\n      if (source !== target) {\n        const { allPath } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);\n        const pathCount = allPath.length;\n        (allPath as ID[][]).flat().forEach((nodeId) => {\n          if (nodeId !== idOf(source) && nodeId !== idOf(target)) {\n            centralityResult.set(nodeId, centralityResult.get(nodeId)! + 1 / pathCount);\n          }\n        });\n      }\n    });\n  });\n  return centralityResult;\n};\n\n/**\n * <zh/> 计算图中每个节点的接近中心性\n *\n * <en/> Calculate the closeness centrality for each node in the graph\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param directed - <zh/> 是否为有向图 | <en/>Whether the graph is directed\n * @param weightPropertyName - <zh/> 边的权重属性名 | <en/>The weight property name of the edge\n * @returns <zh/> 每个节点的接近中心性值 | <en/>The closeness centrality for each node\n */\nexport const computeNodeClosenessCentrality = (\n  graphData: GraphData,\n  directed?: boolean,\n  weightPropertyName?: string,\n): CentralityResult => {\n  const centralityResult = new Map<ID, number>();\n  const { nodes = [] } = graphData;\n  nodes.forEach((source) => {\n    const totalLength = nodes.reduce((acc, target) => {\n      if (source !== target) {\n        const { length } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);\n        acc += length;\n      }\n      return acc;\n    }, 0);\n    centralityResult.set(idOf(source), 1 / totalLength);\n  });\n  return centralityResult;\n};\n\n/**\n * <zh/> 计算图中每个节点的 PageRank 中心性\n *\n * <en/> Calculate the PageRank centrality for each node in the graph\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param epsilon - <zh/> PageRank 算法的收敛容差 | <en/>The convergence tolerance of the PageRank algorithm\n * @param linkProb - <zh/> PageRank 算法的阻尼系数，指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85 | <en/>The damping factor of the PageRank algorithm, which refers to the probability that a user will continue to visit the next node linked to a node at any time, with an empirical value of 0.85\n * @returns <zh/> 每个节点的 PageRank 中心性值 | <en/>The PageRank centrality for each node\n */\nexport const computeNodePageRankCentrality = (\n  graphData: GraphData,\n  epsilon?: number,\n  linkProb?: number,\n): CentralityResult => {\n  const centralityResult = new Map<ID, number>();\n  const data = pageRank(graphData, epsilon, linkProb);\n  graphData.nodes?.forEach((node) => {\n    centralityResult.set(idOf(node), data[idOf(node)]);\n  });\n  return centralityResult;\n};\n\n/**\n * <zh/> 计算图中每个节点的特征向量中心性\n *\n * <en/> Calculate the eigenvector centrality for each node in the graph.\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param directed - <zh/> 是否为有向图 | <en/>Whether the graph is directed\n * @returns 每个节点的特征向量中心性值 The eigenvector centrality for each node.\n */\nexport const computeNodeEigenvectorCentrality = (graphData: GraphData, directed?: boolean): CentralityResult => {\n  const { nodes = [] } = graphData;\n  const adjacencyMatrix = createAdjacencyMatrix(graphData, directed);\n  const eigenvector = powerIteration(adjacencyMatrix, nodes.length);\n\n  const centralityResult = new Map<ID, number>();\n  nodes.forEach((node, index) => {\n    centralityResult.set(idOf(node), eigenvector[index]);\n  });\n\n  return centralityResult;\n};\n\n/**\n * <zh/> 创建图的邻接矩阵\n *\n * <en/> Create the adjacency matrix for the graph.\n * @param graphData - <zh/> 图数据 | <en/>Graph data\n * @param directed - <zh/> 是否为有向图 | <en/>Whether the graph is directed\n * @returns <zh/> 邻接矩阵 | <en/>The adjacency matrix\n */\nexport const createAdjacencyMatrix = (graphData: GraphData, directed?: boolean): number[][] => {\n  const { nodes = [], edges = [] } = graphData;\n  const matrix: number[][] = Array(nodes.length)\n    .fill(null)\n    .map(() => Array(nodes.length).fill(0));\n\n  edges.forEach(({ source, target }) => {\n    const uIndex = nodes.findIndex((node) => idOf(node) === source);\n    const vIndex = nodes.findIndex((node) => idOf(node) === target);\n    if (directed) {\n      matrix[uIndex][vIndex] = 1;\n    } else {\n      matrix[uIndex][vIndex] = 1;\n      matrix[vIndex][uIndex] = 1;\n    }\n  });\n\n  return matrix;\n};\n\n/**\n * <zh/> 使用幂迭代法计算主特征向量\n *\n * <en/> Calculate the principal eigenvector using the power iteration method\n * @see https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors\n * @param matrix - <zh/> 邻接矩阵 | <en/> The adjacency matrix\n * @param numNodes - <zh/> 节点数量 | <en/> The number of nodes\n * @param maxIterations - <zh/> 最大迭代次数 | <en/> The maximum number of iterations\n * @param tolerance - <zh/> 收敛容差 | <en/> The convergence tolerance\n * @returns <zh/> 主特征向量 | <en/> The principal eigenvector\n */\nconst powerIteration = (matrix: number[][], numNodes: number, maxIterations = 100, tolerance = 1e-6): number[] => {\n  let eigenvector = Array(numNodes).fill(1);\n  let diff = Infinity;\n\n  for (let iter = 0; iter < maxIterations && diff > tolerance; iter++) {\n    const newEigenvector = Array(numNodes).fill(0);\n\n    for (let i = 0; i < numNodes; i++) {\n      for (let j = 0; j < numNodes; j++) {\n        newEigenvector[i] += matrix[i][j] * eigenvector[j];\n      }\n    }\n\n    const norm = Math.sqrt(newEigenvector.reduce((sum, val) => sum + val * val, 0));\n    for (let i = 0; i < numNodes; i++) {\n      newEigenvector[i] /= norm;\n    }\n\n    diff = Math.sqrt(newEigenvector.reduce((sum, val, index) => sum + (val - eigenvector[index]) * val, 0));\n    eigenvector = newEigenvector;\n  }\n\n  return eigenvector;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}