{"ast":null,"code":"import { normalizePath } from '../process/normalize-path';\nimport { segmentLineFactory } from './segment-line-factory';\nimport { segmentArcFactory } from './segment-arc-factory';\nimport { segmentCubicFactory } from './segment-cubic-factory';\nimport { segmentQuadFactory } from './segment-quad-factory';\n/**\n * Returns a {x,y} point at a given length\n * of a shape, the shape total length and\n * the shape minimum and maximum {x,y} coordinates.\n */\nexport function pathLengthFactory(pathInput, distance, options) {\n  var _a, _b, _c, _d, _e, _f;\n  var path = normalizePath(pathInput);\n  var distanceIsNumber = typeof distance === 'number';\n  var isM;\n  var data = [];\n  var pathCommand;\n  var x = 0;\n  var y = 0;\n  var mx = 0;\n  var my = 0;\n  var seg;\n  var MIN = [];\n  var MAX = [];\n  var length = 0;\n  var min = {\n    x: 0,\n    y: 0\n  };\n  var max = min;\n  var point = min;\n  var POINT = min;\n  var LENGTH = 0;\n  for (var i = 0, ll = path.length; i < ll; i += 1) {\n    seg = path[i];\n    pathCommand = seg[0];\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y].concat(seg.slice(1)) : data;\n    // this segment is always ZERO\n    /* istanbul ignore else */\n    if (isM) {\n      // remember mx, my for Z\n      mx = seg[1], my = seg[2];\n      min = {\n        x: mx,\n        y: my\n      };\n      max = min;\n      length = 0;\n      if (distanceIsNumber && distance < 0.001) {\n        POINT = min;\n      }\n    } else if (pathCommand === 'L') {\n      _a = segmentLineFactory(data[0], data[1], data[2], data[3], (distance || 0) - LENGTH), length = _a.length, min = _a.min, max = _a.max, point = _a.point;\n    } else if (pathCommand === 'A') {\n      _b = segmentArcFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], (distance || 0) - LENGTH, options || {}), length = _b.length, min = _b.min, max = _b.max, point = _b.point;\n    } else if (pathCommand === 'C') {\n      _c = segmentCubicFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], (distance || 0) - LENGTH, options || {}), length = _c.length, min = _c.min, max = _c.max, point = _c.point;\n    } else if (pathCommand === 'Q') {\n      _d = segmentQuadFactory(data[0], data[1], data[2], data[3], data[4], data[5], (distance || 0) - LENGTH, options || {}), length = _d.length, min = _d.min, max = _d.max, point = _d.point;\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      _e = segmentLineFactory(data[0], data[1], data[2], data[3], (distance || 0) - LENGTH), length = _e.length, min = _e.min, max = _e.max, point = _e.point;\n    }\n    if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {\n      POINT = point;\n    }\n    MAX.push(max);\n    MIN.push(min);\n    LENGTH += length;\n    _f = pathCommand !== 'Z' ? seg.slice(-2) : [mx, my], x = _f[0], y = _f[1];\n  }\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = {\n      x: x,\n      y: y\n    };\n  }\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min.apply(null, MIN.map(function (n) {\n        return n.x;\n      })),\n      y: Math.min.apply(null, MIN.map(function (n) {\n        return n.y;\n      }))\n    },\n    max: {\n      x: Math.max.apply(null, MAX.map(function (n) {\n        return n.x;\n      })),\n      y: Math.max.apply(null, MAX.map(function (n) {\n        return n.y;\n      }))\n    }\n  };\n}","map":{"version":3,"names":["normalizePath","segmentLineFactory","segmentArcFactory","segmentCubicFactory","segmentQuadFactory","pathLengthFactory","pathInput","distance","options","path","distanceIsNumber","isM","data","pathCommand","x","y","mx","my","seg","MIN","MAX","length","min","max","point","POINT","LENGTH","i","ll","concat","slice","_a","_b","_c","_d","_e","push","_f","Math","apply","map","n"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/util/src/path/util/path-length-factory.ts"],"sourcesContent":["import { normalizePath } from '../process/normalize-path';\nimport type { PathCommand, PathArray, LengthFactory, PathLengthFactoryOptions } from '../types';\nimport { segmentLineFactory } from './segment-line-factory';\nimport { segmentArcFactory } from './segment-arc-factory';\nimport { segmentCubicFactory } from './segment-cubic-factory';\nimport { segmentQuadFactory } from './segment-quad-factory';\n\n/**\n * Returns a {x,y} point at a given length\n * of a shape, the shape total length and\n * the shape minimum and maximum {x,y} coordinates.\n */\nexport function pathLengthFactory(\n  pathInput: string | PathArray,\n  distance?: number,\n  options?: Partial<PathLengthFactoryOptions>,\n): LengthFactory {\n  const path = normalizePath(pathInput);\n  const distanceIsNumber = typeof distance === 'number';\n  let isM: boolean;\n  let data: number[] = [];\n  let pathCommand: PathCommand;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let seg;\n  const MIN = [];\n  const MAX = [];\n  let length = 0;\n  let min = { x: 0, y: 0 };\n  let max = min;\n  let point = min;\n  let POINT = min;\n  let LENGTH = 0;\n\n  for (let i = 0, ll = path.length; i < ll; i += 1) {\n    seg = path[i];\n    [pathCommand] = seg;\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y].concat(seg.slice(1)) : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg;\n      min = { x: mx, y: my };\n      max = min;\n      length = 0;\n\n      if (distanceIsNumber && distance < 0.001) {\n        POINT = min;\n      }\n    } else if (pathCommand === 'L') {\n      ({ length, min, max, point } = segmentLineFactory(data[0], data[1], data[2], data[3], (distance || 0) - LENGTH));\n    } else if (pathCommand === 'A') {\n      ({ length, min, max, point } = segmentArcFactory(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        data[8],\n        (distance || 0) - LENGTH,\n        options || {},\n      ));\n    } else if (pathCommand === 'C') {\n      ({ length, min, max, point } = segmentCubicFactory(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        data[6],\n        data[7],\n        (distance || 0) - LENGTH,\n        options || {},\n      ));\n    } else if (pathCommand === 'Q') {\n      ({ length, min, max, point } = segmentQuadFactory(\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4],\n        data[5],\n        (distance || 0) - LENGTH,\n        options || {},\n      ));\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      ({ length, min, max, point } = segmentLineFactory(data[0], data[1], data[2], data[3], (distance || 0) - LENGTH));\n    }\n\n    if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {\n      POINT = point;\n    }\n\n    MAX.push(max);\n    MIN.push(min);\n    LENGTH += length;\n\n    [x, y] = pathCommand !== 'Z' ? seg.slice(-2) : [mx, my];\n  }\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x, y };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min.apply(\n        null,\n        MIN.map((n) => n.x),\n      ),\n      y: Math.min.apply(\n        null,\n        MIN.map((n) => n.y),\n      ),\n    },\n    max: {\n      x: Math.max.apply(\n        null,\n        MAX.map((n) => n.x),\n      ),\n      y: Math.max.apply(\n        null,\n        MAX.map((n) => n.y),\n      ),\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}