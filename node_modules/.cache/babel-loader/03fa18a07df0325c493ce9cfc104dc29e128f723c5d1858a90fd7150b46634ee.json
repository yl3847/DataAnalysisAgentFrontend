{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Graph as Graphlib } from '@antv/graphlib';\nimport { deepMix, isNumber } from '@antv/util';\nimport { COMBO_KEY } from '../constants';\nimport { BaseLayout } from '../layouts/base-layout';\nimport { idOf } from './id';\nimport { parsePoint } from './point';\n/**\n * <zh/> 判断是否是 combo 布局\n *\n * <en/> Determine if it is a combo layout\n * @param options - <zh/> 布局配置项 | <en/> Layout options\n * @returns <zh/> 是否是 combo 布局 | <en/> Whether it is a combo layout\n */\nexport function isComboLayout(options) {\n  const {\n    type\n  } = options;\n  if (['comboCombined', 'comboForce'].includes(type)) return true;\n  if (type === 'antv-dagre' && options.sortByCombo) return true;\n  return false;\n}\n/**\n * <zh/> 判断是否是树图布局\n *\n * <en/> Determine if it is a tree layout\n * @param options - <zh/> 布局配置项 | <en/> Layout options\n * @returns <zh/> 是否是树图布局 | <en/> Whether it is a tree layout\n */\nexport function isTreeLayout(options) {\n  const {\n    type\n  } = options;\n  return ['compact-box', 'mindmap', 'dendrogram', 'indented'].includes(type);\n}\n/**\n * <zh/> 数据中是否指定了位置\n *\n * <en/> Is the position specified in the data\n * @param data - <zh/> 数据 | <en/> Data\n * @returns <zh/> 是否指定了位置 | <en/> Is the position specified\n */\nexport function isPositionSpecified(data) {\n  return isNumber(data.x) && isNumber(data.y);\n}\n/**\n * <zh/> 是否是前布局\n *\n * <en/> Is pre-layout\n * @remarks\n * <zh/> 前布局是指在初始化元素前计算布局，适用于一些布局需要提前计算位置的场景。\n *\n * <en/> Pre-layout refers to calculating the layout before initializing the elements, which is suitable for some layouts that need to calculate the position in advance.\n * @param options - <zh/> 布局配置项 | <en/> Layout options\n * @returns <zh/> 是否是前布局 | <en/> Is it a pre-layout\n */\nexport function isPreLayout(options) {\n  return !Array.isArray(options) && (options === null || options === void 0 ? void 0 : options.preLayout);\n}\n/**\n * <zh/> 将图布局结果转换为 G6 数据\n *\n * <en/> Convert the layout result to G6 data\n * @param layoutMapping - <zh/> 布局映射 | <en/> Layout mapping\n * @returns <zh/> G6 数据 | <en/> G6 data\n */\nexport function layoutMapping2GraphData(layoutMapping) {\n  const {\n    nodes,\n    edges\n  } = layoutMapping;\n  const data = {\n    nodes: [],\n    edges: [],\n    combos: []\n  };\n  nodes.forEach(nodeLike => {\n    const target = nodeLike.data._isCombo ? data.combos : data.nodes;\n    const {\n      x,\n      y,\n      z = 0\n    } = nodeLike.data;\n    target === null || target === void 0 ? void 0 : target.push({\n      id: nodeLike.id,\n      style: {\n        x,\n        y,\n        z\n      }\n    });\n  });\n  edges.forEach(edge => {\n    const {\n      id,\n      source,\n      target,\n      data: {\n        points = [],\n        controlPoints = points.slice(1, points.length - 1)\n      }\n    } = edge;\n    data.edges.push({\n      id: id,\n      source: source,\n      target: target,\n      style: Object.assign({}, (controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.length) ? {\n        controlPoints: controlPoints.map(parsePoint)\n      } : {})\n    });\n  });\n  return data;\n}\n/**\n * <zh/> 将 @antv/layout 布局适配为 G6 布局\n *\n * <en/> Adapt @antv/layout layout to G6 layout\n * @param Ctor - <zh/> 布局类 | <en/> Layout class\n * @param context - <zh/> 运行时上下文 | <en/> Runtime context\n * @returns <zh/> G6 布局类 | <en/> G6 layout class\n */\nexport function layoutAdapter(Ctor, context) {\n  class AdaptLayout extends BaseLayout {\n    constructor(context, options) {\n      super(context, options);\n      this.instance = new Ctor({});\n      this.id = this.instance.id;\n      if ('stop' in this.instance && 'tick' in this.instance) {\n        const instance = this.instance;\n        this.stop = instance.stop.bind(instance);\n        this.tick = iterations => {\n          const tickResult = instance.tick(iterations);\n          return layoutMapping2GraphData(tickResult);\n        };\n      }\n    }\n    execute(model, options) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return layoutMapping2GraphData(yield this.instance.execute(this.graphData2LayoutModel(model), this.transformOptions(deepMix({}, this.options, options))));\n      });\n    }\n    transformOptions(options) {\n      if (!('onTick' in options)) return options;\n      const onTick = options.onTick;\n      options.onTick = data => onTick(layoutMapping2GraphData(data));\n      return options;\n    }\n    graphData2LayoutModel(data) {\n      const {\n        nodes = [],\n        edges = [],\n        combos = []\n      } = data;\n      const nodesToLayout = nodes.map(datum => {\n        const id = idOf(datum);\n        const {\n            data,\n            style,\n            combo\n          } = datum,\n          rest = __rest(datum, [\"data\", \"style\", \"combo\"]);\n        const result = {\n          id,\n          data: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, data), {\n            data\n          }), combo ? {\n            parentId: combo\n          } : {}), {\n            style\n          }), rest)\n        };\n        // 一些布局会从 data 中读取位置信息\n        if (style === null || style === void 0 ? void 0 : style.x) Object.assign(result.data, {\n          x: style.x\n        });\n        if (style === null || style === void 0 ? void 0 : style.y) Object.assign(result.data, {\n          y: style.y\n        });\n        if (style === null || style === void 0 ? void 0 : style.z) Object.assign(result.data, {\n          z: style.z\n        });\n        return result;\n      });\n      const nodesIdMap = new Map(nodesToLayout.map(node => [node.id, node]));\n      const edgesToLayout = edges.filter(edge => {\n        const {\n          source,\n          target\n        } = edge;\n        return nodesIdMap.has(source) && nodesIdMap.has(target);\n      }).map(edge => {\n        const {\n          source,\n          target,\n          data,\n          style\n        } = edge;\n        return {\n          id: idOf(edge),\n          source,\n          target,\n          data: Object.assign({}, data),\n          style: Object.assign({}, style)\n        };\n      });\n      const combosToLayout = combos.map(combo => {\n        return {\n          id: idOf(combo),\n          data: Object.assign({\n            _isCombo: true\n          }, combo.data),\n          style: Object.assign({}, combo.style)\n        };\n      });\n      const layoutModel = new Graphlib({\n        nodes: [...nodesToLayout, ...combosToLayout],\n        edges: edgesToLayout\n      });\n      if (context.model.model.hasTreeStructure(COMBO_KEY)) {\n        layoutModel.attachTreeStructure(COMBO_KEY);\n        // 同步层级关系 / Synchronize hierarchical relationships\n        nodesToLayout.forEach(node => {\n          const parent = context.model.model.getParent(node.id, COMBO_KEY);\n          if (parent && layoutModel.hasNode(parent.id)) {\n            layoutModel.setParent(node.id, parent.id, COMBO_KEY);\n          }\n        });\n      }\n      return layoutModel;\n    }\n  }\n  return AdaptLayout;\n}\n/**\n * <zh/> 调用布局成员方法\n *\n * <en/> Call layout member methods\n * @remarks\n * <zh/> 提供一种通用的调用方式来调用 G6 布局和 \\@antv/layout 布局上的方法\n *\n * <en/> Provide a common way to call methods on G6 layout and \\@antv/layout layout\n * @param layout - <zh/> 布局实例 | <en/> Layout instance\n * @param method - <zh/> 方法名 | <en/> Method name\n * @param args - <zh/> 参数 | <en/> Arguments\n * @returns <zh/> 返回值 | <en/> Return value\n */\nexport function invokeLayoutMethod(layout, method, ...args) {\n  if (method in layout) {\n    return layout[method](...args);\n  }\n  // invoke AdaptLayout method\n  if ('instance' in layout) {\n    const instance = layout.instance;\n    if (method in instance) return instance[method](...args);\n  }\n  return null;\n}\n/**\n * <zh/> 获取布局成员属性\n *\n * <en/> Get layout member properties\n * @param layout - <zh/> 布局实例 | <en/> Layout instance\n * @param name - <zh/> 属性名 | <en/> Property name\n * @returns <zh/> 返回值 | <en/> Return value\n */\nexport function getLayoutProperty(layout, name) {\n  if (name in layout) return layout[name];\n  if ('instance' in layout) {\n    const instance = layout.instance;\n    if (name in instance) return instance[name];\n  }\n  return null;\n}","map":{"version":3,"names":["Graph","Graphlib","deepMix","isNumber","COMBO_KEY","BaseLayout","idOf","parsePoint","isComboLayout","options","type","includes","sortByCombo","isTreeLayout","isPositionSpecified","data","x","y","isPreLayout","Array","isArray","preLayout","layoutMapping2GraphData","layoutMapping","nodes","edges","combos","forEach","nodeLike","target","_isCombo","z","push","id","style","edge","source","points","controlPoints","slice","length","Object","assign","map","layoutAdapter","Ctor","context","AdaptLayout","constructor","instance","stop","bind","tick","iterations","tickResult","execute","model","graphData2LayoutModel","transformOptions","onTick","nodesToLayout","datum","combo","rest","__rest","result","parentId","nodesIdMap","Map","node","edgesToLayout","filter","has","combosToLayout","layoutModel","hasTreeStructure","attachTreeStructure","parent","getParent","hasNode","setParent","invokeLayoutMethod","layout","method","args","getLayoutProperty","name"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/layout.ts"],"sourcesContent":["import { Graph as Graphlib } from '@antv/graphlib';\nimport { deepMix, isNumber } from '@antv/util';\nimport { COMBO_KEY } from '../constants';\nimport { BaseLayout } from '../layouts/base-layout';\nimport { idOf } from './id';\nimport { parsePoint } from './point';\n\nimport type { LayoutMapping, Graph as LayoutModel, Node as LayoutNodeData } from '@antv/layout';\nimport type { AntVLayout } from '../layouts/types';\nimport type { RuntimeContext } from '../runtime/types';\nimport type { GraphData } from '../spec/data';\nimport type { LayoutOptions, STDLayoutOptions } from '../spec/layout';\nimport type { AdaptiveLayout, ID } from '../types';\n\n/**\n * <zh/> 判断是否是 combo 布局\n *\n * <en/> Determine if it is a combo layout\n * @param options - <zh/> 布局配置项 | <en/> Layout options\n * @returns <zh/> 是否是 combo 布局 | <en/> Whether it is a combo layout\n */\nexport function isComboLayout(options: STDLayoutOptions) {\n  const { type } = options;\n  if (['comboCombined', 'comboForce'].includes(type)) return true;\n  if (type === 'antv-dagre' && options.sortByCombo) return true;\n  return false;\n}\n\n/**\n * <zh/> 判断是否是树图布局\n *\n * <en/> Determine if it is a tree layout\n * @param options - <zh/> 布局配置项 | <en/> Layout options\n * @returns <zh/> 是否是树图布局 | <en/> Whether it is a tree layout\n */\nexport function isTreeLayout(options: STDLayoutOptions) {\n  const { type } = options;\n  return ['compact-box', 'mindmap', 'dendrogram', 'indented'].includes(type);\n}\n\n/**\n * <zh/> 数据中是否指定了位置\n *\n * <en/> Is the position specified in the data\n * @param data - <zh/> 数据 | <en/> Data\n * @returns <zh/> 是否指定了位置 | <en/> Is the position specified\n */\nexport function isPositionSpecified(data: Record<string, unknown>) {\n  return isNumber(data.x) && isNumber(data.y);\n}\n\n/**\n * <zh/> 是否是前布局\n *\n * <en/> Is pre-layout\n * @remarks\n * <zh/> 前布局是指在初始化元素前计算布局，适用于一些布局需要提前计算位置的场景。\n *\n * <en/> Pre-layout refers to calculating the layout before initializing the elements, which is suitable for some layouts that need to calculate the position in advance.\n * @param options - <zh/> 布局配置项 | <en/> Layout options\n * @returns <zh/> 是否是前布局 | <en/> Is it a pre-layout\n */\nexport function isPreLayout(options?: LayoutOptions) {\n  return !Array.isArray(options) && options?.preLayout;\n}\n\n/**\n * <zh/> 将图布局结果转换为 G6 数据\n *\n * <en/> Convert the layout result to G6 data\n * @param layoutMapping - <zh/> 布局映射 | <en/> Layout mapping\n * @returns <zh/> G6 数据 | <en/> G6 data\n */\nexport function layoutMapping2GraphData(layoutMapping: LayoutMapping): GraphData {\n  const { nodes, edges } = layoutMapping;\n  const data: GraphData = { nodes: [], edges: [], combos: [] };\n\n  nodes.forEach((nodeLike) => {\n    const target = nodeLike.data._isCombo ? data.combos : data.nodes;\n    const { x, y, z = 0 } = nodeLike.data;\n    target?.push({\n      id: nodeLike.id as ID,\n      style: { x, y, z },\n    });\n  });\n\n  edges.forEach((edge) => {\n    const {\n      id,\n      source,\n      target,\n      data: { points = [], controlPoints = points.slice(1, points.length - 1) },\n    } = edge;\n\n    data.edges!.push({\n      id: id as ID,\n      source: source as ID,\n      target: target as ID,\n      style: {\n        /**\n         * antv-dagre 返回 controlPoints，dagre 返回 points\n         * antv-dagre returns controlPoints, dagre returns points\n         */\n        ...(controlPoints?.length ? { controlPoints: controlPoints.map(parsePoint) } : {}),\n      },\n    });\n  });\n\n  return data;\n}\n\n/**\n * <zh/> 将 @antv/layout 布局适配为 G6 布局\n *\n * <en/> Adapt @antv/layout layout to G6 layout\n * @param Ctor - <zh/> 布局类 | <en/> Layout class\n * @param context - <zh/> 运行时上下文 | <en/> Runtime context\n * @returns <zh/> G6 布局类 | <en/> G6 layout class\n */\nexport function layoutAdapter(\n  Ctor: new (options: Record<string, unknown>) => AntVLayout,\n  context: RuntimeContext,\n): new (context: RuntimeContext, options?: Record<string, unknown>) => BaseLayout {\n  class AdaptLayout extends BaseLayout implements AdaptiveLayout {\n    public instance: AntVLayout;\n\n    public id: string;\n\n    constructor(context: RuntimeContext, options?: Record<string, unknown>) {\n      super(context, options);\n      this.instance = new Ctor({});\n      this.id = this.instance.id;\n\n      if ('stop' in this.instance && 'tick' in this.instance) {\n        const instance = this.instance;\n        this.stop = instance.stop.bind(instance);\n        this.tick = (iterations?: number) => {\n          const tickResult = instance.tick(iterations);\n          return layoutMapping2GraphData(tickResult);\n        };\n      }\n    }\n\n    public async execute(model: GraphData, options?: STDLayoutOptions): Promise<GraphData> {\n      return layoutMapping2GraphData(\n        await this.instance.execute(\n          this.graphData2LayoutModel(model),\n          this.transformOptions(deepMix({}, this.options, options)),\n        ),\n      );\n    }\n\n    private transformOptions(options: STDLayoutOptions) {\n      if (!('onTick' in options)) return options;\n      const onTick = options.onTick as (data: GraphData) => void;\n      options.onTick = (data: LayoutMapping) => onTick(layoutMapping2GraphData(data));\n      return options;\n    }\n\n    public graphData2LayoutModel(data: GraphData): LayoutModel {\n      const { nodes = [], edges = [], combos = [] } = data;\n      const nodesToLayout: LayoutNodeData[] = nodes.map((datum) => {\n        const id = idOf(datum);\n        const { data, style, combo, ...rest } = datum;\n\n        const result = {\n          id,\n          data: {\n            // grid 布局会直接读取 data[sortBy]，兼容处理，需要避免用户 data 下使用 data, style 等字段\n            // The grid layout will directly read data[sortBy], compatible processing, need to avoid users using data, style and other fields under data\n            ...data,\n            data,\n            // antv-dagre 会读取 data.parentId\n            // antv-dagre will read data.parentId\n            ...(combo ? { parentId: combo } : {}),\n            style,\n            ...rest,\n          },\n        };\n        // 一些布局会从 data 中读取位置信息\n        if (style?.x) Object.assign(result.data, { x: style.x });\n        if (style?.y) Object.assign(result.data, { y: style.y });\n        if (style?.z) Object.assign(result.data, { z: style.z });\n\n        return result;\n      });\n      const nodesIdMap = new Map(nodesToLayout.map((node) => [node.id, node]));\n\n      const edgesToLayout = edges\n        .filter((edge) => {\n          const { source, target } = edge;\n          return nodesIdMap.has(source) && nodesIdMap.has(target);\n        })\n        .map((edge) => {\n          const { source, target, data, style } = edge;\n          return { id: idOf(edge), source, target, data: { ...data }, style: { ...style } };\n        });\n\n      const combosToLayout: LayoutNodeData[] = combos.map((combo) => {\n        return { id: idOf(combo), data: { _isCombo: true, ...combo.data }, style: { ...combo.style } };\n      });\n\n      const layoutModel = new Graphlib({\n        nodes: [...nodesToLayout, ...combosToLayout],\n        edges: edgesToLayout,\n      });\n\n      if (context.model.model.hasTreeStructure(COMBO_KEY)) {\n        layoutModel.attachTreeStructure(COMBO_KEY);\n        // 同步层级关系 / Synchronize hierarchical relationships\n        nodesToLayout.forEach((node) => {\n          const parent = context.model.model.getParent(node.id, COMBO_KEY);\n          if (parent && layoutModel.hasNode(parent.id)) {\n            layoutModel.setParent(node.id, parent.id, COMBO_KEY);\n          }\n        });\n      }\n\n      return layoutModel;\n    }\n  }\n\n  return AdaptLayout;\n}\n\n/**\n * <zh/> 调用布局成员方法\n *\n * <en/> Call layout member methods\n * @remarks\n * <zh/> 提供一种通用的调用方式来调用 G6 布局和 \\@antv/layout 布局上的方法\n *\n * <en/> Provide a common way to call methods on G6 layout and \\@antv/layout layout\n * @param layout - <zh/> 布局实例 | <en/> Layout instance\n * @param method - <zh/> 方法名 | <en/> Method name\n * @param args - <zh/> 参数 | <en/> Arguments\n * @returns <zh/> 返回值 | <en/> Return value\n */\nexport function invokeLayoutMethod(layout: BaseLayout, method: string, ...args: unknown[]) {\n  if (method in layout) {\n    return (layout as any)[method](...args);\n  }\n  // invoke AdaptLayout method\n  if ('instance' in layout) {\n    const instance = (layout as any).instance;\n    if (method in instance) return instance[method](...args);\n  }\n  return null;\n}\n\n/**\n * <zh/> 获取布局成员属性\n *\n * <en/> Get layout member properties\n * @param layout - <zh/> 布局实例 | <en/> Layout instance\n * @param name - <zh/> 属性名 | <en/> Property name\n * @returns <zh/> 返回值 | <en/> Return value\n */\nexport function getLayoutProperty(layout: BaseLayout, name: string) {\n  if (name in layout) return (layout as any)[name];\n  if ('instance' in layout) {\n    const instance = (layout as any).instance;\n    if (name in instance) return instance[name];\n  }\n  return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}