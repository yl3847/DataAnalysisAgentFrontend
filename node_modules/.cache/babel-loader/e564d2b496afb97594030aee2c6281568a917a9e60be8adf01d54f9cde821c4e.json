{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Canvas as GCanvas } from '@antv/g';\nimport { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Plugin as DragAndDropPlugin } from '@antv/g-plugin-dragndrop';\nimport { debounce, get } from '@antv/util';\nimport EventEmitter from '@antv/event-emitter';\nimport { group } from '@antv/vendor/d3-array';\nimport { render, destroy, ELEMENT_CLASS_NAME, VIEW_CLASS_NAME } from '../runtime';\nimport { ChartEvent } from '../utils/event';\nimport { findSingleElement, maybeValue, findSeriesElement } from '../interaction/tooltip';\nimport { isHeatmap, dataOf } from '../utils/helper';\nimport { selectPlotArea } from '../interaction/utils';\nimport { normalizeContainer, removeContainer, sizeOf, optionsOf, updateRoot, createEmptyPromise, REMOVE_FLAG } from './utils';\nimport { CompositionNode } from './composition';\nimport { defineProps, nodeProps } from './define';\nimport { MarkNode } from './mark';\nimport { library } from './library';\nexport const G2_CHART_KEY = 'G2_CHART_KEY';\nexport class Runtime extends CompositionNode {\n  constructor(options) {\n    const {\n        container,\n        canvas,\n        renderer,\n        plugins,\n        lib,\n        createCanvas\n      } = options,\n      rest = __rest(options, [\"container\", \"canvas\", \"renderer\", \"plugins\", \"lib\", \"createCanvas\"]);\n    super(rest, 'view');\n    // Identifies whether bindAutoFit.\n    this._hasBindAutoFit = false;\n    this._rendering = false;\n    this._trailingClear = null;\n    this._trailing = false;\n    this._trailingResolve = null;\n    this._trailingReject = null;\n    this._previousDefinedType = null;\n    this._onResize = debounce(() => {\n      this.forceFit();\n    }, 300);\n    this._renderer = renderer || new CanvasRenderer();\n    this._plugins = plugins || [];\n    this._container = normalizeContainer(container);\n    this._emitter = new EventEmitter();\n    this._context = {\n      library: Object.assign(Object.assign({}, lib), library),\n      emitter: this._emitter,\n      canvas,\n      createCanvas\n    };\n    this._create();\n  }\n  render() {\n    if (this._rendering) return this._addToTrailing();\n    if (!this._context.canvas) this._createCanvas();\n    this._bindAutoFit();\n    this._rendering = true;\n    // @fixme The cancel render is not marked, which will cause additional rendered event.\n    // @ref src/runtime/render.ts\n    const finished = new Promise((resolve, reject) => render(this._computedOptions(), this._context, this._createResolve(resolve), this._createReject(reject)));\n    const [finished1, resolve, reject] = createEmptyPromise();\n    finished.then(resolve).then(() => {\n      // Resolve trailing clear.\n      if (this._trailingClear) {\n        const options = this.options();\n        this._trailingClear();\n        // If clear is called during trailing, recover options for next trailing render.\n        if (this._trailing) this.options(options);\n      }\n    }).catch(reject).then(() => {\n      this._trailingClear = null;\n      this._renderTrailing();\n    });\n    return finished1;\n  }\n  /**\n   * @overload\n   * @param {G2ViewTree} [options]\n   * @returns {Runtime|Spec}\n   */\n  options(options) {\n    if (arguments.length === 0) return optionsOf(this);\n    const {\n      type\n    } = options;\n    if (type) this._previousDefinedType = type;\n    updateRoot(this, options, this._previousDefinedType, this._marks, this._compositions);\n    return this;\n  }\n  getContainer() {\n    return this._container;\n  }\n  getContext() {\n    return this._context;\n  }\n  on(event, callback, once) {\n    this._emitter.on(event, callback, once);\n    return this;\n  }\n  once(event, callback) {\n    this._emitter.once(event, callback);\n    return this;\n  }\n  emit(event, ...args) {\n    this._emitter.emit(event, ...args);\n    return this;\n  }\n  off(event, callback) {\n    this._emitter.off(event, callback);\n    return this;\n  }\n  clear(isClearEvents = true) {\n    // Clear after render, otherwise render with destroyed context will return infinite promise, which will block trialing render.\n    if (this._rendering) {\n      this._trailingClear = () => {\n        this.clear(isClearEvents);\n      };\n      // Only reset options, not destroy canvas.\n      this._reset();\n      return;\n    }\n    const options = this.options();\n    this.emit(ChartEvent.BEFORE_CLEAR);\n    this._reset();\n    destroy(options, this._context, false, isClearEvents);\n    this.emit(ChartEvent.AFTER_CLEAR);\n  }\n  destroy() {\n    const options = this.options();\n    this.emit(ChartEvent.BEFORE_DESTROY);\n    this._unbindAutoFit();\n    this._reset();\n    destroy(options, this._context, true);\n    if (this._container[REMOVE_FLAG]) removeContainer(this._container);\n    this.emit(ChartEvent.AFTER_DESTROY);\n  }\n  forceFit() {\n    // Don't fit if size do not change.\n    this.options['autoFit'] = true;\n    const {\n      width,\n      height\n    } = sizeOf(this.options(), this._container);\n    if (width === this._width && height === this._height) {\n      return Promise.resolve(this);\n    }\n    // Don't call changeSize to prevent update width and height of options.\n    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);\n    const finished = this.render();\n    finished.then(() => {\n      this.emit(ChartEvent.AFTER_CHANGE_SIZE);\n    });\n    return finished;\n  }\n  changeSize(width, height) {\n    if (width === this._width && height === this._height) {\n      return Promise.resolve(this);\n    }\n    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);\n    this.attr('width', width);\n    this.attr('height', height);\n    const finished = this.render();\n    finished.then(() => {\n      this.emit(ChartEvent.AFTER_CHANGE_SIZE);\n    });\n    return finished;\n  }\n  getDataByXY(point, options = {}) {\n    const {\n      shared = false,\n      series,\n      facet = false,\n      startX = 0,\n      startY = 0\n    } = options;\n    const {\n      canvas,\n      views\n    } = this._context;\n    const {\n      document\n    } = canvas;\n    const {\n      x,\n      y\n    } = point;\n    // Temporarily do not handle the multi - view situation.\n    const {\n      coordinate,\n      scale,\n      markState,\n      data: dataMap,\n      key\n    } = views[0];\n    const elements = document.getElementsByClassName(ELEMENT_CLASS_NAME);\n    const groupKey = shared ? element => element.__data__.x : d => d;\n    const keyGroup = group(elements, groupKey);\n    const container = document.getElementsByClassName(VIEW_CLASS_NAME)[0];\n    const root = selectPlotArea(container);\n    const hasSeriesInteraction = markState => {\n      return Array.from(markState.values()).some(d => {\n        var _a, _b;\n        return ((_a = d.interaction) === null || _a === void 0 ? void 0 : _a['seriesTooltip']) || ((_b = d.channels) === null || _b === void 0 ? void 0 : _b.some(c => c.name === 'series' && c.values !== undefined));\n      });\n    };\n    const isSeries = maybeValue(series, hasSeriesInteraction(markState));\n    const getElementData = el => get(el, '__data__.data', null);\n    const getElementsData = els => els.map(getElementData);\n    try {\n      // For non-facet and series chart.\n      if (isSeries && hasSeriesInteraction(markState) && !facet) {\n        const {\n          selectedData\n        } = findSeriesElement({\n          root,\n          event: {\n            offsetX: x,\n            offsetY: y\n          },\n          elements,\n          coordinate,\n          scale,\n          startX,\n          startY\n        });\n        const viewData = dataMap.get(`${key}-0`);\n        return selectedData.map(({\n          index\n        }) => viewData[index]);\n      }\n      // For single chart.\n      const element = findSingleElement({\n        root,\n        event: {\n          offsetX: x,\n          offsetY: y\n        },\n        elements,\n        coordinate,\n        scale,\n        shared\n      });\n      if (isHeatmap(element)) return dataOf(element, dataMap.get(key));\n      const k = groupKey(element);\n      const groupElements = keyGroup.get(k);\n      return groupElements ? getElementsData(groupElements) : [];\n    } catch (e) {\n      const topMostElement = canvas.document.elementFromPointSync(x, y);\n      return topMostElement ? getElementData(topMostElement) : [];\n    }\n  }\n  _create() {\n    const {\n      library\n    } = this._context;\n    // @todo After refactor component as mark, remove this.\n    const isMark = key => key.startsWith('mark.') || key === 'component.axisX' || key === 'component.axisY' || key === 'component.legends';\n    const marks = ['mark.mark', ...Object.keys(library).filter(isMark)];\n    // Create mark generators.\n    this._marks = {};\n    for (const key of marks) {\n      const name = key.split('.').pop();\n      class Mark extends MarkNode {\n        constructor() {\n          super({}, name);\n        }\n      }\n      this._marks[name] = Mark;\n      this[name] = function (composite) {\n        const node = this.append(Mark);\n        if (name === 'mark') node.type = composite;\n        return node;\n      };\n    }\n    // Create composition generators.\n    const compositions = ['composition.view', ...Object.keys(library).filter(key => key.startsWith('composition.') && key !== 'composition.mark')];\n    this._compositions = Object.fromEntries(compositions.map(key => {\n      const name = key.split('.').pop();\n      let Composition = class Composition extends CompositionNode {\n        constructor() {\n          super({}, name);\n        }\n      };\n      Composition = __decorate([defineProps(nodeProps(this._marks))], Composition);\n      return [name, Composition];\n    }));\n    for (const Ctor of Object.values(this._compositions)) {\n      defineProps(nodeProps(this._compositions))(Ctor);\n    }\n    for (const key of compositions) {\n      const name = key.split('.').pop();\n      this[name] = function () {\n        const Composition = this._compositions[name];\n        this.type = null;\n        return this.append(Composition);\n      };\n    }\n  }\n  _reset() {\n    const KEYS = ['theme', 'type', 'width', 'height', 'autoFit'];\n    this.type = 'view';\n    this.value = Object.fromEntries(Object.entries(this.value).filter(([key]) => key.startsWith('margin') || key.startsWith('padding') || key.startsWith('inset') || KEYS.includes(key)));\n    this.children = [];\n  }\n  _renderTrailing() {\n    if (!this._trailing) return;\n    this._trailing = false;\n    this.render().then(() => {\n      const trailingResolve = this._trailingResolve.bind(this);\n      this._trailingResolve = null;\n      trailingResolve(this);\n    }).catch(error => {\n      const trailingReject = this._trailingReject.bind(this);\n      this._trailingReject = null;\n      trailingReject(error);\n    });\n  }\n  _createResolve(resolve) {\n    return () => {\n      this._rendering = false;\n      resolve(this);\n    };\n  }\n  _createReject(reject) {\n    return error => {\n      this._rendering = false;\n      reject(error);\n    };\n  }\n  // Update actual size and key.\n  _computedOptions() {\n    const options = this.options();\n    const {\n      key = G2_CHART_KEY\n    } = options;\n    const {\n      width,\n      height,\n      depth\n    } = sizeOf(options, this._container);\n    this._width = width;\n    this._height = height;\n    this._key = key;\n    return Object.assign(Object.assign({\n      key: this._key\n    }, options), {\n      width,\n      height,\n      depth\n    });\n  }\n  // Create canvas if it does not exist.\n  // DragAndDropPlugin is for interaction.\n  // It is OK to register more than one time, G will handle this.\n  _createCanvas() {\n    const {\n      width,\n      height\n    } = sizeOf(this.options(), this._container);\n    this._plugins.push(new DragAndDropPlugin());\n    this._plugins.forEach(d => this._renderer.registerPlugin(d));\n    this._context.canvas = new GCanvas({\n      container: this._container,\n      width,\n      height,\n      renderer: this._renderer\n    });\n  }\n  _addToTrailing() {\n    var _a;\n    // Resolve previous promise, and give up this task.\n    (_a = this._trailingResolve) === null || _a === void 0 ? void 0 : _a.call(this, this);\n    // Create new task.\n    this._trailing = true;\n    const promise = new Promise((resolve, reject) => {\n      this._trailingResolve = resolve;\n      this._trailingReject = reject;\n    });\n    return promise;\n  }\n  _bindAutoFit() {\n    const options = this.options();\n    const {\n      autoFit\n    } = options;\n    if (this._hasBindAutoFit) {\n      // If it was bind before, unbind it now.\n      if (!autoFit) this._unbindAutoFit();\n      return;\n    }\n    if (autoFit) {\n      this._hasBindAutoFit = true;\n      window.addEventListener('resize', this._onResize);\n    }\n  }\n  _unbindAutoFit() {\n    if (this._hasBindAutoFit) {\n      this._hasBindAutoFit = false;\n      window.removeEventListener('resize', this._onResize);\n    }\n  }\n}","map":{"version":3,"names":["Canvas","GCanvas","Renderer","CanvasRenderer","Plugin","DragAndDropPlugin","debounce","get","EventEmitter","group","render","destroy","ELEMENT_CLASS_NAME","VIEW_CLASS_NAME","ChartEvent","findSingleElement","maybeValue","findSeriesElement","isHeatmap","dataOf","selectPlotArea","normalizeContainer","removeContainer","sizeOf","optionsOf","updateRoot","createEmptyPromise","REMOVE_FLAG","CompositionNode","defineProps","nodeProps","MarkNode","library","G2_CHART_KEY","Runtime","constructor","options","container","canvas","renderer","plugins","lib","createCanvas","rest","__rest","_hasBindAutoFit","_rendering","_trailingClear","_trailing","_trailingResolve","_trailingReject","_previousDefinedType","_onResize","forceFit","_renderer","_plugins","_container","_emitter","_context","Object","assign","emitter","_create","_addToTrailing","_createCanvas","_bindAutoFit","finished","Promise","resolve","reject","_computedOptions","_createResolve","_createReject","finished1","then","catch","_renderTrailing","arguments","length","type","_marks","_compositions","getContainer","getContext","on","event","callback","once","emit","args","off","clear","isClearEvents","_reset","BEFORE_CLEAR","AFTER_CLEAR","BEFORE_DESTROY","_unbindAutoFit","AFTER_DESTROY","width","height","_width","_height","BEFORE_CHANGE_SIZE","AFTER_CHANGE_SIZE","changeSize","attr","getDataByXY","point","shared","series","facet","startX","startY","views","document","x","y","coordinate","scale","markState","data","dataMap","key","elements","getElementsByClassName","groupKey","element","__data__","d","keyGroup","root","hasSeriesInteraction","Array","from","values","some","_a","interaction","_b","channels","c","name","undefined","isSeries","getElementData","el","getElementsData","els","map","selectedData","offsetX","offsetY","viewData","index","k","groupElements","e","topMostElement","elementFromPointSync","isMark","startsWith","marks","keys","filter","split","pop","Mark","composite","node","append","compositions","fromEntries","Composition","__decorate","Ctor","KEYS","value","entries","includes","children","trailingResolve","bind","error","trailingReject","depth","_key","push","forEach","registerPlugin","call","promise","autoFit","window","addEventListener","removeEventListener"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/api/runtime.ts"],"sourcesContent":["import {\n  DisplayObject,\n  IRenderer,\n  RendererPlugin,\n  Canvas as GCanvas,\n} from '@antv/g';\nimport { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Plugin as DragAndDropPlugin } from '@antv/g-plugin-dragndrop';\nimport { debounce, get } from '@antv/util';\nimport EventEmitter from '@antv/event-emitter';\nimport { group } from '@antv/vendor/d3-array';\nimport { G2Element } from '../utils/selection';\nimport {\n  G2Context,\n  render,\n  destroy,\n  ELEMENT_CLASS_NAME,\n  VIEW_CLASS_NAME,\n} from '../runtime';\nimport { G2Spec, ViewComposition } from '../spec';\nimport { ChartEvent } from '../utils/event';\nimport type { G2Library } from '../runtime/types/options';\nimport {\n  findSingleElement,\n  maybeValue,\n  findSeriesElement,\n} from '../interaction/tooltip';\nimport { isHeatmap, dataOf } from '../utils/helper';\nimport { selectPlotArea } from '../interaction/utils';\nimport {\n  normalizeContainer,\n  removeContainer,\n  sizeOf,\n  optionsOf,\n  updateRoot,\n  createEmptyPromise,\n  REMOVE_FLAG,\n} from './utils';\nimport { CompositionNode } from './composition';\nimport { Node } from './node';\nimport { defineProps, nodeProps } from './define';\nimport { MarkNode } from './mark';\nimport { library } from './library';\n\nexport const G2_CHART_KEY = 'G2_CHART_KEY';\n\nexport type RuntimeOptions = ViewComposition & {\n  container?: string | HTMLElement;\n  canvas?: GCanvas;\n  autoFit?: boolean;\n  renderer?: IRenderer;\n  plugins?: RendererPlugin[];\n  theme?: string;\n  lib?: G2Library;\n  createCanvas?: () => HTMLCanvasElement;\n};\n\nexport class Runtime<Spec extends G2Spec = G2Spec> extends CompositionNode {\n  private _container: HTMLElement;\n  private _context: G2Context;\n  private _emitter: EventEmitter;\n  private _width: number;\n  private _height: number;\n  private _renderer: IRenderer;\n  private _plugins: RendererPlugin[];\n  // Identifies whether bindAutoFit.\n  private _hasBindAutoFit = false;\n  private _rendering = false;\n  private _trailingClear = null;\n  private _trailing = false;\n  private _trailingResolve = null;\n  private _trailingReject = null;\n  private _previousDefinedType = null;\n  private _marks: Record<string, new () => Node>;\n  private _compositions: Record<string, new () => Node>;\n\n  constructor(options: RuntimeOptions) {\n    const { container, canvas, renderer, plugins, lib, createCanvas, ...rest } =\n      options;\n    super(rest, 'view');\n    this._renderer = renderer || new CanvasRenderer();\n    this._plugins = plugins || [];\n    this._container = normalizeContainer(container);\n    this._emitter = new EventEmitter();\n    this._context = {\n      library: { ...lib, ...library },\n      emitter: this._emitter,\n      canvas,\n      createCanvas,\n    };\n    this._create();\n  }\n\n  render(): Promise<Runtime<Spec>> {\n    if (this._rendering) return this._addToTrailing();\n    if (!this._context.canvas) this._createCanvas();\n    this._bindAutoFit();\n    this._rendering = true;\n\n    // @fixme The cancel render is not marked, which will cause additional rendered event.\n    // @ref src/runtime/render.ts\n    const finished = new Promise<Runtime<Spec>>((resolve, reject) =>\n      render(\n        this._computedOptions(),\n        this._context,\n        this._createResolve(resolve),\n        this._createReject(reject),\n      ),\n    );\n\n    const [finished1, resolve, reject] = createEmptyPromise<Runtime<Spec>>();\n    finished\n      .then(resolve)\n      .then(() => {\n        // Resolve trailing clear.\n        if (this._trailingClear) {\n          const options = this.options();\n\n          this._trailingClear();\n\n          // If clear is called during trailing, recover options for next trailing render.\n          if (this._trailing) this.options(options);\n        }\n      })\n      .catch(reject)\n      .then(() => {\n        this._trailingClear = null;\n        this._renderTrailing();\n      });\n\n    return finished1;\n  }\n\n  /**\n   * @overload\n   * @returns {Spec}\n   */\n  options(): Spec;\n  /**\n   * @overload\n   * @param {G2ViewTree} options\n   * @returns {Runtime}\n   */\n  options(options: Spec): Runtime<Spec>;\n  /**\n   * @overload\n   * @param {G2ViewTree} [options]\n   * @returns {Runtime|Spec}\n   */\n  options(options?: Spec): Runtime<Spec> | Spec {\n    if (arguments.length === 0) return optionsOf(this) as Spec;\n    const { type } = options;\n    if (type) this._previousDefinedType = type;\n    updateRoot(\n      this,\n      options,\n      this._previousDefinedType,\n      this._marks,\n      this._compositions,\n    );\n    return this;\n  }\n\n  getContainer(): HTMLElement {\n    return this._container;\n  }\n\n  getContext(): G2Context {\n    return this._context;\n  }\n\n  on(event: string, callback: (...args: any[]) => any, once?: boolean): this {\n    this._emitter.on(event, callback, once);\n    return this;\n  }\n\n  once(event: string, callback: (...args: any[]) => any): this {\n    this._emitter.once(event, callback);\n    return this;\n  }\n\n  emit(event: string, ...args: any[]): this {\n    this._emitter.emit(event, ...args);\n    return this;\n  }\n\n  off(event?: string, callback?: (...args: any[]) => any) {\n    this._emitter.off(event, callback);\n    return this;\n  }\n\n  clear(isClearEvents = true) {\n    // Clear after render, otherwise render with destroyed context will return infinite promise, which will block trialing render.\n    if (this._rendering) {\n      this._trailingClear = () => {\n        this.clear(isClearEvents);\n      };\n      // Only reset options, not destroy canvas.\n      this._reset();\n      return;\n    }\n    const options = this.options();\n    this.emit(ChartEvent.BEFORE_CLEAR);\n    this._reset();\n    destroy(options, this._context, false, isClearEvents);\n    this.emit(ChartEvent.AFTER_CLEAR);\n  }\n\n  destroy() {\n    const options = this.options();\n    this.emit(ChartEvent.BEFORE_DESTROY);\n    this._unbindAutoFit();\n    this._reset();\n    destroy(options, this._context, true);\n    if (this._container[REMOVE_FLAG]) removeContainer(this._container);\n    this.emit(ChartEvent.AFTER_DESTROY);\n  }\n\n  forceFit() {\n    // Don't fit if size do not change.\n    this.options['autoFit'] = true;\n    const { width, height } = sizeOf(this.options(), this._container);\n    if (width === this._width && height === this._height) {\n      return Promise.resolve(this);\n    }\n\n    // Don't call changeSize to prevent update width and height of options.\n    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);\n    const finished = this.render();\n    finished.then(() => {\n      this.emit(ChartEvent.AFTER_CHANGE_SIZE);\n    });\n    return finished;\n  }\n\n  changeSize(width: number, height: number): Promise<Runtime<Spec>> {\n    if (width === this._width && height === this._height) {\n      return Promise.resolve(this);\n    }\n    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);\n    this.attr('width', width);\n    this.attr('height', height);\n    const finished = this.render();\n    finished.then(() => {\n      this.emit(ChartEvent.AFTER_CHANGE_SIZE);\n    });\n    return finished;\n  }\n\n  getDataByXY(\n    point: { x: number; y: number },\n    options: {\n      shared?: boolean;\n      series?: boolean;\n      facet?: boolean;\n      startX?: number;\n      startY?: number;\n    } = {},\n  ): any[] {\n    const {\n      shared = false,\n      series,\n      facet = false,\n      startX = 0,\n      startY = 0,\n    } = options;\n    const { canvas, views } = this._context;\n    const { document } = canvas;\n    const { x, y } = point;\n    // Temporarily do not handle the multi - view situation.\n    const { coordinate, scale, markState, data: dataMap, key } = views[0];\n    const elements = document.getElementsByClassName(ELEMENT_CLASS_NAME);\n    const groupKey = shared ? (element) => element.__data__.x : (d) => d;\n    const keyGroup = group(elements, groupKey);\n    const container = document.getElementsByClassName(\n      VIEW_CLASS_NAME,\n    )[0] as DisplayObject;\n    const root = selectPlotArea(container);\n    const hasSeriesInteraction = (markState: Map<string, any>) => {\n      return Array.from(markState.values()).some(\n        (d) =>\n          d.interaction?.['seriesTooltip'] ||\n          d.channels?.some(\n            (c) => c.name === 'series' && c.values !== undefined,\n          ),\n      );\n    };\n    const isSeries = maybeValue(\n      series,\n      hasSeriesInteraction(markState as Map<string, any>),\n    );\n    const getElementData = (el: G2Element) => get(el, '__data__.data', null);\n    const getElementsData = (els: G2Element[]) => els.map(getElementData);\n\n    try {\n      // For non-facet and series chart.\n      if (\n        isSeries &&\n        hasSeriesInteraction(markState as Map<string, any>) &&\n        !facet\n      ) {\n        const { selectedData } = findSeriesElement({\n          root,\n          event: { offsetX: x, offsetY: y },\n          elements,\n          coordinate,\n          scale,\n          startX,\n          startY,\n        });\n        const viewData = dataMap.get(`${key}-0`);\n        return selectedData.map(({ index }) => viewData[index]);\n      }\n      // For single chart.\n      const element = findSingleElement({\n        root,\n        event: { offsetX: x, offsetY: y },\n        elements,\n        coordinate,\n        scale,\n        shared,\n      });\n      if (isHeatmap(element)) return dataOf(element, dataMap.get(key));\n      const k = groupKey(element);\n      const groupElements = keyGroup.get(k) as G2Element[];\n      return groupElements ? getElementsData(groupElements) : [];\n    } catch (e) {\n      const topMostElement = canvas.document.elementFromPointSync(\n        x,\n        y,\n      ) as G2Element;\n      return topMostElement ? getElementData(topMostElement) : [];\n    }\n  }\n\n  private _create() {\n    const { library } = this._context;\n\n    // @todo After refactor component as mark, remove this.\n    const isMark = (key) =>\n      key.startsWith('mark.') ||\n      key === 'component.axisX' ||\n      key === 'component.axisY' ||\n      key === 'component.legends';\n\n    const marks = [\n      'mark.mark', // chart.mark(composite)\n      ...Object.keys(library).filter(isMark),\n    ];\n\n    // Create mark generators.\n    this._marks = {};\n    for (const key of marks) {\n      const name = key.split('.').pop();\n      class Mark extends MarkNode {\n        constructor() {\n          super({}, name);\n        }\n      }\n      this._marks[name] = Mark;\n      this[name] = function (composite) {\n        const node = this.append(Mark);\n        if (name === 'mark') node.type = composite;\n        return node;\n      };\n    }\n\n    // Create composition generators.\n    const compositions = [\n      'composition.view', // chat.view()\n      ...Object.keys(library).filter(\n        (key) => key.startsWith('composition.') && key !== 'composition.mark',\n      ),\n    ];\n    this._compositions = Object.fromEntries(\n      compositions.map((key) => {\n        const name = key.split('.').pop();\n        @defineProps(nodeProps(this._marks))\n        class Composition extends CompositionNode {\n          constructor() {\n            super({}, name);\n          }\n        }\n        return [name, Composition];\n      }),\n    );\n\n    for (const Ctor of Object.values(this._compositions)) {\n      defineProps(nodeProps(this._compositions))(Ctor);\n    }\n\n    for (const key of compositions) {\n      const name = key.split('.').pop();\n      this[name] = function () {\n        const Composition = this._compositions[name];\n        this.type = null;\n        return this.append(Composition);\n      };\n    }\n  }\n\n  private _reset() {\n    const KEYS = ['theme', 'type', 'width', 'height', 'autoFit'];\n    this.type = 'view';\n    this.value = Object.fromEntries(\n      Object.entries(this.value).filter(\n        ([key]) =>\n          key.startsWith('margin') ||\n          key.startsWith('padding') ||\n          key.startsWith('inset') ||\n          KEYS.includes(key),\n      ),\n    );\n    this.children = [];\n  }\n\n  private _renderTrailing() {\n    if (!this._trailing) return;\n    this._trailing = false;\n    this.render()\n      .then(() => {\n        const trailingResolve = this._trailingResolve.bind(this);\n        this._trailingResolve = null;\n        trailingResolve(this);\n      })\n      .catch((error) => {\n        const trailingReject = this._trailingReject.bind(this);\n        this._trailingReject = null;\n        trailingReject(error);\n      });\n  }\n\n  private _createResolve(resolve: (chart: Runtime<Spec>) => void) {\n    return () => {\n      this._rendering = false;\n      resolve(this);\n    };\n  }\n\n  private _createReject(reject: (error: Error) => void) {\n    return (error: Error) => {\n      this._rendering = false;\n      reject(error);\n    };\n  }\n\n  // Update actual size and key.\n  private _computedOptions() {\n    const options = this.options();\n    const { key = G2_CHART_KEY } = options;\n    const { width, height, depth } = sizeOf(options, this._container);\n    this._width = width;\n    this._height = height;\n    this._key = key;\n    return { key: this._key, ...options, width, height, depth };\n  }\n\n  // Create canvas if it does not exist.\n  // DragAndDropPlugin is for interaction.\n  // It is OK to register more than one time, G will handle this.\n  private _createCanvas() {\n    const { width, height } = sizeOf(this.options(), this._container);\n    this._plugins.push(new DragAndDropPlugin());\n    this._plugins.forEach((d) => this._renderer.registerPlugin(d));\n    this._context.canvas = new GCanvas({\n      container: this._container,\n      width,\n      height,\n      renderer: this._renderer,\n    });\n  }\n\n  private _addToTrailing(): Promise<Runtime<Spec>> {\n    // Resolve previous promise, and give up this task.\n    this._trailingResolve?.(this);\n\n    // Create new task.\n    this._trailing = true;\n    const promise = new Promise<Runtime<Spec>>((resolve, reject) => {\n      this._trailingResolve = resolve;\n      this._trailingReject = reject;\n    });\n\n    return promise;\n  }\n\n  private _onResize = debounce(() => {\n    this.forceFit();\n  }, 300);\n\n  private _bindAutoFit() {\n    const options = this.options();\n    const { autoFit } = options;\n\n    if (this._hasBindAutoFit) {\n      // If it was bind before, unbind it now.\n      if (!autoFit) this._unbindAutoFit();\n      return;\n    }\n\n    if (autoFit) {\n      this._hasBindAutoFit = true;\n      window.addEventListener('resize', this._onResize);\n    }\n  }\n\n  private _unbindAutoFit() {\n    if (this._hasBindAutoFit) {\n      this._hasBindAutoFit = false;\n      window.removeEventListener('resize', this._onResize);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}