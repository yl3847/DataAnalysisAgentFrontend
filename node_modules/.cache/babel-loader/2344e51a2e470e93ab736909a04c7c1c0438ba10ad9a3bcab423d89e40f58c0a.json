{"ast":null,"code":"/**\n * <zh/> points 转化为 path 路径\n *\n * <en/> points transform path.\n * @param points Point[]\n * @param isClose boolean\n * @returns path string[][]\n */\nexport function pointsToPath(points, isClose = true) {\n  const path = [];\n  points.forEach((point, index) => {\n    path.push([index === 0 ? 'M' : 'L', ...point]);\n  });\n  if (isClose) {\n    path.push(['Z']);\n  }\n  return path;\n}\nconst PATH_COMMANDS = {\n  M: ['x', 'y'],\n  m: ['dx', 'dy'],\n  H: ['x'],\n  h: ['dx'],\n  V: ['y'],\n  v: ['dy'],\n  L: ['x', 'y'],\n  l: ['dx', 'dy'],\n  Z: [],\n  z: [],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  c: ['dx1', 'dy1', 'dx2', 'dy2', 'dx', 'dy'],\n  S: ['x2', 'y2', 'x', 'y'],\n  s: ['dx2', 'dy2', 'dx', 'dy'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  q: ['dx1', 'dy1', 'dx', 'dy'],\n  T: ['x', 'y'],\n  t: ['dx', 'dy'],\n  A: ['rx', 'ry', 'rotation', 'large-arc', 'sweep', 'x', 'y'],\n  a: ['rx', 'ry', 'rotation', 'large-arc', 'sweep', 'dx', 'dy']\n};\n/**\n * <zh/> 将路径字符串转换为路径段数组\n *\n * <en/> Convert a path string to an array of path segments.\n * @param path - <zh/> 路径字符串 | <en/> path string\n * @returns <zh/> 路径段数组 | <en/> path segment array\n */\nexport function parsePath(path) {\n  const items = path.replace(/[\\n\\r]/g, '').replace(/-/g, ' -').replace(/(\\d*\\.)(\\d+)(?=\\.)/g, '$1$2 ').trim().split(/\\s*,|\\s+/);\n  const segments = [];\n  let currentCommand = '';\n  let currentElement = {};\n  while (items.length > 0) {\n    let it = items.shift();\n    if (it in PATH_COMMANDS) {\n      currentCommand = it;\n    } else {\n      items.unshift(it);\n    }\n    currentElement = {\n      type: currentCommand\n    };\n    PATH_COMMANDS[currentCommand].forEach(prop => {\n      it = items.shift(); // TODO sanity check\n      currentElement[prop] = it;\n    });\n    if (currentCommand === 'M') {\n      currentCommand = 'L';\n    } else if (currentCommand === 'm') {\n      currentCommand = 'l';\n    }\n    const [type, ...values] = Object.values(currentElement);\n    segments.push([type, ...values.map(Number)]);\n  }\n  return segments;\n}\n/**\n * <zh/> 将路径转换为点数组\n *\n * <en/> Convert path to points array\n * @param path - <zh/> 路径数组 <en/> path array\n * @returns\n */\nexport function pathToPoints(path) {\n  const points = [];\n  const segments = typeof path === 'string' ? parsePath(path) : path;\n  segments.forEach(seg => {\n    const command = seg[0];\n    if (command === 'Z') {\n      points.push(points[0]);\n      return;\n    }\n    if (command !== 'A') {\n      for (let i = 1; i < seg.length; i = i + 2) {\n        points.push([seg[i], seg[i + 1], 0]);\n      }\n    } else {\n      const length = seg.length;\n      points.push([seg[length - 2], seg[length - 1], 0]);\n    }\n  });\n  return points;\n}\n/**\n * <zh/> 生成平滑闭合曲线\n *\n * <en/> Generate smooth closed curves\n * @param points - <zh/> 点集 | <en/> points\n * @returns <zh/> 平滑闭合曲线 | <en/> smooth closed curves\n */\nexport const getClosedSpline = points => {\n  if (points.length < 2) return [['M', 0, 0], ['L', 0, 0]];\n  const first = points[0];\n  const second = points[1];\n  const last = points[points.length - 1];\n  const lastSecond = points[points.length - 2];\n  points.unshift(lastSecond, last);\n  points.push(first, second);\n  const closedPath = [['M', last[0], last[1]]];\n  for (let i = 1; i < points.length - 2; i += 1) {\n    const [x0, y0] = points[i - 1];\n    const [x1, y1] = points[i];\n    const [x2, y2] = points[i + 1];\n    const [x3, y3] = i !== points.length - 2 ? points[i + 2] : [x2, y2];\n    const cp1x = x1 + (x2 - x0) / 6;\n    const cp1y = y1 + (y2 - y0) / 6;\n    const cp2x = x2 - (x3 - x1) / 6;\n    const cp2y = y2 - (y3 - y1) / 6;\n    closedPath.push(['C', cp1x, cp1y, cp2x, cp2y, x2, y2]);\n  }\n  return closedPath;\n};","map":{"version":3,"names":["pointsToPath","points","isClose","path","forEach","point","index","push","PATH_COMMANDS","M","m","H","h","V","v","L","l","Z","z","C","c","S","s","Q","q","T","t","A","a","parsePath","items","replace","trim","split","segments","currentCommand","currentElement","length","it","shift","unshift","type","prop","values","Object","map","Number","pathToPoints","seg","command","i","getClosedSpline","first","second","last","lastSecond","closedPath","x0","y0","x1","y1","x2","y2","x3","y3","cp1x","cp1y","cp2x","cp2y"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/path.ts"],"sourcesContent":["import type { PathArray, PathCommand } from '@antv/util';\nimport type { Point } from '../types';\n\n/**\n * <zh/> points 转化为 path 路径\n *\n * <en/> points transform path.\n * @param points Point[]\n * @param isClose boolean\n * @returns path string[][]\n */\nexport function pointsToPath(points: Point[], isClose = true): PathArray {\n  const path = [];\n\n  points.forEach((point, index) => {\n    path.push([index === 0 ? 'M' : 'L', ...point]);\n  });\n\n  if (isClose) {\n    path.push(['Z']);\n  }\n  return path as PathArray;\n}\n\nconst PATH_COMMANDS: Record<PathCommand, string[]> = {\n  M: ['x', 'y'],\n  m: ['dx', 'dy'],\n  H: ['x'],\n  h: ['dx'],\n  V: ['y'],\n  v: ['dy'],\n  L: ['x', 'y'],\n  l: ['dx', 'dy'],\n  Z: [],\n  z: [],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  c: ['dx1', 'dy1', 'dx2', 'dy2', 'dx', 'dy'],\n  S: ['x2', 'y2', 'x', 'y'],\n  s: ['dx2', 'dy2', 'dx', 'dy'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  q: ['dx1', 'dy1', 'dx', 'dy'],\n  T: ['x', 'y'],\n  t: ['dx', 'dy'],\n  A: ['rx', 'ry', 'rotation', 'large-arc', 'sweep', 'x', 'y'],\n  a: ['rx', 'ry', 'rotation', 'large-arc', 'sweep', 'dx', 'dy'],\n};\n\n/**\n * <zh/> 将路径字符串转换为路径段数组\n *\n * <en/> Convert a path string to an array of path segments.\n * @param path - <zh/> 路径字符串 | <en/> path string\n * @returns <zh/> 路径段数组 | <en/> path segment array\n */\nexport function parsePath(path: string): PathArray {\n  const items = path\n    .replace(/[\\n\\r]/g, '')\n    .replace(/-/g, ' -')\n    .replace(/(\\d*\\.)(\\d+)(?=\\.)/g, '$1$2 ')\n    .trim()\n    .split(/\\s*,|\\s+/);\n  const segments = [];\n  let currentCommand = '' as PathCommand;\n  let currentElement: Record<string, any> = {};\n  while (items.length > 0) {\n    let it = items.shift()!;\n    if (it in PATH_COMMANDS) {\n      currentCommand = it as PathCommand;\n    } else {\n      items.unshift(it);\n    }\n    currentElement = { type: currentCommand };\n    PATH_COMMANDS[currentCommand].forEach((prop) => {\n      it = items.shift()!; // TODO sanity check\n      currentElement[prop] = it;\n    });\n    if (currentCommand === 'M') {\n      currentCommand = 'L';\n    } else if (currentCommand === 'm') {\n      currentCommand = 'l';\n    }\n    const [type, ...values] = Object.values(currentElement);\n    segments.push([type, ...values.map(Number)]);\n  }\n  return segments as unknown as PathArray;\n}\n\n/**\n * <zh/> 将路径转换为点数组\n *\n * <en/> Convert path to points array\n * @param path - <zh/> 路径数组 <en/> path array\n * @returns\n */\nexport function pathToPoints(path: string | PathArray): Point[] {\n  const points: Point[] = [];\n  const segments = typeof path === 'string' ? parsePath(path) : path;\n\n  segments.forEach((seg) => {\n    const command = seg[0];\n    if (command === 'Z') {\n      points.push(points[0]);\n      return;\n    }\n    if (command !== 'A') {\n      for (let i = 1; i < seg.length; i = i + 2) {\n        points.push([seg[i] as number, seg[i + 1] as number, 0]);\n      }\n    } else {\n      const length = seg.length;\n      points.push([seg[length - 2] as number, seg[length - 1] as number, 0]);\n    }\n  });\n  return points;\n}\n\n/**\n * <zh/> 生成平滑闭合曲线\n *\n * <en/> Generate smooth closed curves\n * @param points - <zh/> 点集 | <en/> points\n * @returns <zh/> 平滑闭合曲线 | <en/> smooth closed curves\n */\nexport const getClosedSpline = (points: Point[]): PathArray => {\n  if (points.length < 2)\n    return [\n      ['M', 0, 0],\n      ['L', 0, 0],\n    ];\n  const first = points[0];\n  const second = points[1];\n  const last = points[points.length - 1];\n  const lastSecond = points[points.length - 2];\n\n  points.unshift(lastSecond, last);\n  points.push(first, second);\n\n  const closedPath = [['M', last[0], last[1]]];\n  for (let i = 1; i < points.length - 2; i += 1) {\n    const [x0, y0] = points[i - 1];\n    const [x1, y1] = points[i];\n    const [x2, y2] = points[i + 1];\n    const [x3, y3] = i !== points.length - 2 ? points[i + 2] : [x2, y2];\n\n    const cp1x = x1 + (x2 - x0) / 6;\n    const cp1y = y1 + (y2 - y0) / 6;\n    const cp2x = x2 - (x3 - x1) / 6;\n    const cp2y = y2 - (y3 - y1) / 6;\n    closedPath.push(['C', cp1x, cp1y, cp2x, cp2y, x2, y2]);\n  }\n\n  return closedPath as PathArray;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}