{"ast":null,"code":"import { isEmpty } from '@antv/util';\nimport { GraphEvent } from '../../constants';\nimport { getPolylinePath } from '../../utils/edge';\nimport { idOf } from '../../utils/id';\nimport { positionOf } from '../../utils/position';\nimport { add, distance, divide, dot, multiply, subtract, toVector2 } from '../../utils/vector';\nimport { BasePlugin } from '../base-plugin';\n/**\n * <zh/> 边绑定\n *\n * <en/> Edge bundling\n * @remarks\n * <zh/> 边绑定（Edge Bundling）是一种图可视化技术，用于减少复杂网络图中的视觉混乱，并揭示图中的高级别模式和结构。其思想是将相邻的边捆绑在一起。\n *\n * <zh/> G6 中提供的边绑定插件是基于 FEDB（Force-Directed Edge Bundling for Graph Visualization）一文的实现：将边建模为可以相互吸引的柔性弹簧，通过自组织的方式进行捆绑。\n *\n * <en/> Edge bundling is a graph visualization technique used to reduce visual clutter in complex network graphs and reveal high-level patterns and structures in the graph. The idea is to bundle adjacent edges together.\n *\n * <en/> The edge bundling plugin provided in G6 is based on the implementation of the paper FEDB (Force-Directed Edge Bundling for Graph Visualization): modeling edges as flexible springs that can attract each other and bundling them in a self-organizing way.\n */\nexport class EdgeBundling extends BasePlugin {\n  constructor(context, options) {\n    super(context, Object.assign({}, EdgeBundling.defaultOptions, options));\n    this.edgeBundles = {};\n    this.edgePoints = {};\n    this.onBundle = () => {\n      const {\n        model,\n        element\n      } = this.context;\n      const edges = model.getEdgeData();\n      this.divideEdges(this.options.divisions);\n      const {\n        cycles,\n        iterRate,\n        divRate\n      } = this.options;\n      let {\n        lambda,\n        divisions,\n        iterations\n      } = this.options;\n      for (let i = 0; i < cycles; i++) {\n        for (let j = 0; j < iterations; j++) {\n          const forces = {};\n          edges.forEach(edge => {\n            var _a;\n            if (edge.source === edge.target) return;\n            const edgeId = idOf(edge);\n            forces[edgeId] = this.getEdgeForces(edge, divisions, lambda);\n            for (let p = 0; p < divisions + 1; p++) {\n              (_a = this.edgePoints)[edgeId] || (_a[edgeId] = []);\n              this.edgePoints[edgeId][p] = add(this.edgePoints[edgeId][p], forces[edgeId][p]);\n            }\n          });\n        }\n        // parameters for next cycle\n        lambda /= 2;\n        divisions *= divRate;\n        iterations *= iterRate;\n        this.divideEdges(divisions);\n      }\n      edges.forEach(edge => {\n        const edgeId = idOf(edge);\n        const edgeEl = element.getElement(edgeId);\n        edgeEl === null || edgeEl === void 0 ? void 0 : edgeEl.update({\n          d: getPolylinePath(this.edgePoints[edgeId])\n        });\n      });\n    };\n    this.bindEvents();\n  }\n  get nodeMap() {\n    const nodes = this.context.model.getNodeData();\n    return Object.fromEntries(nodes.map(node => [idOf(node), toVector2(positionOf(node))]));\n  }\n  divideEdges(divisions) {\n    const edges = this.context.model.getEdgeData();\n    edges.forEach(edge => {\n      var _a;\n      const edgeId = idOf(edge);\n      (_a = this.edgePoints)[edgeId] || (_a[edgeId] = []);\n      const source = this.nodeMap[edge.source];\n      const target = this.nodeMap[edge.target];\n      if (divisions === 1) {\n        this.edgePoints[edgeId].push(source);\n        this.edgePoints[edgeId].push(divide(add(source, target), 2));\n        this.edgePoints[edgeId].push(target);\n      } else {\n        const edgeLength = this.edgePoints[edgeId].length === 0 ?\n        // edge is a straight line\n        distance(source, target) :\n        // edge is a polyline\n        getEdgeLength(this.edgePoints[edgeId]);\n        const divisionLength = edgeLength / (divisions + 1);\n        let currentDivisionLength = divisionLength;\n        const newEdgePoints = [source];\n        for (let i = 1; i < this.edgePoints[edgeId].length; i++) {\n          const prevEp = this.edgePoints[edgeId][i - 1];\n          const ep = this.edgePoints[edgeId][i];\n          let oriDivisionLength = distance(ep, prevEp);\n          while (oriDivisionLength > currentDivisionLength) {\n            const ratio = currentDivisionLength / oriDivisionLength;\n            const edgePoint = add(prevEp, multiply(subtract(ep, prevEp), ratio));\n            newEdgePoints.push(edgePoint);\n            oriDivisionLength -= currentDivisionLength;\n            currentDivisionLength = divisionLength;\n          }\n          currentDivisionLength -= oriDivisionLength;\n        }\n        newEdgePoints.push(target);\n        this.edgePoints[edgeId] = newEdgePoints;\n      }\n    });\n  }\n  getVectorPosition(edge) {\n    const source = this.nodeMap[edge.source];\n    const target = this.nodeMap[edge.target];\n    const [vx, vy] = subtract(target, source);\n    const length = distance(source, target);\n    return {\n      source,\n      target,\n      vx,\n      vy,\n      length\n    };\n  }\n  measureEdgeCompatibility(edge1, edge2) {\n    const vector1 = this.getVectorPosition(edge1);\n    const vector2 = this.getVectorPosition(edge2);\n    const ac = getAngleCompatibility(vector1, vector2);\n    const sc = getScaleCompatibility(vector1, vector2);\n    const pc = getPositionCompatibility(vector1, vector2);\n    const vc = getVisibilityCompatibility(vector1, vector2);\n    return ac * sc * pc * vc;\n  }\n  getEdgeBundles() {\n    const edgeBundles = {};\n    const bundleThreshold = this.options.bundleThreshold;\n    const edges = this.context.model.getEdgeData();\n    edges.forEach((edge1, i) => {\n      edges.forEach((edge2, j) => {\n        var _a, _b;\n        if (j <= i) return;\n        const compatibility = this.measureEdgeCompatibility(edge1, edge2);\n        if (compatibility >= bundleThreshold) {\n          edgeBundles[_a = idOf(edge1)] || (edgeBundles[_a] = []);\n          edgeBundles[idOf(edge1)].push(edge2);\n          edgeBundles[_b = idOf(edge2)] || (edgeBundles[_b] = []);\n          edgeBundles[idOf(edge2)].push(edge1);\n        }\n      });\n    });\n    return edgeBundles;\n  }\n  getSpringForce(divisions, kp) {\n    const {\n      pre,\n      cur,\n      next\n    } = divisions;\n    return multiply(subtract(add(pre, next), multiply(cur, 2)), kp);\n  }\n  getElectrostaticForce(pidx, edge) {\n    if (isEmpty(this.edgeBundles)) {\n      this.edgeBundles = this.getEdgeBundles();\n    }\n    const edgeBundle = this.edgeBundles[idOf(edge)];\n    let resForce = [0, 0];\n    edgeBundle === null || edgeBundle === void 0 ? void 0 : edgeBundle.forEach(eb => {\n      const p1 = this.edgePoints[idOf(eb)][pidx];\n      const p2 = this.edgePoints[idOf(edge)][pidx];\n      const force = subtract(p1, p2);\n      const length = distance(p1, p2);\n      resForce = add(resForce, multiply(force, 1 / length));\n    });\n    return resForce;\n  }\n  getEdgeForces(edge, divisions, lambda) {\n    const source = this.nodeMap[edge.source];\n    const target = this.nodeMap[edge.target];\n    const kp = this.options.K / (distance(source, target) * (divisions + 1));\n    const edgePointForces = [[0, 0]];\n    const edgeId = idOf(edge);\n    for (let i = 1; i < divisions; i++) {\n      const spring = this.getSpringForce({\n        pre: this.edgePoints[edgeId][i - 1],\n        cur: this.edgePoints[edgeId][i],\n        next: this.edgePoints[edgeId][i + 1] || [0, 0]\n      }, kp);\n      const electrostatic = this.getElectrostaticForce(i, edge);\n      edgePointForces.push(multiply(add(spring, electrostatic), lambda));\n    }\n    edgePointForces.push([0, 0]);\n    return edgePointForces;\n  }\n  bindEvents() {\n    const {\n      graph\n    } = this.context;\n    graph.on(GraphEvent.AFTER_RENDER, this.onBundle);\n  }\n  unbindEvents() {\n    const {\n      graph\n    } = this.context;\n    graph.off(GraphEvent.AFTER_RENDER, this.onBundle);\n  }\n  destroy() {\n    this.unbindEvents();\n    super.destroy();\n  }\n}\nEdgeBundling.defaultOptions = {\n  K: 0.1,\n  lambda: 0.1,\n  divisions: 1,\n  divRate: 2,\n  cycles: 6,\n  iterations: 90,\n  iterRate: 2 / 3,\n  bundleThreshold: 0.6\n};\n// The larger the angle between edges P and Q, the smaller Ca(P,Q).\n// Ca(P,Q) is 0 if P and Q are orthogonal and 1 if P and Q are parallel.\nconst getAngleCompatibility = (p, q) => {\n  return Math.abs(dot([p.vx, p.vy], [q.vx, q.vy]) / (p.length * q.length));\n};\n// Cs(P,Q) is 1 if P and Q have equal length and approaches 0 if the ratio between the longest and the shortest edge approaches ∞.\nconst getScaleCompatibility = (p, q) => {\n  const aLength = (p.length + q.length) / 2;\n  return 2 / (aLength / Math.min(p.length, q.length) + Math.max(p.length, q.length) / aLength);\n};\n// Cp(P,Q) is 1 if Pm and Qm coincide and approaches 0 if ||Pm −Qm|| approaches ∞.\nconst getPositionCompatibility = (p, q) => {\n  const aLength = (p.length + q.length) / 2;\n  const pMid = divide(add(p.source, p.target), 2);\n  const qMid = divide(add(q.source, q.target), 2);\n  return aLength / (aLength + distance(pMid, qMid));\n};\nconst projectPointToEdge = (p, e) => {\n  if (e.source[0] === e.target[0]) return [e.source[0], p[1]];\n  if (e.source[1] === e.target[1]) return [p[0], e.source[1]];\n  const k = (e.source[1] - e.target[1]) / (e.source[0] - e.target[0]);\n  const x = (k * k * e.source[0] + k * (p[1] - e.source[1]) + p[0]) / (k * k + 1);\n  const y = k * (x - e.source[0]) + e.source[1];\n  return [x, y];\n};\nconst getEdgeVisibility = (p, q) => {\n  const is = projectPointToEdge(q.source, p);\n  const it = projectPointToEdge(q.target, p);\n  const iMid = divide(add(is, it), 2);\n  const pMid = divide(add(p.source, p.target), 2);\n  if (distance(is, it) === 0) return 0;\n  return Math.max(0, 1 - 2 * distance(pMid, iMid) / distance(is, it));\n};\nconst getVisibilityCompatibility = (p, q) => {\n  return Math.min(getEdgeVisibility(p, q), getEdgeVisibility(q, p));\n};\n/**\n * Calculate the length of a polyline\n * @param points - The points of the polyline\n * @returns The length of the polyline\n */\nconst getEdgeLength = points => {\n  let length = 0;\n  for (let i = 1; i < points.length; i++) {\n    length += distance(points[i], points[i - 1]);\n  }\n  return length;\n};","map":{"version":3,"names":["isEmpty","GraphEvent","getPolylinePath","idOf","positionOf","add","distance","divide","dot","multiply","subtract","toVector2","BasePlugin","EdgeBundling","constructor","context","options","Object","assign","defaultOptions","edgeBundles","edgePoints","onBundle","model","element","edges","getEdgeData","divideEdges","divisions","cycles","iterRate","divRate","lambda","iterations","i","j","forces","forEach","edge","source","target","edgeId","getEdgeForces","p","_a","edgeEl","getElement","update","d","bindEvents","nodeMap","nodes","getNodeData","fromEntries","map","node","push","edgeLength","length","getEdgeLength","divisionLength","currentDivisionLength","newEdgePoints","prevEp","ep","oriDivisionLength","ratio","edgePoint","getVectorPosition","vx","vy","measureEdgeCompatibility","edge1","edge2","vector1","vector2","ac","getAngleCompatibility","sc","getScaleCompatibility","pc","getPositionCompatibility","vc","getVisibilityCompatibility","getEdgeBundles","bundleThreshold","compatibility","_b","getSpringForce","kp","pre","cur","next","getElectrostaticForce","pidx","edgeBundle","resForce","eb","p1","p2","force","K","edgePointForces","spring","electrostatic","graph","on","AFTER_RENDER","unbindEvents","off","destroy","q","Math","abs","aLength","min","max","pMid","qMid","projectPointToEdge","e","k","x","y","getEdgeVisibility","is","it","iMid","points"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/plugins/edge-bundling/index.ts"],"sourcesContent":["import { isEmpty } from '@antv/util';\nimport { GraphEvent } from '../../constants';\nimport type { RuntimeContext } from '../../runtime/types';\nimport type { EdgeData } from '../../spec';\nimport type { ID, Point } from '../../types';\nimport { getPolylinePath } from '../../utils/edge';\nimport { idOf } from '../../utils/id';\nimport { positionOf } from '../../utils/position';\nimport { add, distance, divide, dot, multiply, subtract, toVector2 } from '../../utils/vector';\nimport type { BasePluginOptions } from '../base-plugin';\nimport { BasePlugin } from '../base-plugin';\n\n/**\n * <zh/> 边绑定插件的配置项\n *\n * <en/> Edge bundling options\n */\nexport interface EdgeBundlingOptions extends BasePluginOptions {\n  /**\n   * <zh/> 边的强度\n   *\n   * <en/> The strength of the edge\n   * @defaultValue 0.1\n   */\n  K?: number;\n  /**\n   * <zh/> 初始步长。在后续的周期中，步长将双倍递增\n   *\n   * <en/> An initial step size. In subsequent cycles, the step size will double incrementally\n   * @defaultValue 0.1\n   */\n  lambda?: number;\n  /**\n   * <zh/> 模拟周期数\n   *\n   * <en/> The number of simulation cycles\n   * @defaultValue 6\n   */\n  cycles?: number;\n  /**\n   * <zh/> 初始切割点数。在后续的周期中，切割点数将根据 `divRate` 逐步递增\n   *\n   * <en/> An initial number of subdivision points for each edge. In subsequent cycles, the number of subdivision points will increase gradually according to `divRate`\n   * @defaultValue 1\n   */\n  divisions?: number;\n  /**\n   * <zh/> 切割点数增长率\n   *\n   * <en/> The rate at which the number of subdivision points increases\n   * @defaultValue 2\n   */\n  divRate?: number;\n  /**\n   * <zh/> 指定在第一个周期中执行的迭代次数。在后续的周期中，迭代次数将根据 `iterRate` 逐步递减\n   *\n   * <en/> The number of iteration steps during the first cycle. In subsequent cycles, the number of iterations will decrease gradually according to `iterRate`\n   * @defaultValue 90\n   */\n  iterations?: number;\n  /**\n   * <zh/> 迭代次数递减率\n   *\n   * <en/> The rate at which the number of iterations decreases\n   * @defaultValue 2 / 3\n   */\n  iterRate?: number;\n  /**\n   * <zh/> 边兼容性阈值，决定了哪些边应该被绑定在一起\n   *\n   * <en/> Edge compatibility threshold, which determines which edges should be bundled together\n   * @defaultValue 0.6\n   */\n  bundleThreshold?: number;\n}\n\n/**\n * <zh/> 边绑定\n *\n * <en/> Edge bundling\n * @remarks\n * <zh/> 边绑定（Edge Bundling）是一种图可视化技术，用于减少复杂网络图中的视觉混乱，并揭示图中的高级别模式和结构。其思想是将相邻的边捆绑在一起。\n *\n * <zh/> G6 中提供的边绑定插件是基于 FEDB（Force-Directed Edge Bundling for Graph Visualization）一文的实现：将边建模为可以相互吸引的柔性弹簧，通过自组织的方式进行捆绑。\n *\n * <en/> Edge bundling is a graph visualization technique used to reduce visual clutter in complex network graphs and reveal high-level patterns and structures in the graph. The idea is to bundle adjacent edges together.\n *\n * <en/> The edge bundling plugin provided in G6 is based on the implementation of the paper FEDB (Force-Directed Edge Bundling for Graph Visualization): modeling edges as flexible springs that can attract each other and bundling them in a self-organizing way.\n */\nexport class EdgeBundling extends BasePlugin<EdgeBundlingOptions> {\n  static defaultOptions: Partial<EdgeBundlingOptions> = {\n    K: 0.1,\n    lambda: 0.1,\n    divisions: 1,\n    divRate: 2,\n    cycles: 6,\n    iterations: 90,\n    iterRate: 2 / 3,\n    bundleThreshold: 0.6,\n  };\n\n  constructor(context: RuntimeContext, options?: EdgeBundlingOptions) {\n    super(context, Object.assign({}, EdgeBundling.defaultOptions, options));\n    this.bindEvents();\n  }\n\n  private edgeBundles: Record<ID, EdgeData[]> = {};\n\n  private edgePoints: Record<ID, Point[]> = {};\n\n  private get nodeMap(): Record<ID, Point> {\n    const nodes = this.context.model.getNodeData();\n    return Object.fromEntries(nodes.map((node) => [idOf(node), toVector2(positionOf(node))]));\n  }\n\n  private divideEdges(divisions: number) {\n    const edges = this.context.model.getEdgeData();\n\n    edges.forEach((edge) => {\n      const edgeId = idOf(edge);\n      this.edgePoints[edgeId] ||= [];\n\n      const source = this.nodeMap[edge.source];\n      const target = this.nodeMap[edge.target];\n\n      if (divisions === 1) {\n        this.edgePoints[edgeId].push(source);\n        this.edgePoints[edgeId].push(divide(add(source, target), 2));\n        this.edgePoints[edgeId].push(target);\n      } else {\n        const edgeLength =\n          this.edgePoints[edgeId].length === 0\n            ? // edge is a straight line\n              distance(source, target)\n            : // edge is a polyline\n              getEdgeLength(this.edgePoints[edgeId]);\n\n        const divisionLength = edgeLength / (divisions + 1);\n        let currentDivisionLength = divisionLength;\n\n        const newEdgePoints: Point[] = [source];\n\n        for (let i = 1; i < this.edgePoints[edgeId].length; i++) {\n          const prevEp = this.edgePoints[edgeId][i - 1];\n          const ep = this.edgePoints[edgeId][i];\n          let oriDivisionLength = distance(ep, prevEp);\n\n          while (oriDivisionLength > currentDivisionLength) {\n            const ratio = currentDivisionLength / oriDivisionLength;\n            const edgePoint = add(prevEp, multiply(subtract(ep, prevEp), ratio));\n            newEdgePoints.push(edgePoint);\n\n            oriDivisionLength -= currentDivisionLength;\n            currentDivisionLength = divisionLength;\n          }\n\n          currentDivisionLength -= oriDivisionLength;\n        }\n\n        newEdgePoints.push(target);\n        this.edgePoints[edgeId] = newEdgePoints;\n      }\n    });\n  }\n\n  private getVectorPosition(edge: EdgeData): VectorPosition {\n    const source = this.nodeMap[edge.source];\n    const target = this.nodeMap[edge.target];\n    const [vx, vy] = subtract(target, source);\n    const length = distance(source, target);\n    return { source, target, vx, vy, length };\n  }\n\n  private measureEdgeCompatibility(edge1: EdgeData, edge2: EdgeData) {\n    const vector1 = this.getVectorPosition(edge1);\n    const vector2 = this.getVectorPosition(edge2);\n\n    const ac = getAngleCompatibility(vector1, vector2);\n    const sc = getScaleCompatibility(vector1, vector2);\n    const pc = getPositionCompatibility(vector1, vector2);\n    const vc = getVisibilityCompatibility(vector1, vector2);\n\n    return ac * sc * pc * vc;\n  }\n\n  private getEdgeBundles() {\n    const edgeBundles: Record<ID, EdgeData[]> = {};\n    const bundleThreshold = this.options.bundleThreshold;\n    const edges = this.context.model.getEdgeData();\n\n    edges.forEach((edge1, i) => {\n      edges.forEach((edge2, j) => {\n        if (j <= i) return;\n\n        const compatibility = this.measureEdgeCompatibility(edge1, edge2);\n        if (compatibility >= bundleThreshold) {\n          edgeBundles[idOf(edge1)] ||= [];\n          edgeBundles[idOf(edge1)].push(edge2);\n          edgeBundles[idOf(edge2)] ||= [];\n          edgeBundles[idOf(edge2)].push(edge1);\n        }\n      });\n    });\n    return edgeBundles;\n  }\n\n  private getSpringForce(divisions: { pre: Point; cur: Point; next: Point }, kp: number): Point {\n    const { pre, cur, next } = divisions;\n    return multiply(subtract(add(pre, next), multiply(cur, 2)), kp);\n  }\n\n  private getElectrostaticForce(pidx: number, edge: EdgeData): Point {\n    if (isEmpty(this.edgeBundles)) {\n      this.edgeBundles = this.getEdgeBundles();\n    }\n\n    const edgeBundle = this.edgeBundles[idOf(edge)];\n    let resForce: Point = [0, 0];\n\n    edgeBundle?.forEach((eb) => {\n      const p1 = this.edgePoints[idOf(eb)][pidx];\n      const p2 = this.edgePoints[idOf(edge)][pidx];\n      const force = subtract(p1, p2);\n      const length = distance(p1, p2);\n      resForce = add(resForce, multiply(force, 1 / length));\n    });\n\n    return resForce;\n  }\n\n  private getEdgeForces(edge: EdgeData, divisions: number, lambda: number): Point[] {\n    const source = this.nodeMap[edge.source];\n    const target = this.nodeMap[edge.target];\n    const kp = this.options.K / (distance(source, target) * (divisions + 1));\n    const edgePointForces: Point[] = [[0, 0]];\n    const edgeId = idOf(edge);\n\n    for (let i = 1; i < divisions; i++) {\n      const spring = this.getSpringForce(\n        {\n          pre: this.edgePoints[edgeId][i - 1],\n          cur: this.edgePoints[edgeId][i],\n          next: this.edgePoints[edgeId][i + 1] || [0, 0],\n        },\n        kp,\n      );\n      const electrostatic = this.getElectrostaticForce(i, edge);\n      edgePointForces.push(multiply(add(spring, electrostatic), lambda));\n    }\n\n    edgePointForces.push([0, 0]);\n\n    return edgePointForces;\n  }\n\n  protected onBundle = () => {\n    const { model, element } = this.context;\n    const edges = model.getEdgeData();\n    this.divideEdges(this.options.divisions);\n\n    const { cycles, iterRate, divRate } = this.options;\n    let { lambda, divisions, iterations } = this.options;\n    for (let i = 0; i < cycles; i++) {\n      for (let j = 0; j < iterations; j++) {\n        const forces: Record<ID, Point[]> = {};\n        edges.forEach((edge) => {\n          if (edge.source === edge.target) return;\n          const edgeId = idOf(edge);\n          forces[edgeId] = this.getEdgeForces(edge, divisions, lambda);\n\n          for (let p = 0; p < divisions + 1; p++) {\n            this.edgePoints[edgeId] ||= [];\n            this.edgePoints[edgeId][p] = add(this.edgePoints[edgeId][p], forces[edgeId][p]);\n          }\n        });\n      }\n\n      // parameters for next cycle\n      lambda /= 2;\n      divisions *= divRate;\n      iterations *= iterRate;\n      this.divideEdges(divisions);\n    }\n\n    edges.forEach((edge) => {\n      const edgeId = idOf(edge);\n      const edgeEl = element!.getElement(edgeId);\n      edgeEl?.update({ d: getPolylinePath(this.edgePoints[edgeId]) });\n    });\n  };\n\n  private bindEvents() {\n    const { graph } = this.context;\n\n    graph.on(GraphEvent.AFTER_RENDER, this.onBundle);\n  }\n\n  private unbindEvents() {\n    const { graph } = this.context;\n\n    graph.off(GraphEvent.AFTER_RENDER, this.onBundle);\n  }\n\n  public destroy(): void {\n    this.unbindEvents();\n    super.destroy();\n  }\n}\n\ninterface VectorPosition {\n  source: Point;\n  target: Point;\n  vx: number;\n  vy: number;\n  length: number;\n}\n\n// The larger the angle between edges P and Q, the smaller Ca(P,Q).\n// Ca(P,Q) is 0 if P and Q are orthogonal and 1 if P and Q are parallel.\nconst getAngleCompatibility = (p: VectorPosition, q: VectorPosition): number => {\n  return Math.abs(dot([p.vx, p.vy], [q.vx, q.vy]) / (p.length * q.length));\n};\n\n// Cs(P,Q) is 1 if P and Q have equal length and approaches 0 if the ratio between the longest and the shortest edge approaches ∞.\nconst getScaleCompatibility = (p: VectorPosition, q: VectorPosition): number => {\n  const aLength = (p.length + q.length) / 2;\n  return 2 / (aLength / Math.min(p.length, q.length) + Math.max(p.length, q.length) / aLength);\n};\n\n// Cp(P,Q) is 1 if Pm and Qm coincide and approaches 0 if ||Pm −Qm|| approaches ∞.\nconst getPositionCompatibility = (p: VectorPosition, q: VectorPosition): number => {\n  const aLength = (p.length + q.length) / 2;\n\n  const pMid = divide(add(p.source, p.target), 2);\n  const qMid = divide(add(q.source, q.target), 2);\n\n  return aLength / (aLength + distance(pMid, qMid));\n};\n\nconst projectPointToEdge = (p: Point, e: VectorPosition): Point => {\n  if (e.source[0] === e.target[0]) return [e.source[0], p[1]];\n  if (e.source[1] === e.target[1]) return [p[0], e.source[1]];\n  const k = (e.source[1] - e.target[1]) / (e.source[0] - e.target[0]);\n  const x = (k * k * e.source[0] + k * (p[1] - e.source[1]) + p[0]) / (k * k + 1);\n  const y = k * (x - e.source[0]) + e.source[1];\n  return [x, y];\n};\n\nconst getEdgeVisibility = (p: VectorPosition, q: VectorPosition): number => {\n  const is = projectPointToEdge(q.source, p);\n  const it = projectPointToEdge(q.target, p);\n  const iMid = divide(add(is, it), 2);\n  const pMid = divide(add(p.source, p.target), 2);\n  if (distance(is, it) === 0) return 0;\n  return Math.max(0, 1 - (2 * distance(pMid, iMid)) / distance(is, it));\n};\n\nconst getVisibilityCompatibility = (p: VectorPosition, q: VectorPosition): number => {\n  return Math.min(getEdgeVisibility(p, q), getEdgeVisibility(q, p));\n};\n\n/**\n * Calculate the length of a polyline\n * @param points - The points of the polyline\n * @returns The length of the polyline\n */\nconst getEdgeLength = (points: Point[]): number => {\n  let length = 0;\n  for (let i = 1; i < points.length; i++) {\n    length += distance(points[i], points[i - 1]);\n  }\n  return length;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}