{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Graph as Graphlib } from '@antv/graphlib';\nimport { Supervisor, isLayoutWithIterations } from '@antv/layout';\nimport { deepMix } from '@antv/util';\nimport { COMBO_KEY, GraphEvent, TREE_KEY } from '../constants';\nimport { BaseLayout } from '../layouts';\nimport { getExtension } from '../registry/get';\nimport { getAnimationOptions } from '../utils/animation';\nimport { isCollapsed } from '../utils/collapsibility';\nimport { isToBeDestroyed } from '../utils/element';\nimport { GraphLifeCycleEvent, emit } from '../utils/event';\nimport { createTreeStructure } from '../utils/graphlib';\nimport { idOf } from '../utils/id';\nimport { isTreeLayout, layoutAdapter, layoutMapping2GraphData } from '../utils/layout';\nimport { print } from '../utils/print';\nimport { dfs } from '../utils/traverse';\nexport class LayoutController {\n  get presetOptions() {\n    return {\n      animation: !!getAnimationOptions(this.context.options, true)\n    };\n  }\n  get options() {\n    const {\n      options\n    } = this.context;\n    return options.layout;\n  }\n  constructor(context) {\n    this.instances = [];\n    this.context = context;\n  }\n  getLayoutInstance() {\n    return this.instances;\n  }\n  /**\n   * <zh/> 前布局，即在绘制前执行布局\n   *\n   * <en/> Pre-layout, that is, perform layout before drawing\n   * @param data - <zh/> 绘制数据 | <en/> Draw data\n   * @remarks\n   * <zh/> 前布局应该只在首次绘制前执行，后续更新不会触发\n   *\n   * <en/> Pre-layout should only be executed before the first drawing, and subsequent updates will not trigger\n   */\n  preLayout(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c, _d;\n      const {\n        graph,\n        model\n      } = this.context;\n      const {\n        add\n      } = data;\n      emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, {\n        type: 'pre'\n      }));\n      const simulate = yield (_a = this.context.layout) === null || _a === void 0 ? void 0 : _a.simulate();\n      (_b = simulate === null || simulate === void 0 ? void 0 : simulate.nodes) === null || _b === void 0 ? void 0 : _b.forEach(l => {\n        const id = idOf(l);\n        const node = add.nodes.get(id);\n        model.syncNodeLikeDatum(l);\n        if (node) Object.assign(node.style, l.style);\n      });\n      (_c = simulate === null || simulate === void 0 ? void 0 : simulate.edges) === null || _c === void 0 ? void 0 : _c.forEach(l => {\n        const id = idOf(l);\n        const edge = add.edges.get(id);\n        model.syncEdgeDatum(l);\n        if (edge) Object.assign(edge.style, l.style);\n      });\n      (_d = simulate === null || simulate === void 0 ? void 0 : simulate.combos) === null || _d === void 0 ? void 0 : _d.forEach(l => {\n        const id = idOf(l);\n        const combo = add.combos.get(id);\n        model.syncNodeLikeDatum(l);\n        if (combo) Object.assign(combo.style, l.style);\n      });\n      emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, {\n        type: 'pre'\n      }));\n      this.transformDataAfterLayout('pre', data);\n    });\n  }\n  /**\n   * <zh/> 后布局，即在完成绘制后执行布局\n   *\n   * <en/> Post layout, that is, perform layout after drawing\n   * @param layoutOptions - <zh/> 布局配置项 | <en/> Layout options\n   */\n  postLayout() {\n    return __awaiter(this, arguments, void 0, function* (layoutOptions = this.options) {\n      if (!layoutOptions) return;\n      const pipeline = Array.isArray(layoutOptions) ? layoutOptions : [layoutOptions];\n      const {\n        graph\n      } = this.context;\n      emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, {\n        type: 'post'\n      }));\n      for (let index = 0; index < pipeline.length; index++) {\n        const options = pipeline[index];\n        const data = this.getLayoutData(options);\n        const opts = Object.assign(Object.assign({}, this.presetOptions), options);\n        emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_STAGE_LAYOUT, {\n          options: opts,\n          index\n        }));\n        const result = yield this.stepLayout(data, opts, index);\n        emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_STAGE_LAYOUT, {\n          options: opts,\n          index\n        }));\n        if (!options.animation) {\n          this.updateElementPosition(result, false);\n        }\n      }\n      emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, {\n        type: 'post'\n      }));\n      this.transformDataAfterLayout('post');\n    });\n  }\n  transformDataAfterLayout(type, data) {\n    const transforms = this.context.transform.getTransformInstance();\n    // @ts-expect-error skip type check\n    Object.values(transforms).forEach(transform => transform.afterLayout(type, data));\n  }\n  /**\n   * <zh/> 模拟布局\n   *\n   * <en/> Simulate layout\n   * @returns <zh/> 模拟布局结果 | <en/> Simulated layout result\n   */\n  simulate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.options) return {};\n      const pipeline = Array.isArray(this.options) ? this.options : [this.options];\n      let simulation = {};\n      for (let index = 0; index < pipeline.length; index++) {\n        const options = pipeline[index];\n        const data = this.getLayoutData(options);\n        const result = yield this.stepLayout(data, Object.assign(Object.assign(Object.assign({}, this.presetOptions), options), {\n          animation: false\n        }), index);\n        simulation = result;\n      }\n      return simulation;\n    });\n  }\n  stepLayout(data, options, index) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isTreeLayout(options)) return yield this.treeLayout(data, options, index);\n      return yield this.graphLayout(data, options, index);\n    });\n  }\n  graphLayout(data, options, index) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        animation,\n        enableWorker,\n        iterations = 300\n      } = options;\n      const layout = this.initGraphLayout(options);\n      if (!layout) return {};\n      this.instances[index] = layout;\n      this.instance = layout;\n      // 使用 web worker 执行布局 / Use web worker to execute layout\n      if (enableWorker) {\n        const rawLayout = layout;\n        this.supervisor = new Supervisor(rawLayout.graphData2LayoutModel(data), rawLayout.instance, {\n          iterations\n        });\n        return layoutMapping2GraphData(yield this.supervisor.execute());\n      }\n      if (isLayoutWithIterations(layout)) {\n        // 有动画，基于布局迭代 tick 更新位置 / Update position based on layout iteration tick\n        if (animation) {\n          return yield layout.execute(data, {\n            onTick: tickData => {\n              this.updateElementPosition(tickData, false);\n            }\n          });\n        }\n        // 无动画，直接返回终态位置 / No animation, return final position directly\n        layout.execute(data);\n        layout.stop();\n        return layout.tick(iterations);\n      }\n      // 无迭代的布局，直接返回终态位置 / Layout without iteration, return final position directly\n      const layoutResult = yield layout.execute(data);\n      if (animation) {\n        const animationResult = this.updateElementPosition(layoutResult, animation);\n        yield animationResult === null || animationResult === void 0 ? void 0 : animationResult.finished;\n      }\n      return layoutResult;\n    });\n  }\n  treeLayout(data, options, index) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        type,\n        animation\n      } = options;\n      // @ts-expect-error @antv/hierarchy 布局格式与 @antv/layout 不一致，其导出的是一个方法，而非 class\n      // The layout format of @antv/hierarchy is inconsistent with @antv/layout, it exports a method instead of a class\n      const layout = getExtension('layout', type);\n      if (!layout) return {};\n      const {\n        nodes = [],\n        edges = []\n      } = data;\n      const model = new Graphlib({\n        nodes: nodes.map(node => ({\n          id: idOf(node),\n          data: node.data || {}\n        })),\n        edges: edges.map(edge => ({\n          id: idOf(edge),\n          source: edge.source,\n          target: edge.target,\n          data: edge.data || {}\n        }))\n      });\n      createTreeStructure(model);\n      const layoutPreset = {\n        nodes: [],\n        edges: []\n      };\n      const layoutResult = {\n        nodes: [],\n        edges: []\n      };\n      const roots = model.getRoots(TREE_KEY);\n      roots.forEach(root => {\n        dfs(root, node => {\n          node.children = model.getSuccessors(node.id);\n        }, node => model.getSuccessors(node.id), 'TB');\n        const result = layout(root, options);\n        const {\n          x: rx,\n          y: ry,\n          z: rz = 0\n        } = result;\n        // 将布局结果转化为 LayoutMapping 格式 / Convert the layout result to LayoutMapping format\n        dfs(result, node => {\n          const {\n            id,\n            x,\n            y,\n            z = 0\n          } = node;\n          layoutPreset.nodes.push({\n            id,\n            style: {\n              x: rx,\n              y: ry,\n              z: rz\n            }\n          });\n          layoutResult.nodes.push({\n            id,\n            style: {\n              x,\n              y,\n              z\n            }\n          });\n        }, node => node.children, 'TB');\n      });\n      const offset = this.inferTreeLayoutOffset(layoutResult);\n      applyTreeLayoutOffset(layoutResult, offset);\n      if (animation) {\n        // 先将所有节点移动到根节点位置 / Move all nodes to the root node position first\n        applyTreeLayoutOffset(layoutPreset, offset);\n        this.updateElementPosition(layoutPreset, false);\n        const animationResult = this.updateElementPosition(layoutResult, animation);\n        yield animationResult === null || animationResult === void 0 ? void 0 : animationResult.finished;\n      }\n      return layoutResult;\n    });\n  }\n  inferTreeLayoutOffset(data) {\n    var _a;\n    let [minX, maxX] = [Infinity, -Infinity];\n    let [minY, maxY] = [Infinity, -Infinity];\n    (_a = data.nodes) === null || _a === void 0 ? void 0 : _a.forEach(node => {\n      const {\n        x = 0,\n        y = 0\n      } = node.style || {};\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    });\n    const {\n      canvas\n    } = this.context;\n    const canvasSize = canvas.getSize();\n    const [x1, y1] = canvas.getCanvasByViewport([0, 0]);\n    const [x2, y2] = canvas.getCanvasByViewport(canvasSize);\n    if (minX >= x1 && maxX <= x2 && minY >= y1 && maxY <= y2) return [0, 0];\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return [cx - (minX + maxX) / 2, cy - (minY + maxY) / 2];\n  }\n  stopLayout() {\n    if (this.instance && isLayoutWithIterations(this.instance)) {\n      this.instance.stop();\n      this.instance = undefined;\n    }\n    if (this.supervisor) {\n      this.supervisor.stop();\n      this.supervisor = undefined;\n    }\n    if (this.animationResult) {\n      this.animationResult.finish();\n      this.animationResult = undefined;\n    }\n  }\n  getLayoutData(options) {\n    const {\n      nodeFilter = () => true,\n      preLayout = false,\n      isLayoutInvisibleNodes = false\n    } = options;\n    const {\n      nodes,\n      edges,\n      combos\n    } = this.context.model.getData();\n    const {\n      element,\n      model\n    } = this.context;\n    const getElement = id => element.getElement(id);\n    const filterFn = preLayout ? node => {\n      var _a;\n      if (!isLayoutInvisibleNodes) {\n        if (((_a = node.style) === null || _a === void 0 ? void 0 : _a.visibility) === 'hidden') return false;\n        if (model.getAncestorsData(node.id, TREE_KEY).some(isCollapsed)) return false;\n        if (model.getAncestorsData(node.id, COMBO_KEY).some(isCollapsed)) return false;\n      }\n      return nodeFilter(node);\n    } : node => {\n      const id = idOf(node);\n      const element = getElement(id);\n      if (!element) return false;\n      if (isToBeDestroyed(element)) return false;\n      return nodeFilter(node);\n    };\n    const nodesToLayout = nodes.filter(filterFn);\n    const nodeLikeIdsMap = new Map(nodesToLayout.map(node => [idOf(node), node]));\n    combos.forEach(combo => nodeLikeIdsMap.set(idOf(combo), combo));\n    const edgesToLayout = edges.filter(({\n      source,\n      target\n    }) => {\n      return nodeLikeIdsMap.has(source) && nodeLikeIdsMap.has(target);\n    });\n    return {\n      nodes: nodesToLayout,\n      edges: edgesToLayout,\n      combos\n    };\n  }\n  /**\n   * <zh/> 创建布局实例\n   *\n   * <en/> Create layout instance\n   * @param options - <zh/> 布局配置项 | <en/> Layout options\n   * @returns <zh/> 布局对象 | <en/> Layout object\n   */\n  initGraphLayout(options) {\n    var _a;\n    const {\n      element,\n      viewport\n    } = this.context;\n    const {\n        type,\n        enableWorker,\n        animation,\n        iterations\n      } = options,\n      restOptions = __rest(options, [\"type\", \"enableWorker\", \"animation\", \"iterations\"]);\n    const [width, height] = viewport.getCanvasSize();\n    const center = [width / 2, height / 2];\n    const nodeSize = (_a = options === null || options === void 0 ? void 0 : options.nodeSize) !== null && _a !== void 0 ? _a : node => {\n      const nodeElement = element === null || element === void 0 ? void 0 : element.getElement(node.id);\n      if (nodeElement) return nodeElement.attributes.size;\n      return element === null || element === void 0 ? void 0 : element.getElementComputedStyle('node', node).size;\n    };\n    const Ctor = getExtension('layout', type);\n    if (!Ctor) return print.warn(`The layout of ${type} is not registered.`);\n    const STDCtor = Object.getPrototypeOf(Ctor.prototype) === BaseLayout.prototype ? Ctor : layoutAdapter(Ctor, this.context);\n    const layout = new STDCtor(this.context);\n    const config = {\n      nodeSize,\n      width,\n      height,\n      center\n    };\n    switch (layout.id) {\n      case 'd3-force':\n      case 'd3-force-3d':\n        Object.assign(config, {\n          center: {\n            x: width / 2,\n            y: height / 2,\n            z: 0\n          }\n        });\n        break;\n      default:\n        break;\n    }\n    deepMix(layout.options, config, restOptions);\n    return layout;\n  }\n  updateElementPosition(layoutResult, animation) {\n    const {\n      model,\n      element\n    } = this.context;\n    if (!element) return null;\n    model.updateData(layoutResult);\n    return element.draw({\n      animation,\n      silence: true\n    });\n  }\n  destroy() {\n    var _a;\n    this.stopLayout();\n    // @ts-expect-error force delete\n    this.context = {};\n    (_a = this.supervisor) === null || _a === void 0 ? void 0 : _a.kill();\n    this.supervisor = undefined;\n    this.instance = undefined;\n    this.instances = [];\n    this.animationResult = undefined;\n  }\n}\n/**\n * <zh/> 对树形布局结果应用偏移\n *\n * <en/> Apply offset to tree layout result\n * @param data - <zh/> 布局数据 | <en/> Layout data\n * @param offset - <zh/> 偏移量 | <en/> Offset\n */\nconst applyTreeLayoutOffset = (data, offset) => {\n  var _a;\n  const [ox, oy] = offset;\n  (_a = data.nodes) === null || _a === void 0 ? void 0 : _a.forEach(node => {\n    if (node.style) {\n      const {\n        x = 0,\n        y = 0\n      } = node.style;\n      node.style.x = x + ox;\n      node.style.y = y + oy;\n    } else {\n      node.style = {\n        x: ox,\n        y: oy\n      };\n    }\n  });\n};","map":{"version":3,"names":["Graph","Graphlib","Supervisor","isLayoutWithIterations","deepMix","COMBO_KEY","GraphEvent","TREE_KEY","BaseLayout","getExtension","getAnimationOptions","isCollapsed","isToBeDestroyed","GraphLifeCycleEvent","emit","createTreeStructure","idOf","isTreeLayout","layoutAdapter","layoutMapping2GraphData","print","dfs","LayoutController","presetOptions","animation","context","options","layout","constructor","instances","getLayoutInstance","preLayout","data","graph","model","add","BEFORE_LAYOUT","type","simulate","_a","_b","nodes","forEach","l","id","node","get","syncNodeLikeDatum","Object","assign","style","_c","edges","edge","syncEdgeDatum","_d","combos","combo","AFTER_LAYOUT","transformDataAfterLayout","postLayout","layoutOptions","pipeline","Array","isArray","index","length","getLayoutData","opts","BEFORE_STAGE_LAYOUT","result","stepLayout","AFTER_STAGE_LAYOUT","updateElementPosition","transforms","transform","getTransformInstance","values","afterLayout","simulation","treeLayout","graphLayout","enableWorker","iterations","initGraphLayout","instance","rawLayout","supervisor","graphData2LayoutModel","execute","onTick","tickData","stop","tick","layoutResult","animationResult","finished","map","source","target","layoutPreset","roots","getRoots","root","children","getSuccessors","x","rx","y","ry","z","rz","push","offset","inferTreeLayoutOffset","applyTreeLayoutOffset","minX","maxX","Infinity","minY","maxY","Math","min","max","canvas","canvasSize","getSize","x1","y1","getCanvasByViewport","x2","y2","cx","cy","stopLayout","undefined","finish","nodeFilter","isLayoutInvisibleNodes","getData","element","getElement","filterFn","visibility","getAncestorsData","some","nodesToLayout","filter","nodeLikeIdsMap","Map","set","edgesToLayout","has","viewport","restOptions","__rest","width","height","getCanvasSize","center","nodeSize","nodeElement","attributes","size","getElementComputedStyle","Ctor","warn","STDCtor","getPrototypeOf","prototype","config","updateData","draw","silence","destroy","kill","ox","oy"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/runtime/layout.ts"],"sourcesContent":["import type { IAnimation } from '@antv/g';\nimport { Graph as Graphlib } from '@antv/graphlib';\nimport { Supervisor, isLayoutWithIterations } from '@antv/layout';\nimport { deepMix } from '@antv/util';\nimport { COMBO_KEY, GraphEvent, TREE_KEY } from '../constants';\nimport { BaseLayout } from '../layouts';\nimport type { AntVLayout } from '../layouts/types';\nimport { getExtension } from '../registry/get';\nimport type { GraphData, LayoutOptions, NodeData } from '../spec';\nimport type { STDLayoutOptions } from '../spec/layout';\nimport type { DrawData } from '../transforms/types';\nimport type { AdaptiveLayout, ID, TreeData } from '../types';\nimport { getAnimationOptions } from '../utils/animation';\nimport { isCollapsed } from '../utils/collapsibility';\nimport { isToBeDestroyed } from '../utils/element';\nimport { GraphLifeCycleEvent, emit } from '../utils/event';\nimport { createTreeStructure } from '../utils/graphlib';\nimport { idOf } from '../utils/id';\nimport { isTreeLayout, layoutAdapter, layoutMapping2GraphData } from '../utils/layout';\nimport { print } from '../utils/print';\nimport { dfs } from '../utils/traverse';\nimport type { RuntimeContext } from './types';\n\nexport class LayoutController {\n  private context: RuntimeContext;\n\n  private supervisor?: Supervisor;\n\n  private instance?: BaseLayout;\n\n  private instances: BaseLayout[] = [];\n\n  private animationResult?: IAnimation | null;\n\n  private get presetOptions() {\n    return {\n      animation: !!getAnimationOptions(this.context.options, true),\n    };\n  }\n\n  private get options() {\n    const { options } = this.context;\n    return options.layout;\n  }\n\n  constructor(context: RuntimeContext) {\n    this.context = context;\n  }\n\n  public getLayoutInstance(): BaseLayout[] {\n    return this.instances;\n  }\n\n  /**\n   * <zh/> 前布局，即在绘制前执行布局\n   *\n   * <en/> Pre-layout, that is, perform layout before drawing\n   * @param data - <zh/> 绘制数据 | <en/> Draw data\n   * @remarks\n   * <zh/> 前布局应该只在首次绘制前执行，后续更新不会触发\n   *\n   * <en/> Pre-layout should only be executed before the first drawing, and subsequent updates will not trigger\n   */\n  public async preLayout(data: DrawData) {\n    const { graph, model } = this.context;\n\n    const { add } = data;\n    emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, { type: 'pre' }));\n    const simulate = await this.context.layout?.simulate();\n    simulate?.nodes?.forEach((l) => {\n      const id = idOf(l);\n      const node = add.nodes.get(id);\n      model.syncNodeLikeDatum(l);\n      if (node) Object.assign(node.style!, l.style);\n    });\n    simulate?.edges?.forEach((l) => {\n      const id = idOf(l);\n      const edge = add.edges.get(id);\n      model.syncEdgeDatum(l);\n      if (edge) Object.assign(edge.style!, l.style);\n    });\n    simulate?.combos?.forEach((l) => {\n      const id = idOf(l);\n      const combo = add.combos.get(id);\n      model.syncNodeLikeDatum(l);\n      if (combo) Object.assign(combo.style!, l.style);\n    });\n    emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, { type: 'pre' }));\n    this.transformDataAfterLayout('pre', data);\n  }\n\n  /**\n   * <zh/> 后布局，即在完成绘制后执行布局\n   *\n   * <en/> Post layout, that is, perform layout after drawing\n   * @param layoutOptions - <zh/> 布局配置项 | <en/> Layout options\n   */\n  public async postLayout(layoutOptions: LayoutOptions | undefined = this.options) {\n    if (!layoutOptions) return;\n    const pipeline = Array.isArray(layoutOptions) ? layoutOptions : [layoutOptions];\n    const { graph } = this.context;\n    emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, { type: 'post' }));\n    for (let index = 0; index < pipeline.length; index++) {\n      const options = pipeline[index];\n      const data = this.getLayoutData(options);\n      const opts = { ...this.presetOptions, ...options };\n\n      emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_STAGE_LAYOUT, { options: opts, index }));\n      const result = await this.stepLayout(data, opts, index);\n      emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_STAGE_LAYOUT, { options: opts, index }));\n\n      if (!options.animation) {\n        this.updateElementPosition(result, false);\n      }\n    }\n    emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, { type: 'post' }));\n    this.transformDataAfterLayout('post');\n  }\n\n  private transformDataAfterLayout(type: 'pre' | 'post', data?: DrawData) {\n    const transforms = this.context.transform.getTransformInstance();\n    // @ts-expect-error skip type check\n    Object.values(transforms).forEach((transform) => transform.afterLayout(type, data));\n  }\n\n  /**\n   * <zh/> 模拟布局\n   *\n   * <en/> Simulate layout\n   * @returns <zh/> 模拟布局结果 | <en/> Simulated layout result\n   */\n  public async simulate(): Promise<GraphData> {\n    if (!this.options) return {};\n    const pipeline = Array.isArray(this.options) ? this.options : [this.options];\n\n    let simulation: GraphData = {};\n\n    for (let index = 0; index < pipeline.length; index++) {\n      const options = pipeline[index];\n\n      const data = this.getLayoutData(options);\n      const result = await this.stepLayout(data, { ...this.presetOptions, ...options, animation: false }, index);\n\n      simulation = result;\n    }\n\n    return simulation;\n  }\n\n  public async stepLayout(data: GraphData, options: STDLayoutOptions, index: number): Promise<GraphData> {\n    if (isTreeLayout(options)) return await this.treeLayout(data, options, index);\n    return await this.graphLayout(data, options, index);\n  }\n\n  private async graphLayout(data: GraphData, options: STDLayoutOptions, index: number): Promise<GraphData> {\n    const { animation, enableWorker, iterations = 300 } = options;\n\n    const layout = this.initGraphLayout(options);\n    if (!layout) return {};\n\n    this.instances[index] = layout;\n    this.instance = layout;\n\n    // 使用 web worker 执行布局 / Use web worker to execute layout\n    if (enableWorker) {\n      const rawLayout = layout as unknown as AdaptiveLayout;\n      this.supervisor = new Supervisor(rawLayout.graphData2LayoutModel(data), rawLayout.instance, { iterations });\n      return layoutMapping2GraphData(await this.supervisor.execute());\n    }\n\n    if (isLayoutWithIterations(layout)) {\n      // 有动画，基于布局迭代 tick 更新位置 / Update position based on layout iteration tick\n      if (animation) {\n        return await layout.execute(data, {\n          onTick: (tickData: GraphData) => {\n            this.updateElementPosition(tickData, false);\n          },\n        });\n      }\n\n      // 无动画，直接返回终态位置 / No animation, return final position directly\n      layout.execute(data);\n      layout.stop();\n      return layout.tick(iterations);\n    }\n\n    // 无迭代的布局，直接返回终态位置 / Layout without iteration, return final position directly\n    const layoutResult = await layout.execute(data);\n    if (animation) {\n      const animationResult = this.updateElementPosition(layoutResult, animation);\n      await animationResult?.finished;\n    }\n    return layoutResult;\n  }\n\n  private async treeLayout(data: GraphData, options: STDLayoutOptions, index: number): Promise<GraphData> {\n    const { type, animation } = options;\n    // @ts-expect-error @antv/hierarchy 布局格式与 @antv/layout 不一致，其导出的是一个方法，而非 class\n    // The layout format of @antv/hierarchy is inconsistent with @antv/layout, it exports a method instead of a class\n    const layout = getExtension('layout', type) as (tree: TreeData, options: STDLayoutOptions) => TreeData;\n    if (!layout) return {};\n\n    const { nodes = [], edges = [] } = data;\n\n    const model = new Graphlib({\n      nodes: nodes.map((node) => ({ id: idOf(node), data: node.data || {} })),\n      edges: edges.map((edge) => ({ id: idOf(edge), source: edge.source, target: edge.target, data: edge.data || {} })),\n    });\n\n    createTreeStructure(model);\n\n    const layoutPreset: GraphData = { nodes: [], edges: [] };\n    const layoutResult: GraphData = { nodes: [], edges: [] };\n\n    const roots = model.getRoots(TREE_KEY) as unknown as TreeData[];\n    roots.forEach((root) => {\n      dfs(\n        root,\n        (node) => {\n          node.children = model.getSuccessors(node.id) as TreeData[];\n        },\n        (node) => model.getSuccessors(node.id) as TreeData[],\n        'TB',\n      );\n\n      const result = layout(root, options);\n      const { x: rx, y: ry, z: rz = 0 } = result;\n      // 将布局结果转化为 LayoutMapping 格式 / Convert the layout result to LayoutMapping format\n      dfs(\n        result,\n        (node) => {\n          const { id, x, y, z = 0 } = node;\n          layoutPreset.nodes!.push({ id, style: { x: rx, y: ry, z: rz } });\n          layoutResult.nodes!.push({ id, style: { x, y, z } });\n        },\n        (node) => node.children,\n        'TB',\n      );\n    });\n\n    const offset = this.inferTreeLayoutOffset(layoutResult);\n    applyTreeLayoutOffset(layoutResult, offset);\n\n    if (animation) {\n      // 先将所有节点移动到根节点位置 / Move all nodes to the root node position first\n      applyTreeLayoutOffset(layoutPreset, offset);\n      this.updateElementPosition(layoutPreset, false);\n\n      const animationResult = this.updateElementPosition(layoutResult, animation);\n      await animationResult?.finished;\n    }\n\n    return layoutResult;\n  }\n\n  private inferTreeLayoutOffset(data: GraphData) {\n    let [minX, maxX] = [Infinity, -Infinity];\n    let [minY, maxY] = [Infinity, -Infinity];\n\n    data.nodes?.forEach((node) => {\n      const { x = 0, y = 0 } = node.style || {};\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    });\n\n    const { canvas } = this.context;\n    const canvasSize = canvas.getSize();\n    const [x1, y1] = canvas.getCanvasByViewport([0, 0]);\n    const [x2, y2] = canvas.getCanvasByViewport(canvasSize);\n\n    if (minX >= x1 && maxX <= x2 && minY >= y1 && maxY <= y2) return [0, 0] as [number, number];\n\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    return [cx - (minX + maxX) / 2, cy - (minY + maxY) / 2] as [number, number];\n  }\n\n  public stopLayout() {\n    if (this.instance && isLayoutWithIterations(this.instance)) {\n      this.instance.stop();\n      this.instance = undefined;\n    }\n\n    if (this.supervisor) {\n      this.supervisor.stop();\n      this.supervisor = undefined;\n    }\n\n    if (this.animationResult) {\n      this.animationResult.finish();\n      this.animationResult = undefined;\n    }\n  }\n\n  public getLayoutData(options: STDLayoutOptions): GraphData {\n    const { nodeFilter = () => true, preLayout = false, isLayoutInvisibleNodes = false } = options;\n    const { nodes, edges, combos } = this.context.model.getData();\n\n    const { element, model } = this.context;\n    const getElement = (id: ID) => element!.getElement(id);\n\n    const filterFn = preLayout\n      ? (node: NodeData) => {\n          if (!isLayoutInvisibleNodes) {\n            if (node.style?.visibility === 'hidden') return false;\n            if (model.getAncestorsData(node.id, TREE_KEY).some(isCollapsed)) return false;\n            if (model.getAncestorsData(node.id, COMBO_KEY).some(isCollapsed)) return false;\n          }\n          return nodeFilter(node);\n        }\n      : (node: NodeData) => {\n          const id = idOf(node);\n          const element = getElement(id);\n          if (!element) return false;\n          if (isToBeDestroyed(element)) return false;\n          return nodeFilter(node);\n        };\n\n    const nodesToLayout = nodes.filter(filterFn);\n\n    const nodeLikeIdsMap = new Map<ID, NodeData>(nodesToLayout.map((node) => [idOf(node), node]));\n    combos.forEach((combo) => nodeLikeIdsMap.set(idOf(combo), combo));\n\n    const edgesToLayout = edges.filter(({ source, target }) => {\n      return nodeLikeIdsMap.has(source) && nodeLikeIdsMap.has(target);\n    });\n\n    return {\n      nodes: nodesToLayout,\n      edges: edgesToLayout,\n      combos,\n    };\n  }\n\n  /**\n   * <zh/> 创建布局实例\n   *\n   * <en/> Create layout instance\n   * @param options - <zh/> 布局配置项 | <en/> Layout options\n   * @returns <zh/> 布局对象 | <en/> Layout object\n   */\n  private initGraphLayout(options: STDLayoutOptions) {\n    const { element, viewport } = this.context;\n    const { type, enableWorker, animation, iterations, ...restOptions } = options;\n\n    const [width, height] = viewport!.getCanvasSize();\n    const center = [width / 2, height / 2];\n\n    const nodeSize: number | ((node: NodeData) => number) =\n      (options?.nodeSize as number) ??\n      ((node) => {\n        const nodeElement = element?.getElement(node.id);\n        if (nodeElement) return nodeElement.attributes.size;\n        return element?.getElementComputedStyle('node', node).size;\n      });\n\n    const Ctor = getExtension('layout', type);\n    if (!Ctor) return print.warn(`The layout of ${type} is not registered.`);\n\n    const STDCtor =\n      Object.getPrototypeOf(Ctor.prototype) === BaseLayout.prototype\n        ? Ctor\n        : layoutAdapter(Ctor as new (options?: Record<string, unknown>) => AntVLayout, this.context);\n\n    const layout = new STDCtor(this.context);\n    const config = { nodeSize, width, height, center };\n\n    switch (layout.id) {\n      case 'd3-force':\n      case 'd3-force-3d':\n        Object.assign(config, {\n          center: { x: width / 2, y: height / 2, z: 0 },\n        });\n        break;\n      default:\n        break;\n    }\n\n    deepMix(layout.options, config, restOptions);\n    return layout as unknown as BaseLayout;\n  }\n\n  private updateElementPosition(layoutResult: GraphData, animation: boolean) {\n    const { model, element } = this.context;\n    if (!element) return null;\n    model.updateData(layoutResult);\n\n    return element.draw({ animation, silence: true });\n  }\n\n  public destroy() {\n    this.stopLayout();\n    // @ts-expect-error force delete\n    this.context = {};\n    this.supervisor?.kill();\n    this.supervisor = undefined;\n    this.instance = undefined;\n    this.instances = [];\n    this.animationResult = undefined;\n  }\n}\n\n/**\n * <zh/> 对树形布局结果应用偏移\n *\n * <en/> Apply offset to tree layout result\n * @param data - <zh/> 布局数据 | <en/> Layout data\n * @param offset - <zh/> 偏移量 | <en/> Offset\n */\nconst applyTreeLayoutOffset = (data: GraphData, offset: [number, number]) => {\n  const [ox, oy] = offset;\n  data.nodes?.forEach((node) => {\n    if (node.style) {\n      const { x = 0, y = 0 } = node.style;\n      node.style.x = x + ox;\n      node.style.y = y + oy;\n    } else {\n      node.style = { x: ox, y: oy };\n    }\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}