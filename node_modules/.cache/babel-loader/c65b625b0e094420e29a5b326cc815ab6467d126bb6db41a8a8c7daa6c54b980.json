{"ast":null,"code":"import { executor } from '../animations/executor';\nimport { createAnimationsProxy, getElementAnimationOptions, inferDefaultValue } from '../utils/animation';\nimport { getCachedStyle } from '../utils/cache';\nexport class Animation {\n  constructor(context) {\n    this.tasks = [];\n    this.animations = new Set();\n    this.context = context;\n  }\n  getTasks() {\n    const tasks = [...this.tasks];\n    this.tasks = [];\n    return tasks;\n  }\n  add(context, callbacks) {\n    this.tasks.push([context, callbacks]);\n  }\n  animate(localAnimation, callbacks, extendOptions) {\n    var _a, _b, _c;\n    (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.before) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n    const animations = this.getTasks().map(([context, cb]) => {\n      var _a, _b, _c;\n      const {\n        element,\n        elementType,\n        stage\n      } = context;\n      const options = getElementAnimationOptions(this.context.options, elementType, stage, localAnimation);\n      (_a = cb === null || cb === void 0 ? void 0 : cb.before) === null || _a === void 0 ? void 0 : _a.call(cb);\n      const animation = options.length ? executor(element, this.inferStyle(context, extendOptions), options) : null;\n      if (animation) {\n        (_b = cb === null || cb === void 0 ? void 0 : cb.beforeAnimate) === null || _b === void 0 ? void 0 : _b.call(cb, animation);\n        animation.finished.then(() => {\n          var _a, _b;\n          (_a = cb === null || cb === void 0 ? void 0 : cb.afterAnimate) === null || _a === void 0 ? void 0 : _a.call(cb, animation);\n          (_b = cb === null || cb === void 0 ? void 0 : cb.after) === null || _b === void 0 ? void 0 : _b.call(cb);\n          this.animations.delete(animation);\n        });\n      } else (_c = cb === null || cb === void 0 ? void 0 : cb.after) === null || _c === void 0 ? void 0 : _c.call(cb);\n      return animation;\n    }).filter(Boolean);\n    animations.forEach(animation => this.animations.add(animation));\n    const animation = createAnimationsProxy(animations);\n    if (animation) {\n      (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.beforeAnimate) === null || _b === void 0 ? void 0 : _b.call(callbacks, animation);\n      animation.finished.then(() => {\n        var _a, _b;\n        (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.afterAnimate) === null || _a === void 0 ? void 0 : _a.call(callbacks, animation);\n        (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.after) === null || _b === void 0 ? void 0 : _b.call(callbacks);\n        this.release();\n      });\n    } else (_c = callbacks === null || callbacks === void 0 ? void 0 : callbacks.after) === null || _c === void 0 ? void 0 : _c.call(callbacks);\n    return animation;\n  }\n  /**\n   * <zh/> 推断额外的动画样式\n   *\n   * <en/> Infer additional animation styles\n   * @param context - <zh/> 动画上下文 | <en/> Animation context\n   * @param options - <zh/> 扩展选项 | <en/> Extend options\n   * @returns <zh/> 始态样式与终态样式 | <en/> Initial style and final style\n   */\n  inferStyle(context, options) {\n    var _a, _b;\n    const {\n      element,\n      elementType,\n      stage,\n      originalStyle,\n      updatedStyle = {}\n    } = context;\n    if (!context.modifiedStyle) context.modifiedStyle = Object.assign(Object.assign({}, originalStyle), updatedStyle);\n    const {\n      modifiedStyle\n    } = context;\n    const fromStyle = {};\n    const toStyle = {};\n    if (stage === 'enter') {\n      Object.assign(fromStyle, {\n        opacity: 0\n      });\n    } else if (stage === 'exit') {\n      Object.assign(toStyle, {\n        opacity: 0\n      });\n    } else if (stage === 'show') {\n      Object.assign(fromStyle, {\n        opacity: 0\n      });\n      Object.assign(toStyle, {\n        opacity: (_a = getCachedStyle(element, 'opacity')) !== null && _a !== void 0 ? _a : inferDefaultValue('opacity')\n      });\n    } else if (stage === 'hide') {\n      Object.assign(fromStyle, {\n        opacity: (_b = getCachedStyle(element, 'opacity')) !== null && _b !== void 0 ? _b : inferDefaultValue('opacity')\n      });\n      Object.assign(toStyle, {\n        opacity: 0\n      });\n    } else if (stage === 'collapse') {\n      const {\n        collapse\n      } = options || {};\n      const {\n        target,\n        descendants,\n        position\n      } = collapse;\n      if (elementType === 'node') {\n        // 为即将被删除的元素设置目标位置\n        // Set the target position for the element to be deleted\n        if (descendants.includes(element.id)) {\n          const [x, y, z] = position;\n          Object.assign(toStyle, {\n            x,\n            y,\n            z\n          });\n        }\n      } else if (elementType === 'combo') {\n        if (element.id === target || descendants.includes(element.id)) {\n          const [x, y] = position;\n          Object.assign(toStyle, {\n            x,\n            y,\n            childrenNode: originalStyle.childrenNode\n          });\n        }\n      } else if (elementType === 'edge') {\n        Object.assign(toStyle, {\n          sourceNode: modifiedStyle.sourceNode,\n          targetNode: modifiedStyle.targetNode\n        });\n      }\n    } else if (stage === 'expand') {\n      const {\n        expand\n      } = options || {};\n      const {\n        target,\n        descendants,\n        position\n      } = expand;\n      if (elementType === 'node') {\n        // 设置展开节点的起点位置\n        // Set the starting position of the expanded node\n        if (element.id === target || descendants.includes(element.id)) {\n          const [x, y, z] = position;\n          Object.assign(fromStyle, {\n            x,\n            y,\n            z\n          });\n        }\n      } else if (elementType === 'combo') {\n        // 设置展开后的组合子元素\n        // Set the child elements of the expanded combo\n        if (element.id === target || descendants.includes(element.id)) {\n          const [x, y, z] = position;\n          Object.assign(fromStyle, {\n            x,\n            y,\n            z,\n            childrenNode: modifiedStyle.childrenNode\n          });\n        }\n      } else if (elementType === 'edge') {\n        // 设置展开后的边的起点和终点\n        // Set the starting point and end point of the edge after expansion\n        Object.assign(fromStyle, {\n          sourceNode: modifiedStyle.sourceNode,\n          targetNode: modifiedStyle.targetNode\n        });\n      }\n    }\n    return [Object.keys(fromStyle).length > 0 ? Object.assign({}, originalStyle, fromStyle) : originalStyle, Object.keys(toStyle).length > 0 ? Object.assign({}, modifiedStyle, toStyle) : modifiedStyle];\n  }\n  stop() {\n    this.animations.forEach(animation => animation.cancel());\n  }\n  clear() {\n    this.tasks = [];\n  }\n  /**\n   * <zh/> 释放存量动画对象\n   *\n   * <en/> Release stock animation objects\n   * @description see: https://github.com/antvis/G/issues/1731\n   */\n  release() {\n    var _a, _b;\n    const {\n      canvas\n    } = this.context;\n    // @ts-expect-error private property\n    const animationsWithPromises = (_b = (_a = canvas.document) === null || _a === void 0 ? void 0 : _a.timeline) === null || _b === void 0 ? void 0 : _b.animationsWithPromises;\n    if (animationsWithPromises) {\n      // @ts-expect-error private property\n      canvas.document.timeline.animationsWithPromises = animationsWithPromises.filter(animation => animation.playState !== 'finished');\n    }\n  }\n  destroy() {\n    this.stop();\n    this.animations.clear();\n    this.tasks = [];\n  }\n}","map":{"version":3,"names":["executor","createAnimationsProxy","getElementAnimationOptions","inferDefaultValue","getCachedStyle","Animation","constructor","context","tasks","animations","Set","getTasks","add","callbacks","push","animate","localAnimation","extendOptions","_a","before","call","map","cb","element","elementType","stage","options","animation","length","inferStyle","_b","beforeAnimate","finished","then","afterAnimate","after","delete","_c","filter","Boolean","forEach","release","originalStyle","updatedStyle","modifiedStyle","Object","assign","fromStyle","toStyle","opacity","collapse","target","descendants","position","includes","id","x","y","z","childrenNode","sourceNode","targetNode","expand","keys","stop","cancel","clear","canvas","animationsWithPromises","document","timeline","playState","destroy"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/runtime/animation.ts"],"sourcesContent":["import type { IAnimation } from '@antv/g';\nimport { executor } from '../animations/executor';\nimport type { AnimationContext, AnimationEffectTiming } from '../animations/types';\nimport type { ID, Point } from '../types';\nimport { createAnimationsProxy, getElementAnimationOptions, inferDefaultValue } from '../utils/animation';\nimport { getCachedStyle } from '../utils/cache';\nimport type { RuntimeContext } from './types';\n\nexport class Animation {\n  private context: RuntimeContext;\n\n  constructor(context: RuntimeContext) {\n    this.context = context;\n  }\n\n  private tasks: [AnimationContext, AnimationCallbacks | undefined][] = [];\n\n  private animations: Set<IAnimation> = new Set();\n\n  private getTasks() {\n    const tasks = [...this.tasks];\n    this.tasks = [];\n    return tasks;\n  }\n\n  public add(context: AnimationContext, callbacks?: AnimationCallbacks) {\n    this.tasks.push([context, callbacks]);\n  }\n\n  public animate(\n    localAnimation?: AnimationEffectTiming | boolean,\n    callbacks?: AnimationCallbacks,\n    extendOptions?: ExtendOptions,\n  ) {\n    callbacks?.before?.();\n\n    const animations = this.getTasks()\n      .map(([context, cb]) => {\n        const { element, elementType, stage } = context;\n        const options = getElementAnimationOptions(this.context.options, elementType, stage, localAnimation);\n        cb?.before?.();\n        const animation = options.length ? executor(element, this.inferStyle(context, extendOptions), options) : null;\n\n        if (animation) {\n          cb?.beforeAnimate?.(animation);\n          animation.finished.then(() => {\n            cb?.afterAnimate?.(animation);\n            cb?.after?.();\n            this.animations.delete(animation);\n          });\n        } else cb?.after?.();\n\n        return animation;\n      })\n      .filter(Boolean) as IAnimation[];\n\n    animations.forEach((animation) => this.animations.add(animation));\n\n    const animation = createAnimationsProxy(animations);\n\n    if (animation) {\n      callbacks?.beforeAnimate?.(animation);\n\n      animation.finished.then(() => {\n        callbacks?.afterAnimate?.(animation);\n        callbacks?.after?.();\n        this.release();\n      });\n    } else callbacks?.after?.();\n\n    return animation;\n  }\n\n  /**\n   * <zh/> 推断额外的动画样式\n   *\n   * <en/> Infer additional animation styles\n   * @param context - <zh/> 动画上下文 | <en/> Animation context\n   * @param options - <zh/> 扩展选项 | <en/> Extend options\n   * @returns <zh/> 始态样式与终态样式 | <en/> Initial style and final style\n   */\n  public inferStyle(\n    context: AnimationContext,\n    options?: ExtendOptions,\n  ): [Record<string, unknown>, Record<string, unknown>] {\n    const { element, elementType, stage, originalStyle, updatedStyle = {} } = context;\n\n    if (!context.modifiedStyle) context.modifiedStyle = { ...originalStyle, ...updatedStyle };\n    const { modifiedStyle } = context;\n\n    const fromStyle: Record<string, unknown> = {};\n    const toStyle: Record<string, unknown> = {};\n\n    if (stage === 'enter') {\n      Object.assign(fromStyle, { opacity: 0 });\n    } else if (stage === 'exit') {\n      Object.assign(toStyle, { opacity: 0 });\n    } else if (stage === 'show') {\n      Object.assign(fromStyle, { opacity: 0 });\n      Object.assign(toStyle, { opacity: getCachedStyle(element, 'opacity') ?? inferDefaultValue('opacity') });\n    } else if (stage === 'hide') {\n      Object.assign(fromStyle, { opacity: getCachedStyle(element, 'opacity') ?? inferDefaultValue('opacity') });\n      Object.assign(toStyle, { opacity: 0 });\n    } else if (stage === 'collapse') {\n      const { collapse } = options || {};\n      const { target, descendants, position } = collapse!;\n      if (elementType === 'node') {\n        // 为即将被删除的元素设置目标位置\n        // Set the target position for the element to be deleted\n        if (descendants.includes(element.id)) {\n          const [x, y, z] = position;\n          Object.assign(toStyle, { x, y, z });\n        }\n      } else if (elementType === 'combo') {\n        if (element.id === target || descendants.includes(element.id)) {\n          const [x, y] = position;\n          Object.assign(toStyle, { x, y, childrenNode: originalStyle.childrenNode });\n        }\n      } else if (elementType === 'edge') {\n        Object.assign(toStyle, { sourceNode: modifiedStyle.sourceNode, targetNode: modifiedStyle.targetNode });\n      }\n    } else if (stage === 'expand') {\n      const { expand } = options || {};\n      const { target, descendants, position } = expand!;\n      if (elementType === 'node') {\n        // 设置展开节点的起点位置\n        // Set the starting position of the expanded node\n        if (element.id === target || descendants.includes(element.id)) {\n          const [x, y, z] = position;\n          Object.assign(fromStyle, { x, y, z });\n        }\n      } else if (elementType === 'combo') {\n        // 设置展开后的组合子元素\n        // Set the child elements of the expanded combo\n        if (element.id === target || descendants.includes(element.id)) {\n          const [x, y, z] = position;\n          Object.assign(fromStyle, { x, y, z, childrenNode: modifiedStyle.childrenNode });\n        }\n      } else if (elementType === 'edge') {\n        // 设置展开后的边的起点和终点\n        // Set the starting point and end point of the edge after expansion\n        Object.assign(fromStyle, { sourceNode: modifiedStyle.sourceNode, targetNode: modifiedStyle.targetNode });\n      }\n    }\n\n    return [\n      Object.keys(fromStyle).length > 0 ? Object.assign({}, originalStyle, fromStyle) : originalStyle,\n      Object.keys(toStyle).length > 0 ? Object.assign({}, modifiedStyle, toStyle) : modifiedStyle,\n    ];\n  }\n\n  public stop() {\n    this.animations.forEach((animation) => animation.cancel());\n  }\n\n  public clear() {\n    this.tasks = [];\n  }\n\n  /**\n   * <zh/> 释放存量动画对象\n   *\n   * <en/> Release stock animation objects\n   * @description see: https://github.com/antvis/G/issues/1731\n   */\n  private release() {\n    const { canvas } = this.context;\n\n    // @ts-expect-error private property\n    const animationsWithPromises = canvas.document?.timeline?.animationsWithPromises;\n    if (animationsWithPromises) {\n      // @ts-expect-error private property\n      canvas.document.timeline.animationsWithPromises = animationsWithPromises.filter(\n        (animation: IAnimation) => animation.playState !== 'finished',\n      );\n    }\n  }\n\n  public destroy() {\n    this.stop();\n    this.animations.clear();\n    this.tasks = [];\n  }\n}\n\ninterface AnimationCallbacks {\n  before?: () => void;\n  beforeAnimate?: (animation: IAnimation) => void;\n  afterAnimate?: (animation: IAnimation) => void;\n  after?: () => void;\n}\n\ninterface ExtendOptions {\n  /**\n   * <zh/> stage 为 collapse 时，指定当前展开/收起的目标元素及其后代元素\n   *\n   * <en/> When the stage is collapse, specify the target element and its descendants to expand/collapse\n   */\n  collapse?: {\n    target: ID;\n    descendants: ID[];\n    position: Point;\n  };\n\n  /**\n   * <zh/> stage 为 expand 时，指定当前展开/收起的目标元素及其后代元素\n   *\n   * <en/> When the stage is expand, specify the target element and its descendants to expand/collapse\n   */\n  expand?: {\n    target: ID;\n    descendants: ID[];\n    position: Point;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}