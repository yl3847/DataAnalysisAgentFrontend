{"ast":null,"code":"import { isNumber } from '@antv/util';\nimport { isArray } from './array';\nexport const floydWarshall = adjMatrix => {\n  // initialize\n  const dist = [];\n  const size = adjMatrix.length;\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\nexport const getAdjMatrix = (data, directed) => {\n  const {\n    nodes,\n    edges\n  } = data;\n  const matrix = [];\n  // map node with index in data.nodes\n  const nodeMap = {};\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row = [];\n      matrix.push(row);\n    });\n  }\n  edges === null || edges === void 0 ? void 0 : edges.forEach(e => {\n    const {\n      source,\n      target\n    } = e;\n    const sIndex = nodeMap[source];\n    const tIndex = nodeMap[target];\n    if (sIndex === undefined || tIndex === undefined) return;\n    matrix[sIndex][tIndex] = 1;\n    if (!directed) {\n      matrix[tIndex][sIndex] = 1;\n    }\n  });\n  return matrix;\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\nexport const scaleMatrix = (matrix, ratio) => {\n  const result = [];\n  matrix.forEach(row => {\n    const newRow = [];\n    row.forEach(v => {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * calculate the bounding box for the nodes according to their x, y, and size\n * @param nodes nodes in the layout\n * @returns\n */\nexport const getLayoutBBox = nodes => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  nodes.forEach(node => {\n    let size = node.data.size;\n    if (isArray(size)) {\n      if (size.length === 1) size = [size[0], size[0]];\n    } else if (isNumber(size)) {\n      size = [size, size];\n    } else if (size === undefined || isNaN(size)) {\n      size = [30, 30];\n    }\n    const halfSize = [size[0] / 2, size[1] / 2];\n    const left = node.data.x - halfSize[0];\n    const right = node.data.x + halfSize[0];\n    const top = node.data.y - halfSize[1];\n    const bottom = node.data.y + halfSize[1];\n    if (minX > left) minX = left;\n    if (minY > top) minY = top;\n    if (maxX < right) maxX = right;\n    if (maxY < bottom) maxY = bottom;\n  });\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY\n  };\n};\n/**\n * calculate the euclidean distance form p1 to p2\n * @param p1\n * @param p2\n * @returns\n */\nexport const getEuclideanDistance = (p1, p2) => Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n/**\n * Depth first search begin from nodes in graphCore data.\n * @param graphCore graphlib data structure\n * @param nodes begin nodes\n * @param fn will be called while visiting each node\n * @param mode 'TB' - visit from top to bottom; 'BT' - visit from bottom to top;\n * @returns\n */\nexport const graphTreeDfs = (graph, nodes, fn, mode = 'TB', treeKey, stopFns = {}) => {\n  if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) return;\n  const {\n    stopBranchFn,\n    stopAllFn\n  } = stopFns;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!graph.hasNode(node.id)) continue;\n    if (stopBranchFn === null || stopBranchFn === void 0 ? void 0 : stopBranchFn(node)) continue; // Stop this branch\n    if (stopAllFn === null || stopAllFn === void 0 ? void 0 : stopAllFn(node)) return; // Stop all\n    if (mode === 'TB') fn(node); // Traverse from top to bottom\n    graphTreeDfs(graph, graph.getChildren(node.id, treeKey), fn, mode, treeKey, stopFns);\n    if (mode !== 'TB') fn(node); // Traverse from bottom to top\n  }\n};","map":{"version":3,"names":["isNumber","isArray","floydWarshall","adjMatrix","dist","size","length","i","j","Infinity","k","getAdjMatrix","data","directed","nodes","edges","matrix","nodeMap","Error","forEach","node","id","row","push","e","source","target","sIndex","tIndex","undefined","scaleMatrix","ratio","result","newRow","v","getLayoutBBox","minX","minY","maxX","maxY","isNaN","halfSize","left","x","right","top","y","bottom","getEuclideanDistance","p1","p2","Math","sqrt","graphTreeDfs","graph","fn","mode","treeKey","stopFns","stopBranchFn","stopAllFn","hasNode","getChildren"],"sources":["../../src/util/math.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}