{"ast":null,"code":"import { getArcObject } from '../../../shape/utils';\nimport { isCircular, isRadial } from '../../../utils/coordinate';\nimport { pointOfArc, inferRotation, inferIdentityStyle, inferRadialStyle, inferNonCircularStyle } from './default';\nexport function linePoints(center, angle, radius, radius1, offsetX) {\n  const [x0, y0] = pointOfArc(center, angle, radius);\n  const [x1, y1] = pointOfArc(center, angle, radius1);\n  const sign = Math.sin(angle) > 0 ? 1 : -1;\n  return [[x0, y0], [x1, y1], [x1 + sign * offsetX, y1]];\n}\nexport function radiusOf(points, value, coordinate) {\n  const arcObject = getArcObject(coordinate, points, [value.y, value.y1]);\n  const {\n    innerRadius,\n    outerRadius\n  } = arcObject;\n  return innerRadius + (outerRadius - innerRadius);\n}\nexport function angleOf(points, value, coordinate) {\n  const arcObject = getArcObject(coordinate, points, [value.y, value.y1]);\n  const {\n    startAngle,\n    endAngle\n  } = arcObject;\n  return (startAngle + endAngle) / 2;\n}\nexport function inferOutsideCircularStyle(position, points, value, coordinate) {\n  const {\n    autoRotate,\n    rotateToAlignArc,\n    offset = 0,\n    connector = true,\n    connectorLength = offset,\n    connectorLength2 = 0,\n    connectorDistance = 0\n  } = value;\n  const center = coordinate.getCenter();\n  const angle = angleOf(points, value, coordinate);\n  const sign = Math.sin(angle) > 0 ? 1 : -1;\n  const rotate = inferRotation(angle, autoRotate, rotateToAlignArc);\n  const textStyle = {\n    textAlign: sign > 0 || isRadial(coordinate) ? 'start' : 'end',\n    textBaseline: 'middle',\n    rotate\n  };\n  const radius = radiusOf(points, value, coordinate);\n  const radius1 = radius + (connector ? connectorLength : offset);\n  const [[x0, y0], [x1, y1], [x2, y2]] = linePoints(center, angle, radius, radius1, connector ? connectorLength2 : 0);\n  const dx = connector ? +connectorDistance * sign : 0;\n  const x = x2 + dx;\n  const y = y2;\n  const connectorStyle = {\n    connector,\n    connectorPoints: [[x1 - x, y1 - y], [x2 - x, y2 - y]]\n  };\n  return Object.assign(Object.assign({\n    x0,\n    y0,\n    x: x2 + dx,\n    y: y2\n  }, textStyle), connectorStyle);\n}\nexport function outside(position, points, value, coordinate) {\n  const {\n    bounds\n  } = value;\n  // When bounds.length = 1\n  // For series mark, such as line and area.\n  // The bounds for text is defined with only one point.\n  // Use this point as the label position.\n  if (bounds.length === 1) {\n    return inferIdentityStyle(position, points, value, coordinate);\n  }\n  const inferDefaultStyle = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferOutsideCircularStyle : inferNonCircularStyle;\n  return inferDefaultStyle(position, points, value, coordinate);\n}","map":{"version":3,"names":["getArcObject","isCircular","isRadial","pointOfArc","inferRotation","inferIdentityStyle","inferRadialStyle","inferNonCircularStyle","linePoints","center","angle","radius","radius1","offsetX","x0","y0","x1","y1","sign","Math","sin","radiusOf","points","value","coordinate","arcObject","y","innerRadius","outerRadius","angleOf","startAngle","endAngle","inferOutsideCircularStyle","position","autoRotate","rotateToAlignArc","offset","connector","connectorLength","connectorLength2","connectorDistance","getCenter","rotate","textStyle","textAlign","textBaseline","x2","y2","dx","x","connectorStyle","connectorPoints","Object","assign","outside","bounds","length","inferDefaultStyle"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/label/position/outside.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { Vector2 } from '../../../runtime';\nimport { getArcObject } from '../../../shape/utils';\nimport { isCircular, isRadial } from '../../../utils/coordinate';\n\nimport type { LabelPosition } from './default';\nimport {\n  pointOfArc,\n  inferRotation,\n  inferIdentityStyle,\n  inferRadialStyle,\n  inferNonCircularStyle,\n} from './default';\n\nexport function linePoints(center: Vector2, angle, radius, radius1, offsetX) {\n  const [x0, y0] = pointOfArc(center, angle, radius);\n  const [x1, y1] = pointOfArc(center, angle, radius1);\n  const sign = Math.sin(angle) > 0 ? 1 : -1;\n  return [\n    [x0, y0],\n    [x1, y1],\n    [x1 + sign * offsetX, y1],\n  ];\n}\n\nexport function radiusOf(points, value, coordinate) {\n  const arcObject = getArcObject(coordinate, points, [value.y, value.y1]);\n  const { innerRadius, outerRadius } = arcObject;\n  return innerRadius + (outerRadius - innerRadius);\n}\n\nexport function angleOf(points, value, coordinate) {\n  const arcObject = getArcObject(coordinate, points, [value.y, value.y1]);\n  const { startAngle, endAngle } = arcObject;\n\n  return (startAngle + endAngle) / 2;\n}\n\nexport function inferOutsideCircularStyle(\n  position: LabelPosition,\n  points: Vector2[],\n  value: Record<string, any>,\n  coordinate: Coordinate,\n) {\n  const {\n    autoRotate,\n    rotateToAlignArc,\n    offset = 0,\n    connector = true,\n    connectorLength = offset,\n    connectorLength2 = 0,\n    connectorDistance = 0,\n  } = value;\n  const center = coordinate.getCenter();\n\n  const angle = angleOf(points, value, coordinate);\n  const sign = Math.sin(angle) > 0 ? 1 : -1;\n\n  const rotate = inferRotation(angle, autoRotate, rotateToAlignArc);\n  const textStyle = {\n    textAlign: sign > 0 || isRadial(coordinate) ? 'start' : 'end',\n    textBaseline: 'middle',\n    rotate,\n  };\n\n  const radius = radiusOf(points, value, coordinate);\n  const radius1 = radius + (connector ? connectorLength : offset);\n\n  const [[x0, y0], [x1, y1], [x2, y2]] = linePoints(\n    center,\n    angle,\n    radius,\n    radius1,\n    connector ? connectorLength2 : 0,\n  );\n\n  const dx = connector ? +connectorDistance * sign : 0;\n\n  const x = x2 + dx;\n  const y = y2;\n  const connectorStyle = {\n    connector,\n    connectorPoints: [\n      [x1 - x, y1 - y],\n      [x2 - x, y2 - y],\n    ],\n  };\n\n  return {\n    x0,\n    y0,\n    x: x2 + dx,\n    y: y2,\n    ...textStyle,\n    ...connectorStyle,\n  };\n}\n\nexport function outside(\n  position: LabelPosition,\n  points: Vector2[],\n  value: Record<string, any>,\n  coordinate: Coordinate,\n) {\n  const { bounds } = value;\n  // When bounds.length = 1\n  // For series mark, such as line and area.\n  // The bounds for text is defined with only one point.\n  // Use this point as the label position.\n  if (bounds.length === 1) {\n    return inferIdentityStyle(position, points, value, coordinate);\n  }\n\n  const inferDefaultStyle = isRadial(coordinate)\n    ? inferRadialStyle\n    : isCircular(coordinate)\n    ? inferOutsideCircularStyle\n    : inferNonCircularStyle;\n\n  return inferDefaultStyle(position, points, value, coordinate);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}