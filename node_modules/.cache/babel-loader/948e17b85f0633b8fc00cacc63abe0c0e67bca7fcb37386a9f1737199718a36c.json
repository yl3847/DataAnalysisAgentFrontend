{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { isArray } from '@antv/util';\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n  return minNode;\n};\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n    var relatedEdges = [];\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);else relatedEdges = getEdgesByNodeId(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n  prevs[source] = [source];\n  // 每个节点存可能存在多条最短路径\n  var paths = {};\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  }\n  // 兼容之前单路径\n  var path = {};\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\nexport default dijkstra;\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n  var paths = [];\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if (isArray(prePath)) paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));else paths.push([prePath, target]);\n    }\n  }\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}","map":{"version":3,"names":["__spreadArray","isArray","getOutEdgesNodeId","getEdgesByNodeId","minVertex","D","nodes","marks","minDis","Infinity","minNode","i","length","nodeId","id","dijkstra","graphData","source","directed","weightPropertyName","_a","_b","edges","nodeIds","prevs","forEach","node","push","nodeNum","_loop_1","minNodeId","relatedEdges","edge","edgeTarget","target","edgeSource","w","weight","paths","findAllPaths","path","allPath","foundPaths","_i","prev","prevPaths","prevPaths_1","prePath"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/algorithm/es/dijkstra.js"],"sourcesContent":["import { __spreadArray } from \"tslib\";\nimport { isArray } from '@antv/util';\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n  return minNode;\n};\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n    var relatedEdges = [];\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);else relatedEdges = getEdgesByNodeId(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n  prevs[source] = [source];\n  // 每个节点存可能存在多条最短路径\n  var paths = {};\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  }\n  // 兼容之前单路径\n  var path = {};\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\nexport default dijkstra;\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n  var paths = [];\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if (isArray(prePath)) paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));else paths.push([prePath, target]);\n    }\n  }\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}"],"mappings":"AAAA,SAASA,aAAa,QAAQ,OAAO;AACrC,SAASC,OAAO,QAAQ,YAAY;AACpC,SAASC,iBAAiB,EAAEC,gBAAgB,QAAQ,QAAQ;AAC5D,IAAIC,SAAS,GAAG,SAASA,SAASA,CAACC,CAAC,EAAEC,KAAK,EAAEC,KAAK,EAAE;EAClD;EACA,IAAIC,MAAM,GAAGC,QAAQ;EACrB,IAAIC,OAAO;EACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,IAAIE,MAAM,GAAGP,KAAK,CAACK,CAAC,CAAC,CAACG,EAAE;IACxB,IAAI,CAACP,KAAK,CAACM,MAAM,CAAC,IAAIR,CAAC,CAACQ,MAAM,CAAC,IAAIL,MAAM,EAAE;MACzCA,MAAM,GAAGH,CAAC,CAACQ,MAAM,CAAC;MAClBH,OAAO,GAAGJ,KAAK,CAACK,CAAC,CAAC;IACpB;EACF;EACA,OAAOD,OAAO;AAChB,CAAC;AACD,IAAIK,QAAQ,GAAG,SAASA,QAAQA,CAACC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,kBAAkB,EAAE;EAChF,IAAIC,EAAE,GAAGJ,SAAS,CAACV,KAAK;IACtBA,KAAK,GAAGc,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;IAC/BC,EAAE,GAAGL,SAAS,CAACM,KAAK;IACpBA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;EACjC,IAAIE,OAAO,GAAG,EAAE;EAChB,IAAIhB,KAAK,GAAG,CAAC,CAAC;EACd,IAAIF,CAAC,GAAG,CAAC,CAAC;EACV,IAAImB,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;EAChBlB,KAAK,CAACmB,OAAO,CAAC,UAAUC,IAAI,EAAEf,CAAC,EAAE;IAC/B,IAAIG,EAAE,GAAGY,IAAI,CAACZ,EAAE;IAChBS,OAAO,CAACI,IAAI,CAACb,EAAE,CAAC;IAChBT,CAAC,CAACS,EAAE,CAAC,GAAGL,QAAQ;IAChB,IAAIK,EAAE,KAAKG,MAAM,EAAEZ,CAAC,CAACS,EAAE,CAAC,GAAG,CAAC;EAC9B,CAAC,CAAC;EACF,IAAIc,OAAO,GAAGtB,KAAK,CAACM,MAAM;EAC1B,IAAIiB,OAAO,GAAG,SAASA,OAAOA,CAAClB,CAAC,EAAE;IAChC;IACA,IAAID,OAAO,GAAGN,SAAS,CAACC,CAAC,EAAEC,KAAK,EAAEC,KAAK,CAAC;IACxC,IAAIuB,SAAS,GAAGpB,OAAO,CAACI,EAAE;IAC1BP,KAAK,CAACuB,SAAS,CAAC,GAAG,IAAI;IACvB,IAAIzB,CAAC,CAACyB,SAAS,CAAC,KAAKrB,QAAQ,EAAE,OAAO,UAAU,CAAC,CAAC;IAClD,IAAIsB,YAAY,GAAG,EAAE;IACrB,IAAIb,QAAQ,EAAEa,YAAY,GAAG7B,iBAAiB,CAAC4B,SAAS,EAAER,KAAK,CAAC,CAAC,KAAKS,YAAY,GAAG5B,gBAAgB,CAAC2B,SAAS,EAAER,KAAK,CAAC;IACvHS,YAAY,CAACN,OAAO,CAAC,UAAUO,IAAI,EAAE;MACnC,IAAIC,UAAU,GAAGD,IAAI,CAACE,MAAM;MAC5B,IAAIC,UAAU,GAAGH,IAAI,CAACf,MAAM;MAC5B,IAAImB,CAAC,GAAGH,UAAU,KAAKH,SAAS,GAAGK,UAAU,GAAGF,UAAU;MAC1D,IAAII,MAAM,GAAGlB,kBAAkB,IAAIa,IAAI,CAACb,kBAAkB,CAAC,GAAGa,IAAI,CAACb,kBAAkB,CAAC,GAAG,CAAC;MAC1F,IAAId,CAAC,CAAC+B,CAAC,CAAC,GAAG/B,CAAC,CAACK,OAAO,CAACI,EAAE,CAAC,GAAGuB,MAAM,EAAE;QACjChC,CAAC,CAAC+B,CAAC,CAAC,GAAG/B,CAAC,CAACK,OAAO,CAACI,EAAE,CAAC,GAAGuB,MAAM;QAC7Bb,KAAK,CAACY,CAAC,CAAC,GAAG,CAAC1B,OAAO,CAACI,EAAE,CAAC;MACzB,CAAC,MAAM,IAAIT,CAAC,CAAC+B,CAAC,CAAC,KAAK/B,CAAC,CAACK,OAAO,CAACI,EAAE,CAAC,GAAGuB,MAAM,EAAE;QAC1Cb,KAAK,CAACY,CAAC,CAAC,CAACT,IAAI,CAACjB,OAAO,CAACI,EAAE,CAAC;MAC3B;IACF,CAAC,CAAC;EACJ,CAAC;EACD,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,OAAO,EAAEjB,CAAC,EAAE,EAAE;IAChCkB,OAAO,CAAClB,CAAC,CAAC;EACZ;EACAa,KAAK,CAACP,MAAM,CAAC,GAAG,CAACA,MAAM,CAAC;EACxB;EACA,IAAIqB,KAAK,GAAG,CAAC,CAAC;EACd,KAAK,IAAIJ,MAAM,IAAI7B,CAAC,EAAE;IACpB,IAAIA,CAAC,CAAC6B,MAAM,CAAC,KAAKzB,QAAQ,EAAE;MAC1B8B,YAAY,CAACtB,MAAM,EAAEiB,MAAM,EAAEV,KAAK,EAAEc,KAAK,CAAC;IAC5C;EACF;EACA;EACA,IAAIE,IAAI,GAAG,CAAC,CAAC;EACb,KAAK,IAAIN,MAAM,IAAII,KAAK,EAAE;IACxBE,IAAI,CAACN,MAAM,CAAC,GAAGI,KAAK,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC;EACjC;EACA,OAAO;IACLtB,MAAM,EAAEP,CAAC;IACTmC,IAAI,EAAEA,IAAI;IACVC,OAAO,EAAEH;EACX,CAAC;AACH,CAAC;AACD,eAAevB,QAAQ;AACvB,SAASwB,YAAYA,CAACtB,MAAM,EAAEiB,MAAM,EAAEV,KAAK,EAAEkB,UAAU,EAAE;EACvD,IAAIzB,MAAM,KAAKiB,MAAM,EAAE;IACrB,OAAO,CAACjB,MAAM,CAAC;EACjB;EACA,IAAIyB,UAAU,CAACR,MAAM,CAAC,EAAE;IACtB,OAAOQ,UAAU,CAACR,MAAM,CAAC;EAC3B;EACA,IAAII,KAAK,GAAG,EAAE;EACd,KAAK,IAAIK,EAAE,GAAG,CAAC,EAAEvB,EAAE,GAAGI,KAAK,CAACU,MAAM,CAAC,EAAES,EAAE,GAAGvB,EAAE,CAACR,MAAM,EAAE+B,EAAE,EAAE,EAAE;IACzD,IAAIC,IAAI,GAAGxB,EAAE,CAACuB,EAAE,CAAC;IACjB,IAAIE,SAAS,GAAGN,YAAY,CAACtB,MAAM,EAAE2B,IAAI,EAAEpB,KAAK,EAAEkB,UAAU,CAAC;IAC7D,IAAI,CAACG,SAAS,EAAE;IAChB,KAAK,IAAIxB,EAAE,GAAG,CAAC,EAAEyB,WAAW,GAAGD,SAAS,EAAExB,EAAE,GAAGyB,WAAW,CAAClC,MAAM,EAAES,EAAE,EAAE,EAAE;MACvE,IAAI0B,OAAO,GAAGD,WAAW,CAACzB,EAAE,CAAC;MAC7B,IAAIpB,OAAO,CAAC8C,OAAO,CAAC,EAAET,KAAK,CAACX,IAAI,CAAC3B,aAAa,CAACA,aAAa,CAAC,EAAE,EAAE+C,OAAO,EAAE,IAAI,CAAC,EAAE,CAACb,MAAM,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,KAAKI,KAAK,CAACX,IAAI,CAAC,CAACoB,OAAO,EAAEb,MAAM,CAAC,CAAC;IACvI;EACF;EACAQ,UAAU,CAACR,MAAM,CAAC,GAAGI,KAAK;EAC1B,OAAOI,UAAU,CAACR,MAAM,CAAC;AAC3B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}