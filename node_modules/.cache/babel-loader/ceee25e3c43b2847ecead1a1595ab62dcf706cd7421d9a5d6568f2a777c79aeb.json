{"ast":null,"code":"import { __read } from \"tslib\";\nimport { clone, min, minBy, max, maxBy } from '@antv/util';\n/**\n * 获得数据的最值\n */\nexport function getRange(data) {\n  if (data.length === 0) return [0, 0];\n  return [min(minBy(data, function (arr) {\n    return min(arr) || 0;\n  })), max(maxBy(data, function (arr) {\n    return max(arr) || 0;\n  }))];\n}\n/**\n * 数据转换为堆叠数据\n */\nexport function getStackedData(_) {\n  var data = clone(_);\n  // 生成堆叠数据\n  var datumLen = data[0].length;\n  // 上一个堆叠的数据值，分别记录正负\n  var _a = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2),\n    positivePrev = _a[0],\n    negativePrev = _a[1];\n  for (var i = 0; i < data.length; i += 1) {\n    var datum = data[i];\n    for (var j = 0; j < datumLen; j += 1) {\n      if (datum[j] >= 0) {\n        datum[j] += positivePrev[j];\n        positivePrev[j] = datum[j];\n      } else {\n        datum[j] += negativePrev[j];\n        negativePrev[j] = datum[j];\n      }\n    }\n  }\n  return data;\n}","map":{"version":3,"names":["clone","min","minBy","max","maxBy","getRange","data","length","arr","getStackedData","_","datumLen","_a","__read","Array","fill","positivePrev","negativePrev","i","datum","j"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/component/src/ui/sparkline/utils.ts"],"sourcesContent":["import { clone, min, minBy, max, maxBy } from '@antv/util';\nimport type { Data } from './types';\n\n/**\n * 获得数据的最值\n */\nexport function getRange(data: Data): [number, number] {\n  if (data.length === 0) return [0, 0];\n  return [\n    min(minBy(data, (arr) => min(arr) || 0) as number[]),\n    max(maxBy(data, (arr) => max(arr) || 0) as number[]),\n  ] as [number, number];\n}\n\n/**\n * 数据转换为堆叠数据\n */\nexport function getStackedData(_: Data): Data {\n  const data = clone(_);\n  // 生成堆叠数据\n  const datumLen = data[0].length;\n  // 上一个堆叠的数据值，分别记录正负\n  const [positivePrev, negativePrev] = [Array(datumLen).fill(0), Array(datumLen).fill(0)];\n  for (let i = 0; i < data.length; i += 1) {\n    const datum = data[i];\n    for (let j = 0; j < datumLen; j += 1) {\n      if (datum[j] >= 0) {\n        datum[j] += positivePrev[j];\n        positivePrev[j] = datum[j];\n      } else {\n        datum[j] += negativePrev[j];\n        negativePrev[j] = datum[j];\n      }\n    }\n  }\n  return data;\n}\n"],"mappings":";AAAA,SAASA,KAAK,EAAEC,GAAG,EAAEC,KAAK,EAAEC,GAAG,EAAEC,KAAK,QAAQ,YAAY;AAG1D;;;AAGA,OAAM,SAAUC,QAAQA,CAACC,IAAU;EACjC,IAAIA,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;EACpC,OAAO,CACLN,GAAG,CAACC,KAAK,CAACI,IAAI,EAAE,UAACE,GAAG;IAAK,OAAAP,GAAG,CAACO,GAAG,CAAC,IAAI,CAAC;EAAb,CAAa,CAAa,CAAC,EACpDL,GAAG,CAACC,KAAK,CAACE,IAAI,EAAE,UAACE,GAAG;IAAK,OAAAL,GAAG,CAACK,GAAG,CAAC,IAAI,CAAC;EAAb,CAAa,CAAa,CAAC,CACjC;AACvB;AAEA;;;AAGA,OAAM,SAAUC,cAAcA,CAACC,CAAO;EACpC,IAAMJ,IAAI,GAAGN,KAAK,CAACU,CAAC,CAAC;EACrB;EACA,IAAMC,QAAQ,GAAGL,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM;EAC/B;EACM,IAAAK,EAAA,GAAAC,MAAA,CAA+B,CAACC,KAAK,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC,EAAED,KAAK,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC,CAAC;IAAhFC,YAAY,GAAAJ,EAAA;IAAEK,YAAY,GAAAL,EAAA,GAAsD;EACvF,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,IAAI,CAACC,MAAM,EAAEW,CAAC,IAAI,CAAC,EAAE;IACvC,IAAMC,KAAK,GAAGb,IAAI,CAACY,CAAC,CAAC;IACrB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,QAAQ,EAAES,CAAC,IAAI,CAAC,EAAE;MACpC,IAAID,KAAK,CAACC,CAAC,CAAC,IAAI,CAAC,EAAE;QACjBD,KAAK,CAACC,CAAC,CAAC,IAAIJ,YAAY,CAACI,CAAC,CAAC;QAC3BJ,YAAY,CAACI,CAAC,CAAC,GAAGD,KAAK,CAACC,CAAC,CAAC;MAC5B,CAAC,MAAM;QACLD,KAAK,CAACC,CAAC,CAAC,IAAIH,YAAY,CAACG,CAAC,CAAC;QAC3BH,YAAY,CAACG,CAAC,CAAC,GAAGD,KAAK,CAACC,CAAC,CAAC;MAC5B;IACF;EACF;EACA,OAAOd,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}