{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Circle as GCircle } from '@antv/g';\nimport { getPortXYByPlacement, getTextStyleByPlacement, isSimplePort } from '../../utils/element';\nimport { inferIconStyle } from '../../utils/node';\nimport { getPaletteColors } from '../../utils/palette';\nimport { getRectIntersectPoint } from '../../utils/point';\nimport { omitStyleProps, subObject, subStyleProps } from '../../utils/prefix';\nimport { parseSize } from '../../utils/size';\nimport { mergeOptions } from '../../utils/style';\nimport { getWordWrapWidthByBox } from '../../utils/text';\nimport { setVisibility } from '../../utils/visibility';\nimport { BaseElement } from '../base-element';\nimport { Badge, Icon, Label } from '../shapes';\nimport { connectImage, dispatchPositionChange } from '../shapes/image';\n/**\n * <zh/> 节点元素的基类\n *\n * <en/> Base node class\n * @remarks\n * <zh/> 自定义节点时，建议将此类作为基类。这样，你只需要关注如何实现 keyShape 的绘制逻辑\n *\n * <zh/> 设计文档：https://www.yuque.com/antv/g6/gl1iof1xpzg6ed98\n *\n * <en/> When customizing a node, it is recommended to use this class as the base class. This way, you can directly focus on how to implement the drawing logic of keyShape\n *\n * <en/> Design document: https://www.yuque.com/antv/g6/gl1iof1xpzg6ed98\n */\nexport class BaseNode extends BaseElement {\n  constructor(options) {\n    super(mergeOptions({\n      style: BaseNode.defaultStyleProps\n    }, options));\n    this.type = 'node';\n  }\n  getSize(attributes = this.attributes) {\n    const {\n      size\n    } = attributes;\n    return parseSize(size);\n  }\n  getKeyStyle(attributes) {\n    const style = this.getGraphicStyle(attributes);\n    return Object.assign(omitStyleProps(style, ['label', 'halo', 'icon', 'badge', 'port']));\n  }\n  getLabelStyle(attributes) {\n    if (attributes.label === false || !attributes.labelText) return false;\n    const _a = subStyleProps(this.getGraphicStyle(attributes), 'label'),\n      {\n        placement,\n        maxWidth,\n        offsetX,\n        offsetY\n      } = _a,\n      labelStyle = __rest(_a, [\"placement\", \"maxWidth\", \"offsetX\", \"offsetY\"]);\n    const keyBounds = this.getShape('key').getLocalBounds();\n    return Object.assign(getTextStyleByPlacement(keyBounds, placement, offsetX, offsetY), {\n      wordWrapWidth: getWordWrapWidthByBox(keyBounds, maxWidth)\n    }, labelStyle);\n  }\n  getHaloStyle(attributes) {\n    if (attributes.halo === false) return false;\n    const _a = this.getKeyStyle(attributes),\n      {\n        fill\n      } = _a,\n      keyStyle = __rest(_a, [\"fill\"]);\n    const haloStyle = subStyleProps(this.getGraphicStyle(attributes), 'halo');\n    return Object.assign(Object.assign(Object.assign({}, keyStyle), {\n      stroke: fill\n    }), haloStyle);\n  }\n  getIconStyle(attributes) {\n    if (attributes.icon === false || !attributes.iconText && !attributes.iconSrc) return false;\n    const iconStyle = subStyleProps(this.getGraphicStyle(attributes), 'icon');\n    return Object.assign(inferIconStyle(attributes.size, iconStyle), iconStyle);\n  }\n  getBadgesStyle(attributes) {\n    var _a;\n    const badges = subObject(this.shapeMap, 'badge-');\n    const badgesShapeStyle = {};\n    Object.keys(badges).forEach(key => {\n      badgesShapeStyle[key] = false;\n    });\n    if (attributes.badge === false || !((_a = attributes.badges) === null || _a === void 0 ? void 0 : _a.length)) return badgesShapeStyle;\n    const {\n        badges: badgeOptions = [],\n        badgePalette,\n        opacity = 1\n      } = attributes,\n      restAttributes = __rest(attributes, [\"badges\", \"badgePalette\", \"opacity\"]);\n    const colors = getPaletteColors(badgePalette);\n    const badgeStyle = subStyleProps(this.getGraphicStyle(restAttributes), 'badge');\n    badgeOptions.forEach((option, i) => {\n      badgesShapeStyle[i] = Object.assign(Object.assign({\n        backgroundFill: colors ? colors[i % (colors === null || colors === void 0 ? void 0 : colors.length)] : undefined,\n        opacity\n      }, badgeStyle), this.getBadgeStyle(option));\n    });\n    return badgesShapeStyle;\n  }\n  getBadgeStyle(style) {\n    const keyShape = this.getShape('key');\n    const {\n        placement = 'top',\n        offsetX,\n        offsetY\n      } = style,\n      restStyle = __rest(style, [\"placement\", \"offsetX\", \"offsetY\"]);\n    const textStyle = getTextStyleByPlacement(keyShape.getLocalBounds(), placement, offsetX, offsetY, true);\n    return Object.assign(Object.assign({}, textStyle), restStyle);\n  }\n  getPortsStyle(attributes) {\n    var _a;\n    const ports = this.getPorts();\n    const portsShapeStyle = {};\n    Object.keys(ports).forEach(key => {\n      portsShapeStyle[key] = false;\n    });\n    if (attributes.port === false || !((_a = attributes.ports) === null || _a === void 0 ? void 0 : _a.length)) return portsShapeStyle;\n    const portStyle = subStyleProps(this.getGraphicStyle(attributes), 'port');\n    const {\n      ports: portOptions = []\n    } = attributes;\n    portOptions.forEach((option, index) => {\n      const key = option.key || index;\n      const mergedStyle = Object.assign(Object.assign({}, portStyle), option);\n      if (isSimplePort(mergedStyle)) {\n        portsShapeStyle[key] = false;\n      } else {\n        const [x, y] = this.getPortXY(attributes, option);\n        portsShapeStyle[key] = Object.assign({\n          transform: [['translate', x, y]]\n        }, mergedStyle);\n      }\n    });\n    return portsShapeStyle;\n  }\n  getPortXY(attributes, style) {\n    const {\n      placement = 'left'\n    } = style;\n    const keyShape = this.getShape('key');\n    return getPortXYByPlacement(getBoundsInOffscreen(this.context, keyShape), placement);\n  }\n  /**\n   * Get the ports for the node.\n   * @returns Ports shape map.\n   */\n  getPorts() {\n    return subObject(this.shapeMap, 'port-');\n  }\n  /**\n   * Get the center point of the node.\n   * @returns The center point of the node.\n   */\n  getCenter() {\n    return this.getShape('key').getBounds().center;\n  }\n  /**\n   * Get the point on the outer contour of the node that is the intersection with a line starting in the center the ending in the point `p`.\n   * @param point - The point to intersect with the node.\n   * @param useExtendedLine - Whether to use the extended line.\n   * @returns The intersection point.\n   */\n  getIntersectPoint(point, useExtendedLine = false) {\n    const keyShapeBounds = this.getShape('key').getBounds();\n    return getRectIntersectPoint(point, keyShapeBounds, useExtendedLine);\n  }\n  drawHaloShape(attributes, container) {\n    const style = this.getHaloStyle(attributes);\n    const keyShape = this.getShape('key');\n    this.upsert('halo', keyShape.constructor, style, container);\n  }\n  drawIconShape(attributes, container) {\n    const style = this.getIconStyle(attributes);\n    this.upsert('icon', Icon, style, container);\n    connectImage(this);\n  }\n  drawBadgeShapes(attributes, container) {\n    const badgesStyle = this.getBadgesStyle(attributes);\n    Object.keys(badgesStyle).forEach(key => {\n      const style = badgesStyle[key];\n      this.upsert(`badge-${key}`, Badge, style, container);\n    });\n  }\n  drawPortShapes(attributes, container) {\n    const portsStyle = this.getPortsStyle(attributes);\n    Object.keys(portsStyle).forEach(key => {\n      const style = portsStyle[key];\n      const shapeKey = `port-${key}`;\n      this.upsert(shapeKey, GCircle, style, container);\n    });\n  }\n  drawLabelShape(attributes, container) {\n    const style = this.getLabelStyle(attributes);\n    this.upsert('label', Label, style, container);\n  }\n  // 用于装饰抽象方法 / Used to decorate abstract methods\n  _drawKeyShape(attributes, container) {\n    return this.drawKeyShape(attributes, container);\n  }\n  render(attributes = this.parsedAttributes, container = this) {\n    // 1. key shape\n    this._drawKeyShape(attributes, container);\n    if (!this.getShape('key')) return;\n    // 2. halo, use shape same with keyShape\n    this.drawHaloShape(attributes, container);\n    // 3. icon\n    this.drawIconShape(attributes, container);\n    // 4. badges\n    this.drawBadgeShapes(attributes, container);\n    // 5. label\n    this.drawLabelShape(attributes, container);\n    // 6. ports\n    this.drawPortShapes(attributes, container);\n  }\n  update(attr) {\n    super.update(attr);\n    if (attr && ('x' in attr || 'y' in attr || 'z' in attr)) {\n      dispatchPositionChange(this);\n    }\n  }\n  onframe() {\n    this.drawBadgeShapes(this.parsedAttributes, this);\n    this.drawLabelShape(this.parsedAttributes, this);\n  }\n}\nBaseNode.defaultStyleProps = {\n  x: 0,\n  y: 0,\n  size: 32,\n  droppable: true,\n  draggable: true,\n  port: true,\n  ports: [],\n  portZIndex: 2,\n  portLinkToCenter: false,\n  badge: true,\n  badges: [],\n  badgeZIndex: 3,\n  halo: false,\n  haloDroppable: false,\n  haloLineDash: 0,\n  haloLineWidth: 12,\n  haloStrokeOpacity: 0.25,\n  haloPointerEvents: 'none',\n  haloZIndex: -1,\n  icon: true,\n  iconZIndex: 1,\n  label: true,\n  labelIsBillboard: true,\n  labelMaxWidth: '200%',\n  labelPlacement: 'bottom',\n  labelWordWrap: false,\n  labelZIndex: 0\n};\n/**\n * <zh/> 在离屏画布中获取图形包围盒\n *\n * <en/> Get the bounding box of the shape in the off-screen canvas\n * @param context - <zh/> 运行时上下文 <en/> Runtime context\n * @param shape - <zh/> 图形实例 <en/> Graphic instance\n * @returns <zh/> 图形包围盒 <en/> Graphic bounding box\n */\nfunction getBoundsInOffscreen(context, shape) {\n  if (!context) return shape.getLocalBounds();\n  // 将主图形靠背至全局空间，避免受到父级 transform 的影响\n  // 合理的操作应该是拷贝至离屏画布，但目前 G 有点问题\n  // Move the main shape to the global space to avoid being affected by the parent transform\n  // The reasonable operation should be moved to the off-screen canvas, but there is a problem with G at present\n  const canvas = context.canvas.getLayer();\n  const substitute = shape.cloneNode();\n  setVisibility(substitute, 'hidden');\n  canvas.appendChild(substitute);\n  const bounds = substitute.getLocalBounds();\n  substitute.destroy();\n  return bounds;\n}","map":{"version":3,"names":["Circle","GCircle","getPortXYByPlacement","getTextStyleByPlacement","isSimplePort","inferIconStyle","getPaletteColors","getRectIntersectPoint","omitStyleProps","subObject","subStyleProps","parseSize","mergeOptions","getWordWrapWidthByBox","setVisibility","BaseElement","Badge","Icon","Label","connectImage","dispatchPositionChange","BaseNode","constructor","options","style","defaultStyleProps","type","getSize","attributes","size","getKeyStyle","getGraphicStyle","Object","assign","getLabelStyle","label","labelText","_a","placement","maxWidth","offsetX","offsetY","labelStyle","__rest","keyBounds","getShape","getLocalBounds","wordWrapWidth","getHaloStyle","halo","fill","keyStyle","haloStyle","stroke","getIconStyle","icon","iconText","iconSrc","iconStyle","getBadgesStyle","badges","shapeMap","badgesShapeStyle","keys","forEach","key","badge","length","badgeOptions","badgePalette","opacity","restAttributes","colors","badgeStyle","option","i","backgroundFill","undefined","getBadgeStyle","keyShape","restStyle","textStyle","getPortsStyle","ports","getPorts","portsShapeStyle","port","portStyle","portOptions","index","mergedStyle","x","y","getPortXY","transform","getBoundsInOffscreen","context","getCenter","getBounds","center","getIntersectPoint","point","useExtendedLine","keyShapeBounds","drawHaloShape","container","upsert","drawIconShape","drawBadgeShapes","badgesStyle","drawPortShapes","portsStyle","shapeKey","drawLabelShape","_drawKeyShape","drawKeyShape","render","parsedAttributes","update","attr","onframe","droppable","draggable","portZIndex","portLinkToCenter","badgeZIndex","haloDroppable","haloLineDash","haloLineWidth","haloStrokeOpacity","haloPointerEvents","haloZIndex","iconZIndex","labelIsBillboard","labelMaxWidth","labelPlacement","labelWordWrap","labelZIndex","shape","canvas","getLayer","substitute","cloneNode","appendChild","bounds","destroy"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/elements/nodes/base-node.ts"],"sourcesContent":["import type { BaseStyleProps, CircleStyleProps, DisplayObject, DisplayObjectConfig, Group } from '@antv/g';\nimport { Circle as GCircle } from '@antv/g';\nimport type { CategoricalPalette } from '../../palettes/types';\nimport type { RuntimeContext } from '../../runtime/types';\nimport type { NodeData } from '../../spec';\nimport type {\n  ID,\n  Node,\n  NodeBadgeStyleProps,\n  NodeLabelStyleProps,\n  NodePortStyleProps,\n  Point,\n  Port,\n  PortPlacement,\n  PortStyleProps,\n  Prefix,\n  Size,\n} from '../../types';\nimport { getPortXYByPlacement, getTextStyleByPlacement, isSimplePort } from '../../utils/element';\nimport { inferIconStyle } from '../../utils/node';\nimport { getPaletteColors } from '../../utils/palette';\nimport { getRectIntersectPoint } from '../../utils/point';\nimport { omitStyleProps, subObject, subStyleProps } from '../../utils/prefix';\nimport { parseSize } from '../../utils/size';\nimport { mergeOptions } from '../../utils/style';\nimport { getWordWrapWidthByBox } from '../../utils/text';\nimport { setVisibility } from '../../utils/visibility';\nimport { BaseElement } from '../base-element';\nimport type { BadgeStyleProps, BaseShapeStyleProps, IconStyleProps, LabelStyleProps } from '../shapes';\nimport { Badge, Icon, Label } from '../shapes';\nimport { connectImage, dispatchPositionChange } from '../shapes/image';\n\n/**\n * <zh/> 节点通用样式配置项\n *\n * <en/> Base node style props\n */\nexport interface BaseNodeStyleProps\n  extends BaseShapeStyleProps,\n    Prefix<'label', NodeLabelStyleProps>,\n    Prefix<'halo', BaseStyleProps>,\n    Prefix<'icon', IconStyleProps>,\n    Prefix<'badge', BadgeStyleProps>,\n    Prefix<'port', PortStyleProps> {\n  /**\n   * <zh/> x 坐标\n   *\n   * <en/> The x-coordinate of node\n   */\n  x?: number;\n  /**\n   * <zh/> y 坐标\n   *\n   * <en/> The y-coordinate of node\n   */\n  y?: number;\n  /**\n   * <zh/> z 坐标\n   *\n   * <en/> The z-coordinate of node\n   */\n  z?: number;\n  /**\n   * <zh/> 节点大小，快捷设置节点宽高\n   * - 若值为数字，则表示节点的宽度、高度以及深度相同为指定值\n   * - 若值为数组，则按数组元素依次表示节点的宽度、高度以及深度\n   *\n   * <en/> The size of node, which is a shortcut to set the width and height of node\n   * - If the value is a number, it means the width, height, and depth of the node are the same as the specified value\n   * - If the value is an array, it means the width, height, and depth of the node are represented by the array elements in turn\n   */\n  size?: Size;\n  /**\n   * <zh/> 当前节点/组合是否展开\n   *\n   * <en/> Whether the current node/combo is expanded\n   */\n  collapsed?: boolean;\n  /**\n   * <zh/> 子节点实例\n   *\n   * <en/> The instance of the child node\n   * @remarks\n   * <zh/> 仅在树图中生效\n   *\n   * <en/> Only valid in the tree graph\n   * @ignore\n   */\n  childrenNode?: ID[];\n  /**\n   * <zh/> 子节点数据\n   *\n   * <en/> The data of the child node\n   * @remarks\n   * <zh/> 仅在树图中生效。如果当前节点为收起状态，children 可能为空，通过 childrenData 能够获取完整的子元素数据\n   *\n   * <en/> Only valid in the tree graph. If the current node is collapsed, children may be empty, and the complete child element data can be obtained through childrenData\n   * @ignore\n   */\n  childrenData?: NodeData[];\n  /**\n   * <zh/> 是否显示节点标签\n   *\n   * <en/> Whether to show the node label\n   * @defaultValue true\n   */\n  label?: boolean;\n  /**\n   * <zh/> 是否显示节点光晕\n   *\n   * <en/> Whether to show the node halo\n   * @defaultValue false\n   */\n  halo?: boolean;\n  /**\n   * <zh/> 是否显示节点图标\n   *\n   * <en/> Whether to show the node icon\n   * @defaultValue true\n   */\n  icon?: boolean;\n  /**\n   * <zh/> 是否显示节点徽标\n   *\n   * <en/> Whether to show the node badge\n   * @defaultValue true\n   */\n  badge?: boolean;\n  /**\n   * <zh/> 是否显示连接桩\n   *\n   * <en/> Whether to show the node port\n   * @defaultValue true\n   */\n  port?: boolean;\n  /**\n   * <zh/> 连接桩配置项，支持配置多个连接桩\n   *\n   * <en/> Port configuration, supports configuring multiple ports\n   * @example\n   * ```json\n   * {\n   *    port: true,\n   *    ports: [\n   *      { key: 'top', placement: [0.5, 0], r: 4, stroke: '#31d0c6', fill: '#fff' },\n   *      { key: 'bottom', placement: [0.5, 1], r: 4, stroke: '#31d0c6', fill: '#fff' },\n   *    ],\n   * }\n   * ```\n   */\n  ports?: NodePortStyleProps[];\n  /**\n   * <zh/> 徽标\n   *\n   * <en/> Badge\n   * @example\n   * ```json\n   * {\n   *    badge: true,\n   *    badges: [\n   *      { text: 'A', placement: 'right-top'},\n   *      { text: 'Important', placement: 'right' },\n   *      { text: 'Notice', placement: 'right-bottom' },\n   *    ],\n   *    badgePalette: ['#7E92B5', '#F4664A', '#FFBE3A'],\n   * }\n   * ```\n   */\n  badges?: NodeBadgeStyleProps[];\n  /**\n   * <zh/> 徽标的背景色板\n   *\n   * <en/> Badge background color palette\n   */\n  badgePalette?: CategoricalPalette;\n}\n\n/**\n * <zh/> 节点元素的基类\n *\n * <en/> Base node class\n * @remarks\n * <zh/> 自定义节点时，建议将此类作为基类。这样，你只需要关注如何实现 keyShape 的绘制逻辑\n *\n * <zh/> 设计文档：https://www.yuque.com/antv/g6/gl1iof1xpzg6ed98\n *\n * <en/> When customizing a node, it is recommended to use this class as the base class. This way, you can directly focus on how to implement the drawing logic of keyShape\n *\n * <en/> Design document: https://www.yuque.com/antv/g6/gl1iof1xpzg6ed98\n */\nexport abstract class BaseNode<S extends BaseNodeStyleProps = BaseNodeStyleProps>\n  extends BaseElement<S>\n  implements Node\n{\n  public type = 'node';\n\n  static defaultStyleProps: Partial<BaseNodeStyleProps> = {\n    x: 0,\n    y: 0,\n    size: 32,\n    droppable: true,\n    draggable: true,\n    port: true,\n    ports: [],\n    portZIndex: 2,\n    portLinkToCenter: false,\n    badge: true,\n    badges: [],\n    badgeZIndex: 3,\n    halo: false,\n    haloDroppable: false,\n    haloLineDash: 0,\n    haloLineWidth: 12,\n    haloStrokeOpacity: 0.25,\n    haloPointerEvents: 'none',\n    haloZIndex: -1,\n    icon: true,\n    iconZIndex: 1,\n    label: true,\n    labelIsBillboard: true,\n    labelMaxWidth: '200%',\n    labelPlacement: 'bottom',\n    labelWordWrap: false,\n    labelZIndex: 0,\n  };\n\n  constructor(options: DisplayObjectConfig<S>) {\n    super(mergeOptions({ style: BaseNode.defaultStyleProps }, options));\n  }\n\n  protected getSize(attributes = this.attributes) {\n    const { size } = attributes;\n    return parseSize(size);\n  }\n\n  protected getKeyStyle(attributes: Required<S>) {\n    const style = this.getGraphicStyle(attributes);\n\n    return Object.assign(omitStyleProps(style, ['label', 'halo', 'icon', 'badge', 'port'])) as any;\n  }\n\n  protected getLabelStyle(attributes: Required<S>): false | LabelStyleProps {\n    if (attributes.label === false || !attributes.labelText) return false;\n\n    const { placement, maxWidth, offsetX, offsetY, ...labelStyle } = subStyleProps<Required<NodeLabelStyleProps>>(\n      this.getGraphicStyle(attributes),\n      'label',\n    );\n    const keyBounds = this.getShape('key').getLocalBounds();\n\n    return Object.assign(\n      getTextStyleByPlacement(keyBounds, placement, offsetX, offsetY),\n      { wordWrapWidth: getWordWrapWidthByBox(keyBounds, maxWidth) },\n      labelStyle,\n    );\n  }\n\n  protected getHaloStyle(attributes: Required<S>) {\n    if (attributes.halo === false) return false;\n\n    const { fill, ...keyStyle } = this.getKeyStyle(attributes);\n    const haloStyle = subStyleProps(this.getGraphicStyle(attributes), 'halo');\n\n    return { ...keyStyle, stroke: fill, ...haloStyle } as any;\n  }\n\n  protected getIconStyle(attributes: Required<S>): false | IconStyleProps {\n    if (attributes.icon === false || (!attributes.iconText && !attributes.iconSrc)) return false;\n\n    const iconStyle = subStyleProps(this.getGraphicStyle(attributes), 'icon');\n\n    return Object.assign(inferIconStyle(attributes.size!, iconStyle), iconStyle);\n  }\n\n  protected getBadgesStyle(attributes: Required<S>): Record<string, NodeBadgeStyleProps | false> {\n    const badges = subObject(this.shapeMap, 'badge-');\n    const badgesShapeStyle: Record<string, NodeBadgeStyleProps | false> = {};\n\n    Object.keys(badges).forEach((key) => {\n      badgesShapeStyle[key] = false;\n    });\n    if (attributes.badge === false || !attributes.badges?.length) return badgesShapeStyle;\n\n    const { badges: badgeOptions = [], badgePalette, opacity = 1, ...restAttributes } = attributes;\n    const colors = getPaletteColors(badgePalette);\n    const badgeStyle = subStyleProps<BadgeStyleProps>(this.getGraphicStyle(restAttributes), 'badge');\n\n    badgeOptions.forEach((option, i) => {\n      badgesShapeStyle[i] = {\n        backgroundFill: colors ? colors[i % colors?.length] : undefined,\n        opacity,\n        ...badgeStyle,\n        ...this.getBadgeStyle(option),\n      };\n    });\n\n    return badgesShapeStyle;\n  }\n\n  protected getBadgeStyle(style: NodeBadgeStyleProps): NodeBadgeStyleProps {\n    const keyShape = this.getShape('key');\n    const { placement = 'top', offsetX, offsetY, ...restStyle } = style;\n    const textStyle = getTextStyleByPlacement(keyShape.getLocalBounds(), placement, offsetX, offsetY, true);\n    return { ...textStyle, ...restStyle };\n  }\n\n  protected getPortsStyle(attributes: Required<S>): Record<string, PortStyleProps | false> {\n    const ports = this.getPorts();\n    const portsShapeStyle: Record<string, PortStyleProps | false> = {};\n\n    Object.keys(ports).forEach((key) => {\n      portsShapeStyle[key] = false;\n    });\n\n    if (attributes.port === false || !attributes.ports?.length) return portsShapeStyle;\n\n    const portStyle = subStyleProps<PortStyleProps>(this.getGraphicStyle(attributes), 'port');\n    const { ports: portOptions = [] } = attributes;\n    portOptions.forEach((option, index) => {\n      const key = option.key || index;\n      const mergedStyle = { ...portStyle, ...option };\n      if (isSimplePort(mergedStyle)) {\n        portsShapeStyle[key] = false;\n      } else {\n        const [x, y] = this.getPortXY(attributes, option);\n        portsShapeStyle[key] = { transform: [['translate', x, y]], ...mergedStyle };\n      }\n    });\n    return portsShapeStyle;\n  }\n\n  protected getPortXY(attributes: Required<S>, style: NodePortStyleProps): Point {\n    const { placement = 'left' } = style;\n    const keyShape = this.getShape('key');\n    return getPortXYByPlacement(getBoundsInOffscreen(this.context, keyShape), placement as PortPlacement);\n  }\n\n  /**\n   * Get the ports for the node.\n   * @returns Ports shape map.\n   */\n  public getPorts(): Record<string, Port> {\n    return subObject(this.shapeMap, 'port-');\n  }\n\n  /**\n   * Get the center point of the node.\n   * @returns The center point of the node.\n   */\n  public getCenter(): Point {\n    return this.getShape('key').getBounds().center;\n  }\n\n  /**\n   * Get the point on the outer contour of the node that is the intersection with a line starting in the center the ending in the point `p`.\n   * @param point - The point to intersect with the node.\n   * @param useExtendedLine - Whether to use the extended line.\n   * @returns The intersection point.\n   */\n  public getIntersectPoint(point: Point, useExtendedLine = false): Point {\n    const keyShapeBounds = this.getShape('key').getBounds();\n    return getRectIntersectPoint(point, keyShapeBounds, useExtendedLine);\n  }\n\n  protected drawHaloShape(attributes: Required<S>, container: Group): void {\n    const style = this.getHaloStyle(attributes);\n    const keyShape = this.getShape('key');\n    this.upsert('halo', keyShape.constructor as new (...args: unknown[]) => DisplayObject, style, container);\n  }\n\n  protected drawIconShape(attributes: Required<S>, container: Group): void {\n    const style = this.getIconStyle(attributes);\n    this.upsert('icon', Icon, style, container);\n    connectImage(this);\n  }\n\n  protected drawBadgeShapes(attributes: Required<S>, container: Group): void {\n    const badgesStyle = this.getBadgesStyle(attributes);\n    Object.keys(badgesStyle).forEach((key) => {\n      const style = badgesStyle[key];\n      this.upsert(`badge-${key}`, Badge, style, container);\n    });\n  }\n\n  protected drawPortShapes(attributes: Required<S>, container: Group): void {\n    const portsStyle = this.getPortsStyle(attributes);\n\n    Object.keys(portsStyle).forEach((key) => {\n      const style = portsStyle[key] as CircleStyleProps;\n      const shapeKey = `port-${key}`;\n      this.upsert(shapeKey, GCircle, style, container);\n    });\n  }\n\n  protected drawLabelShape(attributes: Required<S>, container: Group): void {\n    const style = this.getLabelStyle(attributes);\n    this.upsert('label', Label, style, container);\n  }\n\n  protected abstract drawKeyShape(attributes: Required<S>, container: Group): DisplayObject | undefined;\n\n  // 用于装饰抽象方法 / Used to decorate abstract methods\n  private _drawKeyShape(attributes: Required<S>, container: Group) {\n    return this.drawKeyShape(attributes, container);\n  }\n\n  public render(attributes = this.parsedAttributes, container: Group = this) {\n    // 1. key shape\n    this._drawKeyShape(attributes, container);\n    if (!this.getShape('key')) return;\n\n    // 2. halo, use shape same with keyShape\n    this.drawHaloShape(attributes, container);\n\n    // 3. icon\n    this.drawIconShape(attributes, container);\n\n    // 4. badges\n    this.drawBadgeShapes(attributes, container);\n\n    // 5. label\n    this.drawLabelShape(attributes, container);\n\n    // 6. ports\n    this.drawPortShapes(attributes, container);\n  }\n\n  public update(attr?: Partial<S>): void {\n    super.update(attr);\n    if (attr && ('x' in attr || 'y' in attr || 'z' in attr)) {\n      dispatchPositionChange(this);\n    }\n  }\n\n  protected onframe() {\n    this.drawBadgeShapes(this.parsedAttributes, this);\n    this.drawLabelShape(this.parsedAttributes, this);\n  }\n}\n\n/**\n * <zh/> 在离屏画布中获取图形包围盒\n *\n * <en/> Get the bounding box of the shape in the off-screen canvas\n * @param context - <zh/> 运行时上下文 <en/> Runtime context\n * @param shape - <zh/> 图形实例 <en/> Graphic instance\n * @returns <zh/> 图形包围盒 <en/> Graphic bounding box\n */\nfunction getBoundsInOffscreen(context: RuntimeContext, shape: DisplayObject) {\n  if (!context) return shape.getLocalBounds();\n\n  // 将主图形靠背至全局空间，避免受到父级 transform 的影响\n  // 合理的操作应该是拷贝至离屏画布，但目前 G 有点问题\n  // Move the main shape to the global space to avoid being affected by the parent transform\n  // The reasonable operation should be moved to the off-screen canvas, but there is a problem with G at present\n  const canvas = context.canvas.getLayer();\n  const substitute = shape.cloneNode();\n  setVisibility(substitute, 'hidden');\n  canvas.appendChild(substitute);\n  const bounds = substitute.getLocalBounds();\n  substitute.destroy();\n\n  return bounds;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}