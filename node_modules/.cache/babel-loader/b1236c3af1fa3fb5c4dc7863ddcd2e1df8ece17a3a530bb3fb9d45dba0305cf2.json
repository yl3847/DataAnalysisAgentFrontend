{"ast":null,"code":"/**\n * bubblesets-js\n * https://github.com/upsetjs/bubblesets-js\n *\n * Copyright (c) 2021-2022 Samuel Gratzl <sam@sgratzl.com>\n */\n\nfunction linePtSegDistSq(lx1, ly1, lx2, ly2, x, y) {\n  const x1 = lx1;\n  const y1 = ly1;\n  const x2 = lx2 - x1;\n  const y2 = ly2 - y1;\n  let px = x - x1;\n  let py = y - y1;\n  let dotprod = px * x2 + py * y2;\n  let projlenSq = 0;\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n  const lenSq = px * px + py * py - projlenSq;\n  if (lenSq < 0) {\n    return 0;\n  }\n  return lenSq;\n}\nfunction ptsDistanceSq(x1, y1, x2, y2) {\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\nfunction doublePointsEqual(x1, y1, x2, y2, delta) {\n  return ptsDistanceSq(x1, y1, x2, y2) < delta * delta;\n}\nfunction round(digits) {\n  if (!Number.isFinite(digits)) {\n    return v => v;\n  }\n  if (digits === 0) {\n    return Math.round;\n  }\n  const factor = Math.pow(10, digits);\n  return v => Math.round(v * factor) / factor;\n}\nfunction lineBoundingBox(line) {\n  const minX = Math.min(line.x1, line.x2);\n  const maxX = Math.max(line.x1, line.x2);\n  const minY = Math.min(line.y1, line.y2);\n  const maxY = Math.max(line.y1, line.y2);\n  return {\n    x: minX,\n    y: minY,\n    x2: maxX,\n    y2: maxY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nclass Line {\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  equals(that) {\n    return this.x1 === that.x1 && this.y1 === that.y1 && this.x2 === that.x2 && this.y2 === that.y2;\n  }\n  draw(ctx) {\n    ctx.moveTo(this.x1, this.y1);\n    ctx.lineTo(this.x2, this.y2);\n  }\n  toString() {\n    return `Line(from=(${this.x1},${this.y1}),to=(${this.x2},${this.y2}))`;\n  }\n  static from(l) {\n    return new Line(l.x1, l.y1, l.x2, l.y2);\n  }\n  cuts(px, py) {\n    if (this.y1 === this.y2) {\n      return false;\n    }\n    if (py < this.y1 && py <= this.y2 || py > this.y1 && py >= this.y2) {\n      return false;\n    }\n    if (px > this.x1 && px >= this.x2) {\n      return false;\n    }\n    if (px < this.x1 && px <= this.x2) {\n      return true;\n    }\n    const cross = this.x1 + (py - this.y1) * (this.x2 - this.x1) / (this.y2 - this.y1);\n    return px <= cross;\n  }\n  distSquare(x, y) {\n    return linePtSegDistSq(this.x1, this.y1, this.x2, this.y2, x, y);\n  }\n  ptClose(x, y, r) {\n    if (this.x1 < this.x2) {\n      if (x < this.x1 - r || x > this.x2 + r) {\n        return false;\n      }\n    } else {\n      if (x < this.x2 - r || x > this.x1 + r) {\n        return false;\n      }\n    }\n    if (this.y1 < this.y2) {\n      if (y < this.y1 - r || y > this.y2 + r) {\n        return false;\n      }\n    } else {\n      if (y < this.y2 - r || y > this.y1 + r) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nvar EState;\n(function (EState) {\n  EState[EState[\"POINT\"] = 1] = \"POINT\";\n  EState[EState[\"PARALLEL\"] = 2] = \"PARALLEL\";\n  EState[EState[\"COINCIDENT\"] = 3] = \"COINCIDENT\";\n  EState[EState[\"NONE\"] = 4] = \"NONE\";\n})(EState || (EState = {}));\nclass Intersection {\n  constructor(state, x = 0, y = 0) {\n    this.state = state;\n    this.x = x;\n    this.y = y;\n  }\n}\nfunction intersectLineLine(la, lb) {\n  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n  if (uB) {\n    const ua = uaT / uB;\n    const ub = ubT / uB;\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return new Intersection(EState.POINT, la.x1 + ua * (la.x2 - la.x1), la.y1 + ua * (la.y2 - la.y1));\n    }\n    return new Intersection(EState.NONE);\n  }\n  return new Intersection(uaT === 0 || ubT === 0 ? EState.COINCIDENT : EState.PARALLEL);\n}\nfunction fractionAlongLineA(la, lb) {\n  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n  if (uB) {\n    const ua = uaT / uB;\n    const ub = ubT / uB;\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return ua;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\nfunction hasFractionToLineCenter(bounds, line) {\n  function testLine(xa, ya, xb, yb) {\n    let testDistance = fractionAlongLineA(line, new Line(xa, ya, xb, yb));\n    testDistance = Math.abs(testDistance - 0.5);\n    if (testDistance >= 0 && testDistance <= 1) {\n      return 1;\n    }\n    return 0;\n  }\n  let countIntersections = testLine(bounds.x, bounds.y, bounds.x2, bounds.y);\n  countIntersections += testLine(bounds.x, bounds.y, bounds.x, bounds.y2);\n  if (countIntersections > 1) {\n    return true;\n  }\n  countIntersections += testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);\n  if (countIntersections > 1) {\n    return true;\n  }\n  countIntersections += testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);\n  return countIntersections > 0;\n}\nvar OutCode;\n(function (OutCode) {\n  OutCode[OutCode[\"LEFT\"] = 0] = \"LEFT\";\n  OutCode[OutCode[\"TOP\"] = 1] = \"TOP\";\n  OutCode[OutCode[\"RIGHT\"] = 2] = \"RIGHT\";\n  OutCode[OutCode[\"BOTTOM\"] = 3] = \"BOTTOM\";\n})(OutCode || (OutCode = {}));\nfunction outcode(bounds, px, py) {\n  const out = new Set();\n  if (bounds.width <= 0) {\n    out.add(OutCode.LEFT);\n    out.add(OutCode.RIGHT);\n  } else if (px < bounds.x) {\n    out.add(OutCode.LEFT);\n  } else if (px > bounds.x + bounds.width) {\n    out.add(OutCode.RIGHT);\n  }\n  if (bounds.height <= 0) {\n    out.add(OutCode.TOP);\n    out.add(OutCode.BOTTOM);\n  } else if (py < bounds.y) {\n    out.add(OutCode.TOP);\n  } else if (py > bounds.y + bounds.height) {\n    out.add(OutCode.BOTTOM);\n  }\n  return out;\n}\nfunction intersectsLine(bounds, line) {\n  let x1 = line.x1;\n  let y1 = line.y1;\n  const x2 = line.x2;\n  const y2 = line.y2;\n  const out2 = Array.from(outcode(bounds, x2, y2));\n  if (out2.length === 0) {\n    return true;\n  }\n  let out1 = outcode(bounds, x1, y1);\n  while (out1.size !== 0) {\n    for (const a of out2) {\n      if (out1.has(a)) {\n        return false;\n      }\n    }\n    if (out1.has(OutCode.RIGHT) || out1.has(OutCode.LEFT)) {\n      let x = bounds.x;\n      if (out1.has(OutCode.RIGHT)) {\n        x += bounds.width;\n      }\n      y1 = y1 + (x - x1) * (y2 - y1) / (x2 - x1);\n      x1 = x;\n    } else {\n      let y = bounds.y;\n      if (out1.has(OutCode.BOTTOM)) {\n        y += bounds.height;\n      }\n      x1 = x1 + (y - y1) * (x2 - x1) / (y2 - y1);\n      y1 = y;\n    }\n    out1 = outcode(bounds, x1, y1);\n  }\n  return true;\n}\nfunction fractionToLineCenter(bounds, line) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  let countIntersections = 0;\n  function testLine(xa, ya, xb, yb) {\n    let testDistance = fractionAlongLineA(line, new Line(xa, ya, xb, yb));\n    testDistance = Math.abs(testDistance - 0.5);\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections++;\n      if (testDistance < minDistance) {\n        minDistance = testDistance;\n      }\n    }\n  }\n  testLine(bounds.x, bounds.y, bounds.x2, bounds.y);\n  testLine(bounds.x, bounds.y, bounds.x, bounds.y2);\n  if (countIntersections > 1) {\n    return minDistance;\n  }\n  testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);\n  if (countIntersections > 1) {\n    return minDistance;\n  }\n  testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);\n  if (countIntersections === 0) {\n    return -1;\n  }\n  return minDistance;\n}\nfunction testIntersection(line, bounds) {\n  let count = 0;\n  const top = intersectLineLine(line, new Line(bounds.x, bounds.y, bounds.x2, bounds.y));\n  count += top.state === EState.POINT ? 1 : 0;\n  const left = intersectLineLine(line, new Line(bounds.x, bounds.y, bounds.x, bounds.y2));\n  count += left.state === EState.POINT ? 1 : 0;\n  const bottom = intersectLineLine(line, new Line(bounds.x, bounds.y2, bounds.x2, bounds.y2));\n  count += bottom.state === EState.POINT ? 1 : 0;\n  const right = intersectLineLine(line, new Line(bounds.x2, bounds.y, bounds.x2, bounds.y2));\n  count += right.state === EState.POINT ? 1 : 0;\n  return {\n    top,\n    left,\n    bottom,\n    right,\n    count\n  };\n}\nclass Rectangle {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  get x2() {\n    return this.x + this.width;\n  }\n  get y2() {\n    return this.y + this.height;\n  }\n  get cx() {\n    return this.x + this.width / 2;\n  }\n  get cy() {\n    return this.y + this.height / 2;\n  }\n  get radius() {\n    return Math.max(this.width, this.height) / 2;\n  }\n  static from(r) {\n    return new Rectangle(r.x, r.y, r.width, r.height);\n  }\n  equals(that) {\n    return this.x === that.x && this.y === that.y && this.width === that.width && this.height === that.height;\n  }\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  add(that) {\n    const x = Math.min(this.x, that.x);\n    const y = Math.min(this.y, that.y);\n    const x2 = Math.max(this.x2, that.x + that.width);\n    const y2 = Math.max(this.y2, that.y + that.height);\n    this.x = x;\n    this.y = y;\n    this.width = x2 - x;\n    this.height = y2 - y;\n  }\n  addPoint(p) {\n    const x = Math.min(this.x, p.x);\n    const y = Math.min(this.y, p.y);\n    const x2 = Math.max(this.x2, p.x);\n    const y2 = Math.max(this.y2, p.y);\n    this.x = x;\n    this.y = y;\n    this.width = x2 - x;\n    this.height = y2 - y;\n  }\n  toString() {\n    return `Rectangle[x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height}]`;\n  }\n  draw(ctx) {\n    ctx.rect(this.x, this.y, this.width, this.height);\n  }\n  containsPt(px, py) {\n    return px >= this.x && px <= this.x2 && py >= this.y && py <= this.y2;\n  }\n  get area() {\n    return this.width * this.height;\n  }\n  intersects(that) {\n    if (this.area <= 0 || that.width <= 0 || that.height <= 0) {\n      return false;\n    }\n    return that.x + that.width > this.x && that.y + that.height > this.y && that.x < this.x2 && that.y < this.y2;\n  }\n  distSquare(tempX, tempY) {\n    if (this.containsPt(tempX, tempY)) {\n      return 0;\n    }\n    const code = outcode(this, tempX, tempY);\n    if (code.has(OutCode.TOP)) {\n      if (code.has(OutCode.LEFT)) {\n        return ptsDistanceSq(tempX, tempY, this.x, this.y);\n      }\n      if (code.has(OutCode.RIGHT)) {\n        return ptsDistanceSq(tempX, tempY, this.x2, this.y);\n      }\n      return (this.y - tempY) * (this.y - tempY);\n    }\n    if (code.has(OutCode.BOTTOM)) {\n      if (code.has(OutCode.LEFT)) {\n        return ptsDistanceSq(tempX, tempY, this.x, this.y2);\n      }\n      if (code.has(OutCode.RIGHT)) {\n        return ptsDistanceSq(tempX, tempY, this.x2, this.y2);\n      }\n      return (tempY - this.y2) * (tempY - this.y2);\n    }\n    if (code.has(OutCode.LEFT)) {\n      return (this.x - tempX) * (this.x - tempX);\n    }\n    if (code.has(OutCode.RIGHT)) {\n      return (tempX - this.x2) * (tempX - this.x2);\n    }\n    return 0;\n  }\n}\nfunction boundingBox(path) {\n  if (path.length === 0) {\n    return null;\n  }\n  const first = path[0];\n  const bb = new Rectangle(first.x, first.y, 0, 0);\n  for (const point of path) {\n    bb.addPoint(point);\n  }\n  return bb;\n}\nclass Circle {\n  constructor(cx, cy, radius) {\n    this.cx = cx;\n    this.cy = cy;\n    this.radius = radius;\n  }\n  get x() {\n    return this.cx - this.radius;\n  }\n  get x2() {\n    return this.cx + this.radius;\n  }\n  get width() {\n    return this.radius * 2;\n  }\n  get y() {\n    return this.cy - this.radius;\n  }\n  get y2() {\n    return this.cy + this.radius;\n  }\n  get height() {\n    return this.radius * 2;\n  }\n  static from(r) {\n    return new Circle(r.cx, r.cy, r.radius);\n  }\n  containsPt(x, y) {\n    return ptsDistanceSq(this.cx, this.cy, x, y) < this.radius * this.radius;\n  }\n  distSquare(tempX, tempY) {\n    const dist = ptsDistanceSq(this.cx, this.cy, tempX, tempY);\n    if (dist < this.radius * this.radius) {\n      return 0;\n    }\n    const offset = Math.sqrt(dist) - this.radius;\n    return offset * offset;\n  }\n  draw(ctx) {\n    ctx.ellipse(this.cx, this.cy, this.radius, this.radius, 0, 0, Math.PI * 2);\n  }\n}\nclass Area {\n  constructor(pixelGroup, i = 0, j = 0, pixelX = 0, pixelY = 0, width = 10, height = 10, pixels = new Float32Array(Math.max(0, width * height)).fill(0)) {\n    this.pixelGroup = pixelGroup;\n    this.i = i;\n    this.j = j;\n    this.pixelX = pixelX;\n    this.pixelY = pixelY;\n    this.width = width;\n    this.height = height;\n    this.area = pixels;\n  }\n  createSub(rect, pixelPos) {\n    return new Area(this.pixelGroup, rect.x, rect.y, pixelPos.x, pixelPos.y, rect.width, rect.height);\n  }\n  static fromPixelRegion(pixelRect, pixelGroup) {\n    return new Area(pixelGroup, 0, 0, pixelRect.x, pixelRect.y, Math.ceil(pixelRect.width / pixelGroup), Math.ceil(pixelRect.height / pixelGroup));\n  }\n  copy(sub, pixelPoint) {\n    return new Area(this.pixelGroup, this.scaleX(pixelPoint.x), this.scaleY(pixelPoint.y), pixelPoint.x, pixelPoint.y, sub.width, sub.height, sub.area);\n  }\n  boundX(pos) {\n    if (pos < this.i) {\n      return this.i;\n    }\n    if (pos >= this.width) {\n      return this.width - 1;\n    }\n    return pos;\n  }\n  boundY(pos) {\n    if (pos < this.j) {\n      return this.j;\n    }\n    if (pos >= this.height) {\n      return this.height - 1;\n    }\n    return pos;\n  }\n  scaleX(pixel) {\n    return this.boundX(Math.floor((pixel - this.pixelX) / this.pixelGroup));\n  }\n  scaleY(pixel) {\n    return this.boundY(Math.floor((pixel - this.pixelY) / this.pixelGroup));\n  }\n  scale(pixelRect) {\n    const x = this.scaleX(pixelRect.x);\n    const y = this.scaleY(pixelRect.y);\n    const x2 = this.boundX(Math.ceil((pixelRect.x + pixelRect.width - this.pixelX) / this.pixelGroup));\n    const y2 = this.boundY(Math.ceil((pixelRect.y + pixelRect.height - this.pixelY) / this.pixelGroup));\n    const width = x2 - x;\n    const height = y2 - y;\n    return new Rectangle(x, y, width, height);\n  }\n  invertScaleX(v) {\n    return Math.round(v * this.pixelGroup + this.pixelX);\n  }\n  invertScaleY(v) {\n    return Math.round(v * this.pixelGroup + this.pixelY);\n  }\n  addPadding(rect, pixelPadding) {\n    const padding = Math.ceil(pixelPadding / this.pixelGroup);\n    const x = this.boundX(rect.x - padding);\n    const y = this.boundY(rect.y - padding);\n    const x2 = this.boundX(rect.x2 + padding);\n    const y2 = this.boundY(rect.y2 + padding);\n    const width = x2 - x;\n    const height = y2 - y;\n    return new Rectangle(x, y, width, height);\n  }\n  get(i, j) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return Number.NaN;\n    }\n    return this.area[i + j * this.width];\n  }\n  inc(i, j, v) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return;\n    }\n    this.area[i + j * this.width] += v;\n  }\n  set(i, j, v) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return;\n    }\n    this.area[i + j * this.width] = v;\n  }\n  incArea(sub, factor) {\n    if (sub.width <= 0 || sub.height <= 0 || factor === 0) {\n      return;\n    }\n    const w = this.width;\n    const aw = sub.width;\n    const i1 = Math.max(0, sub.i);\n    const j1 = Math.max(0, sub.j);\n    const i2 = Math.min(sub.i + sub.width, w);\n    const j2 = Math.min(sub.j + sub.height, this.height);\n    if (j2 <= 0 || i2 <= 0 || i1 >= w || j2 >= this.height) {\n      return;\n    }\n    for (let j = j1; j < j2; j++) {\n      const subRow = (j - sub.j) * aw;\n      const row = j * w;\n      for (let i = i1; i < i2; i++) {\n        const v = sub.area[i - sub.i + subRow];\n        if (v === 0) {\n          continue;\n        }\n        this.area[i + row] += factor * v;\n      }\n    }\n  }\n  fill(value) {\n    this.area.fill(value);\n  }\n  fillArea(rect, value) {\n    const offset = rect.x + rect.y * this.width;\n    for (let j = 0; j < rect.height; j++) {\n      const pos = offset + j * this.width;\n      this.area.fill(value, pos, pos + rect.width);\n    }\n  }\n  fillHorizontalLine(i, j, width, value) {\n    const offset = i + j * this.width;\n    this.area.fill(value, offset, offset + width);\n  }\n  fillVerticalLine(i, j, height, value) {\n    const offset = i + j * this.width;\n    for (let k = 0; k < height; k++) {\n      this.area[offset + k * this.width] = value;\n    }\n  }\n  clear() {\n    this.area.fill(0);\n  }\n  toString() {\n    let r = '';\n    for (let j = 0; j < this.height; j++) {\n      const row = j * this.width;\n      for (let i = 0; i < this.width; i++) {\n        const v = this.area[row + i];\n        r += v.toFixed(1).padStart(6);\n        r += ' ';\n      }\n      r += '\\n';\n    }\n    return r;\n  }\n  draw(ctx, offset = true) {\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    ctx.save();\n    if (offset) {\n      ctx.translate(this.pixelX, this.pixelY);\n    }\n    const min = this.area.reduce((acc, v) => Math.min(acc, v), Number.POSITIVE_INFINITY);\n    const max = this.area.reduce((acc, v) => Math.max(acc, v), Number.NEGATIVE_INFINITY);\n    const scale = v => (v - min) / (max - min);\n    ctx.scale(this.pixelGroup, this.pixelGroup);\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        const v = this.area[i + j * this.width];\n        ctx.fillStyle = `rgba(0, 0, 0, ${scale(v)})`;\n        ctx.fillRect(i, j, 1, 1);\n      }\n    }\n    ctx.restore();\n  }\n  drawThreshold(ctx, threshold, offset = true) {\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    ctx.save();\n    if (offset) {\n      ctx.translate(this.pixelX, this.pixelY);\n    }\n    ctx.scale(this.pixelGroup, this.pixelGroup);\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        const v = this.area[i + j * this.width];\n        ctx.fillStyle = v > threshold ? 'black' : 'white';\n        ctx.fillRect(i, j, 1, 1);\n      }\n    }\n    ctx.restore();\n  }\n}\nfunction addPadding(rect, padding) {\n  const map = r => ({\n    x: r.x - padding,\n    y: r.y - padding,\n    width: r.width + 2 * padding,\n    height: r.height + 2 * padding\n  });\n  if (Array.isArray(rect)) {\n    return rect.map(map);\n  }\n  return map(rect);\n}\nfunction createLineInfluenceArea(line, potentialArea, padding) {\n  return createGenericInfluenceArea(Object.assign(lineBoundingBox(line), {\n    distSquare: (x, y) => linePtSegDistSq(line.x1, line.y1, line.x2, line.y2, x, y)\n  }), potentialArea, padding);\n}\nfunction createGenericInfluenceArea(shape, potentialArea, padding) {\n  const lr = addPadding(shape, padding);\n  const scaled = potentialArea.scale(lr);\n  const area = potentialArea.createSub(scaled, lr);\n  sample(area, potentialArea, padding, (x, y) => shape.distSquare(x, y));\n  return area;\n}\nfunction sample(area, potentialArea, padding, distanceFunction) {\n  const padding2 = padding * padding;\n  for (let y = 0; y < area.height; y++) {\n    for (let x = 0; x < area.width; x++) {\n      const tempX = potentialArea.invertScaleX(area.i + x);\n      const tempY = potentialArea.invertScaleY(area.j + y);\n      const distanceSq = distanceFunction(tempX, tempY);\n      if (distanceSq === 0) {\n        area.set(x, y, padding2);\n        continue;\n      }\n      if (distanceSq < padding2) {\n        const dr = padding - Math.sqrt(distanceSq);\n        area.set(x, y, dr * dr);\n      }\n    }\n  }\n  return area;\n}\nfunction createRectangleInfluenceArea(rect, potentialArea, padding) {\n  const scaled = potentialArea.scale(rect);\n  const padded = potentialArea.addPadding(scaled, padding);\n  const area = potentialArea.createSub(padded, {\n    x: rect.x - padding,\n    y: rect.y - padding\n  });\n  const paddingLeft = scaled.x - padded.x;\n  const paddingTop = scaled.y - padded.y;\n  const paddingRight = padded.x2 - scaled.x2;\n  const paddingBottom = padded.y2 - scaled.y2;\n  const innerWidth = padded.width - paddingLeft - paddingRight;\n  const innerHeight = padded.height - paddingTop - paddingBottom;\n  const padding2 = padding * padding;\n  area.fillArea({\n    x: paddingLeft,\n    y: paddingTop,\n    width: innerWidth + 1,\n    height: innerHeight + 1\n  }, padding2);\n  const straightDistances = [0];\n  const maxPadding = Math.max(paddingTop, paddingLeft, paddingRight, paddingBottom);\n  {\n    const tempX = potentialArea.invertScaleX(scaled.x + scaled.width / 2);\n    for (let i = 1; i < maxPadding; i++) {\n      const tempY = potentialArea.invertScaleY(scaled.y - i);\n      const distanceSq = rect.distSquare(tempX, tempY);\n      if (distanceSq < padding2) {\n        const dr = padding - Math.sqrt(distanceSq);\n        straightDistances.push(dr * dr);\n      } else {\n        break;\n      }\n    }\n  }\n  const cornerDistances = [];\n  const maxHorizontalPadding = Math.max(paddingLeft, paddingRight);\n  const maxVerticalPadding = Math.max(paddingTop, paddingRight);\n  for (let i = 1; i < maxHorizontalPadding; i++) {\n    const tempX = potentialArea.invertScaleX(scaled.x - i);\n    const row = [];\n    for (let j = 1; j < maxVerticalPadding; j++) {\n      const tempY = potentialArea.invertScaleY(scaled.y - j);\n      const distanceSq = rect.distSquare(tempX, tempY);\n      if (distanceSq < padding2) {\n        const dr = padding - Math.sqrt(distanceSq);\n        row.push(dr * dr);\n      } else {\n        row.push(0);\n      }\n    }\n    cornerDistances.push(row);\n  }\n  for (let y = 1; y < Math.min(paddingTop, straightDistances.length); y++) {\n    const value = straightDistances[y];\n    area.fillHorizontalLine(paddingLeft, paddingTop - y, innerWidth + 1, value);\n  }\n  for (let y = 1; y < Math.min(paddingBottom, straightDistances.length); y++) {\n    const value = straightDistances[y];\n    area.fillHorizontalLine(paddingLeft, paddingTop + innerHeight + y, innerWidth + 1, value);\n  }\n  for (let x = 1; x < Math.min(paddingLeft, straightDistances.length); x++) {\n    const value = straightDistances[x];\n    area.fillVerticalLine(paddingLeft - x, paddingTop, innerHeight + 1, value);\n  }\n  for (let x = 1; x < Math.min(paddingBottom, straightDistances.length); x++) {\n    const value = straightDistances[x];\n    area.fillVerticalLine(paddingLeft + innerWidth + x, paddingTop, innerHeight + 1, value);\n  }\n  for (let i = 1; i < paddingLeft; i++) {\n    const row = cornerDistances[i - 1];\n    const ii = paddingLeft - i;\n    for (let j = 1; j < paddingTop; j++) {\n      area.set(ii, paddingTop - j, row[j - 1]);\n    }\n    for (let j = 1; j < paddingBottom; j++) {\n      area.set(ii, paddingTop + innerHeight + j, row[j - 1]);\n    }\n  }\n  for (let i = 1; i < paddingRight; i++) {\n    const row = cornerDistances[i - 1];\n    const ii = paddingLeft + innerWidth + i;\n    for (let j = 1; j < paddingTop; j++) {\n      area.set(ii, paddingTop - j, row[j - 1]);\n    }\n    for (let j = 1; j < paddingBottom; j++) {\n      area.set(ii, paddingTop + innerHeight + j, row[j - 1]);\n    }\n  }\n  return area;\n}\nfunction rect(x, y, width, height) {\n  return {\n    x,\n    y,\n    width,\n    height\n  };\n}\nfunction circle(cx, cy, radius) {\n  return {\n    cx,\n    cy,\n    radius\n  };\n}\nfunction line(x1, y1, x2, y2) {\n  return {\n    x1,\n    y1,\n    x2,\n    y2\n  };\n}\nfunction point(x, y) {\n  return {\n    x,\n    y\n  };\n}\nfunction calculateVirtualEdges(items, nonMembers, maxRoutingIterations, morphBuffer) {\n  if (items.length === 0) {\n    return [];\n  }\n  const sorted = sortByDistanceToCentroid(items);\n  return sorted.map((d, i) => {\n    const visited = sorted.slice(0, i);\n    return connectItem(nonMembers, d, visited, maxRoutingIterations, morphBuffer);\n  }).flat();\n}\nfunction connectItem(nonMembers, item, visited, maxRoutingIterations, morphBuffer) {\n  const itemCenter = point(item.cx, item.cy);\n  const closestNeighbor = calculateClosestNeighbor(itemCenter, visited, nonMembers);\n  if (closestNeighbor == null) {\n    return [];\n  }\n  const directLine = new Line(itemCenter.x, itemCenter.y, closestNeighbor.cx, closestNeighbor.cy);\n  const scannedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  return mergeLines(scannedLines, nonMembers);\n}\nfunction computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  const scannedLines = [];\n  const linesToCheck = [];\n  linesToCheck.push(directLine);\n  let hasIntersection = true;\n  for (let iterations = 0; iterations < maxRoutingIterations && hasIntersection; iterations++) {\n    hasIntersection = false;\n    while (!hasIntersection && linesToCheck.length > 0) {\n      const line = linesToCheck.pop();\n      const closestItem = getCenterItem(nonMembers, line);\n      const intersections = closestItem ? testIntersection(line, closestItem) : null;\n      if (!closestItem || !intersections || intersections.count !== 2) {\n        if (!hasIntersection) {\n          scannedLines.push(line);\n        }\n        continue;\n      }\n      let tempMorphBuffer = morphBuffer;\n      let movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);\n      let foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n      let pointInside = isPointInRectangles(movePoint, nonMembers);\n      while (!foundFirst && pointInside && tempMorphBuffer >= 1) {\n        tempMorphBuffer /= 1.5;\n        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);\n        foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n        pointInside = isPointInRectangles(movePoint, nonMembers);\n      }\n      if (movePoint && !foundFirst && !pointInside) {\n        linesToCheck.push(new Line(line.x1, line.y1, movePoint.x, movePoint.y));\n        linesToCheck.push(new Line(movePoint.x, movePoint.y, line.x2, line.y2));\n        hasIntersection = true;\n      }\n      if (hasIntersection) {\n        continue;\n      }\n      tempMorphBuffer = morphBuffer;\n      movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);\n      let foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n      pointInside = isPointInRectangles(movePoint, nonMembers);\n      while (!foundSecond && pointInside && tempMorphBuffer >= 1) {\n        tempMorphBuffer /= 1.5;\n        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);\n        foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n        pointInside = isPointInRectangles(movePoint, nonMembers);\n      }\n      if (movePoint && !foundSecond) {\n        linesToCheck.push(new Line(line.x1, line.y1, movePoint.x, movePoint.y));\n        linesToCheck.push(new Line(movePoint.x, movePoint.y, line.x2, line.y2));\n        hasIntersection = true;\n      }\n      if (!hasIntersection) {\n        scannedLines.push(line);\n      }\n    }\n  }\n  while (linesToCheck.length > 0) {\n    scannedLines.push(linesToCheck.pop());\n  }\n  return scannedLines;\n}\nfunction mergeLines(scannedLines, nonMembers) {\n  const finalRoute = [];\n  while (scannedLines.length > 0) {\n    const line1 = scannedLines.pop();\n    if (scannedLines.length === 0) {\n      finalRoute.push(line1);\n      break;\n    }\n    const line2 = scannedLines.pop();\n    const mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n    const closestItem = getCenterItem(nonMembers, mergeLine);\n    if (!closestItem) {\n      scannedLines.push(mergeLine);\n    } else {\n      finalRoute.push(line1);\n      scannedLines.push(line2);\n    }\n  }\n  return finalRoute;\n}\nfunction calculateClosestNeighbor(itemCenter, visited, nonMembers) {\n  let minLengthSq = Number.POSITIVE_INFINITY;\n  return visited.reduce((closestNeighbor, neighborItem) => {\n    const distanceSq = ptsDistanceSq(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);\n    if (distanceSq > minLengthSq) {\n      return closestNeighbor;\n    }\n    const directLine = new Line(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);\n    const numberInterferenceItems = itemsCuttingLine(nonMembers, directLine);\n    if (distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1) < minLengthSq) {\n      closestNeighbor = neighborItem;\n      minLengthSq = distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1);\n    }\n    return closestNeighbor;\n  }, null);\n}\nfunction sortByDistanceToCentroid(items) {\n  if (items.length < 2) {\n    return items;\n  }\n  let totalX = 0;\n  let totalY = 0;\n  items.forEach(item => {\n    totalX += item.cx;\n    totalY += item.cy;\n  });\n  totalX /= items.length;\n  totalY /= items.length;\n  return items.map(item => {\n    const diffX = totalX - item.cx;\n    const diffY = totalY - item.cy;\n    const dist = diffX * diffX + diffY * diffY;\n    return [item, dist];\n  }).sort((a, b) => a[1] - b[1]).map(d => d[0]);\n}\nfunction isPointInRectangles(p, rects) {\n  return rects.some(r => r.containsPt(p.x, p.y));\n}\nfunction pointExists(pointToCheck, lines) {\n  return lines.some(checkEndPointsLine => {\n    if (doublePointsEqual(checkEndPointsLine.x1, checkEndPointsLine.y1, pointToCheck.x, pointToCheck.y, 1e-3)) {\n      return true;\n    }\n    if (doublePointsEqual(checkEndPointsLine.x2, checkEndPointsLine.y2, pointToCheck.x, pointToCheck.y, 1e-3)) {\n      return true;\n    }\n    return false;\n  });\n}\nfunction getCenterItem(items, testLine) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  let closestItem = null;\n  for (const item of items) {\n    if (!intersectsLine(item, testLine)) {\n      continue;\n    }\n    const distance = fractionToLineCenter(item, testLine);\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  }\n  return closestItem;\n}\nfunction itemsCuttingLine(items, testLine) {\n  return items.reduce((count, item) => {\n    if (intersectsLine(item, testLine) && hasFractionToLineCenter(item, testLine)) {\n      return count + 1;\n    }\n    return count;\n  }, 0);\n}\nfunction rerouteLine(item, rerouteBuffer, intersections, wrapNormal) {\n  const topIntersect = intersections.top;\n  const leftIntersect = intersections.left;\n  const bottomIntersect = intersections.bottom;\n  const rightIntersect = intersections.right;\n  if (wrapNormal) {\n    if (leftIntersect.state === EState.POINT) {\n      if (topIntersect.state === EState.POINT) return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n      if (bottomIntersect.state === EState.POINT) return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n      const totalArea = item.width * item.height;\n      const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);\n      if (topArea < totalArea * 0.5) {\n        if (leftIntersect.y > rightIntersect.y) return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n        return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n      }\n      if (leftIntersect.y < rightIntersect.y) return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n      return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    if (rightIntersect.state === EState.POINT) {\n      if (topIntersect.state === EState.POINT) return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n      if (bottomIntersect.state === EState.POINT) return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    const totalArea = item.height * item.width;\n    const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);\n    if (leftArea < totalArea * 0.5) {\n      if (topIntersect.x > bottomIntersect.x) return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n      return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    if (topIntersect.x < bottomIntersect.x) return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n  }\n  if (leftIntersect.state === EState.POINT) {\n    if (topIntersect.state === EState.POINT) return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    if (bottomIntersect.state === EState.POINT) return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    const totalArea = item.height * item.width;\n    const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y) return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n      return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    if (leftIntersect.y < rightIntersect.y) return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n  }\n  if (rightIntersect.state === EState.POINT) {\n    if (topIntersect.state === EState.POINT) return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    if (bottomIntersect.state === EState.POINT) return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n  }\n  const totalArea = item.height * item.width;\n  const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x) return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n  }\n  if (topIntersect.x < bottomIntersect.x) return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n  return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n}\nfunction canTakeNext(path, start, end, toleranceSquared) {\n  const validEnd = path.closed ? end < path.length : end < path.length - 1;\n  if (!validEnd) {\n    return false;\n  }\n  const s = path.get(start);\n  const e = path.get(end + 1);\n  for (let index = start + 1; index <= end; index++) {\n    const p = path.get(index);\n    const len = linePtSegDistSq(s.x, s.y, e.x, e.y, p.x, p.y);\n    if (len > toleranceSquared) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shapeSimplifier(tolerance = 0.0) {\n  return path => {\n    if (tolerance < 0 || path.length < 3) {\n      return path;\n    }\n    const points = [];\n    let start = 0;\n    const toleranceSquared = tolerance * tolerance;\n    while (start < path.length) {\n      let end = start + 1;\n      while (canTakeNext(path, start, end, toleranceSquared)) {\n        end++;\n      }\n      points.push(path.get(start));\n      start = end;\n    }\n    return new PointPath(points);\n  };\n}\nfunction basicFunction(i, t) {\n  switch (i) {\n    case -2:\n      return (((-t + 3.0) * t - 3.0) * t + 1.0) / 6.0;\n    case -1:\n      return ((3.0 * t - 6.0) * t * t + 4.0) / 6.0;\n    case 0:\n      return (((-3.0 * t + 3.0) * t + 3.0) * t + 1.0) / 6.0;\n    case 1:\n      return t * t * t / 6.0;\n    default:\n      throw new Error('unknown error');\n  }\n}\nfunction bSplineShapeGenerator(granularity = 6.0) {\n  const ORDER = 3;\n  const START_INDEX = ORDER - 1;\n  const REL_END = 1;\n  const REL_START = REL_END - ORDER;\n  function calcPoint(path, i, t) {\n    let px = 0.0;\n    let py = 0.0;\n    for (let j = REL_START; j <= REL_END; j++) {\n      const p = path.get(i + j);\n      const bf = basicFunction(j, t);\n      px += bf * p.x;\n      py += bf * p.y;\n    }\n    return {\n      x: px,\n      y: py\n    };\n  }\n  return path => {\n    if (path.length < 3) {\n      return path;\n    }\n    const res = [];\n    const closed = path.closed;\n    const count = path.length + ORDER - 1 + (closed ? 0 : 2);\n    res.push(calcPoint(path, START_INDEX - (closed ? 0 : 2), 0));\n    for (let ix = START_INDEX - (closed ? 0 : 2); ix < count; ix++) {\n      for (let k = 1; k <= granularity; k++) {\n        res.push(calcPoint(path, ix, k / granularity));\n      }\n    }\n    return new PointPath(res);\n  };\n}\nfunction samplePath(skip = 8) {\n  return path => {\n    let actSkip = skip;\n    let size = path.length;\n    if (actSkip > 1) {\n      size = Math.floor(path.length / actSkip);\n      while (size < 3 && actSkip > 1) {\n        actSkip -= 1;\n        size = Math.floor(path.length / actSkip);\n      }\n    }\n    const finalHull = [];\n    for (let i = 0, j = 0; j < size; j++, i += actSkip) {\n      finalHull.push(path.get(i));\n    }\n    return new PointPath(finalHull);\n  };\n}\nclass PointPath {\n  constructor(points = [], closed = true) {\n    this.points = points;\n    this.closed = closed;\n  }\n  get(index) {\n    const i = index;\n    const l = this.points.length;\n    if (index < 0) {\n      return this.closed ? this.get(index + l) : this.points[0];\n    } else if (index >= l) {\n      return this.closed ? this.get(index - l) : this.points[l - 1];\n    }\n    return this.points[i];\n  }\n  get length() {\n    return this.points.length;\n  }\n  toString(roundToDigits = Infinity) {\n    const points = this.points;\n    if (points.length === 0) {\n      return '';\n    }\n    const rounder = typeof roundToDigits === 'function' ? roundToDigits : round(roundToDigits);\n    let r = 'M';\n    for (const p of points) {\n      r += `${rounder(p.x)},${rounder(p.y)} L`;\n    }\n    r = r.slice(0, -1);\n    if (this.closed) {\n      r += ' Z';\n    }\n    return r;\n  }\n  draw(ctx) {\n    const points = this.points;\n    if (points.length === 0) {\n      return;\n    }\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for (const p of points) {\n      ctx.lineTo(p.x, p.y);\n    }\n    if (this.closed) {\n      ctx.closePath();\n    }\n  }\n  sample(skip) {\n    return samplePath(skip)(this);\n  }\n  simplify(tolerance) {\n    return shapeSimplifier(tolerance)(this);\n  }\n  bSplines(granularity) {\n    return bSplineShapeGenerator(granularity)(this);\n  }\n  apply(transformer) {\n    return transformer(this);\n  }\n  containsElements(members) {\n    const bb = boundingBox(this.points);\n    if (!bb) {\n      return false;\n    }\n    return members.every(member => {\n      return bb.containsPt(member.cx, member.cy) && this.withinArea(member.cx, member.cy);\n    });\n  }\n  withinArea(px, py) {\n    if (this.length === 0) {\n      return false;\n    }\n    let crossings = 0;\n    const first = this.points[0];\n    const line = new Line(first.x, first.y, first.x, first.y);\n    for (let i = 1; i < this.points.length; i++) {\n      const cur = this.points[i];\n      line.x1 = line.x2;\n      line.y1 = line.y2;\n      line.x2 = cur.x;\n      line.y2 = cur.y;\n      if (line.cuts(px, py)) {\n        crossings++;\n      }\n    }\n    line.x1 = line.x2;\n    line.y1 = line.y2;\n    line.x2 = first.x;\n    line.y2 = first.y;\n    if (line.cuts(px, py)) {\n      crossings++;\n    }\n    return crossings % 2 === 1;\n  }\n}\nclass PointList {\n  constructor(size = 0) {\n    this.count = 0;\n    this.arr = [];\n    this.set = new Set();\n    this.arr.length = size;\n  }\n  add(p) {\n    this.set.add(`${p.x}x${p.y}`);\n    this.arr[this.count++] = p;\n  }\n  contains(p) {\n    return this.set.has(`${p.x}x${p.y}`);\n  }\n  isFirst(p) {\n    if (this.count === 0) {\n      return false;\n    }\n    const o = this.arr[0];\n    return o != null && o.x === p.x && o.y === p.y;\n  }\n  path() {\n    return new PointPath(this.arr.slice(0, this.count));\n  }\n  clear() {\n    this.set.clear();\n    this.count = 0;\n  }\n  get(ix) {\n    return this.arr[ix];\n  }\n  get length() {\n    return this.count;\n  }\n}\nconst N = 0;\nconst S = 1;\nconst E = 2;\nconst W = 3;\nfunction marchingSquares(potentialArea, threshold) {\n  const estLength = (Math.floor(potentialArea.width) + Math.floor(potentialArea.height)) * 2;\n  const contour = new PointList(estLength);\n  function updateDir(x, y, dir, res) {\n    const v = potentialArea.get(x, y);\n    if (Number.isNaN(v)) {\n      return Number.NaN;\n    }\n    if (v > threshold) {\n      return dir + res;\n    }\n    return dir;\n  }\n  function getState(x, y) {\n    let dir = N;\n    dir = updateDir(x, y, dir, 1);\n    dir = updateDir(x + 1, y, dir, 2);\n    dir = updateDir(x, y + 1, dir, 4);\n    dir = updateDir(x + 1, y + 1, dir, 8);\n    if (Number.isNaN(dir)) {\n      return -1;\n    }\n    return dir;\n  }\n  let direction = S;\n  function doMarch(xPos, yPos) {\n    let x = xPos;\n    let y = yPos;\n    let xPixel = potentialArea.invertScaleX(x);\n    let yPixel = potentialArea.invertScaleY(y);\n    for (let i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      const p = {\n        x: xPixel,\n        y: yPixel\n      };\n      if (contour.contains(p)) {\n        if (!contour.isFirst(p)) ;else {\n          return true;\n        }\n      } else {\n        contour.add(p);\n      }\n      const state = getState(x, y);\n      switch (state) {\n        case -1:\n          return true;\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          direction = E;\n          break;\n        case 12:\n        case 14:\n        case 4:\n          direction = W;\n          break;\n        case 6:\n          direction = direction === N ? W : E;\n          break;\n        case 1:\n        case 13:\n        case 5:\n          direction = N;\n          break;\n        case 9:\n          direction = direction === E ? N : S;\n          break;\n        case 10:\n        case 8:\n        case 11:\n          direction = S;\n          break;\n        default:\n          console.warn('Marching squares invalid state: ' + state);\n          return true;\n      }\n      switch (direction) {\n        case N:\n          y--;\n          yPixel -= potentialArea.pixelGroup;\n          break;\n        case S:\n          y++;\n          yPixel += potentialArea.pixelGroup;\n          break;\n        case W:\n          x--;\n          xPixel -= potentialArea.pixelGroup;\n          break;\n        case E:\n          x++;\n          xPixel += potentialArea.pixelGroup;\n          break;\n        default:\n          console.warn('Marching squares invalid state: ' + state);\n          return true;\n      }\n    }\n    return true;\n  }\n  for (let x = 0; x < potentialArea.width; x++) {\n    for (let y = 0; y < potentialArea.height; y++) {\n      if (potentialArea.get(x, y) <= threshold) {\n        continue;\n      }\n      const state = getState(x, y);\n      if (state < 0 || state === 15) {\n        continue;\n      }\n      if (doMarch(x, y)) {\n        return contour.path();\n      }\n    }\n  }\n  return null;\n}\nconst defaultOptions = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 20,\n  pixelGroup: 4,\n  edgeR0: 10,\n  edgeR1: 20,\n  nodeR0: 15,\n  nodeR1: 50,\n  morphBuffer: 10,\n  threshold: 1,\n  memberInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  nonMemberInfluenceFactor: -0.8,\n  virtualEdges: true\n};\nfunction isCircle(v) {\n  return v != null && typeof v.radius === 'number';\n}\nfunction isEqual(a, b) {\n  if (isCircle(a) !== isCircle(b)) {\n    return false;\n  }\n  if (isCircle(a)) {\n    const bc = b;\n    return a.cx === bc.cx && a.cy === bc.cy && a.radius === bc.radius;\n  }\n  const br = b;\n  return a.x === br.x && a.y === br.y && a.width === br.width && a.height === br.height;\n}\nvar EDirty;\n(function (EDirty) {\n  EDirty[EDirty[\"MEMBERS\"] = 0] = \"MEMBERS\";\n  EDirty[EDirty[\"NON_MEMBERS\"] = 1] = \"NON_MEMBERS\";\n  EDirty[EDirty[\"EDGES\"] = 2] = \"EDGES\";\n})(EDirty || (EDirty = {}));\nclass BubbleSets {\n  constructor(options = {}) {\n    this.dirty = new Set();\n    this.members = [];\n    this.nonMembers = [];\n    this.virtualEdges = [];\n    this.edges = [];\n    this.activeRegion = new Rectangle(0, 0, 0, 0);\n    this.potentialArea = new Area(1, 0, 0, 0, 0, 0, 0);\n    this.o = Object.assign({}, defaultOptions, options);\n  }\n  pushMember(...members) {\n    if (members.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.MEMBERS);\n    for (const v of members) {\n      this.members.push({\n        raw: v,\n        obj: isCircle(v) ? Circle.from(v) : Rectangle.from(v),\n        area: null\n      });\n    }\n  }\n  removeMember(member) {\n    const index = this.members.findIndex(d => isEqual(d.raw, member));\n    if (index < 0) {\n      return false;\n    }\n    this.members.splice(index, 1);\n    this.dirty.add(EDirty.MEMBERS);\n    return true;\n  }\n  removeNonMember(nonMember) {\n    const index = this.nonMembers.findIndex(d => isEqual(d.raw, nonMember));\n    if (index < 0) {\n      return false;\n    }\n    this.nonMembers.splice(index, 1);\n    this.dirty.add(EDirty.NON_MEMBERS);\n    return true;\n  }\n  removeEdge(edge) {\n    const index = this.edges.findIndex(d => d.obj.equals(edge));\n    if (index < 0) {\n      return false;\n    }\n    this.edges.splice(index, 1);\n    this.dirty.add(EDirty.NON_MEMBERS);\n    return true;\n  }\n  pushNonMember(...nonMembers) {\n    if (nonMembers.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.NON_MEMBERS);\n    for (const v of nonMembers) {\n      this.nonMembers.push({\n        raw: v,\n        obj: isCircle(v) ? Circle.from(v) : Rectangle.from(v),\n        area: null\n      });\n    }\n  }\n  pushEdge(...edges) {\n    if (edges.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.EDGES);\n    for (const v of edges) {\n      this.edges.push({\n        raw: v,\n        obj: Line.from(v),\n        area: null\n      });\n    }\n  }\n  update() {\n    const dirtyMembers = this.dirty.has(EDirty.MEMBERS);\n    const dirtyNonMembers = this.dirty.has(EDirty.NON_MEMBERS);\n    let dirtyEdges = this.dirty.has(EDirty.EDGES);\n    this.dirty.clear();\n    const memberObjs = this.members.map(d => d.obj);\n    if (this.o.virtualEdges && (dirtyMembers || dirtyNonMembers)) {\n      const nonMembersAsRects = this.nonMembers.map(d => d.obj);\n      const virtualEdges = calculateVirtualEdges(memberObjs, nonMembersAsRects, this.o.maxRoutingIterations, this.o.morphBuffer);\n      const old = new Map(this.virtualEdges.map(e => [e.obj.toString(), e.area]));\n      this.virtualEdges = virtualEdges.map(e => {\n        var _a;\n        return {\n          raw: e,\n          obj: e,\n          area: (_a = old.get(e.toString())) !== null && _a !== void 0 ? _a : null\n        };\n      });\n      dirtyEdges = true;\n    }\n    let activeRegionDirty = false;\n    if (dirtyMembers || dirtyEdges) {\n      const edgesObj = this.virtualEdges.concat(this.edges).map(e => e.obj);\n      const bb = unionBoundingBox(memberObjs, edgesObj);\n      const padding = Math.max(this.o.edgeR1, this.o.nodeR1) + this.o.morphBuffer;\n      const activeRegion = Rectangle.from(addPadding(bb, padding));\n      if (!activeRegion.equals(this.activeRegion)) {\n        activeRegionDirty = true;\n        this.activeRegion = activeRegion;\n      }\n    }\n    if (activeRegionDirty) {\n      const potentialWidth = Math.ceil(this.activeRegion.width / this.o.pixelGroup);\n      const potentialHeight = Math.ceil(this.activeRegion.height / this.o.pixelGroup);\n      if (this.activeRegion.x !== this.potentialArea.pixelX || this.activeRegion.y !== this.potentialArea.pixelY) {\n        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);\n        this.members.forEach(m => m.area = null);\n        this.nonMembers.forEach(m => m.area = null);\n        this.edges.forEach(m => m.area = null);\n        this.virtualEdges.forEach(m => m.area = null);\n      } else if (potentialWidth !== this.potentialArea.width || potentialHeight !== this.potentialArea.height) {\n        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);\n      }\n    }\n    const existing = new Map();\n    const addCache = m => {\n      if (m.area) {\n        const key = `${m.obj.width}x${m.obj.height}x${m.obj instanceof Rectangle ? 'R' : 'C'}`;\n        existing.set(key, m.area);\n      }\n    };\n    const createOrAddCache = m => {\n      if (m.area) {\n        return;\n      }\n      const key = `${m.obj.width}x${m.obj.height}x${m.obj instanceof Rectangle ? 'R' : 'C'}`;\n      if (existing.has(key)) {\n        const r = existing.get(key);\n        m.area = this.potentialArea.copy(r, {\n          x: m.obj.x - this.o.nodeR1,\n          y: m.obj.y - this.o.nodeR1\n        });\n        return;\n      }\n      const r = m.obj instanceof Rectangle ? createRectangleInfluenceArea(m.obj, this.potentialArea, this.o.nodeR1) : createGenericInfluenceArea(m.obj, this.potentialArea, this.o.nodeR1);\n      m.area = r;\n      existing.set(key, r);\n    };\n    this.members.forEach(addCache);\n    this.nonMembers.forEach(addCache);\n    this.members.forEach(createOrAddCache);\n    this.nonMembers.forEach(m => {\n      if (!this.activeRegion.intersects(m.obj)) {\n        m.area = null;\n      } else {\n        createOrAddCache(m);\n      }\n    });\n    this.edges.forEach(edge => {\n      if (!edge.area) {\n        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);\n      }\n    });\n    this.virtualEdges.forEach(edge => {\n      if (!edge.area) {\n        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);\n      }\n    });\n  }\n  drawMembers(ctx) {\n    for (const member of this.members) {\n      member.obj.draw(ctx);\n    }\n  }\n  drawNonMembers(ctx) {\n    for (const member of this.nonMembers) {\n      member.obj.draw(ctx);\n    }\n  }\n  drawEdges(ctx) {\n    for (const edge of this.edges) {\n      edge.obj.draw(ctx);\n    }\n  }\n  drawPotentialArea(ctx, offset = true) {\n    this.potentialArea.draw(ctx, offset);\n  }\n  compute() {\n    if (this.members.length === 0) {\n      return new PointPath([]);\n    }\n    if (this.dirty.size > 0) {\n      this.update();\n    }\n    const {\n      o,\n      potentialArea\n    } = this;\n    const members = this.members.map(m => m.area);\n    const edges = this.virtualEdges.concat(this.edges).map(d => d.area);\n    const nonMembers = this.nonMembers.filter(d => d.area != null).map(d => d.area);\n    const memberObjs = this.members.map(m => m.obj);\n    return calculatePotentialOutline(potentialArea, members, edges, nonMembers, p => p.containsElements(memberObjs), o);\n  }\n}\nfunction calculatePotentialOutline(potentialArea, members, edges, nonMembers, validPath, options = {}) {\n  const o = Object.assign({}, defaultOptions, options);\n  let threshold = o.threshold;\n  let memberInfluenceFactor = o.memberInfluenceFactor;\n  let edgeInfluenceFactor = o.edgeInfluenceFactor;\n  let nonMemberInfluenceFactor = o.nonMemberInfluenceFactor;\n  const nodeInfA = (o.nodeR0 - o.nodeR1) * (o.nodeR0 - o.nodeR1);\n  const edgeInfA = (o.edgeR0 - o.edgeR1) * (o.edgeR0 - o.edgeR1);\n  for (let iterations = 0; iterations < o.maxMarchingIterations; iterations++) {\n    potentialArea.clear();\n    if (memberInfluenceFactor !== 0) {\n      const f = memberInfluenceFactor / nodeInfA;\n      for (const item of members) {\n        potentialArea.incArea(item, f);\n      }\n    }\n    if (edgeInfluenceFactor !== 0) {\n      const f = edgeInfluenceFactor / edgeInfA;\n      for (const area of edges) {\n        potentialArea.incArea(area, f);\n      }\n    }\n    if (nonMemberInfluenceFactor !== 0) {\n      const f = nonMemberInfluenceFactor / nodeInfA;\n      for (const area of nonMembers) {\n        potentialArea.incArea(area, f);\n      }\n    }\n    const contour = marchingSquares(potentialArea, threshold);\n    if (contour && validPath(contour)) {\n      return contour;\n    }\n    threshold *= 0.95;\n    if (iterations <= o.maxMarchingIterations * 0.5) {\n      memberInfluenceFactor *= 1.2;\n      edgeInfluenceFactor *= 1.2;\n    } else if (nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n  return new PointPath([]);\n}\nfunction unionBoundingBox(memberItems, edgeItems) {\n  if (memberItems.length === 0) {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  const activeRegion = Rectangle.from(memberItems[0]);\n  for (const m of memberItems) {\n    activeRegion.add(m);\n  }\n  for (const l of edgeItems) {\n    activeRegion.add(lineBoundingBox(l));\n  }\n  return activeRegion;\n}\nfunction createOutline(members, nonMembers = [], edges = [], options = {}) {\n  if (members.length === 0) {\n    return new PointPath([]);\n  }\n  const bb = new BubbleSets(options);\n  bb.pushMember(...members);\n  bb.pushNonMember(...nonMembers);\n  bb.pushEdge(...edges);\n  return bb.compute();\n}\nexport { Area, BubbleSets, Circle, Line, PointPath, Rectangle, addPadding, boundingBox, calculatePotentialOutline, calculateVirtualEdges, circle, createGenericInfluenceArea, createLineInfluenceArea, createOutline, createRectangleInfluenceArea, BubbleSets as default, defaultOptions, line, lineBoundingBox, point, rect, unionBoundingBox };","map":{"version":3,"names":["linePtSegDistSq","lx1","ly1","lx2","ly2","x","y","x1","y1","x2","y2","px","py","dotprod","projlenSq","lenSq","ptsDistanceSq","doublePointsEqual","delta","round","digits","Number","isFinite","v","Math","factor","pow","lineBoundingBox","line","minX","min","maxX","max","minY","maxY","width","height","Line","constructor","equals","that","draw","ctx","moveTo","lineTo","toString","from","l","cuts","cross","distSquare","ptClose","r","EState","Intersection","state","intersectLineLine","la","lb","uaT","ubT","uB","ua","ub","POINT","NONE","COINCIDENT","PARALLEL","fractionAlongLineA","POSITIVE_INFINITY","hasFractionToLineCenter","bounds","testLine","xa","ya","xb","yb","testDistance","abs","countIntersections","OutCode","outcode","out","Set","add","LEFT","RIGHT","TOP","BOTTOM","intersectsLine","out2","Array","length","out1","size","a","has","fractionToLineCenter","minDistance","testIntersection","count","top","left","bottom","right","Rectangle","cx","cy","radius","clone","addPoint","p","rect","containsPt","area","intersects","tempX","tempY","code","boundingBox","path","first","bb","point","Circle","dist","offset","sqrt","ellipse","PI","Area","pixelGroup","i","j","pixelX","pixelY","pixels","Float32Array","fill","createSub","pixelPos","fromPixelRegion","pixelRect","ceil","copy","sub","pixelPoint","scaleX","scaleY","boundX","pos","boundY","pixel","floor","scale","invertScaleX","invertScaleY","addPadding","pixelPadding","padding","get","NaN","inc","set","incArea","w","aw","i1","j1","i2","j2","subRow","row","value","fillArea","fillHorizontalLine","fillVerticalLine","k","clear","toFixed","padStart","save","translate","reduce","acc","NEGATIVE_INFINITY","fillStyle","fillRect","restore","drawThreshold","threshold","map","isArray","createLineInfluenceArea","potentialArea","createGenericInfluenceArea","Object","assign","shape","lr","scaled","sample","distanceFunction","padding2","distanceSq","dr","createRectangleInfluenceArea","padded","paddingLeft","paddingTop","paddingRight","paddingBottom","innerWidth","innerHeight","straightDistances","maxPadding","push","cornerDistances","maxHorizontalPadding","maxVerticalPadding","ii","circle","calculateVirtualEdges","items","nonMembers","maxRoutingIterations","morphBuffer","sorted","sortByDistanceToCentroid","d","visited","slice","connectItem","flat","item","itemCenter","closestNeighbor","calculateClosestNeighbor","directLine","scannedLines","computeRoute","mergeLines","linesToCheck","hasIntersection","iterations","pop","closestItem","getCenterItem","intersections","tempMorphBuffer","movePoint","rerouteLine","foundFirst","pointExists","pointInside","isPointInRectangles","foundSecond","finalRoute","line1","line2","mergeLine","minLengthSq","neighborItem","numberInterferenceItems","itemsCuttingLine","totalX","totalY","forEach","diffX","diffY","sort","b","rects","some","pointToCheck","lines","checkEndPointsLine","distance","rerouteBuffer","wrapNormal","topIntersect","leftIntersect","bottomIntersect","rightIntersect","totalArea","topArea","leftArea","canTakeNext","start","end","toleranceSquared","validEnd","closed","s","e","index","len","shapeSimplifier","tolerance","points","PointPath","basicFunction","t","Error","bSplineShapeGenerator","granularity","ORDER","START_INDEX","REL_END","REL_START","calcPoint","bf","res","ix","samplePath","skip","actSkip","finalHull","roundToDigits","Infinity","rounder","beginPath","closePath","simplify","bSplines","apply","transformer","containsElements","members","every","member","withinArea","crossings","cur","PointList","arr","contains","isFirst","o","N","S","E","W","marchingSquares","estLength","contour","updateDir","dir","isNaN","getState","direction","doMarch","xPos","yPos","xPixel","yPixel","console","warn","defaultOptions","maxMarchingIterations","edgeR0","edgeR1","nodeR0","nodeR1","memberInfluenceFactor","edgeInfluenceFactor","nonMemberInfluenceFactor","virtualEdges","isCircle","isEqual","bc","br","EDirty","BubbleSets","options","dirty","edges","activeRegion","pushMember","MEMBERS","raw","obj","removeMember","findIndex","splice","removeNonMember","nonMember","NON_MEMBERS","removeEdge","edge","pushNonMember","pushEdge","EDGES","update","dirtyMembers","dirtyNonMembers","dirtyEdges","memberObjs","nonMembersAsRects","old","Map","_a","activeRegionDirty","edgesObj","concat","unionBoundingBox","potentialWidth","potentialHeight","m","existing","addCache","key","createOrAddCache","drawMembers","drawNonMembers","drawEdges","drawPotentialArea","compute","filter","calculatePotentialOutline","validPath","nodeInfA","edgeInfA","f","memberItems","edgeItems","createOutline"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/utils.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/model/Line.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/Intersection.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/model/Rectangle.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/model/Circle.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/model/Area.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/padding.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/potentialAreas.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/interfaces.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/routing.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/simplifiers/ShapeSimplifier.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/simplifiers/BSplineShapeGenerator.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/simplifiers/Sample.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/PointPath.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/model/PointList.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/MarchingSquares.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/bubblesets-js/src/BubbleSets.ts"],"sourcesContent":["export function linePtSegDistSq(lx1: number, ly1: number, lx2: number, ly2: number, x: number, y: number) {\n  // taken from JDK 8 java.awt.geom.Line2D#ptSegDistSq(double, double, double, double, double, double)\n  const x1 = lx1;\n  const y1 = ly1;\n  const x2 = lx2 - x1;\n  const y2 = ly2 - y1;\n  let px = x - x1;\n  let py = y - y1;\n  let dotprod = px * x2 + py * y2;\n  let projlenSq = 0;\n\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = (dotprod * dotprod) / (x2 * x2 + y2 * y2);\n    }\n  }\n\n  const lenSq = px * px + py * py - projlenSq;\n  if (lenSq < 0) {\n    return 0;\n  }\n  return lenSq;\n}\n\nexport function ptsDistanceSq(x1: number, y1: number, x2: number, y2: number) {\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\n\nexport function doublePointsEqual(x1: number, y1: number, x2: number, y2: number, delta: number) {\n  return ptsDistanceSq(x1, y1, x2, y2) < delta * delta;\n}\n\nexport function round(digits: number) {\n  if (!Number.isFinite(digits)) {\n    return (v: number) => v;\n  }\n  if (digits === 0) {\n    return Math.round;\n  }\n  const factor = Math.pow(10, digits);\n  return (v: number) => Math.round(v * factor) / factor;\n}\n","import { linePtSegDistSq } from '../utils';\nimport type { ILine, IRectangle2 } from '../interfaces';\n\nexport function lineBoundingBox(line: ILine): IRectangle2 {\n  const minX = Math.min(line.x1, line.x2);\n  const maxX = Math.max(line.x1, line.x2);\n  const minY = Math.min(line.y1, line.y2);\n  const maxY = Math.max(line.y1, line.y2);\n\n  return {\n    x: minX,\n    y: minY,\n    x2: maxX,\n    y2: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nexport class Line {\n  constructor(\n    public x1: number,\n    public y1: number,\n    public x2: number,\n    public y2: number\n  ) {}\n\n  equals(that: ILine) {\n    return this.x1 === that.x1 && this.y1 === that.y1 && this.x2 === that.x2 && this.y2 === that.y2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.moveTo(this.x1, this.y1);\n    ctx.lineTo(this.x2, this.y2);\n  }\n\n  toString() {\n    return `Line(from=(${this.x1},${this.y1}),to=(${this.x2},${this.y2}))`;\n  }\n\n  static from(l: { x1: number; y1: number; x2: number; y2: number }) {\n    return new Line(l.x1, l.y1, l.x2, l.y2);\n  }\n\n  // whether an infinite line to positive x from the point p will cut through the line\n  cuts(px: number, py: number) {\n    if (this.y1 === this.y2) {\n      return false;\n    }\n    if ((py < this.y1 && py <= this.y2) || (py > this.y1 && py >= this.y2)) {\n      return false;\n    }\n    if (px > this.x1 && px >= this.x2) {\n      return false;\n    }\n    if (px < this.x1 && px <= this.x2) {\n      return true;\n    }\n    const cross = this.x1 + ((py - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1);\n    return px <= cross;\n  }\n\n  distSquare(x: number, y: number) {\n    return linePtSegDistSq(this.x1, this.y1, this.x2, this.y2, x, y);\n  }\n\n  ptClose(x: number, y: number, r: number) {\n    // check whether the point is outside the bounding rectangle with padding r\n    if (this.x1 < this.x2) {\n      if (x < this.x1 - r || x > this.x2 + r) {\n        return false;\n      }\n    } else {\n      if (x < this.x2 - r || x > this.x1 + r) {\n        return false;\n      }\n    }\n    if (this.y1 < this.y2) {\n      if (y < this.y1 - r || y > this.y2 + r) {\n        return false;\n      }\n    } else {\n      if (y < this.y2 - r || y > this.y1 + r) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","import { Line } from './model/Line';\nimport type { IRectangle2, ILine, IRectangle } from './interfaces';\n\nexport enum EState {\n  POINT = 1,\n  PARALLEL = 2,\n  COINCIDENT = 3,\n  NONE = 4,\n}\n\nexport class Intersection {\n  constructor(\n    public readonly state: EState,\n    public readonly x = 0,\n    public readonly y = 0\n  ) {}\n}\n\nexport function intersectLineLine(la: ILine, lb: ILine) {\n  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n  if (uB) {\n    const ua = uaT / uB;\n    const ub = ubT / uB;\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return new Intersection(EState.POINT, la.x1 + ua * (la.x2 - la.x1), la.y1 + ua * (la.y2 - la.y1));\n    }\n    return new Intersection(EState.NONE);\n  }\n  return new Intersection(uaT === 0 || ubT === 0 ? EState.COINCIDENT : EState.PARALLEL);\n}\n\nexport function fractionAlongLineA(la: ILine, lb: ILine) {\n  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n  if (uB) {\n    const ua = uaT / uB;\n    const ub = ubT / uB;\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return ua;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\n\nexport function hasFractionToLineCenter(bounds: IRectangle2, line: ILine) {\n  function testLine(xa: number, ya: number, xb: number, yb: number) {\n    let testDistance = fractionAlongLineA(line, new Line(xa, ya, xb, yb));\n    testDistance = Math.abs(testDistance - 0.5);\n    if (testDistance >= 0 && testDistance <= 1) {\n      return 1;\n    }\n    return 0;\n  }\n\n  // top\n  let countIntersections = testLine(bounds.x, bounds.y, bounds.x2, bounds.y);\n  // left\n  countIntersections += testLine(bounds.x, bounds.y, bounds.x, bounds.y2);\n  if (countIntersections > 1) {\n    return true;\n  }\n  // bottom\n  countIntersections += testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);\n  if (countIntersections > 1) {\n    return true;\n  }\n  // right\n  countIntersections += testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);\n  // if no intersection, return -1\n  return countIntersections > 0;\n}\n\nexport enum OutCode {\n  LEFT,\n  TOP,\n  RIGHT,\n  BOTTOM,\n}\n\nexport function outcode(bounds: IRectangle, px: number, py: number): Set<OutCode> {\n  // taken from JDK 8 java.awt.geom.Rectangle2D.Double#outcode(double, double)\n  const out = new Set<OutCode>();\n  if (bounds.width <= 0) {\n    out.add(OutCode.LEFT);\n    out.add(OutCode.RIGHT);\n  } else if (px < bounds.x) {\n    out.add(OutCode.LEFT);\n  } else if (px > bounds.x + bounds.width) {\n    out.add(OutCode.RIGHT);\n  }\n  if (bounds.height <= 0) {\n    out.add(OutCode.TOP);\n    out.add(OutCode.BOTTOM);\n  } else if (py < bounds.y) {\n    out.add(OutCode.TOP);\n  } else if (py > bounds.y + bounds.height) {\n    out.add(OutCode.BOTTOM);\n  }\n  return out;\n}\n\nexport function intersectsLine(bounds: IRectangle, line: ILine) {\n  let x1 = line.x1;\n  let y1 = line.y1;\n  const x2 = line.x2;\n  const y2 = line.y2;\n  // taken from JDK 8 java.awt.geom.Rectangle2D.Double#intersectsLine(double, double, double, double)\n  const out2 = Array.from(outcode(bounds, x2, y2));\n  if (out2.length === 0) {\n    return true;\n  }\n  let out1 = outcode(bounds, x1, y1);\n  while (out1.size !== 0) {\n    for (const a of out2) {\n      if (out1.has(a)) {\n        return false;\n      }\n    }\n    if (out1.has(OutCode.RIGHT) || out1.has(OutCode.LEFT)) {\n      let x = bounds.x;\n      if (out1.has(OutCode.RIGHT)) {\n        x += bounds.width;\n      }\n      y1 = y1 + ((x - x1) * (y2 - y1)) / (x2 - x1);\n      x1 = x;\n    } else {\n      let y = bounds.y;\n      if (out1.has(OutCode.BOTTOM)) {\n        y += bounds.height;\n      }\n      x1 = x1 + ((y - y1) * (x2 - x1)) / (y2 - y1);\n      y1 = y;\n    }\n    out1 = outcode(bounds, x1, y1);\n  }\n  return true;\n}\n\nexport function fractionToLineCenter(bounds: IRectangle2, line: ILine) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  let countIntersections = 0;\n\n  function testLine(xa: number, ya: number, xb: number, yb: number) {\n    let testDistance = fractionAlongLineA(line, new Line(xa, ya, xb, yb));\n    testDistance = Math.abs(testDistance - 0.5);\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections++;\n      if (testDistance < minDistance) {\n        minDistance = testDistance;\n      }\n    }\n  }\n\n  // top\n  testLine(bounds.x, bounds.y, bounds.x2, bounds.y);\n  // left\n  testLine(bounds.x, bounds.y, bounds.x, bounds.y2);\n  if (countIntersections > 1) {\n    return minDistance;\n  }\n  // bottom\n  testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);\n  if (countIntersections > 1) {\n    return minDistance;\n  }\n  // right\n  testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);\n  // if no intersection, return -1\n  if (countIntersections === 0) {\n    return -1;\n  }\n  return minDistance;\n}\n\nexport function fractionToLineEnd(bounds: IRectangle2, line: ILine) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  let countIntersections = 0;\n\n  function testLine(xa: number, ya: number, xb: number, yb: number) {\n    const testDistance = fractionAlongLineA(line, new Line(xa, ya, xb, yb));\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections++;\n      if (testDistance < minDistance) {\n        minDistance = testDistance;\n      }\n    }\n  }\n\n  // top\n  testLine(bounds.x, bounds.y, bounds.x2, bounds.y);\n  // left\n  testLine(bounds.x, bounds.y, bounds.x, bounds.y2);\n  if (countIntersections > 1) {\n    return minDistance;\n  }\n  // bottom\n  testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);\n  if (countIntersections > 1) {\n    return minDistance;\n  }\n  // right\n  testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);\n  // if no intersection, return -1\n  if (countIntersections === 0) {\n    return -1;\n  }\n  return minDistance;\n}\n\nexport function testIntersection(line: ILine, bounds: IRectangle2) {\n  let count = 0;\n  // top\n  const top = intersectLineLine(line, new Line(bounds.x, bounds.y, bounds.x2, bounds.y));\n  count += top.state === EState.POINT ? 1 : 0;\n  // left\n  const left = intersectLineLine(line, new Line(bounds.x, bounds.y, bounds.x, bounds.y2));\n  count += left.state === EState.POINT ? 1 : 0;\n  // bottom\n  const bottom = intersectLineLine(line, new Line(bounds.x, bounds.y2, bounds.x2, bounds.y2));\n  count += bottom.state === EState.POINT ? 1 : 0;\n  // right\n  const right = intersectLineLine(line, new Line(bounds.x2, bounds.y, bounds.x2, bounds.y2));\n  count += right.state === EState.POINT ? 1 : 0;\n\n  return { top, left, bottom, right, count };\n}\n","import type { IPoint, IRectangle, IRectangle2, ICircle } from '../interfaces';\nimport { ptsDistanceSq } from '../utils';\nimport { outcode, OutCode } from '../Intersection';\n\nexport class Rectangle implements IRectangle2, ICircle {\n  constructor(\n    public x: number,\n    public y: number,\n    public width: number,\n    public height: number\n  ) {}\n\n  get x2() {\n    return this.x + this.width;\n  }\n\n  get y2() {\n    return this.y + this.height;\n  }\n\n  get cx() {\n    return this.x + this.width / 2;\n  }\n\n  get cy() {\n    return this.y + this.height / 2;\n  }\n\n  get radius() {\n    return Math.max(this.width, this.height) / 2;\n  }\n\n  static from(r: IRectangle) {\n    return new Rectangle(r.x, r.y, r.width, r.height);\n  }\n\n  equals(that: IRectangle) {\n    return this.x === that.x && this.y === that.y && this.width === that.width && this.height === that.height;\n  }\n\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n\n  add(that: IRectangle) {\n    const x = Math.min(this.x, that.x);\n    const y = Math.min(this.y, that.y);\n    const x2 = Math.max(this.x2, that.x + that.width);\n    const y2 = Math.max(this.y2, that.y + that.height);\n    this.x = x;\n    this.y = y;\n    this.width = x2 - x;\n    this.height = y2 - y;\n  }\n\n  addPoint(p: IPoint) {\n    const x = Math.min(this.x, p.x);\n    const y = Math.min(this.y, p.y);\n    const x2 = Math.max(this.x2, p.x);\n    const y2 = Math.max(this.y2, p.y);\n    this.x = x;\n    this.y = y;\n    this.width = x2 - x;\n    this.height = y2 - y;\n  }\n\n  toString() {\n    return `Rectangle[x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height}]`;\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.rect(this.x, this.y, this.width, this.height);\n  }\n\n  containsPt(px: number, py: number) {\n    return px >= this.x && px <= this.x2 && py >= this.y && py <= this.y2;\n  }\n\n  get area() {\n    return this.width * this.height;\n  }\n\n  intersects(that: IRectangle) {\n    if (this.area <= 0 || that.width <= 0 || that.height <= 0) {\n      return false;\n    }\n    return that.x + that.width > this.x && that.y + that.height > this.y && that.x < this.x2 && that.y < this.y2;\n  }\n\n  distSquare(tempX: number, tempY: number) {\n    // test current point to see if it is inside rectangle\n    if (this.containsPt(tempX, tempY)) {\n      return 0;\n    }\n    // which edge of rectangle is closest\n    const code = outcode(this, tempX, tempY);\n    // top\n    if (code.has(OutCode.TOP)) {\n      // and left\n      if (code.has(OutCode.LEFT)) {\n        // linear distance from upper left corner\n        return ptsDistanceSq(tempX, tempY, this.x, this.y);\n      }\n      if (code.has(OutCode.RIGHT)) {\n        // and right\n        // linear distance from upper right corner\n        return ptsDistanceSq(tempX, tempY, this.x2, this.y);\n      }\n      // distance from top line segment\n      return (this.y - tempY) * (this.y - tempY);\n    }\n    // bottom\n    if (code.has(OutCode.BOTTOM)) {\n      // and left\n      if (code.has(OutCode.LEFT)) {\n        // linear distance from lower left corner\n        return ptsDistanceSq(tempX, tempY, this.x, this.y2);\n      }\n      // and right\n      if (code.has(OutCode.RIGHT)) {\n        // linear distance from lower right corner\n        return ptsDistanceSq(tempX, tempY, this.x2, this.y2);\n      }\n      // distance from bottom line segment\n      return (tempY - this.y2) * (tempY - this.y2);\n    }\n    // left only\n    if (code.has(OutCode.LEFT)) {\n      // linear distance from left edge\n      return (this.x - tempX) * (this.x - tempX);\n    }\n    // right only\n    if (code.has(OutCode.RIGHT)) {\n      // linear distance from right edge\n      return (tempX - this.x2) * (tempX - this.x2);\n    }\n    return 0;\n  }\n}\n\nexport function boundingBox(path: ReadonlyArray<IPoint>) {\n  if (path.length === 0) {\n    return null;\n  }\n  const first = path[0];\n  const bb = new Rectangle(first.x, first.y, 0, 0);\n  for (const point of path) {\n    bb.addPoint(point);\n  }\n  return bb;\n}\n","import type { ICircle, IRectangle2 } from '../interfaces';\nimport { ptsDistanceSq } from '../utils';\n\nexport class Circle implements IRectangle2, ICircle {\n  constructor(\n    public cx: number,\n    public cy: number,\n    public radius: number\n  ) {}\n\n  get x() {\n    return this.cx - this.radius;\n  }\n\n  get x2() {\n    return this.cx + this.radius;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get y() {\n    return this.cy - this.radius;\n  }\n\n  get y2() {\n    return this.cy + this.radius;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n\n  static from(r: ICircle) {\n    return new Circle(r.cx, r.cy, r.radius);\n  }\n\n  containsPt(x: number, y: number) {\n    return ptsDistanceSq(this.cx, this.cy, x, y) < this.radius * this.radius;\n  }\n\n  distSquare(tempX: number, tempY: number) {\n    const dist = ptsDistanceSq(this.cx, this.cy, tempX, tempY);\n    if (dist < this.radius * this.radius) {\n      // inside\n      return 0;\n    }\n    const offset = Math.sqrt(dist) - this.radius;\n    return offset * offset;\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.ellipse(this.cx, this.cy, this.radius, this.radius, 0, 0, Math.PI * 2);\n  }\n}\n","import type { IRectangle, IPoint } from '../interfaces';\nimport { Rectangle } from './Rectangle';\n\nexport class Area {\n  private readonly area: Float32Array;\n\n  constructor(\n    public readonly pixelGroup: number,\n    public readonly i = 0,\n    public readonly j = 0,\n    public readonly pixelX = 0,\n    public readonly pixelY = 0,\n    public readonly width: number = 10,\n    public readonly height: number = 10,\n    pixels = new Float32Array(Math.max(0, width * height)).fill(0)\n  ) {\n    this.area = pixels;\n  }\n\n  createSub(rect: IRectangle, pixelPos: IPoint) {\n    return new Area(this.pixelGroup, rect.x, rect.y, pixelPos.x, pixelPos.y, rect.width, rect.height);\n  }\n\n  static fromPixelRegion(pixelRect: IRectangle, pixelGroup: number) {\n    return new Area(\n      pixelGroup,\n      0,\n      0,\n      pixelRect.x,\n      pixelRect.y,\n      Math.ceil(pixelRect.width / pixelGroup),\n      Math.ceil(pixelRect.height / pixelGroup)\n    );\n  }\n\n  copy(sub: Area, pixelPoint: IPoint) {\n    return new Area(\n      this.pixelGroup,\n      this.scaleX(pixelPoint.x),\n      this.scaleY(pixelPoint.y),\n      pixelPoint.x,\n      pixelPoint.y,\n      sub.width,\n      sub.height,\n      sub.area\n    );\n  }\n\n  boundX(pos: number) {\n    if (pos < this.i) {\n      return this.i;\n    }\n    if (pos >= this.width) {\n      return this.width - 1;\n    }\n    return pos;\n  }\n\n  boundY(pos: number) {\n    if (pos < this.j) {\n      return this.j;\n    }\n    if (pos >= this.height) {\n      return this.height - 1;\n    }\n    return pos;\n  }\n\n  scaleX(pixel: number) {\n    return this.boundX(Math.floor((pixel - this.pixelX) / this.pixelGroup));\n  }\n\n  scaleY(pixel: number) {\n    return this.boundY(Math.floor((pixel - this.pixelY) / this.pixelGroup));\n  }\n\n  scale(pixelRect: IRectangle) {\n    const x = this.scaleX(pixelRect.x);\n    const y = this.scaleY(pixelRect.y);\n    const x2 = this.boundX(Math.ceil((pixelRect.x + pixelRect.width - this.pixelX) / this.pixelGroup));\n    const y2 = this.boundY(Math.ceil((pixelRect.y + pixelRect.height - this.pixelY) / this.pixelGroup));\n    const width = x2 - x;\n    const height = y2 - y;\n    return new Rectangle(x, y, width, height);\n  }\n\n  invertScaleX(v: number) {\n    return Math.round(v * this.pixelGroup + this.pixelX);\n  }\n\n  invertScaleY(v: number) {\n    return Math.round(v * this.pixelGroup + this.pixelY);\n  }\n\n  addPadding(rect: Rectangle, pixelPadding: number) {\n    const padding = Math.ceil(pixelPadding / this.pixelGroup);\n    const x = this.boundX(rect.x - padding);\n    const y = this.boundY(rect.y - padding);\n    const x2 = this.boundX(rect.x2 + padding);\n    const y2 = this.boundY(rect.y2 + padding);\n    const width = x2 - x;\n    const height = y2 - y;\n    return new Rectangle(x, y, width, height);\n  }\n\n  get(i: number, j: number) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return Number.NaN;\n    }\n    return this.area[i + j * this.width];\n  }\n\n  inc(i: number, j: number, v: number) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return;\n    }\n    this.area[i + j * this.width] += v;\n  }\n\n  set(i: number, j: number, v: number) {\n    if (i < 0 || j < 0 || i >= this.width || j >= this.height) {\n      return;\n    }\n    this.area[i + j * this.width] = v;\n  }\n\n  incArea(sub: Area, factor: number) {\n    if (sub.width <= 0 || sub.height <= 0 || factor === 0) {\n      return;\n    }\n    // assume it is within the bounds\n    const w = this.width;\n    const aw = sub.width;\n    const i1 = Math.max(0, sub.i);\n    const j1 = Math.max(0, sub.j);\n    const i2 = Math.min(sub.i + sub.width, w);\n    const j2 = Math.min(sub.j + sub.height, this.height);\n\n    if (j2 <= 0 || i2 <= 0 || i1 >= w || j2 >= this.height) {\n      return;\n    }\n\n    for (let j = j1; j < j2; j++) {\n      const subRow = (j - sub.j) * aw;\n      const row = j * w;\n      for (let i = i1; i < i2; i++) {\n        const v = sub.area[i - sub.i + subRow];\n        if (v === 0) {\n          continue;\n        }\n        this.area[i + row] += factor * v;\n      }\n    }\n  }\n\n  fill(value: number) {\n    this.area.fill(value);\n  }\n\n  fillArea(rect: IRectangle, value: number) {\n    const offset = rect.x + rect.y * this.width;\n    for (let j = 0; j < rect.height; j++) {\n      const pos = offset + j * this.width;\n      this.area.fill(value, pos, pos + rect.width);\n    }\n  }\n\n  fillHorizontalLine(i: number, j: number, width: number, value: number) {\n    const offset = i + j * this.width;\n    this.area.fill(value, offset, offset + width);\n  }\n\n  fillVerticalLine(i: number, j: number, height: number, value: number) {\n    const offset = i + j * this.width;\n    for (let k = 0; k < height; k++) {\n      this.area[offset + k * this.width] = value;\n    }\n  }\n\n  clear() {\n    this.area.fill(0);\n  }\n\n  toString() {\n    let r = '';\n    for (let j = 0; j < this.height; j++) {\n      const row = j * this.width;\n      for (let i = 0; i < this.width; i++) {\n        const v = this.area[row + i];\n        r += v.toFixed(1).padStart(6);\n        r += ' ';\n      }\n      r += '\\n';\n    }\n    return r;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, offset = true) {\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    ctx.save();\n    if (offset) {\n      ctx.translate(this.pixelX, this.pixelY);\n    }\n    const min = this.area.reduce((acc, v) => Math.min(acc, v), Number.POSITIVE_INFINITY);\n    const max = this.area.reduce((acc, v) => Math.max(acc, v), Number.NEGATIVE_INFINITY);\n\n    const scale = (v: number) => (v - min) / (max - min);\n    ctx.scale(this.pixelGroup, this.pixelGroup);\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        const v = this.area[i + j * this.width];\n        ctx.fillStyle = `rgba(0, 0, 0, ${scale(v)})`;\n        ctx.fillRect(i, j, 1, 1);\n      }\n    }\n    ctx.restore();\n  }\n\n  drawThreshold(ctx: CanvasRenderingContext2D, threshold: number, offset = true) {\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    ctx.save();\n    if (offset) {\n      ctx.translate(this.pixelX, this.pixelY);\n    }\n    ctx.scale(this.pixelGroup, this.pixelGroup);\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        const v = this.area[i + j * this.width];\n        ctx.fillStyle = v > threshold ? 'black' : 'white';\n        ctx.fillRect(i, j, 1, 1);\n      }\n    }\n    ctx.restore();\n  }\n}\n","import type { IRectangle } from './interfaces';\n\nexport function addPadding(rect: IRectangle, padding: number): IRectangle;\nexport function addPadding(rect: ReadonlyArray<IRectangle>, padding: number): ReadonlyArray<IRectangle>;\nexport function addPadding(\n  rect: IRectangle | ReadonlyArray<IRectangle>,\n  padding: number\n): IRectangle | ReadonlyArray<IRectangle> {\n  const map = (r: IRectangle) => ({\n    x: r.x - padding,\n    y: r.y - padding,\n    width: r.width + 2 * padding,\n    height: r.height + 2 * padding,\n  });\n  if (Array.isArray(rect)) {\n    return rect.map(map);\n  }\n  return map(rect as IRectangle);\n}\n","import { lineBoundingBox } from './model';\nimport type { Area } from './model/Area';\nimport { addPadding } from './padding';\nimport type { IRectangle, ILine } from './interfaces';\nimport { linePtSegDistSq } from './utils';\n\nexport function createLineInfluenceArea(line: ILine, potentialArea: Area, padding: number) {\n  return createGenericInfluenceArea(\n    Object.assign(lineBoundingBox(line), {\n      distSquare: (x: number, y: number) => linePtSegDistSq(line.x1, line.y1, line.x2, line.y2, x, y),\n    }),\n    potentialArea,\n    padding\n  );\n}\n\nexport function createGenericInfluenceArea(\n  shape: IRectangle & { distSquare(x: number, y: number): number },\n  potentialArea: Area,\n  padding: number\n) {\n  const lr = addPadding(shape, padding);\n  const scaled = potentialArea.scale(lr);\n  const area = potentialArea.createSub(scaled, lr);\n  sample(area, potentialArea, padding, (x, y) => shape.distSquare(x, y));\n  return area;\n}\n\nfunction sample(area: Area, potentialArea: Area, padding: number, distanceFunction: (x: number, y: number) => number) {\n  const padding2 = padding * padding;\n\n  // find the affected subregion of potentialArea\n  // for every point in active subregion of potentialArea, calculate\n  // distance to nearest point on rectangle and add influence\n\n  for (let y = 0; y < area.height; y++) {\n    for (let x = 0; x < area.width; x++) {\n      // convert back to screen coordinates\n      const tempX = potentialArea.invertScaleX(area.i + x);\n      const tempY = potentialArea.invertScaleY(area.j + y);\n      const distanceSq = distanceFunction(tempX, tempY);\n      if (distanceSq === 0) {\n        area.set(x, y, padding2);\n        continue;\n      }\n      // only influence if less than r1\n      if (distanceSq < padding2) {\n        const dr = padding - Math.sqrt(distanceSq);\n        area.set(x, y, dr * dr);\n      }\n    }\n  }\n  return area;\n}\n\nexport function createRectangleInfluenceArea(\n  rect: IRectangle & { distSquare(x: number, y: number): number },\n  potentialArea: Area,\n  padding: number\n) {\n  const scaled = potentialArea.scale(rect);\n  const padded = potentialArea.addPadding(scaled, padding);\n  const area = potentialArea.createSub(padded, { x: rect.x - padding, y: rect.y - padding });\n  const paddingLeft = scaled.x - padded.x;\n  const paddingTop = scaled.y - padded.y;\n  const paddingRight = padded.x2 - scaled.x2;\n  const paddingBottom = padded.y2 - scaled.y2;\n  const innerWidth = padded.width - paddingLeft - paddingRight;\n  const innerHeight = padded.height - paddingTop - paddingBottom;\n\n  // outside rect ... depends on distance\n  // cttc\n  // lffr\n  // lffr\n  // cbbc\n  const padding2 = padding * padding;\n  // within the rect ... full ri2\n  area.fillArea(\n    {\n      x: paddingLeft,\n      y: paddingTop,\n      width: innerWidth + 1,\n      height: innerHeight + 1,\n    },\n    padding2\n  );\n\n  const straightDistances: number[] = [0];\n  const maxPadding = Math.max(paddingTop, paddingLeft, paddingRight, paddingBottom);\n  {\n    const tempX = potentialArea.invertScaleX(scaled.x + scaled.width / 2);\n    for (let i = 1; i < maxPadding; i++) {\n      const tempY = potentialArea.invertScaleY(scaled.y - i);\n      const distanceSq = rect.distSquare(tempX, tempY);\n      // only influence if less than r1\n      if (distanceSq < padding2) {\n        const dr = padding - Math.sqrt(distanceSq);\n        straightDistances.push(dr * dr);\n      } else {\n        break;\n      }\n    }\n  }\n  const cornerDistances: number[][] = [];\n  const maxHorizontalPadding = Math.max(paddingLeft, paddingRight);\n  const maxVerticalPadding = Math.max(paddingTop, paddingRight);\n  for (let i = 1; i < maxHorizontalPadding; i++) {\n    const tempX = potentialArea.invertScaleX(scaled.x - i);\n    const row: number[] = [];\n    for (let j = 1; j < maxVerticalPadding; j++) {\n      const tempY = potentialArea.invertScaleY(scaled.y - j);\n      const distanceSq = rect.distSquare(tempX, tempY);\n      // only influence if less than r1\n      if (distanceSq < padding2) {\n        const dr = padding - Math.sqrt(distanceSq);\n        row.push(dr * dr);\n      } else {\n        row.push(0);\n      }\n    }\n    cornerDistances.push(row);\n  }\n\n  //top\n  for (let y = 1; y < Math.min(paddingTop, straightDistances.length); y++) {\n    const value = straightDistances[y];\n    area.fillHorizontalLine(paddingLeft, paddingTop - y, innerWidth + 1, value);\n  }\n  //bottom\n  for (let y = 1; y < Math.min(paddingBottom, straightDistances.length); y++) {\n    const value = straightDistances[y];\n    area.fillHorizontalLine(paddingLeft, paddingTop + innerHeight + y, innerWidth + 1, value);\n  }\n  //left\n  for (let x = 1; x < Math.min(paddingLeft, straightDistances.length); x++) {\n    const value = straightDistances[x];\n    area.fillVerticalLine(paddingLeft - x, paddingTop, innerHeight + 1, value);\n  }\n  //right\n  for (let x = 1; x < Math.min(paddingBottom, straightDistances.length); x++) {\n    const value = straightDistances[x];\n    area.fillVerticalLine(paddingLeft + innerWidth + x, paddingTop, innerHeight + 1, value);\n  }\n  //top/bottom left\n  for (let i = 1; i < paddingLeft; i++) {\n    const row = cornerDistances[i - 1];\n    const ii = paddingLeft - i;\n    for (let j = 1; j < paddingTop; j++) {\n      area.set(ii, paddingTop - j, row[j - 1]);\n    }\n    for (let j = 1; j < paddingBottom; j++) {\n      area.set(ii, paddingTop + innerHeight + j, row[j - 1]);\n    }\n  }\n  //top/bottom right\n  for (let i = 1; i < paddingRight; i++) {\n    const row = cornerDistances[i - 1];\n    const ii = paddingLeft + innerWidth + i;\n    for (let j = 1; j < paddingTop; j++) {\n      area.set(ii, paddingTop - j, row[j - 1]);\n    }\n    for (let j = 1; j < paddingBottom; j++) {\n      area.set(ii, paddingTop + innerHeight + j, row[j - 1]);\n    }\n  }\n\n  // const other = sample(padded, potentialArea, padding, (x, y) => rect.rectDistSq(x, y));\n  // console.log(other.toString());\n  // console.log(area.toString());\n  return area;\n}\n","export declare type IPoint = { x: number; y: number };\n\nexport interface ICenterPoint {\n  cx: number;\n  cy: number;\n}\n\nexport interface IRectangle extends IPoint {\n  width: number;\n  height: number;\n}\n\nexport interface IRectangle2 extends IRectangle {\n  x2: number;\n  y2: number;\n}\n\nexport interface ILine {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n}\n\nexport interface ICircle extends ICenterPoint {\n  radius: number;\n}\n\nexport function rect(x: number, y: number, width: number, height: number): IRectangle {\n  return { x, y, width, height };\n}\n\nexport function circle(cx: number, cy: number, radius: number): ICircle {\n  return { cx, cy, radius };\n}\n\nexport function line(x1: number, y1: number, x2: number, y2: number): ILine {\n  return { x1, y1, x2, y2 };\n}\n\nexport function point(x: number, y: number) {\n  return { x, y };\n}\n","import {\n  EState,\n  fractionToLineCenter,\n  Intersection,\n  testIntersection,\n  hasFractionToLineCenter,\n  intersectsLine,\n} from './Intersection';\nimport { Line } from './model/Line';\nimport { doublePointsEqual, ptsDistanceSq } from './utils';\nimport { type IPoint, point, type ICircle, type IRectangle2 } from './interfaces';\n\nexport function calculateVirtualEdges(\n  items: ReadonlyArray<ICircle>,\n  nonMembers: ReadonlyArray<IRectangle2 & { containsPt(x: number, y: number): boolean }>,\n  maxRoutingIterations: number,\n  morphBuffer: number\n) {\n  if (items.length === 0) {\n    return [];\n  }\n  const sorted = sortByDistanceToCentroid(items);\n\n  return sorted\n    .map((d, i) => {\n      const visited = sorted.slice(0, i);\n      return connectItem(nonMembers, d, visited, maxRoutingIterations, morphBuffer);\n    })\n    .flat();\n}\n\nfunction connectItem(\n  nonMembers: ReadonlyArray<IRectangle2 & { containsPt(x: number, y: number): boolean }>,\n  item: ICircle,\n  visited: ReadonlyArray<ICircle>,\n  maxRoutingIterations: number,\n  morphBuffer: number\n) {\n  const itemCenter = point(item.cx, item.cy);\n\n  // discover the nearest neighbor with minimal interference items\n  const closestNeighbor = calculateClosestNeighbor(itemCenter, visited, nonMembers);\n  if (closestNeighbor == null) {\n    return [];\n  }\n  // if there is a visited closest neighbor, add straight line between\n  // them to the positive energy to ensure connected clusters\n  const directLine = new Line(itemCenter.x, itemCenter.y, closestNeighbor.cx, closestNeighbor.cy);\n\n  // route the edge around intersecting nodes not in set\n  const scannedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n\n  return mergeLines(scannedLines, nonMembers);\n}\n\nfunction computeRoute(\n  directLine: Line,\n  nonMembers: ReadonlyArray<IRectangle2 & { containsPt(x: number, y: number): boolean }>,\n  maxRoutingIterations: number,\n  morphBuffer: number\n) {\n  // route the edge around intersecting nodes not in set\n  const scannedLines: Line[] = [];\n  const linesToCheck: Line[] = [];\n  linesToCheck.push(directLine);\n\n  let hasIntersection = true;\n\n  for (let iterations = 0; iterations < maxRoutingIterations && hasIntersection; iterations++) {\n    hasIntersection = false;\n    while (!hasIntersection && linesToCheck.length > 0) {\n      const line = linesToCheck.pop()!;\n      // resolve intersections in order along edge\n      const closestItem = getCenterItem(nonMembers, line);\n      const intersections = closestItem ? testIntersection(line, closestItem) : null;\n\n      // 2 intersections = line passes through item\n      if (!closestItem || !intersections || intersections.count !== 2) {\n        // no intersection found, mark this line as completed\n        if (!hasIntersection) {\n          scannedLines.push(line);\n        }\n        continue;\n      }\n\n      let tempMorphBuffer = morphBuffer;\n      let movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);\n      // test the movePoint already exists\n      let foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n      let pointInside = isPointInRectangles(movePoint, nonMembers);\n      // prefer first corner, even if buffer becomes very small\n      while (!foundFirst && pointInside && tempMorphBuffer >= 1) {\n        // try a smaller buffer\n        tempMorphBuffer /= 1.5;\n        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);\n        foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n        pointInside = isPointInRectangles(movePoint, nonMembers);\n      }\n\n      if (movePoint && !foundFirst && !pointInside) {\n        // add 2 rerouted lines to check\n        linesToCheck.push(new Line(line.x1, line.y1, movePoint.x, movePoint.y));\n        linesToCheck.push(new Line(movePoint.x, movePoint.y, line.x2, line.y2));\n        // indicate intersection found\n        hasIntersection = true;\n      }\n\n      if (hasIntersection) {\n        continue;\n      }\n\n      // if we didn't find a valid point around the\n      // first corner, try the second\n      tempMorphBuffer = morphBuffer;\n      movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);\n      let foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n      pointInside = isPointInRectangles(movePoint, nonMembers);\n      // if both corners have been used, stop; otherwise gradually reduce buffer and try second corner\n      while (!foundSecond && pointInside && tempMorphBuffer >= 1) {\n        // try a smaller buffer\n        tempMorphBuffer /= 1.5;\n        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);\n        foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);\n        pointInside = isPointInRectangles(movePoint, nonMembers);\n      }\n\n      if (movePoint && !foundSecond) {\n        // add 2 rerouted lines to check\n        linesToCheck.push(new Line(line.x1, line.y1, movePoint.x, movePoint.y));\n        linesToCheck.push(new Line(movePoint.x, movePoint.y, line.x2, line.y2));\n        // indicate intersection found\n        hasIntersection = true;\n      }\n      // no intersection found, mark this line as completed\n      if (!hasIntersection) {\n        scannedLines.push(line);\n      }\n    }\n  }\n  // finalize any that were not rerouted (due to running out of\n  // iterations) or if we aren't morphing\n  while (linesToCheck.length > 0) {\n    scannedLines.push(linesToCheck.pop()!);\n  }\n\n  return scannedLines;\n}\n\nfunction mergeLines(scannedLines: Line[], nonMembers: ReadonlyArray<IRectangle2>) {\n  const finalRoute: Line[] = [];\n  // try to merge consecutive lines if possible\n  while (scannedLines.length > 0) {\n    const line1 = scannedLines.pop()!;\n    if (scannedLines.length === 0) {\n      finalRoute.push(line1);\n      break;\n    }\n    const line2 = scannedLines.pop()!;\n    const mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n    // resolve intersections in order along edge\n    const closestItem = getCenterItem(nonMembers, mergeLine);\n    // merge most recent line and previous line\n    if (!closestItem) {\n      scannedLines.push(mergeLine);\n    } else {\n      finalRoute.push(line1);\n      scannedLines.push(line2);\n    }\n  }\n  return finalRoute;\n}\n\nfunction calculateClosestNeighbor(\n  itemCenter: IPoint,\n  visited: ReadonlyArray<ICircle>,\n  nonMembers: ReadonlyArray<IRectangle2>\n) {\n  let minLengthSq = Number.POSITIVE_INFINITY;\n  return visited.reduce(\n    (closestNeighbor, neighborItem) => {\n      const distanceSq = ptsDistanceSq(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);\n      if (distanceSq > minLengthSq) {\n        // the interference can only increase the distance so if already bigger, return\n        return closestNeighbor;\n      }\n\n      const directLine = new Line(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);\n      // augment distance by number of interfering items\n      const numberInterferenceItems = itemsCuttingLine(nonMembers, directLine);\n\n      // TODO is there a better function to consider interference in nearest-neighbor checking? This is hacky\n      if (distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1) < minLengthSq) {\n        closestNeighbor = neighborItem;\n        minLengthSq = distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1);\n      }\n      return closestNeighbor;\n    },\n    null as ICircle | null\n  );\n}\n\nfunction sortByDistanceToCentroid<T extends ICircle>(items: ReadonlyArray<T>) {\n  if (items.length < 2) {\n    return items;\n  }\n  let totalX = 0;\n  let totalY = 0;\n  items.forEach((item) => {\n    totalX += item.cx;\n    totalY += item.cy;\n  });\n  totalX /= items.length;\n  totalY /= items.length;\n  return items\n    .map((item) => {\n      const diffX = totalX - item.cx;\n      const diffY = totalY - item.cy;\n      const dist = diffX * diffX + diffY * diffY;\n      return [item, dist] as [T, number];\n    })\n    .sort((a, b) => a[1] - b[1])\n    .map((d) => d[0]);\n}\n\nfunction isPointInRectangles(p: IPoint, rects: ReadonlyArray<{ containsPt(x: number, y: number): boolean }>) {\n  return rects.some((r) => r.containsPt(p.x, p.y));\n}\n\nfunction pointExists(pointToCheck: IPoint, lines: ReadonlyArray<Line>) {\n  return lines.some((checkEndPointsLine) => {\n    if (doublePointsEqual(checkEndPointsLine.x1, checkEndPointsLine.y1, pointToCheck.x, pointToCheck.y, 1e-3)) {\n      return true;\n    }\n    if (doublePointsEqual(checkEndPointsLine.x2, checkEndPointsLine.y2, pointToCheck.x, pointToCheck.y, 1e-3)) {\n      return true;\n    }\n    return false;\n  });\n}\n\nfunction getCenterItem(items: ReadonlyArray<IRectangle2>, testLine: Line) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  let closestItem: IRectangle2 | null = null;\n\n  for (const item of items) {\n    if (!intersectsLine(item, testLine)) {\n      continue;\n    }\n    const distance = fractionToLineCenter(item, testLine);\n    // find closest intersection\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  }\n  return closestItem;\n}\n\nfunction itemsCuttingLine(items: ReadonlyArray<IRectangle2>, testLine: Line) {\n  return items.reduce((count, item) => {\n    if (intersectsLine(item, testLine) && hasFractionToLineCenter(item, testLine)) {\n      return count + 1;\n    }\n    return count;\n  }, 0);\n}\n\nfunction rerouteLine(\n  item: IRectangle2,\n  rerouteBuffer: number,\n  intersections: { top: Intersection; left: Intersection; right: Intersection; bottom: Intersection },\n  wrapNormal: boolean\n) {\n  const topIntersect = intersections.top;\n  const leftIntersect = intersections.left;\n  const bottomIntersect = intersections.bottom;\n  const rightIntersect = intersections.right;\n\n  // wrap around the most efficient way\n  if (wrapNormal) {\n    // left side\n    if (leftIntersect.state === EState.POINT) {\n      if (topIntersect.state === EState.POINT)\n        // triangle, must go around top left\n        return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n      if (bottomIntersect.state === EState.POINT)\n        // triangle, must go around bottom left\n        return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n      // else through left to right, calculate areas\n      const totalArea = item.width * item.height;\n      // top area\n      const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);\n      if (topArea < totalArea * 0.5) {\n        // go around top (the side which would make a greater movement)\n        if (leftIntersect.y > rightIntersect.y)\n          // top left\n          return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n        // top right\n        return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n      }\n      // go around bottom\n      if (leftIntersect.y < rightIntersect.y)\n        // bottom left\n        return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n      // bottom right\n      return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    // right side\n    if (rightIntersect.state === EState.POINT) {\n      if (topIntersect.state === EState.POINT)\n        // triangle, must go around top right\n        return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n      if (bottomIntersect.state === EState.POINT)\n        // triangle, must go around bottom right\n        return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    // else through top to bottom, calculate areas\n    const totalArea = item.height * item.width;\n    const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);\n    if (leftArea < totalArea * 0.5) {\n      // go around left\n      if (topIntersect.x > bottomIntersect.x)\n        // top left\n        return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n      // bottom left\n      return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    // go around right\n    if (topIntersect.x < bottomIntersect.x)\n      // top right\n      return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    // bottom right\n    return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n  }\n  // wrap around opposite (usually because the first move caused a problem)\n  if (leftIntersect.state === EState.POINT) {\n    if (topIntersect.state === EState.POINT)\n      // triangle, must go around bottom right\n      return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    if (bottomIntersect.state === EState.POINT)\n      // triangle, must go around top right\n      return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    // else through left to right, calculate areas\n    const totalArea = item.height * item.width;\n    const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);\n    if (topArea < totalArea * 0.5) {\n      // go around bottom (the side which would make a lesser movement)\n      if (leftIntersect.y > rightIntersect.y)\n        // bottom right\n        return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n      // bottom left\n      return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    }\n    // go around top\n    if (leftIntersect.y < rightIntersect.y)\n      // top right\n      return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n    // top left\n    return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n  }\n  if (rightIntersect.state === EState.POINT) {\n    if (topIntersect.state === EState.POINT)\n      // triangle, must go around bottom left\n      return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n    if (bottomIntersect.state === EState.POINT)\n      // triangle, must go around top left\n      return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n  }\n  // else through top to bottom, calculate areas\n  const totalArea = item.height * item.width;\n  const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);\n  if (leftArea < totalArea * 0.5) {\n    // go around right\n    if (topIntersect.x > bottomIntersect.x)\n      // bottom right\n      return point(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);\n    // top right\n    return point(item.x2 + rerouteBuffer, item.y - rerouteBuffer);\n  }\n  // go around left\n  if (topIntersect.x < bottomIntersect.x)\n    // bottom left\n    return point(item.x - rerouteBuffer, item.y2 + rerouteBuffer);\n  // top left\n  return point(item.x - rerouteBuffer, item.y - rerouteBuffer);\n}\n","import { PointPath } from '../PointPath';\nimport { linePtSegDistSq } from '../utils';\nimport type { IPoint } from '../interfaces';\n\nfunction canTakeNext(path: PointPath, start: number, end: number, toleranceSquared: number) {\n  const validEnd = path.closed ? end < path.length : end < path.length - 1;\n  if (!validEnd) {\n    return false;\n  }\n\n  const s = path.get(start);\n  const e = path.get(end + 1);\n\n  for (let index = start + 1; index <= end; index++) {\n    const p = path.get(index);\n    const len = linePtSegDistSq(s.x, s.y, e.x, e.y, p.x, p.y);\n    if (len > toleranceSquared) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function shapeSimplifier(tolerance = 0.0) {\n  return (path: PointPath) => {\n    if (tolerance < 0 || path.length < 3) {\n      return path;\n    }\n    const points: IPoint[] = [];\n    let start = 0;\n    const toleranceSquared = tolerance * tolerance;\n    while (start < path.length) {\n      let end = start + 1;\n      while (canTakeNext(path, start, end, toleranceSquared)) {\n        end++;\n      }\n      points.push(path.get(start));\n      start = end;\n    }\n    return new PointPath(points);\n  };\n}\n","import { PointPath } from '../PointPath';\nimport type { IPoint } from '../interfaces';\n\nfunction basicFunction(i: number, t: number) {\n  // the basis function for a cubic B spline\n  switch (i) {\n    case -2:\n      return (((-t + 3.0) * t - 3.0) * t + 1.0) / 6.0;\n    case -1:\n      return ((3.0 * t - 6.0) * t * t + 4.0) / 6.0;\n    case 0:\n      return (((-3.0 * t + 3.0) * t + 3.0) * t + 1.0) / 6.0;\n    case 1:\n      return (t * t * t) / 6.0;\n    default:\n      throw new Error('unknown error');\n  }\n}\n\nexport function bSplineShapeGenerator(granularity = 6.0) {\n  const ORDER = 3;\n  const START_INDEX = ORDER - 1;\n  const REL_END = 1;\n  const REL_START = REL_END - ORDER;\n\n  function calcPoint(path: PointPath, i: number, t: number): IPoint {\n    let px = 0.0;\n    let py = 0.0;\n    for (let j = REL_START; j <= REL_END; j++) {\n      const p = path.get(i + j);\n      const bf = basicFunction(j, t);\n      px += bf * p.x;\n      py += bf * p.y;\n    }\n    return { x: px, y: py };\n  }\n\n  return (path: PointPath) => {\n    // covering special cases\n    if (path.length < 3) {\n      return path;\n    }\n    // actual b-spline calculation\n    const res: IPoint[] = [];\n    const closed = path.closed;\n    const count = path.length + ORDER - 1 + (closed ? 0 : 2);\n    res.push(calcPoint(path, START_INDEX - (closed ? 0 : 2), 0));\n    for (let ix = START_INDEX - (closed ? 0 : 2); ix < count; ix++) {\n      for (let k = 1; k <= granularity; k++) {\n        res.push(calcPoint(path, ix, k / granularity));\n      }\n    }\n    return new PointPath(res);\n  };\n}\n","import { PointPath } from '../PointPath';\nimport type { IPoint } from '../interfaces';\n\nexport function samplePath(skip = 8) {\n  return (path: PointPath) => {\n    // start with global SKIP value, but decrease skip amount if there aren't enough points in the surface\n    let actSkip = skip;\n    // prepare viz attribute array\n    let size = path.length;\n\n    if (actSkip > 1) {\n      size = Math.floor(path.length / actSkip);\n      // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\n      while (size < 3 && actSkip > 1) {\n        actSkip -= 1;\n        size = Math.floor(path.length / actSkip);\n      }\n    }\n\n    const finalHull: IPoint[] = [];\n    // copy hull values\n    for (let i = 0, j = 0; j < size; j++, i += actSkip) {\n      finalHull.push(path.get(i));\n    }\n    return new PointPath(finalHull);\n  };\n}\n","import { shapeSimplifier, bSplineShapeGenerator, samplePath } from './simplifiers';\nimport { Line, boundingBox } from './model';\nimport type { IPoint, ICenterPoint } from './interfaces';\nimport { round } from './utils';\n\nexport class PointPath {\n  readonly points: ReadonlyArray<IPoint>;\n\n  readonly closed: boolean;\n\n  constructor(points: ReadonlyArray<IPoint> = [], closed = true) {\n    this.points = points;\n    this.closed = closed;\n  }\n\n  get(index: number): IPoint {\n    const i = index;\n    const l = this.points.length;\n    if (index < 0) {\n      return this.closed ? this.get(index + l) : this.points[0];\n    } else if (index >= l) {\n      return this.closed ? this.get(index - l) : this.points[l - 1];\n    }\n    return this.points[i];\n  }\n\n  get length() {\n    return this.points.length;\n  }\n\n  toString(roundToDigits: number | ((v: number) => number) = Infinity) {\n    const points = this.points;\n    if (points.length === 0) {\n      return '';\n    }\n    const rounder = typeof roundToDigits === 'function' ? roundToDigits : round(roundToDigits);\n    let r = 'M';\n    for (const p of points) {\n      r += `${rounder(p.x)},${rounder(p.y)} L`;\n    }\n    r = r.slice(0, -1);\n    if (this.closed) {\n      r += ' Z';\n    }\n    return r;\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const points = this.points;\n    if (points.length === 0) {\n      return;\n    }\n    ctx.beginPath();\n\n    ctx.moveTo(points[0].x, points[0].y);\n\n    for (const p of points) {\n      ctx.lineTo(p.x, p.y);\n    }\n\n    if (this.closed) {\n      ctx.closePath();\n    }\n  }\n\n  sample(skip?: number) {\n    return samplePath(skip)(this);\n  }\n\n  simplify(tolerance?: number) {\n    return shapeSimplifier(tolerance)(this);\n  }\n\n  bSplines(granularity?: number) {\n    return bSplineShapeGenerator(granularity)(this);\n  }\n\n  apply(transformer: (path: PointPath) => PointPath) {\n    return transformer(this);\n  }\n\n  containsElements(members: ReadonlyArray<ICenterPoint>) {\n    const bb = boundingBox(this.points);\n    if (!bb) {\n      return false;\n    }\n    return members.every((member) => {\n      return bb.containsPt(member.cx, member.cy) && this.withinArea(member.cx, member.cy);\n    });\n  }\n\n  withinArea(px: number, py: number) {\n    if (this.length === 0) {\n      return false;\n    }\n    let crossings = 0;\n    const first = this.points[0]!;\n    const line = new Line(first.x, first.y, first.x, first.y);\n\n    for (let i = 1; i < this.points.length; i++) {\n      const cur = this.points[i];\n      line.x1 = line.x2;\n      line.y1 = line.y2;\n      line.x2 = cur.x;\n      line.y2 = cur.y;\n\n      if (line.cuts(px, py)) {\n        crossings++;\n      }\n    }\n    // close to start\n    line.x1 = line.x2;\n    line.y1 = line.y2;\n    line.x2 = first.x;\n    line.y2 = first.y;\n\n    if (line.cuts(px, py)) {\n      crossings++;\n    }\n\n    return crossings % 2 === 1;\n  }\n}\n","import { PointPath } from '../PointPath';\nimport { Rectangle } from './Rectangle';\nimport type { IPoint } from '../interfaces';\n\nexport class PointList {\n  private count = 0;\n\n  private readonly arr: IPoint[] = [];\n\n  private readonly set = new Set<string>();\n\n  constructor(size = 0) {\n    this.arr.length = size; // pre-allocating\n  }\n\n  add(p: IPoint) {\n    this.set.add(`${p.x}x${p.y}`);\n    this.arr[this.count++] = p;\n  }\n\n  contains(p: IPoint) {\n    return this.set.has(`${p.x}x${p.y}`);\n  }\n\n  isFirst(p: IPoint) {\n    if (this.count === 0) {\n      return false;\n    }\n    const o = this.arr[0];\n    return o != null && o.x === p.x && o.y === p.y;\n  }\n\n  path() {\n    return new PointPath(this.arr.slice(0, this.count));\n  }\n\n  clear() {\n    // for (let i = 0; i < this.count; i++) {\n    //   this.arr[i] = null; // nulling is cheaper than deleting or reallocating\n    // }\n    this.set.clear();\n    this.count = 0;\n  }\n\n  get(ix: number) {\n    return this.arr[ix];\n  }\n\n  get length() {\n    return this.count;\n  }\n}\n\nexport function boundingBox(path: PointPath) {\n  if (path.length === 0) {\n    return null;\n  }\n  const first = path.points[0];\n  const bb = new Rectangle(first.x, first.y, 0, 0);\n  for (const point of path.points) {\n    bb.addPoint(point);\n  }\n  return bb;\n}\n","import { PointList } from './model/PointList';\nimport type { Area } from './model/Area';\n\nconst N = 0;\nconst S = 1;\nconst E = 2;\nconst W = 3;\n\nexport function marchingSquares(potentialArea: Area, threshold: number) {\n  const estLength = (Math.floor(potentialArea.width) + Math.floor(potentialArea.height)) * 2;\n  const contour = new PointList(estLength);\n\n  function updateDir(x: number, y: number, dir: number, res: number) {\n    const v = potentialArea.get(x, y);\n    if (Number.isNaN(v)) {\n      return Number.NaN;\n    }\n    if (v > threshold) {\n      return dir + res;\n    }\n    return dir;\n  }\n\n  function getState(x: number, y: number) {\n    let dir = N;\n    dir = updateDir(x, y, dir, 1);\n    dir = updateDir(x + 1, y, dir, 2);\n    dir = updateDir(x, y + 1, dir, 4);\n    dir = updateDir(x + 1, y + 1, dir, 8);\n    if (Number.isNaN(dir)) {\n      // console.warn(\n      //   'marched out of bounds: ' + x + ' ' + y + ' bounds: ' + potentialArea.width + ' ' + potentialArea.height\n      // );\n      return -1;\n    }\n    return dir;\n  }\n\n  let direction = S;\n\n  function doMarch(xPos: number, yPos: number) {\n    let x = xPos;\n    let y = yPos;\n    let xPixel = potentialArea.invertScaleX(x);\n    let yPixel = potentialArea.invertScaleY(y);\n    // artificial limit\n    for (let i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      // iterative version of end recursion\n      const p = { x: xPixel, y: yPixel };\n      // check if we're back where we started\n      if (contour.contains(p)) {\n        if (!contour.isFirst(p)) {\n          // encountered a loop but haven't returned to start; will change\n          // direction using conditionals and continue back to start\n        } else {\n          return true;\n        }\n      } else {\n        contour.add(p);\n      }\n      const state = getState(x, y);\n      // x, y are upper left of 2X2 marching square\n      switch (state) {\n        case -1:\n          return true; // Marched out of bounds\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          direction = E;\n          break;\n        case 12:\n        case 14:\n        case 4:\n          direction = W;\n          break;\n        case 6:\n          direction = direction === N ? W : E;\n          break;\n        case 1:\n        case 13:\n        case 5:\n          direction = N;\n          break;\n        case 9:\n          direction = direction === E ? N : S;\n          break;\n        case 10:\n        case 8:\n        case 11:\n          direction = S;\n          break;\n        default:\n          console.warn('Marching squares invalid state: ' + state);\n          return true;\n      }\n\n      switch (direction) {\n        case N:\n          y--; // up\n          yPixel -= potentialArea.pixelGroup;\n          break;\n        case S:\n          y++; // down\n          yPixel += potentialArea.pixelGroup;\n          break;\n        case W:\n          x--; // left\n          xPixel -= potentialArea.pixelGroup;\n          break;\n        case E:\n          x++; // right\n          xPixel += potentialArea.pixelGroup;\n          break;\n        default:\n          console.warn('Marching squares invalid state: ' + state);\n          return true;\n      }\n    }\n    return true;\n  }\n\n  for (let x = 0; x < potentialArea.width; x++) {\n    for (let y = 0; y < potentialArea.height; y++) {\n      if (potentialArea.get(x, y) <= threshold) {\n        continue;\n      }\n      const state = getState(x, y);\n      if (state < 0 || state === 15) {\n        continue;\n      }\n      if (doMarch(x, y)) {\n        return contour.path();\n      }\n    }\n  }\n  return null;\n}\n","import type { ICircle, ILine, IRectangle } from './interfaces';\nimport { createGenericInfluenceArea, createLineInfluenceArea, createRectangleInfluenceArea } from './potentialAreas';\nimport { calculateVirtualEdges } from './routing';\nimport { Circle } from './model';\nimport { Area } from './model/Area';\nimport { Line, lineBoundingBox } from './model/Line';\nimport { marchingSquares } from './MarchingSquares';\nimport { Rectangle } from './model/Rectangle';\nimport { addPadding } from './padding';\nimport { PointPath } from './PointPath';\n\nexport interface IPotentialOptions {\n  /**\n   * how many pixels per potential area group to improve speed\n   * @default 4\n   */\n  pixelGroup?: number;\n  morphBuffer?: number;\n}\n\nexport interface IRoutingOptions {\n  virtualEdges?: boolean;\n  /**\n   * maximum number of iterations when computing routes between members\n   * @default 100\n   */\n  maxRoutingIterations?: number;\n  morphBuffer?: number;\n}\nexport interface IOutlineOptions {\n  /**\n   * maximum number of iterations when computing the contour\n   * @default 20\n   */\n  maxMarchingIterations?: number;\n\n  edgeR0?: number;\n  edgeR1?: number;\n  nodeR0?: number;\n  nodeR1?: number;\n\n  threshold?: number;\n  memberInfluenceFactor?: number;\n  edgeInfluenceFactor?: number;\n  nonMemberInfluenceFactor?: number;\n}\n\nexport interface IBubbleSetOptions extends IRoutingOptions, IOutlineOptions, IPotentialOptions {}\n\nexport const defaultOptions: Readonly<Required<IBubbleSetOptions>> = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 20,\n  pixelGroup: 4,\n  edgeR0: 10,\n  edgeR1: 20,\n  nodeR0: 15,\n  nodeR1: 50,\n  morphBuffer: 10,\n\n  threshold: 1,\n  memberInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  nonMemberInfluenceFactor: -0.8,\n\n  virtualEdges: true,\n};\n\nfunction isCircle(v: IRectangle | ICircle): v is ICircle {\n  return v != null && typeof (v as ICircle).radius === 'number';\n}\n\nfunction isEqual(a: IRectangle | ICircle, b: IRectangle | ICircle) {\n  if (isCircle(a) !== isCircle(b)) {\n    return false;\n  }\n  if (isCircle(a)) {\n    const bc = b as ICircle;\n    return a.cx === bc.cx && a.cy === bc.cy && a.radius === bc.radius;\n  }\n  const br = b as IRectangle;\n  return a.x === br.x && a.y === br.y && a.width === br.width && a.height === br.height;\n}\n\nenum EDirty {\n  MEMBERS,\n  NON_MEMBERS,\n  EDGES,\n}\n\ninterface IMember {\n  readonly raw: IRectangle | ICircle;\n  obj: Rectangle | Circle;\n  area: Area | null;\n}\n\ninterface IEdge {\n  readonly raw: ILine;\n  obj: Line;\n  area: Area | null;\n}\n\nexport class BubbleSets {\n  private readonly dirty = new Set<EDirty>();\n\n  private readonly o: Required<IBubbleSetOptions>;\n\n  private readonly members: IMember[] = [];\n\n  private readonly nonMembers: IMember[] = [];\n\n  private virtualEdges: IEdge[] = [];\n\n  private readonly edges: IEdge[] = [];\n\n  private activeRegion = new Rectangle(0, 0, 0, 0);\n\n  private potentialArea = new Area(1, 0, 0, 0, 0, 0, 0);\n\n  constructor(options: IBubbleSetOptions = {}) {\n    this.o = Object.assign({}, defaultOptions, options);\n  }\n\n  pushMember(...members: ReadonlyArray<IRectangle | ICircle>) {\n    if (members.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.MEMBERS);\n    for (const v of members) {\n      this.members.push({\n        raw: v,\n        obj: isCircle(v) ? Circle.from(v) : Rectangle.from(v),\n        area: null,\n      });\n    }\n  }\n\n  removeMember(member: IRectangle | ICircle) {\n    const index = this.members.findIndex((d) => isEqual(d.raw, member));\n    if (index < 0) {\n      return false;\n    }\n    this.members.splice(index, 1);\n    this.dirty.add(EDirty.MEMBERS);\n    return true;\n  }\n\n  removeNonMember(nonMember: IRectangle | ICircle) {\n    const index = this.nonMembers.findIndex((d) => isEqual(d.raw, nonMember));\n    if (index < 0) {\n      return false;\n    }\n    this.nonMembers.splice(index, 1);\n    this.dirty.add(EDirty.NON_MEMBERS);\n    return true;\n  }\n\n  removeEdge(edge: ILine) {\n    const index = this.edges.findIndex((d) => d.obj.equals(edge));\n    if (index < 0) {\n      return false;\n    }\n    this.edges.splice(index, 1);\n    this.dirty.add(EDirty.NON_MEMBERS);\n    return true;\n  }\n\n  pushNonMember(...nonMembers: ReadonlyArray<IRectangle | ICircle>) {\n    if (nonMembers.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.NON_MEMBERS);\n    for (const v of nonMembers) {\n      this.nonMembers.push({\n        raw: v,\n        obj: isCircle(v) ? Circle.from(v) : Rectangle.from(v),\n        area: null,\n      });\n    }\n  }\n\n  pushEdge(...edges: ReadonlyArray<ILine>) {\n    if (edges.length === 0) {\n      return;\n    }\n    this.dirty.add(EDirty.EDGES);\n    for (const v of edges) {\n      this.edges.push({\n        raw: v,\n        obj: Line.from(v),\n        area: null,\n      });\n    }\n  }\n\n  private update() {\n    const dirtyMembers = this.dirty.has(EDirty.MEMBERS);\n    const dirtyNonMembers = this.dirty.has(EDirty.NON_MEMBERS);\n    let dirtyEdges = this.dirty.has(EDirty.EDGES);\n    this.dirty.clear();\n\n    const memberObjs = this.members.map((d) => d.obj);\n    if (this.o.virtualEdges && (dirtyMembers || dirtyNonMembers)) {\n      // update virtual edges\n      const nonMembersAsRects = this.nonMembers.map((d) => d.obj);\n      const virtualEdges = calculateVirtualEdges(\n        memberObjs,\n        nonMembersAsRects,\n        this.o.maxRoutingIterations,\n        this.o.morphBuffer\n      );\n\n      const old = new Map<string, Area | null>(this.virtualEdges.map((e) => [e.obj.toString(), e.area]));\n      // reuse edge areas if possible\n      this.virtualEdges = virtualEdges.map((e) => ({\n        raw: e,\n        obj: e,\n        area: old.get(e.toString()) ?? null,\n      }));\n      dirtyEdges = true;\n    }\n\n    let activeRegionDirty = false;\n    if (dirtyMembers || dirtyEdges) {\n      // update the active region\n      const edgesObj = this.virtualEdges.concat(this.edges).map((e) => e.obj);\n      const bb = unionBoundingBox(memberObjs, edgesObj);\n      const padding = Math.max(this.o.edgeR1, this.o.nodeR1) + this.o.morphBuffer;\n      const activeRegion = Rectangle.from(addPadding(bb, padding));\n      if (!activeRegion.equals(this.activeRegion)) {\n        activeRegionDirty = true;\n        this.activeRegion = activeRegion;\n      }\n    }\n\n    if (activeRegionDirty) {\n      const potentialWidth = Math.ceil(this.activeRegion.width / this.o.pixelGroup);\n      const potentialHeight = Math.ceil(this.activeRegion.height / this.o.pixelGroup);\n\n      if (this.activeRegion.x !== this.potentialArea.pixelX || this.activeRegion.y !== this.potentialArea.pixelY) {\n        // full recreate\n        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);\n        this.members.forEach((m) => (m.area = null));\n        this.nonMembers.forEach((m) => (m.area = null));\n        this.edges.forEach((m) => (m.area = null));\n        this.virtualEdges.forEach((m) => (m.area = null));\n      } else if (potentialWidth !== this.potentialArea.width || potentialHeight !== this.potentialArea.height) {\n        // recreate but we can keep the existing areas\n        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);\n      }\n    }\n\n    // update\n    const existing = new Map<string, Area>();\n    const addCache = (m: IMember) => {\n      if (m.area) {\n        const key = `${m.obj.width}x${m.obj.height}x${m.obj instanceof Rectangle ? 'R' : 'C'}`;\n        existing.set(key, m.area);\n      }\n    };\n    const createOrAddCache = (m: IMember) => {\n      if (m.area) {\n        return;\n      }\n      const key = `${m.obj.width}x${m.obj.height}x${m.obj instanceof Rectangle ? 'R' : 'C'}`;\n      if (existing.has(key)) {\n        const r = existing.get(key)!;\n        m.area = this.potentialArea.copy(r, { x: m.obj.x - this.o.nodeR1, y: m.obj.y - this.o.nodeR1 });\n        return;\n      }\n      const r =\n        m.obj instanceof Rectangle\n          ? createRectangleInfluenceArea(m.obj, this.potentialArea, this.o.nodeR1)\n          : createGenericInfluenceArea(m.obj, this.potentialArea, this.o.nodeR1);\n      m.area = r;\n      existing.set(key, r);\n    };\n    this.members.forEach(addCache);\n    this.nonMembers.forEach(addCache);\n\n    this.members.forEach(createOrAddCache);\n    this.nonMembers.forEach((m) => {\n      if (!this.activeRegion.intersects(m.obj)) {\n        m.area = null;\n      } else {\n        createOrAddCache(m);\n      }\n    });\n\n    this.edges.forEach((edge) => {\n      if (!edge.area) {\n        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);\n      }\n    });\n    this.virtualEdges.forEach((edge) => {\n      if (!edge.area) {\n        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);\n      }\n    });\n  }\n\n  drawMembers(ctx: CanvasRenderingContext2D) {\n    for (const member of this.members) {\n      member.obj.draw(ctx);\n    }\n  }\n\n  drawNonMembers(ctx: CanvasRenderingContext2D) {\n    for (const member of this.nonMembers) {\n      member.obj.draw(ctx);\n    }\n  }\n\n  drawEdges(ctx: CanvasRenderingContext2D) {\n    for (const edge of this.edges) {\n      edge.obj.draw(ctx);\n    }\n  }\n\n  drawPotentialArea(ctx: CanvasRenderingContext2D, offset = true) {\n    this.potentialArea.draw(ctx, offset);\n  }\n\n  compute() {\n    if (this.members.length === 0) {\n      return new PointPath([]);\n    }\n\n    if (this.dirty.size > 0) {\n      this.update();\n    }\n\n    const { o, potentialArea } = this;\n\n    const members = this.members.map((m) => m.area!);\n    const edges = this.virtualEdges.concat(this.edges).map((d) => d.area!);\n    const nonMembers = this.nonMembers.filter((d) => d.area != null).map((d) => d.area!);\n    const memberObjs = this.members.map((m) => m.obj);\n\n    return calculatePotentialOutline(\n      potentialArea,\n      members,\n      edges,\n      nonMembers,\n      (p) => p.containsElements(memberObjs),\n      o\n    );\n  }\n}\n\nexport function calculatePotentialOutline(\n  potentialArea: Area,\n  members: ReadonlyArray<Area>,\n  edges: ReadonlyArray<Area>,\n  nonMembers: ReadonlyArray<Area>,\n  validPath: (path: PointPath) => boolean,\n  options: IOutlineOptions = {}\n) {\n  const o = Object.assign({}, defaultOptions, options);\n  let threshold = o.threshold;\n  let memberInfluenceFactor = o.memberInfluenceFactor;\n  let edgeInfluenceFactor = o.edgeInfluenceFactor;\n  let nonMemberInfluenceFactor = o.nonMemberInfluenceFactor;\n\n  // using inverse a for numerical stability\n  const nodeInfA = (o.nodeR0 - o.nodeR1) * (o.nodeR0 - o.nodeR1);\n  const edgeInfA = (o.edgeR0 - o.edgeR1) * (o.edgeR0 - o.edgeR1);\n\n  // try to march, check if surface contains all items\n  for (let iterations = 0; iterations < o.maxMarchingIterations; iterations++) {\n    potentialArea.clear();\n\n    // add all positive energy (included items) first, as negative energy\n    // (morphing) requires all positives to be already set\n    if (memberInfluenceFactor !== 0) {\n      const f = memberInfluenceFactor / nodeInfA;\n      for (const item of members) {\n        // add node energy\n        potentialArea.incArea(item, f);\n      }\n    }\n\n    if (edgeInfluenceFactor !== 0) {\n      // add the influence of all the virtual edges\n      const f = edgeInfluenceFactor / edgeInfA;\n      for (const area of edges) {\n        potentialArea.incArea(area, f);\n      }\n    }\n\n    // calculate negative energy contribution for all other visible items within bounds\n    if (nonMemberInfluenceFactor !== 0) {\n      const f = nonMemberInfluenceFactor / nodeInfA;\n      for (const area of nonMembers) {\n        // add node energy\n        potentialArea.incArea(area, f);\n      }\n    }\n\n    // compute contour\n    const contour = marchingSquares(potentialArea, threshold);\n    if (contour && validPath(contour)) {\n      // found a valid path\n      return contour;\n    }\n\n    // prepare for next iteration\n\n    // reduce negative influences first; this will allow the surface to\n    // pass without making it fatter all around (which raising the threshold does)\n    threshold *= 0.95;\n    if (iterations <= o.maxMarchingIterations * 0.5) {\n      memberInfluenceFactor *= 1.2;\n      edgeInfluenceFactor *= 1.2;\n    } else if (nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      // after half the iterations, start increasing positive energy and lowering the threshold\n      nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n  // cannot find a solution\n  return new PointPath([]);\n}\n\nexport function unionBoundingBox(memberItems: IRectangle[], edgeItems: Line[]) {\n  if (memberItems.length === 0) {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  const activeRegion = Rectangle.from(memberItems[0]);\n  for (const m of memberItems) {\n    activeRegion.add(m);\n  }\n  for (const l of edgeItems) {\n    activeRegion.add(lineBoundingBox(l));\n  }\n  return activeRegion;\n}\n\nexport function createOutline(\n  members: ReadonlyArray<IRectangle | ICircle>,\n  nonMembers: ReadonlyArray<IRectangle> = [],\n  edges: ReadonlyArray<ILine> = [],\n  options: IOutlineOptions = {}\n) {\n  if (members.length === 0) {\n    return new PointPath([]);\n  }\n  const bb = new BubbleSets(options);\n  bb.pushMember(...members);\n  bb.pushNonMember(...nonMembers);\n  bb.pushEdge(...edges);\n  return bb.compute();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}