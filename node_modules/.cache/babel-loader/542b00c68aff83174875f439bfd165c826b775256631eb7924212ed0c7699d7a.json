{"ast":null,"code":"/*!\n * @antv/g-plugin-canvas-renderer\n * @description A G plugin of renderer implementation with Canvas2D API\n * @version 2.3.3\n * @date 7/30/2025, 1:36:40 PM\n * @author AntVis\n * @docs https://g.antv.antgroup.com/\n */\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _callSuper from '@babel/runtime/helpers/callSuper';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport { ElementEvent, AABB, CustomEvent, CanvasEvent, Shape, Node, GradientType, isPattern, AbstractRendererPlugin } from '@antv/g-lite';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _classPrivateFieldLooseBase from '@babel/runtime/helpers/classPrivateFieldLooseBase';\nimport _classPrivateFieldLooseKey from '@babel/runtime/helpers/classPrivateFieldLooseKey';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { isNil } from '@antv/util';\nimport { ImagePool } from '@antv/g-plugin-image-loader';\nvar _renderState = /*#__PURE__*/_classPrivateFieldLooseKey(\"renderState\");\n/**\n * support 2 modes in rendering:\n * * immediate\n * * delayed: render at the end of frame with dirty-rectangle\n */\nvar CanvasRendererPlugin = /*#__PURE__*/function () {\n  /**\n   * RBush used in dirty rectangle rendering\n   */\n\n  function CanvasRendererPlugin(canvasRendererPluginOptions // private styleRendererFactory: Record<Shape, StyleRenderer>,\n  ) {\n    _classCallCheck(this, CanvasRendererPlugin);\n    this.removedRBushNodeAABBs = [];\n    this.renderQueue = [];\n    Object.defineProperty(this, _renderState, {\n      writable: true,\n      value: {\n        restoreStack: [],\n        prevObject: null,\n        currentContext: new Map()\n      }\n    });\n    this.clearFullScreenLastFrame = false;\n    this.clearFullScreen = false;\n    /**\n     * view projection matrix\n     */\n    this.vpMatrix = mat4.create();\n    this.dprMatrix = mat4.create();\n    this.tmpMat4 = mat4.create();\n    this.vec3a = vec3.create();\n    this.vec3b = vec3.create();\n    this.vec3c = vec3.create();\n    this.vec3d = vec3.create();\n    this.canvasRendererPluginOptions = canvasRendererPluginOptions;\n  }\n  return _createClass(CanvasRendererPlugin, [{\n    key: \"apply\",\n    value: function apply(context, runtime) {\n      var _this = this;\n      this.context = context;\n      var _this$context = this.context,\n        config = _this$context.config,\n        camera = _this$context.camera,\n        renderingService = _this$context.renderingService,\n        renderingContext = _this$context.renderingContext,\n        rBushRoot = _this$context.rBushRoot,\n        pathGeneratorFactory = _this$context.pathGeneratorFactory;\n      var enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;\n      config.renderer.getConfig().enableDirtyCheck = false;\n      config.renderer.getConfig().enableDirtyRectangleRendering = false;\n      this.rBush = rBushRoot;\n      this.pathGeneratorFactory = pathGeneratorFactory;\n      var contextService = context.contextService;\n      var canvas = renderingContext.root.ownerDocument.defaultView;\n      var handleUnmounted = function handleUnmounted(e) {\n        var object = e.target;\n\n        // remove r-bush node\n        // @ts-ignore\n        var rBushNode = object.rBushNode;\n        if (rBushNode !== null && rBushNode !== void 0 && rBushNode.aabb) {\n          // save removed aabbs for dirty-rectangle rendering later\n          _this.removedRBushNodeAABBs.push(rBushNode.aabb);\n        }\n      };\n      var handleCulled = function handleCulled(e) {\n        var object = e.target;\n        // @ts-ignore\n        var rBushNode = object.rBushNode;\n        if (rBushNode.aabb) {\n          // save removed aabbs for dirty-rectangle rendering later\n          _this.removedRBushNodeAABBs.push(rBushNode.aabb);\n        }\n      };\n      renderingService.hooks.init.tap(CanvasRendererPlugin.tag, function () {\n        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);\n        canvas.addEventListener(ElementEvent.CULLED, handleCulled);\n\n        // clear fullscreen\n        var dpr = contextService.getDPR();\n        var width = config.width,\n          height = config.height;\n        var context = contextService.getContext();\n        _this.clearRect(context, 0, 0, width * dpr, height * dpr, config.background);\n      });\n      renderingService.hooks.destroy.tap(CanvasRendererPlugin.tag, function () {\n        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);\n        canvas.removeEventListener(ElementEvent.CULLED, handleCulled);\n        _this.renderQueue = [];\n        _this.removedRBushNodeAABBs = [];\n        _classPrivateFieldLooseBase(_this, _renderState)[_renderState] = {\n          restoreStack: [],\n          prevObject: null,\n          currentContext: null\n        };\n      });\n      var beforeDraw = function beforeDraw() {\n        var _canvas$context$rende;\n        var context = contextService.getContext();\n        var dpr = contextService.getDPR();\n        var width = config.width,\n          height = config.height;\n        var _this$canvasRendererP = _this.canvasRendererPluginOptions,\n          dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold,\n          dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;\n\n        // some heuristic conditions such as 80% object changed\n        var _renderingService$get = renderingService.getStats(),\n          total = _renderingService$get.total,\n          rendered = _renderingService$get.rendered;\n        var ratio = rendered / total;\n        _this.clearFullScreen = _this.clearFullScreenLastFrame ||\n        // @ts-ignore\n        !((_canvas$context$rende = canvas.context.renderingPlugins[1]) !== null && _canvas$context$rende !== void 0 && _canvas$context$rende.isFirstTimeRenderingFinished) || renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;\n        if (!context) {\n          return;\n        }\n        if (typeof context.resetTransform === 'function') {\n          context.resetTransform();\n        } else {\n          context.setTransform(1, 0, 0, 1, 0, 0);\n        }\n        if (_this.clearFullScreen) {\n          _this.clearRect(context, 0, 0, width * dpr, height * dpr, config.background);\n        }\n      };\n\n      /**\n       * render objects by z-index\n       *\n       * - The level of the child node will be affected by the level of the parent node\n       */\n      var renderByZIndex = function renderByZIndex(object, context) {\n        var stack = [object];\n        while (stack.length > 0) {\n          var _currentObject$sortab;\n          var currentObject = stack.pop();\n          if (currentObject.isVisible() && !currentObject.isCulled()) {\n            if (enableRenderingOptimization) {\n              _this.renderDisplayObjectOptimized(currentObject, context, _this.context, _classPrivateFieldLooseBase(_this, _renderState)[_renderState], runtime);\n            } else {\n              _this.renderDisplayObject(currentObject, context, _this.context, _classPrivateFieldLooseBase(_this, _renderState)[_renderState], runtime);\n            }\n          }\n          var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;\n          // should account for z-index\n          for (var i = objects.length - 1; i >= 0; i--) {\n            stack.push(objects[i]);\n          }\n        }\n      };\n\n      // render at the end of frame\n      renderingService.hooks.endFrame.tap(CanvasRendererPlugin.tag, function () {\n        beforeDraw();\n\n        // Skip rendering.\n        if (renderingContext.root.childNodes.length === 0) {\n          _this.clearFullScreenLastFrame = true;\n          return;\n        }\n        enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;\n\n        // init\n        _classPrivateFieldLooseBase(_this, _renderState)[_renderState] = {\n          restoreStack: [],\n          prevObject: null,\n          currentContext: _classPrivateFieldLooseBase(_this, _renderState)[_renderState].currentContext\n        };\n        _classPrivateFieldLooseBase(_this, _renderState)[_renderState].currentContext.clear();\n        _this.clearFullScreenLastFrame = false;\n        var context = contextService.getContext();\n        // clear & clip dirty rectangle\n        var dpr = contextService.getDPR();\n        mat4.fromScaling(_this.dprMatrix, [dpr, dpr, 1]);\n        mat4.multiply(_this.vpMatrix, _this.dprMatrix, camera.getOrthoMatrix());\n        if (_this.clearFullScreen) {\n          // console.time('renderByZIndex');\n          if (enableRenderingOptimization) {\n            context.save();\n            renderByZIndex(renderingContext.root, context);\n            context.restore();\n          } else {\n            renderByZIndex(renderingContext.root, context);\n          }\n          // console.timeEnd('renderByZIndex');\n\n          _this.removedRBushNodeAABBs = [];\n        } else {\n          // console.log('canvas renderer next...', this.renderQueue);\n          // merge removed AABB\n          var dirtyRenderBounds = _this.safeMergeAABB.apply(_this, [_this.mergeDirtyAABBs(_this.renderQueue)].concat(_toConsumableArray(_this.removedRBushNodeAABBs.map(function (_ref) {\n            var minX = _ref.minX,\n              minY = _ref.minY,\n              maxX = _ref.maxX,\n              maxY = _ref.maxY;\n            var aabb = new AABB();\n            aabb.setMinMax(\n            // vec3.fromValues(minX, minY, 0),\n            // vec3.fromValues(maxX, maxY, 0),\n            [minX, minY, 0], [maxX, maxY, 0]);\n            return aabb;\n          }))));\n          _this.removedRBushNodeAABBs = [];\n          if (AABB.isEmpty(dirtyRenderBounds)) {\n            _this.renderQueue = [];\n            return;\n          }\n          var dirtyRect = _this.convertAABB2Rect(dirtyRenderBounds);\n          var x = dirtyRect.x,\n            y = dirtyRect.y,\n            width = dirtyRect.width,\n            height = dirtyRect.height;\n          var tl = vec3.transformMat4(_this.vec3a, [x, y, 0], _this.vpMatrix);\n          var tr = vec3.transformMat4(_this.vec3b, [x + width, y, 0], _this.vpMatrix);\n          var bl = vec3.transformMat4(_this.vec3c, [x, y + height, 0], _this.vpMatrix);\n          var br = vec3.transformMat4(_this.vec3d, [x + width, y + height, 0], _this.vpMatrix);\n          var minx = Math.min(tl[0], tr[0], br[0], bl[0]);\n          var miny = Math.min(tl[1], tr[1], br[1], bl[1]);\n          var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);\n          var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);\n          var ix = Math.floor(minx);\n          var iy = Math.floor(miny);\n          var iwidth = Math.ceil(maxx - minx);\n          var iheight = Math.ceil(maxy - miny);\n          context.save();\n          _this.clearRect(context, ix, iy, iwidth, iheight, config.background);\n          context.beginPath();\n          context.rect(ix, iy, iwidth, iheight);\n          context.clip();\n\n          // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations\n          context.setTransform(_this.vpMatrix[0], _this.vpMatrix[1], _this.vpMatrix[4], _this.vpMatrix[5], _this.vpMatrix[12], _this.vpMatrix[13]);\n\n          // draw dirty rectangle\n          var _config$renderer$getC = config.renderer.getConfig(),\n            enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;\n          if (enableDirtyRectangleRenderingDebug) {\n            canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {\n              dirtyRect: {\n                x: ix,\n                y: iy,\n                width: iwidth,\n                height: iheight\n              }\n            }));\n          }\n\n          // search objects intersect with dirty rectangle\n          var dirtyObjects = _this.searchDirtyObjects(dirtyRenderBounds);\n\n          // do rendering\n          dirtyObjects\n          // sort by z-index\n          .sort(function (a, b) {\n            return a.sortable.renderOrder - b.sortable.renderOrder;\n          }).forEach(function (object) {\n            // culled object should not be rendered\n            if (object && object.isVisible() && !object.isCulled()) {\n              _this.renderDisplayObject(object, context, _this.context, _classPrivateFieldLooseBase(_this, _renderState)[_renderState], runtime);\n            }\n          });\n          context.restore();\n\n          // save dirty AABBs in last frame\n          _this.renderQueue.forEach(function (object) {\n            _this.saveDirtyAABB(object);\n          });\n\n          // clear queue\n          _this.renderQueue = [];\n        }\n\n        // pop restore stack, eg. root -> parent -> child\n        _classPrivateFieldLooseBase(_this, _renderState)[_renderState].restoreStack.forEach(function () {\n          context.restore();\n        });\n        // clear restore stack\n        _classPrivateFieldLooseBase(_this, _renderState)[_renderState].restoreStack = [];\n      });\n      renderingService.hooks.render.tap(CanvasRendererPlugin.tag, function (object) {\n        if (!_this.clearFullScreen) {\n          // render at the end of frame\n          _this.renderQueue.push(object);\n        }\n      });\n    }\n  }, {\n    key: \"clearRect\",\n    value: function clearRect(context, x, y, width, height, background) {\n      // clearRect is faster than fillRect @see https://stackoverflow.com/a/30830253\n      context.clearRect(x, y, width, height);\n      if (background) {\n        context.fillStyle = background;\n        context.fillRect(x, y, width, height);\n      }\n    }\n  }, {\n    key: \"renderDisplayObjectOptimized\",\n    value: function renderDisplayObjectOptimized(object, context, canvasContext, renderState, runtime) {\n      var nodeName = object.nodeName;\n      var updateTransform = false;\n      var clipDraw = false;\n\n      // @ts-ignore\n      var styleRenderer = this.context.styleRendererFactory[nodeName];\n      var generatePath = this.pathGeneratorFactory[nodeName];\n\n      // clip path\n      var clipPath = object.parsedStyle.clipPath;\n      if (clipPath) {\n        updateTransform = !renderState.prevObject || !mat4.exactEquals(clipPath.getWorldTransform(), renderState.prevObject.getWorldTransform());\n        if (updateTransform) {\n          this.applyWorldTransform(context, clipPath);\n          renderState.prevObject = null;\n        }\n\n        // generate path in local space\n        var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];\n        if (_generatePath) {\n          context.save();\n          clipDraw = true;\n          context.beginPath();\n          _generatePath(context, clipPath.parsedStyle);\n          context.closePath();\n          context.clip();\n        }\n      }\n\n      // fill & stroke\n\n      if (styleRenderer) {\n        updateTransform = !renderState.prevObject || !mat4.exactEquals(object.getWorldTransform(), renderState.prevObject.getWorldTransform());\n        if (updateTransform) {\n          this.applyWorldTransform(context, object);\n        }\n        var forceUpdateStyle = !renderState.prevObject;\n        if (!forceUpdateStyle) {\n          var prevNodeName = renderState.prevObject.nodeName;\n          if (nodeName === Shape.TEXT) {\n            forceUpdateStyle = prevNodeName !== Shape.TEXT;\n          } else if (nodeName === Shape.IMAGE) {\n            forceUpdateStyle = prevNodeName !== Shape.IMAGE;\n          } else {\n            forceUpdateStyle = prevNodeName === Shape.TEXT || prevNodeName === Shape.IMAGE;\n          }\n        }\n        styleRenderer.applyStyleToContext(context, object, forceUpdateStyle, renderState);\n        renderState.prevObject = object;\n      }\n      if (generatePath) {\n        context.beginPath();\n        generatePath(context, object.parsedStyle);\n        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {\n          context.closePath();\n        }\n      }\n\n      // fill & stroke\n      if (styleRenderer) {\n        styleRenderer.drawToContext(context, object, _classPrivateFieldLooseBase(this, _renderState)[_renderState], this, runtime);\n      }\n      if (clipDraw) {\n        context.restore();\n      }\n\n      // finish rendering, clear dirty flag\n      object.dirty(false);\n    }\n  }, {\n    key: \"renderDisplayObject\",\n    value: function renderDisplayObject(object, context, canvasContext, renderState, runtime) {\n      var nodeName = object.nodeName;\n\n      // restore to its ancestor\n\n      var parent = renderState.restoreStack[renderState.restoreStack.length - 1];\n      if (parent && !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {\n        context.restore();\n        renderState.restoreStack.pop();\n      }\n\n      // @ts-ignore\n      var styleRenderer = this.context.styleRendererFactory[nodeName];\n      var generatePath = this.pathGeneratorFactory[nodeName];\n\n      // clip path\n      var clipPath = object.parsedStyle.clipPath;\n      if (clipPath) {\n        this.applyWorldTransform(context, clipPath);\n\n        // generate path in local space\n        var _generatePath2 = this.pathGeneratorFactory[clipPath.nodeName];\n        if (_generatePath2) {\n          context.save();\n\n          // save clip\n          renderState.restoreStack.push(object);\n          context.beginPath();\n          _generatePath2(context, clipPath.parsedStyle);\n          context.closePath();\n          context.clip();\n        }\n      }\n\n      // fill & stroke\n\n      if (styleRenderer) {\n        this.applyWorldTransform(context, object);\n        context.save();\n\n        // apply attributes to context\n        this.applyAttributesToContext(context, object);\n      }\n      if (generatePath) {\n        context.beginPath();\n        generatePath(context, object.parsedStyle);\n        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {\n          context.closePath();\n        }\n      }\n\n      // fill & stroke\n      if (styleRenderer) {\n        styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime);\n\n        // restore applied attributes, eg. shadowBlur shadowColor...\n        context.restore();\n      }\n\n      // finish rendering, clear dirty flag\n      object.dirty(false);\n    }\n  }, {\n    key: \"applyAttributesToContext\",\n    value: function applyAttributesToContext(context, object) {\n      var _ref2 = object.parsedStyle,\n        stroke = _ref2.stroke,\n        fill = _ref2.fill,\n        opacity = _ref2.opacity,\n        lineDash = _ref2.lineDash,\n        lineDashOffset = _ref2.lineDashOffset;\n      // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash\n      if (lineDash) {\n        context.setLineDash(lineDash);\n      }\n\n      // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset\n      if (!isNil(lineDashOffset)) {\n        context.lineDashOffset = lineDashOffset;\n      }\n      if (!isNil(opacity)) {\n        context.globalAlpha *= opacity;\n      }\n      if (!isNil(stroke) && !Array.isArray(stroke) && !stroke.isNone) {\n        context.strokeStyle = object.attributes.stroke;\n      }\n      if (!isNil(fill) && !Array.isArray(fill) && !fill.isNone) {\n        context.fillStyle = object.attributes.fill;\n      }\n    }\n  }, {\n    key: \"convertAABB2Rect\",\n    value: function convertAABB2Rect(aabb) {\n      var min = aabb.getMin();\n      var max = aabb.getMax();\n      // expand the rectangle a bit to avoid artifacts\n      // @see https://www.yuque.com/antv/ou292n/bi8nix#ExvCu\n      var minX = Math.floor(min[0]);\n      var minY = Math.floor(min[1]);\n      var maxX = Math.ceil(max[0]);\n      var maxY = Math.ceil(max[1]);\n      var width = maxX - minX;\n      var height = maxY - minY;\n      return {\n        x: minX,\n        y: minY,\n        width: width,\n        height: height\n      };\n    }\n\n    /**\n     * TODO: merge dirty rectangles with some strategies.\n     * For now, we just simply merge all the rectangles into one.\n     * @see https://idom.me/articles/841.html\n     */\n  }, {\n    key: \"mergeDirtyAABBs\",\n    value: function mergeDirtyAABBs(dirtyObjects) {\n      // merge into a big AABB\n      // TODO: skip descendant if ancestor is caculated, but compareNodePosition is really slow\n      var aabb = new AABB();\n      dirtyObjects.forEach(function (object) {\n        var renderBounds = object.getRenderBounds();\n        aabb.add(renderBounds);\n        var dirtyRenderBounds = object.renderable.dirtyRenderBounds;\n        if (dirtyRenderBounds) {\n          aabb.add(dirtyRenderBounds);\n        }\n      });\n      return aabb;\n    }\n  }, {\n    key: \"searchDirtyObjects\",\n    value: function searchDirtyObjects(dirtyRectangle) {\n      // search in r-tree, get all affected nodes\n      var _dirtyRectangle$getMi = dirtyRectangle.getMin(),\n        _dirtyRectangle$getMi2 = _slicedToArray(_dirtyRectangle$getMi, 2),\n        minX = _dirtyRectangle$getMi2[0],\n        minY = _dirtyRectangle$getMi2[1];\n      var _dirtyRectangle$getMa = dirtyRectangle.getMax(),\n        _dirtyRectangle$getMa2 = _slicedToArray(_dirtyRectangle$getMa, 2),\n        maxX = _dirtyRectangle$getMa2[0],\n        maxY = _dirtyRectangle$getMa2[1];\n      var rBushNodes = this.rBush.search({\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY\n      });\n      return rBushNodes.map(function (_ref3) {\n        var displayObject = _ref3.displayObject;\n        return displayObject;\n      });\n    }\n  }, {\n    key: \"saveDirtyAABB\",\n    value: function saveDirtyAABB(object) {\n      var renderable = object.renderable;\n      if (!renderable.dirtyRenderBounds) {\n        renderable.dirtyRenderBounds = new AABB();\n      }\n      var renderBounds = object.getRenderBounds();\n      if (renderBounds) {\n        // save last dirty aabb\n        renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);\n      }\n    }\n  }, {\n    key: \"applyWorldTransform\",\n    value: function applyWorldTransform(context, object, matrix) {\n      // apply clip shape's RTS\n      if (matrix) {\n        mat4.copy(this.tmpMat4, object.getLocalTransform());\n        mat4.multiply(this.tmpMat4, matrix, this.tmpMat4);\n        mat4.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);\n      } else {\n        // apply RTS transformation in world space\n        mat4.copy(this.tmpMat4, object.getWorldTransform());\n        mat4.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);\n      }\n\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations\n      context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);\n    }\n  }, {\n    key: \"safeMergeAABB\",\n    value: function safeMergeAABB() {\n      var merged = new AABB();\n      for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {\n        aabbs[_key] = arguments[_key];\n      }\n      aabbs.forEach(function (aabb) {\n        merged.add(aabb);\n      });\n      return merged;\n    }\n  }]);\n}();\nCanvasRendererPlugin.tag = 'CanvasRenderer';\nfunction getPattern(pattern, object, context, canvasContext, plugin, runtime, imagePool) {\n  var $offscreenCanvas;\n  var dpr;\n  if (pattern.image.nodeName === 'rect') {\n    var _parsedStyle = pattern.image.parsedStyle,\n      width = _parsedStyle.width,\n      height = _parsedStyle.height;\n    dpr = canvasContext.contextService.getDPR();\n    var offscreenCanvas = canvasContext.config.offscreenCanvas;\n    $offscreenCanvas = runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n    $offscreenCanvas.width = width * dpr;\n    $offscreenCanvas.height = height * dpr;\n    var offscreenCanvasContext = runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);\n    var renderState = {\n      restoreStack: [],\n      prevObject: null,\n      currentContext: new Map()\n    };\n\n    // offscreenCanvasContext.scale(1 / dpr, 1 / dpr);\n\n    pattern.image.forEach(function (object) {\n      plugin.renderDisplayObject(object, offscreenCanvasContext, canvasContext, renderState, runtime);\n    });\n    renderState.restoreStack.forEach(function () {\n      offscreenCanvasContext.restore();\n    });\n  }\n  var canvasPattern = imagePool.getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, object.getGeometryBounds().min, function () {\n    // set dirty rectangle flag\n    object.dirty();\n    canvasContext.renderingService.dirtify();\n  });\n  return canvasPattern;\n}\nfunction getColor(parsedColor, object, context, imagePool) {\n  var color;\n  if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {\n    var bounds = object.getGeometryBounds();\n    var width = bounds && bounds.halfExtents[0] * 2 || 1;\n    var height = bounds && bounds.halfExtents[1] * 2 || 1;\n    var min = bounds && bounds.min || [0, 0];\n    color = imagePool.getOrCreateGradient(_objectSpread(_objectSpread({\n      type: parsedColor.type\n    }, parsedColor.value), {}, {\n      min: min,\n      width: width,\n      height: height\n    }), context);\n  }\n  return color;\n}\nvar SHADOW_NUMBER_STYLE = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\nvar STROKE_STYLE = ['lineCap', 'lineJoin', 'miterLimit'];\nvar DEFAULT_STYLE = {\n  // common\n  globalAlpha: 1,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  shadowColor: '#000',\n  filter: 'none',\n  globalCompositeOperation: 'source-over',\n  // stroke/fill\n  strokeStyle: '#000',\n  strokeOpacity: 1,\n  lineWidth: 1,\n  lineDash: [],\n  lineDashOffset: 0,\n  lineCap: 'butt',\n  lineJoin: 'miter',\n  miterLimit: 10,\n  fillStyle: '#000',\n  fillOpacity: 1\n\n  // image\n};\nvar defaultParsedStyle = {};\n\n/**\n * Updating the canvas context is an expensive operation. The state of the context is cached and the actual update operation is performed only when the cache is not hit.\n *\n * In any case, the previous value is returned, which is convenient for temporarily updating the context and restoring it later.\n */\nfunction updateContextIfNotHitCache(context, key, value, cache) {\n  var prevValue = cache.has(key) ? cache.get(key) : DEFAULT_STYLE[key];\n  if (prevValue !== value) {\n    // console.log('not hit cache', key, value, prevValue, cache);\n    if (key === 'lineDash') {\n      context.setLineDash(value);\n    } else {\n      // @ts-ignore\n      context[key] = value;\n    }\n    cache.set(key, value);\n  }\n  return prevValue;\n}\nvar OptimizedDefaultRenderer = /*#__PURE__*/function () {\n  function OptimizedDefaultRenderer(imagePool) {\n    _classCallCheck(this, OptimizedDefaultRenderer);\n    this.imagePool = imagePool;\n  }\n  return _createClass(OptimizedDefaultRenderer, [{\n    key: \"applyAttributesToContext\",\n    value: function applyAttributesToContext(context, object) {}\n  }, {\n    key: \"render\",\n    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime) {}\n\n    // #region common style\n  }, {\n    key: \"applyCommonStyleToContext\",\n    value: function applyCommonStyleToContext(context, object, forceUpdate, renderState) {\n      // const dpr = object.ownerDocument.defaultView.getContextService().getDPR();\n      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;\n      var style = object.parsedStyle;\n      if (forceUpdate || style.opacity !== prevStyle.opacity) {\n        updateContextIfNotHitCache(context, 'globalAlpha', !isNil(style.opacity) ? style.opacity : DEFAULT_STYLE.globalAlpha, renderState.currentContext);\n      }\n\n      // TODO blend prop\n      // @ts-ignore\n      if (forceUpdate || style.blend !== prevStyle.blend) {\n        updateContextIfNotHitCache(context, 'globalCompositeOperation',\n        // @ts-ignore\n        !isNil(style.blend) ?\n        // @ts-ignore\n        style.blend : DEFAULT_STYLE.globalCompositeOperation, renderState.currentContext);\n      }\n    }\n    // #endregion common style\n\n    // #region stroke/fill style\n  }, {\n    key: \"applyStrokeFillStyleToContext\",\n    value: function applyStrokeFillStyleToContext(context, object, forceUpdate, renderState) {\n      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;\n      var style = object.parsedStyle;\n      var _style$lineWidth = style.lineWidth,\n        lineWidth = _style$lineWidth === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth;\n      var hasFill = style.fill && !style.fill.isNone;\n      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;\n      if (hasStroke) {\n        if (forceUpdate || object.attributes.stroke !== renderState.prevObject.attributes.stroke) {\n          var value = !isNil(style.stroke) && !Array.isArray(style.stroke) && !style.stroke.isNone ? object.attributes.stroke : DEFAULT_STYLE.strokeStyle;\n          updateContextIfNotHitCache(context, 'strokeStyle', value, renderState.currentContext);\n        }\n        if (forceUpdate || style.lineWidth !== prevStyle.lineWidth) {\n          updateContextIfNotHitCache(context, 'lineWidth', !isNil(style.lineWidth) ? style.lineWidth : DEFAULT_STYLE.lineWidth, renderState.currentContext);\n        }\n        if (forceUpdate || style.lineDash !== prevStyle.lineDash) {\n          updateContextIfNotHitCache(context, 'lineDash', style.lineDash || DEFAULT_STYLE.lineDash, renderState.currentContext);\n        }\n        if (forceUpdate || style.lineDashOffset !== prevStyle.lineDashOffset) {\n          updateContextIfNotHitCache(context, 'lineDashOffset', !isNil(style.lineDashOffset) ? style.lineDashOffset : DEFAULT_STYLE.lineDashOffset, renderState.currentContext);\n        }\n        for (var i = 0; i < STROKE_STYLE.length; i++) {\n          var styleName = STROKE_STYLE[i];\n          if (forceUpdate || style[styleName] !== prevStyle[styleName]) {\n            updateContextIfNotHitCache(context, styleName, !isNil(style[styleName]) ? style[styleName] : DEFAULT_STYLE[styleName], renderState.currentContext);\n          }\n        }\n      }\n      if (hasFill && (forceUpdate || object.attributes.fill !== renderState.prevObject.attributes.fill)) {\n        var _value = !isNil(style.fill) && !Array.isArray(style.fill) && !style.fill.isNone ? object.attributes.fill : DEFAULT_STYLE.fillStyle;\n        updateContextIfNotHitCache(context, 'fillStyle', _value, renderState.currentContext);\n      }\n    }\n    // #endregion stroke/fill style\n  }, {\n    key: \"applyStyleToContext\",\n    value: function applyStyleToContext(context, object, forceUpdate, renderState) {\n      var nodeName = object.nodeName;\n      this.applyCommonStyleToContext(context, object, forceUpdate, renderState);\n      if (nodeName === Shape.IMAGE) ;else {\n        this.applyStrokeFillStyleToContext(context, object, forceUpdate, renderState);\n      }\n    }\n  }, {\n    key: \"applyShadowAndFilterStyleToContext\",\n    value: function applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState) {\n      var style = object.parsedStyle;\n      if (hasShadow) {\n        updateContextIfNotHitCache(context, 'shadowColor', style.shadowColor.toString(), renderState.currentContext);\n        for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {\n          var styleName = SHADOW_NUMBER_STYLE[i];\n          updateContextIfNotHitCache(context, styleName, style[styleName] || DEFAULT_STYLE[styleName], renderState.currentContext);\n        }\n      }\n      if (style.filter && style.filter.length) {\n        updateContextIfNotHitCache(context, 'filter',\n        // use raw filter string\n        object.attributes.filter, renderState.currentContext);\n      }\n    }\n  }, {\n    key: \"clearShadowAndFilterStyleForContext\",\n    value: function clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState) {\n      var onlyClearShadowFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      if (hasShadow) {\n        updateContextIfNotHitCache(context, 'shadowColor', DEFAULT_STYLE.shadowColor, renderState.currentContext);\n        for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {\n          var styleName = SHADOW_NUMBER_STYLE[i];\n          updateContextIfNotHitCache(context, styleName, DEFAULT_STYLE[styleName], renderState.currentContext);\n        }\n      }\n      if (hasFilter) {\n        if (hasShadow && onlyClearShadowFilter) {\n          // save drop-shadow filter\n          var oldFilter = context.filter;\n          if (!isNil(oldFilter) && oldFilter.indexOf('drop-shadow') > -1) {\n            updateContextIfNotHitCache(context, 'filter', oldFilter.replace(/drop-shadow\\([^)]*\\)/, '').trim() || DEFAULT_STYLE.filter, renderState.currentContext);\n          }\n        } else {\n          updateContextIfNotHitCache(context, 'filter', DEFAULT_STYLE.filter, renderState.currentContext);\n        }\n      }\n    }\n  }, {\n    key: \"fillToContext\",\n    value: function fillToContext(context, object, renderState, plugin, runtime) {\n      var _this = this;\n      var _object$parsedStyle = object.parsedStyle,\n        fill = _object$parsedStyle.fill,\n        fillRule = _object$parsedStyle.fillRule;\n      var resetStyle = null;\n      if (Array.isArray(fill) && fill.length > 0) {\n        fill.forEach(function (gradient) {\n          var prevStyle = updateContextIfNotHitCache(context, 'fillStyle', getColor(gradient, object, context, _this.imagePool), renderState.currentContext);\n          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;\n          if (fillRule) {\n            context.fill(fillRule);\n          } else {\n            context.fill();\n          }\n        });\n      } else {\n        if (isPattern(fill)) {\n          var pattern = getPattern(fill, object, context, object.ownerDocument.defaultView.context, plugin, runtime, this.imagePool);\n          if (pattern) {\n            context.fillStyle = pattern;\n            resetStyle = true;\n          }\n        }\n        if (fillRule) {\n          context.fill(fillRule);\n        } else {\n          context.fill();\n        }\n      }\n      if (resetStyle !== null) {\n        updateContextIfNotHitCache(context, 'fillStyle', resetStyle, renderState.currentContext);\n      }\n    }\n  }, {\n    key: \"strokeToContext\",\n    value: function strokeToContext(context, object, renderState, plugin, runtime) {\n      var _this2 = this;\n      var stroke = object.parsedStyle.stroke;\n      var resetStyle = null;\n      if (Array.isArray(stroke) && stroke.length > 0) {\n        stroke.forEach(function (gradient) {\n          var prevStyle = updateContextIfNotHitCache(context, 'strokeStyle', getColor(gradient, object, context, _this2.imagePool), renderState.currentContext);\n          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;\n          context.stroke();\n        });\n      } else {\n        if (isPattern(stroke)) {\n          var pattern = getPattern(stroke, object, context, object.ownerDocument.defaultView.context, plugin, runtime, this.imagePool);\n          if (pattern) {\n            var prevStyle = updateContextIfNotHitCache(context, 'strokeStyle', pattern, renderState.currentContext);\n            resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;\n          }\n        }\n        context.stroke();\n      }\n      if (resetStyle !== null) {\n        updateContextIfNotHitCache(context, 'strokeStyle', resetStyle, renderState.currentContext);\n      }\n    }\n  }, {\n    key: \"drawToContext\",\n    value: function drawToContext(context, object, renderState, plugin, runtime) {\n      var _style$fill;\n      var nodeName = object.nodeName;\n      var style = object.parsedStyle;\n      var _style$opacity = style.opacity,\n        opacity = _style$opacity === void 0 ? DEFAULT_STYLE.globalAlpha : _style$opacity,\n        _style$fillOpacity = style.fillOpacity,\n        fillOpacity = _style$fillOpacity === void 0 ? DEFAULT_STYLE.fillOpacity : _style$fillOpacity,\n        _style$strokeOpacity = style.strokeOpacity,\n        strokeOpacity = _style$strokeOpacity === void 0 ? DEFAULT_STYLE.strokeOpacity : _style$strokeOpacity,\n        _style$lineWidth2 = style.lineWidth,\n        lineWidth = _style$lineWidth2 === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth2;\n      var hasFill = style.fill && !style.fill.isNone;\n      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;\n      if (!hasFill && !hasStroke) {\n        return;\n      }\n      var hasShadow = !isNil(style.shadowColor) && style.shadowBlur > 0;\n      var isInnerShadow = style.shadowType === 'inner';\n      var isFillTransparent = ((_style$fill = style.fill) === null || _style$fill === void 0 ? void 0 : _style$fill.alpha) === 0;\n      var hasFilter = !!(style.filter && style.filter.length);\n      // Shadows can only be applied to fill() or stroke(), the default is fill()\n      var shouldDrawShadowWithStroke = hasShadow && hasStroke && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);\n\n      // TODO https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/paint-order\n\n      var originGlobalAlpha = null;\n      if (hasFill) {\n        if (!shouldDrawShadowWithStroke) {\n          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);\n        }\n        var updateOpacity = opacity * fillOpacity;\n        originGlobalAlpha = updateContextIfNotHitCache(context, 'globalAlpha', updateOpacity, renderState.currentContext);\n        this.fillToContext(context, object, renderState, plugin, runtime);\n        if (!shouldDrawShadowWithStroke) {\n          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);\n        }\n      }\n      if (hasStroke) {\n        var clearShadowAndFilter = false;\n        var _updateOpacity = opacity * strokeOpacity;\n        var prevOpacity = updateContextIfNotHitCache(context, 'globalAlpha', _updateOpacity, renderState.currentContext);\n        originGlobalAlpha = hasFill ? originGlobalAlpha : prevOpacity;\n        if (shouldDrawShadowWithStroke) {\n          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);\n          clearShadowAndFilter = true;\n          if (isInnerShadow) {\n            var originBlend = context.globalCompositeOperation;\n            context.globalCompositeOperation = 'source-atop';\n            this.strokeToContext(context, object, renderState, plugin, runtime);\n            context.globalCompositeOperation = originBlend;\n            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState, true);\n          }\n        }\n        this.strokeToContext(context, object, renderState, plugin, runtime);\n        if (clearShadowAndFilter) {\n          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);\n        }\n      }\n\n      // clear\n      if (originGlobalAlpha !== null) {\n        updateContextIfNotHitCache(context, 'globalAlpha', originGlobalAlpha, renderState.currentContext);\n      }\n    }\n  }]);\n}();\nvar DefaultRenderer = /*#__PURE__*/function (_OptimizedDefaultRend) {\n  function DefaultRenderer() {\n    _classCallCheck(this, DefaultRenderer);\n    return _callSuper(this, DefaultRenderer, arguments);\n  }\n  _inherits(DefaultRenderer, _OptimizedDefaultRend);\n  return _createClass(DefaultRenderer, [{\n    key: \"render\",\n    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime) {\n      var fill = parsedStyle.fill,\n        fillRule = parsedStyle.fillRule,\n        _parsedStyle$opacity = parsedStyle.opacity,\n        opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity,\n        _parsedStyle$fillOpac = parsedStyle.fillOpacity,\n        fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac,\n        stroke = parsedStyle.stroke,\n        _parsedStyle$strokeOp = parsedStyle.strokeOpacity,\n        strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp,\n        _parsedStyle$lineWidt = parsedStyle.lineWidth,\n        lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt,\n        lineCap = parsedStyle.lineCap,\n        lineJoin = parsedStyle.lineJoin,\n        shadowType = parsedStyle.shadowType,\n        shadowColor = parsedStyle.shadowColor,\n        shadowBlur = parsedStyle.shadowBlur,\n        filter = parsedStyle.filter,\n        miterLimit = parsedStyle.miterLimit;\n      var hasFill = fill && !fill.isNone;\n      var hasStroke = stroke && !stroke.isNone && lineWidth > 0;\n      var isFillTransparent = (fill === null || fill === void 0 ? void 0 : fill.alpha) === 0;\n      var hasFilter = !!(filter && filter.length);\n      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;\n      var nodeName = object.nodeName;\n      var isInnerShadow = shadowType === 'inner';\n      var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);\n      if (hasFill) {\n        context.globalAlpha = opacity * fillOpacity;\n        if (!shouldDrawShadowWithStroke) {\n          setShadowAndFilter(object, context, hasShadow);\n        }\n        applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime, this.imagePool);\n        if (!shouldDrawShadowWithStroke) {\n          this.clearShadowAndFilter(context, hasFilter, hasShadow);\n        }\n      }\n      if (hasStroke) {\n        context.globalAlpha = opacity * strokeOpacity;\n        context.lineWidth = lineWidth;\n        if (!isNil(miterLimit)) {\n          context.miterLimit = miterLimit;\n        }\n        if (!isNil(lineCap)) {\n          context.lineCap = lineCap;\n        }\n        if (!isNil(lineJoin)) {\n          context.lineJoin = lineJoin;\n        }\n        if (shouldDrawShadowWithStroke) {\n          if (isInnerShadow) {\n            context.globalCompositeOperation = 'source-atop';\n          }\n          setShadowAndFilter(object, context, true);\n          if (isInnerShadow) {\n            applyStroke(context, object, stroke, canvasContext, plugin, runtime, this.imagePool);\n            context.globalCompositeOperation = DEFAULT_STYLE.globalCompositeOperation;\n            this.clearShadowAndFilter(context, hasFilter, true);\n          }\n        }\n        applyStroke(context, object, stroke, canvasContext, plugin, runtime, this.imagePool);\n      }\n    }\n  }, {\n    key: \"clearShadowAndFilter\",\n    value: function clearShadowAndFilter(context, hasFilter, hasShadow) {\n      if (hasShadow) {\n        context.shadowColor = 'transparent';\n        context.shadowBlur = 0;\n      }\n      if (hasFilter) {\n        // save drop-shadow filter\n        var oldFilter = context.filter;\n        if (!isNil(oldFilter) && oldFilter.indexOf('drop-shadow') > -1) {\n          context.filter = oldFilter.replace(/drop-shadow\\([^)]*\\)/, '').trim() || 'none';\n        }\n      }\n    }\n  }]);\n}(OptimizedDefaultRenderer);\n\n/**\n * apply before fill and stroke but only once\n */\nfunction setShadowAndFilter(object, context, hasShadow) {\n  var _object$parsedStyle = object.parsedStyle,\n    filter = _object$parsedStyle.filter,\n    shadowColor = _object$parsedStyle.shadowColor,\n    shadowBlur = _object$parsedStyle.shadowBlur,\n    shadowOffsetX = _object$parsedStyle.shadowOffsetX,\n    shadowOffsetY = _object$parsedStyle.shadowOffsetY;\n  if (filter && filter.length) {\n    // use raw filter string\n    context.filter = object.style.filter;\n  }\n  if (hasShadow) {\n    context.shadowColor = shadowColor.toString();\n    context.shadowBlur = shadowBlur || 0;\n    context.shadowOffsetX = shadowOffsetX || 0;\n    context.shadowOffsetY = shadowOffsetY || 0;\n  }\n}\nfunction applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime, imagePool) {\n  var skipFill = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  if (Array.isArray(fill)) {\n    fill.forEach(function (gradient) {\n      context.fillStyle = getColor(gradient, object, context, imagePool);\n      if (!skipFill) {\n        fillRule ? context.fill(fillRule) : context.fill();\n      }\n    });\n  } else {\n    if (isPattern(fill)) {\n      context.fillStyle = getPattern(fill, object, context, canvasContext, plugin, runtime, imagePool);\n    }\n    if (!skipFill) {\n      fillRule ? context.fill(fillRule) : context.fill();\n    }\n  }\n}\nfunction applyStroke(context, object, stroke, canvasContext, plugin, runtime, imagePool) {\n  var skipStroke = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  if (Array.isArray(stroke)) {\n    stroke.forEach(function (gradient) {\n      context.strokeStyle = getColor(gradient, object, context, imagePool);\n      if (!skipStroke) {\n        context.stroke();\n      }\n    });\n  } else {\n    if (isPattern(stroke)) {\n      context.strokeStyle = getPattern(stroke, object, context, canvasContext, plugin, runtime, imagePool);\n    }\n    if (!skipStroke) {\n      context.stroke();\n    }\n  }\n}\nfunction calculateOverlapRect(rect1, rect2) {\n  var _rect = _slicedToArray(rect1, 4),\n    x1 = _rect[0],\n    y1 = _rect[1],\n    w1 = _rect[2],\n    h1 = _rect[3];\n  var _rect2 = _slicedToArray(rect2, 4),\n    x2 = _rect2[0],\n    y2 = _rect2[1],\n    w2 = _rect2[2],\n    h2 = _rect2[3];\n\n  // 计算重叠区域的左上角和右下角\n  var overlapLeft = Math.max(x1, x2);\n  var overlapTop = Math.max(y1, y2);\n  var overlapRight = Math.min(x1 + w1, x2 + w2);\n  var overlapBottom = Math.min(y1 + h1, y2 + h2);\n  if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) {\n    return null;\n  }\n  return [overlapLeft, overlapTop, overlapRight - overlapLeft, overlapBottom - overlapTop];\n}\nfunction transformRect(rect, matrix) {\n  var tl = vec3.transformMat4(vec3.create(), [rect[0], rect[1], 0], matrix);\n  var tr = vec3.transformMat4(vec3.create(), [rect[0] + rect[2], rect[1], 0], matrix);\n  var bl = vec3.transformMat4(vec3.create(), [rect[0], rect[1] + rect[3], 0], matrix);\n  var br = vec3.transformMat4(vec3.create(), [rect[0] + rect[2], rect[1] + rect[3], 0], matrix);\n  return [Math.min(tl[0], tr[0], bl[0], br[0]), Math.min(tl[1], tr[1], bl[1], br[1]), Math.max(tl[0], tr[0], bl[0], br[0]) - Math.min(tl[0], tr[0], bl[0], br[0]), Math.max(tl[1], tr[1], bl[1], br[1]) - Math.min(tl[1], tr[1], bl[1], br[1])];\n}\nvar ImageRenderer = /*#__PURE__*/function (_DefaultRenderer) {\n  function ImageRenderer() {\n    _classCallCheck(this, ImageRenderer);\n    return _callSuper(this, ImageRenderer, arguments);\n  }\n  _inherits(ImageRenderer, _DefaultRenderer);\n  return _createClass(ImageRenderer, [{\n    key: \"renderDownSampled\",\n    value: function renderDownSampled(context, parsedStyle, object, data) {\n      var src = data.src,\n        imageCache = data.imageCache;\n      if (!imageCache.downSampled) {\n        this.imagePool.createDownSampledImage(src, object).then(function () {\n          // be removed from dom tree\n          if (!object.ownerDocument) {\n            return;\n          }\n\n          // rerender\n          object.dirty();\n          object.ownerDocument.defaultView.context.renderingService.dirtify();\n        })[\"catch\"](function (reason) {\n          console.error(reason);\n        });\n        return;\n      }\n      context.drawImage(imageCache.downSampled, Math.floor(data.drawRect[0]), Math.floor(data.drawRect[1]), Math.ceil(data.drawRect[2]), Math.ceil(data.drawRect[3]));\n    }\n  }, {\n    key: \"renderTile\",\n    value: function renderTile(context, parsedStyle, object, data) {\n      var src = data.src,\n        imageCache = data.imageCache,\n        imageRect = data.imageRect,\n        drawRect = data.drawRect;\n      var originalSize = imageCache.size;\n      var _context$getTransform = context.getTransform(),\n        a = _context$getTransform.a,\n        b = _context$getTransform.b,\n        c = _context$getTransform.c,\n        d = _context$getTransform.d,\n        e = _context$getTransform.e,\n        f = _context$getTransform.f;\n      context.resetTransform();\n      if (!(imageCache !== null && imageCache !== void 0 && imageCache.gridSize)) {\n        this.imagePool.createImageTiles(src, [], function () {\n          // be removed from dom tree\n          if (!object.ownerDocument) {\n            return;\n          }\n\n          // rerender\n          object.dirty();\n          object.ownerDocument.defaultView.context.renderingService.dirtify();\n        }, object)[\"catch\"](function (reason) {\n          console.error(reason);\n        });\n        return;\n      }\n      var scaleToOrigin = [originalSize[0] / imageRect[2], originalSize[1] / imageRect[3]];\n      var scaledTileSize = [imageCache.tileSize[0] / scaleToOrigin[0], imageCache.tileSize[1] / scaleToOrigin[1]];\n      var _ref = [Math.floor((drawRect[0] - imageRect[0]) / scaledTileSize[0]), Math.ceil((drawRect[0] + drawRect[2] - imageRect[0]) / scaledTileSize[0])],\n        startTileX = _ref[0],\n        endTileX = _ref[1];\n      var _ref2 = [Math.floor((drawRect[1] - imageRect[1]) / scaledTileSize[1]), Math.ceil((drawRect[1] + drawRect[3] - imageRect[1]) / scaledTileSize[1])],\n        startTileY = _ref2[0],\n        endTileY = _ref2[1];\n      for (var tileY = startTileY; tileY <= endTileY; tileY++) {\n        for (var tileX = startTileX; tileX <= endTileX; tileX++) {\n          var item = imageCache.tiles[tileY][tileX];\n          if (item) {\n            var tileRect = [Math.floor(imageRect[0] + item.tileX * scaledTileSize[0]), Math.floor(imageRect[1] + item.tileY * scaledTileSize[1]), Math.ceil(scaledTileSize[0]), Math.ceil(scaledTileSize[1])];\n            context.drawImage(item.data, tileRect[0], tileRect[1], tileRect[2], tileRect[3]);\n          }\n        }\n      }\n      context.setTransform(a, b, c, d, e, f);\n    }\n  }, {\n    key: \"render\",\n    value: function render(context, parsedStyle, object) {\n      var _parsedStyle$x = parsedStyle.x,\n        x = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x,\n        _parsedStyle$y = parsedStyle.y,\n        y = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y,\n        width = parsedStyle.width,\n        height = parsedStyle.height,\n        src = parsedStyle.src,\n        shadowColor = parsedStyle.shadowColor,\n        shadowBlur = parsedStyle.shadowBlur;\n      var imageCache = this.imagePool.getImageSync(src, object);\n      var image = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;\n      var iw = width;\n      var ih = height;\n      if (!image) {\n        return;\n      }\n      iw || (iw = image.width);\n      ih || (ih = image.height);\n      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;\n      setShadowAndFilter(object, context, hasShadow);\n\n      // node-canvas will throw the following err:\n      // Error: Image given has not completed loading\n      try {\n        var _object$ownerDocument = object.ownerDocument.defaultView.getContextService().getDomElement(),\n          viewWidth = _object$ownerDocument.width,\n          viewHeight = _object$ownerDocument.height;\n        var currentTransform = context.getTransform();\n        var a = currentTransform.a,\n          b = currentTransform.b,\n          c = currentTransform.c,\n          d = currentTransform.d,\n          e = currentTransform.e,\n          f = currentTransform.f;\n        // 构建 mat4 矩阵\n        // prettier-ignore\n        var transformMatrix = mat4.fromValues(a, c, 0, 0, b, d, 0, 0, 0, 0, 1, 0, e, f, 0, 1);\n        var imageRect = transformRect([x, y, iw, ih], transformMatrix);\n        var drawRect = calculateOverlapRect([0, 0, viewWidth, viewHeight], imageRect);\n        if (!drawRect) {\n          return;\n        }\n        if (!object.ownerDocument.defaultView.getConfig().enableLargeImageOptimization) {\n          ImageRenderer.renderFull(context, parsedStyle, object, {\n            image: image,\n            drawRect: [x, y, iw, ih]\n          });\n          return;\n        }\n        var sizeOfOrigin = imageRect[2] / imageCache.size[0];\n        if (sizeOfOrigin < (imageCache.downSamplingRate || 0.5)) {\n          this.renderDownSampled(context, parsedStyle, object, {\n            src: src,\n            imageCache: imageCache,\n            drawRect: [x, y, iw, ih]\n          });\n          return;\n        }\n        if (!ImagePool.isSupportTile) {\n          ImageRenderer.renderFull(context, parsedStyle, object, {\n            image: image,\n            drawRect: [x, y, iw, ih]\n          });\n          return;\n        }\n        this.renderTile(context, parsedStyle, object, {\n          src: src,\n          imageCache: imageCache,\n          imageRect: imageRect,\n          drawRect: drawRect\n        });\n      } catch (_unused) {\n        // expected error\n      }\n    }\n\n    // ---\n  }, {\n    key: \"drawToContext\",\n    value: function drawToContext(context, object, renderState, plugin, runtime) {\n      this.render(context, object.parsedStyle, object);\n    }\n  }], [{\n    key: \"renderFull\",\n    value: function renderFull(context, parsedStyle, object, data) {\n      context.drawImage(data.image, Math.floor(data.drawRect[0]), Math.floor(data.drawRect[1]), Math.ceil(data.drawRect[2]), Math.ceil(data.drawRect[3]));\n    }\n  }]);\n}(DefaultRenderer);\nvar TextRenderer = /*#__PURE__*/function (_DefaultRenderer) {\n  function TextRenderer() {\n    _classCallCheck(this, TextRenderer);\n    return _callSuper(this, TextRenderer, arguments);\n  }\n  _inherits(TextRenderer, _DefaultRenderer);\n  return _createClass(TextRenderer, [{\n    key: \"render\",\n    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime) {\n      // Trigger text geometry calculation.\n      object.getBounds();\n      var _parsedStyle$lineWidt = parsedStyle.lineWidth,\n        lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt,\n        _parsedStyle$textAlig = parsedStyle.textAlign,\n        textAlign = _parsedStyle$textAlig === void 0 ? 'start' : _parsedStyle$textAlig,\n        _parsedStyle$textBase = parsedStyle.textBaseline,\n        textBaseline = _parsedStyle$textBase === void 0 ? 'alphabetic' : _parsedStyle$textBase,\n        _parsedStyle$lineJoin = parsedStyle.lineJoin,\n        lineJoin = _parsedStyle$lineJoin === void 0 ? 'miter' : _parsedStyle$lineJoin,\n        _parsedStyle$miterLim = parsedStyle.miterLimit,\n        miterLimit = _parsedStyle$miterLim === void 0 ? 10 : _parsedStyle$miterLim,\n        _parsedStyle$letterSp = parsedStyle.letterSpacing,\n        letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp,\n        stroke = parsedStyle.stroke,\n        fill = parsedStyle.fill,\n        fillRule = parsedStyle.fillRule,\n        _parsedStyle$fillOpac = parsedStyle.fillOpacity,\n        fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac,\n        _parsedStyle$strokeOp = parsedStyle.strokeOpacity,\n        strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp,\n        _parsedStyle$opacity = parsedStyle.opacity,\n        opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity,\n        metrics = parsedStyle.metrics,\n        _parsedStyle$x = parsedStyle.x,\n        x = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x,\n        _parsedStyle$y = parsedStyle.y,\n        y = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y,\n        dx = parsedStyle.dx,\n        dy = parsedStyle.dy,\n        shadowColor = parsedStyle.shadowColor,\n        shadowBlur = parsedStyle.shadowBlur;\n      var font = metrics.font,\n        lines = metrics.lines,\n        height = metrics.height,\n        lineHeight = metrics.lineHeight,\n        lineMetrics = metrics.lineMetrics;\n      context.font = font;\n      context.lineWidth = lineWidth;\n      context.textAlign = textAlign === 'middle' ? 'center' : textAlign;\n      var formattedTextBaseline = textBaseline;\n      if (formattedTextBaseline === 'alphabetic') {\n        formattedTextBaseline = 'bottom';\n      }\n      context.lineJoin = lineJoin;\n      if (!isNil(miterLimit)) {\n        context.miterLimit = miterLimit;\n      }\n      var linePositionY = y;\n      // handle vertical text baseline\n      if (textBaseline === 'middle') {\n        linePositionY += -height / 2 - lineHeight / 2;\n      } else if (textBaseline === 'bottom' || textBaseline === 'alphabetic' || textBaseline === 'ideographic') {\n        linePositionY += -height;\n      } else if (textBaseline === 'top' || textBaseline === 'hanging') {\n        linePositionY += -lineHeight;\n      }\n\n      // account for dx & dy\n      var offsetX = x + (dx || 0);\n      linePositionY += dy || 0;\n      if (lines.length === 1) {\n        if (formattedTextBaseline === 'bottom') {\n          formattedTextBaseline = 'middle';\n          linePositionY -= 0.5 * height;\n        } else if (formattedTextBaseline === 'top') {\n          formattedTextBaseline = 'middle';\n          linePositionY += 0.5 * height;\n        }\n      }\n      context.textBaseline = formattedTextBaseline;\n      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;\n      setShadowAndFilter(object, context, hasShadow);\n\n      // draw lines line by line\n      for (var i = 0; i < lines.length; i++) {\n        var linePositionX = lineWidth / 2 + offsetX;\n        linePositionY += lineHeight;\n\n        // no need to re-position X, cause we already set text align\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign\n        if (!isNil(stroke) && !stroke.isNone && lineWidth) {\n          this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, true, canvasContext, plugin, runtime);\n        }\n        if (!isNil(fill)) {\n          this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, false, canvasContext, plugin, runtime);\n        }\n      }\n    }\n  }, {\n    key: \"drawLetterSpacing\",\n    value: function drawLetterSpacing(context, object, text, lineMetrics, textAlign, x, y, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, isStroke, canvasContext, plugin, runtime) {\n      // letterSpacing of 0 means normal, render all texts directly\n      if (letterSpacing === 0) {\n        if (isStroke) {\n          this.strokeText(context, object, text, x, y, stroke, strokeOpacity, canvasContext, plugin, runtime);\n        } else {\n          this.fillText(context, object, text, x, y, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime);\n        }\n        return;\n      }\n\n      // draw text using left align\n      var currentTextAlign = context.textAlign;\n      context.textAlign = 'left';\n      var currentPosition = x;\n      if (textAlign === 'center' || textAlign === 'middle') {\n        currentPosition = x - lineMetrics.width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        currentPosition = x - lineMetrics.width;\n      }\n      var stringArray = Array.from(text);\n      var previousWidth = context.measureText(text).width;\n      var currentWidth = 0;\n      for (var i = 0; i < stringArray.length; ++i) {\n        var currentChar = stringArray[i];\n        if (isStroke) {\n          this.strokeText(context, object, currentChar, currentPosition, y, stroke, strokeOpacity, canvasContext, plugin, runtime);\n        } else {\n          this.fillText(context, object, currentChar, currentPosition, y, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime);\n        }\n        currentWidth = context.measureText(text.substring(i + 1)).width;\n        currentPosition += previousWidth - currentWidth + letterSpacing;\n        previousWidth = currentWidth;\n      }\n      context.textAlign = currentTextAlign;\n    }\n  }, {\n    key: \"fillText\",\n    value: function fillText(context, object, text, x, y, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime) {\n      applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime, this.imagePool, true);\n      var currentGlobalAlpha;\n      var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;\n      if (applyOpacity) {\n        currentGlobalAlpha = context.globalAlpha;\n        context.globalAlpha = fillOpacity * opacity;\n      }\n      context.fillText(text, x, y);\n      if (applyOpacity) {\n        context.globalAlpha = currentGlobalAlpha;\n      }\n    }\n  }, {\n    key: \"strokeText\",\n    value: function strokeText(context, object, text, x, y, stroke, strokeOpacity, canvasContext, plugin, runtime) {\n      applyStroke(context, object, stroke, canvasContext, plugin, runtime, this.imagePool, true);\n      var currentGlobalAlpha;\n      var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;\n      if (applyOpacity) {\n        currentGlobalAlpha = context.globalAlpha;\n        context.globalAlpha = strokeOpacity;\n      }\n      context.strokeText(text, x, y);\n      if (applyOpacity) {\n        context.globalAlpha = currentGlobalAlpha;\n      }\n    }\n\n    // ---\n  }, {\n    key: \"drawToContext\",\n    value: function drawToContext(context, object, renderState, plugin, runtime) {\n      this.render(context, object.parsedStyle, object, object.ownerDocument.defaultView.context, plugin, runtime);\n    }\n  }]);\n}(DefaultRenderer);\nvar Plugin = /*#__PURE__*/function (_AbstractRendererPlug) {\n  function Plugin() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Plugin);\n    _this = _callSuper(this, Plugin);\n    _this.name = 'canvas-renderer';\n    _this.options = options;\n    return _this;\n  }\n  _inherits(Plugin, _AbstractRendererPlug);\n  return _createClass(Plugin, [{\n    key: \"init\",\n    value: function init() {\n      var _defaultStyleRenderer;\n      var canvasRendererPluginOptions = _objectSpread({\n        dirtyObjectNumThreshold: 500,\n        dirtyObjectRatioThreshold: 0.8\n      }, this.options);\n\n      // @ts-ignore\n      var imagePool = this.context.imagePool;\n      var defaultRenderer = new DefaultRenderer(imagePool);\n      var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.CIRCLE, defaultRenderer), Shape.ELLIPSE, defaultRenderer), Shape.RECT, defaultRenderer), Shape.IMAGE, new ImageRenderer(imagePool)), Shape.TEXT, new TextRenderer(imagePool)), Shape.LINE, defaultRenderer), Shape.POLYLINE, defaultRenderer), Shape.POLYGON, defaultRenderer), Shape.PATH, defaultRenderer), Shape.GROUP, undefined), _defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.HTML, undefined), Shape.MESH, undefined), Shape.FRAGMENT, undefined));\n      this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;\n      this.context.styleRendererFactory = defaultStyleRendererFactory;\n      this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.removeAllRenderingPlugins();\n      delete this.context.defaultStyleRendererFactory;\n      delete this.context.styleRendererFactory;\n    }\n  }]);\n}(AbstractRendererPlugin);\nexport { DefaultRenderer as CircleRenderer, DefaultRenderer, DefaultRenderer as EllipseRenderer, ImageRenderer, DefaultRenderer as LineRenderer, DefaultRenderer as PathRenderer, Plugin, DefaultRenderer as PolygonRenderer, DefaultRenderer as PolylineRenderer, DefaultRenderer as RectRenderer, TextRenderer };","map":{"version":3,"names":["_renderState","_classPrivateFieldLooseKey","CanvasRendererPlugin","canvasRendererPluginOptions","_classCallCheck","removedRBushNodeAABBs","renderQueue","Object","defineProperty","writable","value","restoreStack","prevObject","currentContext","Map","clearFullScreenLastFrame","clearFullScreen","vpMatrix","mat4","create","dprMatrix","tmpMat4","vec3a","vec3","vec3b","vec3c","vec3d","_createClass","key","apply","context","runtime","_this","_this$context","config","camera","renderingService","renderingContext","rBushRoot","pathGeneratorFactory","enableRenderingOptimization","renderer","getConfig","enableDirtyCheck","enableDirtyRectangleRendering","rBush","contextService","canvas","root","ownerDocument","defaultView","handleUnmounted","e","object","target","rBushNode","aabb","push","handleCulled","hooks","init","tap","tag","addEventListener","ElementEvent","UNMOUNTED","CULLED","dpr","getDPR","width","height","getContext","clearRect","background","destroy","removeEventListener","_classPrivateFieldLooseBase","beforeDraw","_canvas$context$rende","_this$canvasRendererP","dirtyObjectNumThreshold","dirtyObjectRatioThreshold","_renderingService$get","getStats","total","rendered","ratio","renderingPlugins","isFirstTimeRenderingFinished","disableDirtyRectangleRendering","resetTransform","setTransform","renderByZIndex","stack","length","_currentObject$sortab","currentObject","pop","isVisible","isCulled","renderDisplayObjectOptimized","renderDisplayObject","objects","sortable","sorted","childNodes","i","endFrame","clear","fromScaling","multiply","getOrthoMatrix","save","restore","dirtyRenderBounds","safeMergeAABB","mergeDirtyAABBs","concat","_toConsumableArray","map","_ref","minX","minY","maxX","maxY","AABB","setMinMax","isEmpty","dirtyRect","convertAABB2Rect","x","y","tl","transformMat4","tr","bl","br","minx","Math","min","miny","maxx","max","maxy","ix","floor","iy","iwidth","ceil","iheight","beginPath","rect","clip","_config$renderer$getC","enableDirtyRectangleRenderingDebug","dispatchEvent","CustomEvent","CanvasEvent","DIRTY_RECTANGLE","dirtyObjects","searchDirtyObjects","sort","a","b","renderOrder","forEach","saveDirtyAABB","render","fillStyle","fillRect","canvasContext","renderState","nodeName","updateTransform","clipDraw","styleRenderer","styleRendererFactory","generatePath","clipPath","parsedStyle","exactEquals","getWorldTransform","applyWorldTransform","_generatePath","closePath","forceUpdateStyle","prevNodeName","Shape","TEXT","IMAGE","applyStyleToContext","LINE","PATH","POLYLINE","drawToContext","dirty","parent","compareDocumentPosition","Node","DOCUMENT_POSITION_CONTAINS","_generatePath2","applyAttributesToContext","_ref2","stroke","fill","opacity","lineDash","lineDashOffset","setLineDash","isNil","globalAlpha","Array","isArray","isNone","strokeStyle","attributes","getMin","getMax","renderBounds","getRenderBounds","add","renderable","dirtyRectangle","_dirtyRectangle$getMi","_dirtyRectangle$getMi2","_slicedToArray","_dirtyRectangle$getMa","_dirtyRectangle$getMa2","rBushNodes","search","_ref3","displayObject","update","center","halfExtents","matrix","copy","getLocalTransform","merged","_len","arguments","aabbs","_key","getPattern","pattern","plugin","imagePool","$offscreenCanvas","image","_parsedStyle","offscreenCanvas","offscreenCanvasCreator","getOrCreateCanvas","offscreenCanvasContext","getOrCreateContext","canvasPattern","getOrCreatePatternSync","getGeometryBounds","dirtify","getColor","parsedColor","color","type","GradientType","LinearGradient","RadialGradient","bounds","getOrCreateGradient","_objectSpread","SHADOW_NUMBER_STYLE","STROKE_STYLE","DEFAULT_STYLE","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","filter","globalCompositeOperation","strokeOpacity","lineWidth","lineCap","lineJoin","miterLimit","fillOpacity","defaultParsedStyle","updateContextIfNotHitCache","cache","prevValue","has","get","set","OptimizedDefaultRenderer","applyCommonStyleToContext","forceUpdate","prevStyle","style","blend","applyStrokeFillStyleToContext","_style$lineWidth","hasFill","hasStroke","styleName","_value","applyShadowAndFilterStyleToContext","hasShadow","toString","clearShadowAndFilterStyleForContext","hasFilter","onlyClearShadowFilter","undefined","oldFilter","indexOf","replace","trim","fillToContext","_object$parsedStyle","fillRule","resetStyle","gradient","isPattern","strokeToContext","_this2","_style$fill","_style$opacity","_style$fillOpacity","_style$strokeOpacity","_style$lineWidth2","isInnerShadow","shadowType","isFillTransparent","alpha","shouldDrawShadowWithStroke","originGlobalAlpha","updateOpacity","clearShadowAndFilter","_updateOpacity","prevOpacity","originBlend","DefaultRenderer","_OptimizedDefaultRend","_callSuper","_inherits","_parsedStyle$opacity","_parsedStyle$fillOpac","_parsedStyle$strokeOp","_parsedStyle$lineWidt","setShadowAndFilter","applyFill","applyStroke","skipFill","skipStroke","calculateOverlapRect","rect1","rect2","_rect","x1","y1","w1","h1","_rect2","x2","y2","w2","h2","overlapLeft","overlapTop","overlapRight","overlapBottom","transformRect","ImageRenderer","_DefaultRenderer","renderDownSampled","data","src","imageCache","downSampled","createDownSampledImage","then","reason","console","error","drawImage","drawRect","renderTile","imageRect","originalSize","size","_context$getTransform","getTransform","c","d","f","gridSize","createImageTiles","scaleToOrigin","scaledTileSize","tileSize","startTileX","endTileX","startTileY","endTileY","tileY","tileX","item","tiles","tileRect","_parsedStyle$x","_parsedStyle$y","getImageSync","img","iw","ih","_object$ownerDocument","getContextService","getDomElement","viewWidth","viewHeight","currentTransform","transformMatrix","fromValues","enableLargeImageOptimization","renderFull","sizeOfOrigin","downSamplingRate","ImagePool","isSupportTile","_unused","TextRenderer","getBounds","_parsedStyle$textAlig","textAlign","_parsedStyle$textBase","textBaseline","_parsedStyle$lineJoin","_parsedStyle$miterLim","_parsedStyle$letterSp","letterSpacing","metrics","dx","dy","font","lines","lineHeight","lineMetrics","formattedTextBaseline","linePositionY","offsetX","linePositionX","drawLetterSpacing","text","isStroke","strokeText","fillText","currentTextAlign","currentPosition","stringArray","from","previousWidth","measureText","currentWidth","currentChar","substring","currentGlobalAlpha","applyOpacity","Plugin","_AbstractRendererPlug","options","name","_defaultStyleRenderer","defaultRenderer","defaultStyleRendererFactory","_defineProperty","CIRCLE","ELLIPSE","RECT","POLYGON","GROUP","HTML","MESH","FRAGMENT","addRenderingPlugin","removeAllRenderingPlugins","AbstractRendererPlugin"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-renderer/src/CanvasRendererPlugin.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-renderer/src/shapes/styles/helper.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-renderer/src/shapes/styles/OptimizedDefault.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-renderer/src/shapes/styles/Default.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-renderer/src/utils/math.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-renderer/src/shapes/styles/Image.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-renderer/src/shapes/styles/Text.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-renderer/src/index.ts"],"sourcesContent":["import type {\n  DisplayObject,\n  FederatedEvent,\n  RBushNodeAABB,\n  RenderingPlugin,\n  RBush,\n  RenderingPluginContext,\n  ContextService,\n  CanvasContext,\n  GlobalRuntime,\n  ParsedBaseStyleProps,\n  CSSRGB,\n} from '@antv/g-lite';\nimport {\n  AABB,\n  CanvasEvent,\n  CustomEvent,\n  ElementEvent,\n  Shape,\n  Node,\n} from '@antv/g-lite';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { isNil } from '@antv/util';\nimport type { CanvasRendererPluginOptions } from './interfaces';\nimport type { Plugin } from '.';\n\ninterface Rect {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface RenderState {\n  restoreStack: DisplayObject[];\n  prevObject: DisplayObject;\n  currentContext: Map<keyof CanvasRenderingContext2D | 'lineDash', unknown>;\n}\n\n/**\n * support 2 modes in rendering:\n * * immediate\n * * delayed: render at the end of frame with dirty-rectangle\n */\nexport class CanvasRendererPlugin implements RenderingPlugin {\n  static tag = 'CanvasRenderer';\n\n  private context: Plugin['context'];\n\n  private pathGeneratorFactory: Plugin['context']['pathGeneratorFactory'];\n\n  /**\n   * RBush used in dirty rectangle rendering\n   */\n  private rBush: RBush<RBushNodeAABB>;\n\n  constructor(\n    private canvasRendererPluginOptions: CanvasRendererPluginOptions, // private styleRendererFactory: Record<Shape, StyleRenderer>,\n  ) {}\n\n  private removedRBushNodeAABBs: RBushNodeAABB[] = [];\n\n  private renderQueue: DisplayObject[] = [];\n\n  #renderState: RenderState = {\n    restoreStack: [],\n    prevObject: null,\n    currentContext: new Map(),\n  };\n\n  private clearFullScreenLastFrame = false;\n  private clearFullScreen = false;\n\n  /**\n   * view projection matrix\n   */\n  private vpMatrix = mat4.create();\n  private dprMatrix = mat4.create();\n  private tmpMat4 = mat4.create();\n  private vec3a = vec3.create();\n  private vec3b = vec3.create();\n  private vec3c = vec3.create();\n  private vec3d = vec3.create();\n\n  apply(context: RenderingPluginContext, runtime: GlobalRuntime) {\n    this.context = context as unknown as Plugin['context'];\n\n    const {\n      config,\n      camera,\n      renderingService,\n      renderingContext,\n      rBushRoot,\n      // @ts-ignore\n      pathGeneratorFactory,\n    } = this.context;\n    let enableRenderingOptimization =\n      config.renderer.getConfig().enableRenderingOptimization;\n\n    config.renderer.getConfig().enableDirtyCheck = false;\n    config.renderer.getConfig().enableDirtyRectangleRendering = false;\n\n    this.rBush = rBushRoot;\n    this.pathGeneratorFactory = pathGeneratorFactory;\n\n    const contextService =\n      context.contextService as ContextService<CanvasRenderingContext2D>;\n\n    const canvas = renderingContext.root.ownerDocument.defaultView;\n\n    const handleUnmounted = (e: FederatedEvent) => {\n      const object = e.target as DisplayObject;\n\n      // remove r-bush node\n      // @ts-ignore\n      const { rBushNode } = object;\n\n      if (rBushNode?.aabb) {\n        // save removed aabbs for dirty-rectangle rendering later\n        this.removedRBushNodeAABBs.push(rBushNode.aabb);\n      }\n    };\n\n    const handleCulled = (e: FederatedEvent) => {\n      const object = e.target as DisplayObject;\n      // @ts-ignore\n      const { rBushNode } = object;\n\n      if (rBushNode.aabb) {\n        // save removed aabbs for dirty-rectangle rendering later\n        this.removedRBushNodeAABBs.push(rBushNode.aabb);\n      }\n    };\n\n    renderingService.hooks.init.tap(CanvasRendererPlugin.tag, () => {\n      canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);\n      canvas.addEventListener(ElementEvent.CULLED, handleCulled);\n\n      // clear fullscreen\n      const dpr = contextService.getDPR();\n      const { width, height } = config;\n      const context = contextService.getContext();\n      this.clearRect(\n        context,\n        0,\n        0,\n        width * dpr,\n        height * dpr,\n        config.background,\n      );\n    });\n\n    renderingService.hooks.destroy.tap(CanvasRendererPlugin.tag, () => {\n      canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);\n      canvas.removeEventListener(ElementEvent.CULLED, handleCulled);\n      this.renderQueue = [];\n      this.removedRBushNodeAABBs = [];\n      this.#renderState = {\n        restoreStack: [],\n        prevObject: null,\n        currentContext: null,\n      };\n    });\n\n    const beforeDraw = () => {\n      const context = contextService.getContext();\n      const dpr = contextService.getDPR();\n      const { width, height } = config;\n      const { dirtyObjectNumThreshold, dirtyObjectRatioThreshold } =\n        this.canvasRendererPluginOptions;\n\n      // some heuristic conditions such as 80% object changed\n      const { total, rendered } = renderingService.getStats();\n      const ratio = rendered / total;\n\n      this.clearFullScreen =\n        this.clearFullScreenLastFrame ||\n        // @ts-ignore\n        !canvas.context.renderingPlugins[1]?.isFirstTimeRenderingFinished ||\n        renderingService.disableDirtyRectangleRendering() ||\n        (rendered > dirtyObjectNumThreshold &&\n          ratio > dirtyObjectRatioThreshold);\n\n      if (!context) {\n        return;\n      }\n\n      if (typeof context.resetTransform === 'function') {\n        context.resetTransform();\n      } else {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n      }\n\n      if (this.clearFullScreen) {\n        this.clearRect(\n          context,\n          0,\n          0,\n          width * dpr,\n          height * dpr,\n          config.background,\n        );\n      }\n    };\n\n    /**\n     * render objects by z-index\n     *\n     * - The level of the child node will be affected by the level of the parent node\n     */\n    const renderByZIndex = (\n      object: DisplayObject,\n      context: CanvasRenderingContext2D,\n    ) => {\n      const stack = [object];\n\n      while (stack.length > 0) {\n        const currentObject = stack.pop();\n\n        if (currentObject.isVisible() && !currentObject.isCulled()) {\n          if (enableRenderingOptimization) {\n            this.renderDisplayObjectOptimized(\n              currentObject,\n              context,\n              this.context,\n              this.#renderState,\n              runtime,\n            );\n          } else {\n            this.renderDisplayObject(\n              currentObject,\n              context,\n              this.context,\n              this.#renderState,\n              runtime,\n            );\n          }\n        }\n\n        const objects =\n          currentObject.sortable?.sorted?.length > 0\n            ? currentObject.sortable.sorted\n            : currentObject.childNodes;\n        // should account for z-index\n        for (let i = objects.length - 1; i >= 0; i--) {\n          stack.push(objects[i] as unknown as DisplayObject);\n        }\n      }\n    };\n\n    // render at the end of frame\n    renderingService.hooks.endFrame.tap(CanvasRendererPlugin.tag, () => {\n      beforeDraw();\n\n      // Skip rendering.\n      if (renderingContext.root.childNodes.length === 0) {\n        this.clearFullScreenLastFrame = true;\n        return;\n      }\n\n      enableRenderingOptimization =\n        config.renderer.getConfig().enableRenderingOptimization;\n\n      // init\n      this.#renderState = {\n        restoreStack: [],\n        prevObject: null,\n        currentContext: this.#renderState.currentContext,\n      };\n      this.#renderState.currentContext.clear();\n      this.clearFullScreenLastFrame = false;\n\n      const context = contextService.getContext();\n      // clear & clip dirty rectangle\n      const dpr = contextService.getDPR();\n      mat4.fromScaling(this.dprMatrix, [dpr, dpr, 1]);\n      mat4.multiply(this.vpMatrix, this.dprMatrix, camera.getOrthoMatrix());\n\n      if (this.clearFullScreen) {\n        // console.time('renderByZIndex');\n        if (enableRenderingOptimization) {\n          context.save();\n          renderByZIndex(renderingContext.root, context);\n          context.restore();\n        } else {\n          renderByZIndex(renderingContext.root, context);\n        }\n        // console.timeEnd('renderByZIndex');\n\n        this.removedRBushNodeAABBs = [];\n      } else {\n        // console.log('canvas renderer next...', this.renderQueue);\n        // merge removed AABB\n        const dirtyRenderBounds = this.safeMergeAABB(\n          this.mergeDirtyAABBs(this.renderQueue),\n          ...this.removedRBushNodeAABBs.map(({ minX, minY, maxX, maxY }) => {\n            const aabb = new AABB();\n            aabb.setMinMax(\n              // vec3.fromValues(minX, minY, 0),\n              // vec3.fromValues(maxX, maxY, 0),\n              [minX, minY, 0],\n              [maxX, maxY, 0],\n            );\n            return aabb;\n          }),\n        );\n        this.removedRBushNodeAABBs = [];\n\n        if (AABB.isEmpty(dirtyRenderBounds)) {\n          this.renderQueue = [];\n          return;\n        }\n\n        const dirtyRect = this.convertAABB2Rect(dirtyRenderBounds);\n        const { x, y, width, height } = dirtyRect;\n\n        const tl = vec3.transformMat4(this.vec3a, [x, y, 0], this.vpMatrix);\n        const tr = vec3.transformMat4(\n          this.vec3b,\n          [x + width, y, 0],\n          this.vpMatrix,\n        );\n        const bl = vec3.transformMat4(\n          this.vec3c,\n          [x, y + height, 0],\n          this.vpMatrix,\n        );\n        const br = vec3.transformMat4(\n          this.vec3d,\n          [x + width, y + height, 0],\n          this.vpMatrix,\n        );\n\n        const minx = Math.min(tl[0], tr[0], br[0], bl[0]);\n        const miny = Math.min(tl[1], tr[1], br[1], bl[1]);\n        const maxx = Math.max(tl[0], tr[0], br[0], bl[0]);\n        const maxy = Math.max(tl[1], tr[1], br[1], bl[1]);\n\n        const ix = Math.floor(minx);\n        const iy = Math.floor(miny);\n        const iwidth = Math.ceil(maxx - minx);\n        const iheight = Math.ceil(maxy - miny);\n\n        context.save();\n        this.clearRect(context, ix, iy, iwidth, iheight, config.background);\n        context.beginPath();\n        context.rect(ix, iy, iwidth, iheight);\n        context.clip();\n\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations\n        context.setTransform(\n          this.vpMatrix[0],\n          this.vpMatrix[1],\n          this.vpMatrix[4],\n          this.vpMatrix[5],\n          this.vpMatrix[12],\n          this.vpMatrix[13],\n        );\n\n        // draw dirty rectangle\n        const { enableDirtyRectangleRenderingDebug } =\n          config.renderer.getConfig();\n        if (enableDirtyRectangleRenderingDebug) {\n          canvas.dispatchEvent(\n            new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {\n              dirtyRect: {\n                x: ix,\n                y: iy,\n                width: iwidth,\n                height: iheight,\n              },\n            }),\n          );\n        }\n\n        // search objects intersect with dirty rectangle\n        const dirtyObjects = this.searchDirtyObjects(dirtyRenderBounds);\n\n        // do rendering\n        dirtyObjects\n          // sort by z-index\n          .sort((a, b) => a.sortable.renderOrder - b.sortable.renderOrder)\n          .forEach((object) => {\n            // culled object should not be rendered\n            if (object && object.isVisible() && !object.isCulled()) {\n              this.renderDisplayObject(\n                object,\n                context,\n                this.context,\n                this.#renderState,\n                runtime,\n              );\n            }\n          });\n\n        context.restore();\n\n        // save dirty AABBs in last frame\n        this.renderQueue.forEach((object) => {\n          this.saveDirtyAABB(object);\n        });\n\n        // clear queue\n        this.renderQueue = [];\n      }\n\n      // pop restore stack, eg. root -> parent -> child\n      this.#renderState.restoreStack.forEach(() => {\n        context.restore();\n      });\n      // clear restore stack\n      this.#renderState.restoreStack = [];\n    });\n\n    renderingService.hooks.render.tap(\n      CanvasRendererPlugin.tag,\n      (object: DisplayObject) => {\n        if (!this.clearFullScreen) {\n          // render at the end of frame\n          this.renderQueue.push(object);\n        }\n      },\n    );\n  }\n\n  private clearRect(\n    context: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    background: string,\n  ) {\n    // clearRect is faster than fillRect @see https://stackoverflow.com/a/30830253\n    context.clearRect(x, y, width, height);\n    if (background) {\n      context.fillStyle = background;\n      context.fillRect(x, y, width, height);\n    }\n  }\n\n  renderDisplayObjectOptimized(\n    object: DisplayObject,\n    context: CanvasRenderingContext2D,\n    canvasContext: CanvasContext,\n    renderState: RenderState,\n    runtime: GlobalRuntime,\n  ) {\n    const nodeName = object.nodeName as Shape;\n    let updateTransform = false;\n    let clipDraw = false;\n\n    // @ts-ignore\n    const styleRenderer = this.context.styleRendererFactory[nodeName];\n    const generatePath = this.pathGeneratorFactory[nodeName];\n\n    // clip path\n    const { clipPath } = object.parsedStyle;\n    if (clipPath) {\n      updateTransform =\n        !renderState.prevObject ||\n        !mat4.exactEquals(\n          clipPath.getWorldTransform(),\n          renderState.prevObject.getWorldTransform(),\n        );\n\n      if (updateTransform) {\n        this.applyWorldTransform(context, clipPath);\n        renderState.prevObject = null;\n      }\n\n      // generate path in local space\n      const generatePath =\n        this.pathGeneratorFactory[clipPath.nodeName as Shape];\n      if (generatePath) {\n        context.save();\n        clipDraw = true;\n\n        context.beginPath();\n        generatePath(context, clipPath.parsedStyle);\n        context.closePath();\n        context.clip();\n      }\n    }\n\n    // fill & stroke\n\n    if (styleRenderer) {\n      updateTransform =\n        !renderState.prevObject ||\n        !mat4.exactEquals(\n          object.getWorldTransform(),\n          renderState.prevObject.getWorldTransform(),\n        );\n\n      if (updateTransform) {\n        this.applyWorldTransform(context, object);\n      }\n\n      let forceUpdateStyle = !renderState.prevObject;\n      if (!forceUpdateStyle) {\n        const prevNodeName = renderState.prevObject.nodeName as Shape;\n\n        if (nodeName === Shape.TEXT) {\n          forceUpdateStyle = prevNodeName !== Shape.TEXT;\n        } else if (nodeName === Shape.IMAGE) {\n          forceUpdateStyle = prevNodeName !== Shape.IMAGE;\n        } else {\n          forceUpdateStyle =\n            prevNodeName === Shape.TEXT || prevNodeName === Shape.IMAGE;\n        }\n      }\n\n      styleRenderer.applyStyleToContext(\n        context,\n        object,\n        forceUpdateStyle,\n        renderState,\n      );\n\n      renderState.prevObject = object;\n    }\n\n    if (generatePath) {\n      context.beginPath();\n      generatePath(context, object.parsedStyle);\n      if (\n        nodeName !== Shape.LINE &&\n        nodeName !== Shape.PATH &&\n        nodeName !== Shape.POLYLINE\n      ) {\n        context.closePath();\n      }\n    }\n\n    // fill & stroke\n    if (styleRenderer) {\n      styleRenderer.drawToContext(\n        context,\n        object,\n        this.#renderState,\n        this,\n        runtime,\n      );\n    }\n\n    if (clipDraw) {\n      context.restore();\n    }\n\n    // finish rendering, clear dirty flag\n    object.dirty(false);\n  }\n\n  renderDisplayObject(\n    object: DisplayObject,\n    context: CanvasRenderingContext2D,\n    canvasContext: CanvasContext,\n    renderState: RenderState,\n    runtime: GlobalRuntime,\n  ) {\n    const nodeName = object.nodeName as Shape;\n\n    // restore to its ancestor\n\n    const parent =\n      renderState.restoreStack[renderState.restoreStack.length - 1];\n    if (\n      parent &&\n      !(\n        object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS\n      )\n    ) {\n      context.restore();\n      renderState.restoreStack.pop();\n    }\n\n    // @ts-ignore\n    const styleRenderer = this.context.styleRendererFactory[nodeName];\n    const generatePath = this.pathGeneratorFactory[nodeName];\n\n    // clip path\n    const { clipPath } = object.parsedStyle;\n    if (clipPath) {\n      this.applyWorldTransform(context, clipPath);\n\n      // generate path in local space\n      const generatePath =\n        this.pathGeneratorFactory[clipPath.nodeName as Shape];\n      if (generatePath) {\n        context.save();\n\n        // save clip\n        renderState.restoreStack.push(object);\n\n        context.beginPath();\n        generatePath(context, clipPath.parsedStyle);\n        context.closePath();\n        context.clip();\n      }\n    }\n\n    // fill & stroke\n\n    if (styleRenderer) {\n      this.applyWorldTransform(context, object);\n\n      context.save();\n\n      // apply attributes to context\n      this.applyAttributesToContext(context, object);\n    }\n\n    if (generatePath) {\n      context.beginPath();\n      generatePath(context, object.parsedStyle);\n      if (\n        nodeName !== Shape.LINE &&\n        nodeName !== Shape.PATH &&\n        nodeName !== Shape.POLYLINE\n      ) {\n        context.closePath();\n      }\n    }\n\n    // fill & stroke\n    if (styleRenderer) {\n      styleRenderer.render(\n        context,\n        object.parsedStyle,\n        object,\n        canvasContext,\n        this,\n        runtime,\n      );\n\n      // restore applied attributes, eg. shadowBlur shadowColor...\n      context.restore();\n    }\n\n    // finish rendering, clear dirty flag\n    object.dirty(false);\n  }\n\n  private applyAttributesToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n  ) {\n    const { stroke, fill, opacity, lineDash, lineDashOffset } =\n      object.parsedStyle as ParsedBaseStyleProps;\n    // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash\n    if (lineDash) {\n      context.setLineDash(lineDash);\n    }\n\n    // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset\n    if (!isNil(lineDashOffset)) {\n      context.lineDashOffset = lineDashOffset;\n    }\n\n    if (!isNil(opacity)) {\n      context.globalAlpha *= opacity;\n    }\n\n    if (\n      !isNil(stroke) &&\n      !Array.isArray(stroke) &&\n      !(stroke as CSSRGB).isNone\n    ) {\n      context.strokeStyle = object.attributes.stroke as string;\n    }\n\n    if (!isNil(fill) && !Array.isArray(fill) && !(fill as CSSRGB).isNone) {\n      context.fillStyle = object.attributes.fill as string;\n    }\n  }\n\n  private convertAABB2Rect(aabb: AABB): Rect {\n    const min = aabb.getMin();\n    const max = aabb.getMax();\n    // expand the rectangle a bit to avoid artifacts\n    // @see https://www.yuque.com/antv/ou292n/bi8nix#ExvCu\n    const minX = Math.floor(min[0]);\n    const minY = Math.floor(min[1]);\n    const maxX = Math.ceil(max[0]);\n    const maxY = Math.ceil(max[1]);\n    const width = maxX - minX;\n    const height = maxY - minY;\n\n    return { x: minX, y: minY, width, height };\n  }\n\n  /**\n   * TODO: merge dirty rectangles with some strategies.\n   * For now, we just simply merge all the rectangles into one.\n   * @see https://idom.me/articles/841.html\n   */\n  private mergeDirtyAABBs(dirtyObjects: DisplayObject[]): AABB {\n    // merge into a big AABB\n    // TODO: skip descendant if ancestor is caculated, but compareNodePosition is really slow\n    const aabb = new AABB();\n    dirtyObjects.forEach((object) => {\n      const renderBounds = object.getRenderBounds();\n      aabb.add(renderBounds);\n\n      const { dirtyRenderBounds } = object.renderable;\n      if (dirtyRenderBounds) {\n        aabb.add(dirtyRenderBounds);\n      }\n    });\n\n    return aabb;\n  }\n\n  private searchDirtyObjects(dirtyRectangle: AABB): DisplayObject[] {\n    // search in r-tree, get all affected nodes\n    const [minX, minY] = dirtyRectangle.getMin();\n    const [maxX, maxY] = dirtyRectangle.getMax();\n    const rBushNodes = this.rBush.search({\n      minX,\n      minY,\n      maxX,\n      maxY,\n    });\n\n    return rBushNodes.map(({ displayObject }) => displayObject);\n  }\n\n  private saveDirtyAABB(object: DisplayObject) {\n    const { renderable } = object;\n    if (!renderable.dirtyRenderBounds) {\n      renderable.dirtyRenderBounds = new AABB();\n    }\n    const renderBounds = object.getRenderBounds();\n    if (renderBounds) {\n      // save last dirty aabb\n      renderable.dirtyRenderBounds.update(\n        renderBounds.center,\n        renderBounds.halfExtents,\n      );\n    }\n  }\n\n  private applyWorldTransform(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    matrix?: mat4,\n  ) {\n    // apply clip shape's RTS\n    if (matrix) {\n      mat4.copy(this.tmpMat4, object.getLocalTransform());\n      mat4.multiply(this.tmpMat4, matrix, this.tmpMat4);\n      mat4.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);\n    } else {\n      // apply RTS transformation in world space\n      mat4.copy(this.tmpMat4, object.getWorldTransform());\n      mat4.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);\n    }\n\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations\n    context.setTransform(\n      this.tmpMat4[0],\n      this.tmpMat4[1],\n      this.tmpMat4[4],\n      this.tmpMat4[5],\n      this.tmpMat4[12],\n      this.tmpMat4[13],\n    );\n  }\n\n  private safeMergeAABB(...aabbs: AABB[]): AABB {\n    const merged = new AABB();\n    aabbs.forEach((aabb) => {\n      merged.add(aabb);\n    });\n    return merged;\n  }\n}\n","import {\n  CanvasContext,\n  CSSGradientValue,\n  DisplayObject,\n  GlobalRuntime,\n  LinearGradient,\n  Pattern,\n  RadialGradient,\n  Rect,\n  GradientType,\n} from '@antv/g-lite';\nimport type { ImagePool } from '@antv/g-plugin-image-loader';\nimport {\n  CanvasRendererPlugin,\n  type RenderState,\n} from '../../CanvasRendererPlugin';\n\nexport function getPattern(\n  pattern: Pattern,\n  object: DisplayObject,\n  context: CanvasRenderingContext2D,\n  canvasContext: CanvasContext,\n  plugin: CanvasRendererPlugin,\n  runtime: GlobalRuntime,\n  imagePool: ImagePool,\n): CanvasPattern {\n  let $offscreenCanvas: HTMLCanvasElement;\n  let dpr: number;\n  if ((pattern.image as Rect).nodeName === 'rect') {\n    const { width, height } = (pattern.image as Rect).parsedStyle;\n    dpr = canvasContext.contextService.getDPR();\n    const { offscreenCanvas } = canvasContext.config;\n    $offscreenCanvas = runtime.offscreenCanvasCreator.getOrCreateCanvas(\n      offscreenCanvas,\n    ) as HTMLCanvasElement;\n\n    $offscreenCanvas.width = width * dpr;\n    $offscreenCanvas.height = height * dpr;\n\n    const offscreenCanvasContext =\n      runtime.offscreenCanvasCreator.getOrCreateContext(\n        offscreenCanvas,\n      ) as CanvasRenderingContext2D;\n\n    const renderState: RenderState = {\n      restoreStack: [],\n      prevObject: null,\n      currentContext: new Map(),\n    };\n\n    // offscreenCanvasContext.scale(1 / dpr, 1 / dpr);\n\n    (pattern.image as Rect).forEach((object: DisplayObject) => {\n      plugin.renderDisplayObject(\n        object,\n        offscreenCanvasContext,\n        canvasContext,\n        renderState,\n        runtime,\n      );\n    });\n\n    renderState.restoreStack.forEach(() => {\n      offscreenCanvasContext.restore();\n    });\n  }\n\n  const canvasPattern = imagePool.getOrCreatePatternSync(\n    object,\n    pattern,\n    context,\n    $offscreenCanvas,\n    dpr,\n    object.getGeometryBounds().min,\n    () => {\n      // set dirty rectangle flag\n      object.dirty();\n      canvasContext.renderingService.dirtify();\n    },\n  );\n\n  return canvasPattern;\n}\n\nexport function getColor(\n  parsedColor: CSSGradientValue,\n  object: DisplayObject,\n  context: CanvasRenderingContext2D,\n  imagePool: ImagePool,\n) {\n  let color: CanvasGradient | string;\n\n  if (\n    parsedColor.type === GradientType.LinearGradient ||\n    parsedColor.type === GradientType.RadialGradient\n  ) {\n    const bounds = object.getGeometryBounds();\n    const width = (bounds && bounds.halfExtents[0] * 2) || 1;\n    const height = (bounds && bounds.halfExtents[1] * 2) || 1;\n    const min = (bounds && bounds.min) || [0, 0];\n    color = imagePool.getOrCreateGradient(\n      {\n        type: parsedColor.type,\n        ...(parsedColor.value as LinearGradient & RadialGradient),\n        min: min as [number, number],\n        width,\n        height,\n      },\n      context,\n    );\n  }\n\n  return color;\n}\n","import {\n  CanvasContext,\n  CSSRGB,\n  DisplayObject,\n  GlobalRuntime,\n  ParsedBaseStyleProps,\n  isPattern,\n  Shape,\n} from '@antv/g-lite';\nimport type { ImagePool } from '@antv/g-plugin-image-loader';\nimport { isNil } from '@antv/util';\nimport {\n  CanvasRendererPlugin,\n  type RenderState,\n} from '../../CanvasRendererPlugin';\nimport type { StyleRenderer } from './interfaces';\nimport { getColor, getPattern } from './helper';\n\nconst SHADOW_NUMBER_STYLE = [\n  'shadowBlur',\n  'shadowOffsetX',\n  'shadowOffsetY',\n] as const;\nconst STROKE_STYLE = ['lineCap', 'lineJoin', 'miterLimit'] as const;\nexport const DEFAULT_STYLE = {\n  // common\n  globalAlpha: 1,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  shadowColor: '#000',\n  filter: 'none' as const,\n  globalCompositeOperation: 'source-over' as const,\n\n  // stroke/fill\n  strokeStyle: '#000',\n  strokeOpacity: 1,\n  lineWidth: 1,\n  lineDash: [],\n  lineDashOffset: 0,\n  lineCap: 'butt' as const,\n  lineJoin: 'miter' as const,\n  miterLimit: 10,\n  fillStyle: '#000',\n  fillOpacity: 1,\n\n  // image\n};\n\nconst defaultParsedStyle = {} as ParsedBaseStyleProps;\n\n/**\n * Updating the canvas context is an expensive operation. The state of the context is cached and the actual update operation is performed only when the cache is not hit.\n *\n * In any case, the previous value is returned, which is convenient for temporarily updating the context and restoring it later.\n */\nfunction updateContextIfNotHitCache<\n  K extends keyof CanvasRenderingContext2D | 'lineDash',\n  V = unknown,\n>(context: CanvasRenderingContext2D, key: K, value: V, cache: Map<K, unknown>) {\n  const prevValue = (\n    cache.has(key)\n      ? cache.get(key)\n      : DEFAULT_STYLE[key as keyof typeof DEFAULT_STYLE]\n  ) as V;\n\n  if (prevValue !== value) {\n    // console.log('not hit cache', key, value, prevValue, cache);\n    if (key === 'lineDash') {\n      context.setLineDash(value as number[]);\n    } else {\n      // @ts-ignore\n      context[key] = value;\n    }\n    cache.set(key, value);\n  }\n\n  return prevValue;\n}\n\nexport class OptimizedDefaultRenderer implements StyleRenderer {\n  constructor(public imagePool: ImagePool) {}\n\n  applyAttributesToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n  ) {}\n\n  render(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedBaseStyleProps,\n    object: DisplayObject,\n    canvasContext: CanvasContext,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {}\n\n  // #region common style\n  private applyCommonStyleToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    forceUpdate: boolean,\n    renderState: RenderState,\n  ) {\n    // const dpr = object.ownerDocument.defaultView.getContextService().getDPR();\n    const prevStyle = forceUpdate\n      ? defaultParsedStyle\n      : renderState.prevObject.parsedStyle;\n    const style = object.parsedStyle;\n\n    if (forceUpdate || style.opacity !== prevStyle.opacity) {\n      updateContextIfNotHitCache(\n        context,\n        'globalAlpha',\n        !isNil(style.opacity) ? style.opacity : DEFAULT_STYLE.globalAlpha,\n        renderState.currentContext,\n      );\n    }\n\n    // TODO blend prop\n    // @ts-ignore\n    if (forceUpdate || style.blend !== prevStyle.blend) {\n      updateContextIfNotHitCache(\n        context,\n        'globalCompositeOperation',\n        // @ts-ignore\n        !isNil(style.blend)\n          ? // @ts-ignore\n            style.blend\n          : DEFAULT_STYLE.globalCompositeOperation,\n        renderState.currentContext,\n      );\n    }\n  }\n  // #endregion common style\n\n  // #region stroke/fill style\n  private applyStrokeFillStyleToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    forceUpdate: boolean,\n    renderState: RenderState,\n  ) {\n    const prevStyle = forceUpdate\n      ? defaultParsedStyle\n      : renderState.prevObject.parsedStyle;\n    const style = object.parsedStyle;\n    const { lineWidth = DEFAULT_STYLE.lineWidth } = style;\n    const hasFill = style.fill && !(style.fill as CSSRGB).isNone;\n    const hasStroke =\n      style.stroke && !(style.stroke as CSSRGB).isNone && lineWidth > 0;\n\n    if (hasStroke) {\n      if (\n        forceUpdate ||\n        object.attributes.stroke !== renderState.prevObject.attributes.stroke\n      ) {\n        const value =\n          !isNil(style.stroke) &&\n          !Array.isArray(style.stroke) &&\n          !(style.stroke as CSSRGB).isNone\n            ? object.attributes.stroke\n            : DEFAULT_STYLE.strokeStyle;\n\n        updateContextIfNotHitCache(\n          context,\n          'strokeStyle',\n          value,\n          renderState.currentContext,\n        );\n      }\n\n      if (forceUpdate || style.lineWidth !== prevStyle.lineWidth) {\n        updateContextIfNotHitCache(\n          context,\n          'lineWidth',\n          !isNil(style.lineWidth) ? style.lineWidth : DEFAULT_STYLE.lineWidth,\n          renderState.currentContext,\n        );\n      }\n\n      if (forceUpdate || style.lineDash !== prevStyle.lineDash) {\n        updateContextIfNotHitCache(\n          context,\n          'lineDash',\n          style.lineDash || DEFAULT_STYLE.lineDash,\n          renderState.currentContext,\n        );\n      }\n\n      if (forceUpdate || style.lineDashOffset !== prevStyle.lineDashOffset) {\n        updateContextIfNotHitCache(\n          context,\n          'lineDashOffset',\n          !isNil(style.lineDashOffset)\n            ? style.lineDashOffset\n            : DEFAULT_STYLE.lineDashOffset,\n          renderState.currentContext,\n        );\n      }\n\n      for (let i = 0; i < STROKE_STYLE.length; i++) {\n        const styleName = STROKE_STYLE[i];\n        if (forceUpdate || style[styleName] !== prevStyle[styleName]) {\n          updateContextIfNotHitCache(\n            context,\n            styleName,\n            !isNil(style[styleName])\n              ? style[styleName]\n              : DEFAULT_STYLE[styleName],\n            renderState.currentContext,\n          );\n        }\n      }\n    }\n\n    if (\n      hasFill &&\n      (forceUpdate ||\n        object.attributes.fill !== renderState.prevObject.attributes.fill)\n    ) {\n      const value =\n        !isNil(style.fill) &&\n        !Array.isArray(style.fill) &&\n        !(style.fill as CSSRGB).isNone\n          ? object.attributes.fill\n          : DEFAULT_STYLE.fillStyle;\n\n      updateContextIfNotHitCache(\n        context,\n        'fillStyle',\n        value,\n        renderState.currentContext,\n      );\n    }\n  }\n  // #endregion stroke/fill style\n\n  applyStyleToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    forceUpdate: boolean,\n    renderState: RenderState,\n  ) {\n    const nodeName = object.nodeName as Shape;\n\n    this.applyCommonStyleToContext(context, object, forceUpdate, renderState);\n\n    if (nodeName === Shape.IMAGE) {\n      //\n    } else {\n      this.applyStrokeFillStyleToContext(\n        context,\n        object,\n        forceUpdate,\n        renderState,\n      );\n    }\n  }\n\n  applyShadowAndFilterStyleToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    hasShadow: boolean,\n    renderState: RenderState,\n  ) {\n    const style = object.parsedStyle;\n\n    if (hasShadow) {\n      updateContextIfNotHitCache(\n        context,\n        'shadowColor',\n        style.shadowColor.toString(),\n        renderState.currentContext,\n      );\n      for (let i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {\n        const styleName = SHADOW_NUMBER_STYLE[i];\n        updateContextIfNotHitCache(\n          context,\n          styleName,\n          style[styleName] || DEFAULT_STYLE[styleName],\n          renderState.currentContext,\n        );\n      }\n    }\n\n    if (style.filter && style.filter.length) {\n      updateContextIfNotHitCache(\n        context,\n        'filter',\n        // use raw filter string\n        object.attributes.filter,\n        renderState.currentContext,\n      );\n    }\n  }\n\n  clearShadowAndFilterStyleForContext(\n    context: CanvasRenderingContext2D,\n    hasShadow: boolean,\n    hasFilter: boolean,\n    renderState: RenderState,\n    onlyClearShadowFilter = false,\n  ) {\n    if (hasShadow) {\n      updateContextIfNotHitCache(\n        context,\n        'shadowColor',\n        DEFAULT_STYLE.shadowColor,\n        renderState.currentContext,\n      );\n      for (let i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {\n        const styleName = SHADOW_NUMBER_STYLE[i];\n        updateContextIfNotHitCache(\n          context,\n          styleName,\n          DEFAULT_STYLE[styleName],\n          renderState.currentContext,\n        );\n      }\n    }\n\n    if (hasFilter) {\n      if (hasShadow && onlyClearShadowFilter) {\n        // save drop-shadow filter\n        const oldFilter = context.filter;\n        if (!isNil(oldFilter) && oldFilter.indexOf('drop-shadow') > -1) {\n          updateContextIfNotHitCache(\n            context,\n            'filter',\n            oldFilter.replace(/drop-shadow\\([^)]*\\)/, '').trim() ||\n              DEFAULT_STYLE.filter,\n            renderState.currentContext,\n          );\n        }\n      } else {\n        updateContextIfNotHitCache(\n          context,\n          'filter',\n          DEFAULT_STYLE.filter,\n          renderState.currentContext,\n        );\n      }\n    }\n  }\n\n  fillToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    renderState: RenderState,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    const { fill, fillRule } = object.parsedStyle;\n    let resetStyle = null as unknown;\n\n    if (Array.isArray(fill) && fill.length > 0) {\n      fill.forEach((gradient) => {\n        const prevStyle = updateContextIfNotHitCache(\n          context,\n          'fillStyle',\n          getColor(gradient, object, context, this.imagePool),\n          renderState.currentContext,\n        );\n        resetStyle = resetStyle ?? prevStyle;\n\n        if (fillRule) {\n          context.fill(fillRule);\n        } else {\n          context.fill();\n        }\n      });\n    } else {\n      if (isPattern(fill)) {\n        const pattern = getPattern(\n          fill,\n          object,\n          context,\n          object.ownerDocument.defaultView.context,\n          plugin,\n          runtime,\n          this.imagePool,\n        );\n        if (pattern) {\n          context.fillStyle = pattern;\n          resetStyle = true;\n        }\n      }\n\n      if (fillRule) {\n        context.fill(fillRule);\n      } else {\n        context.fill();\n      }\n    }\n\n    if (resetStyle !== null) {\n      updateContextIfNotHitCache(\n        context,\n        'fillStyle',\n        resetStyle,\n        renderState.currentContext,\n      );\n    }\n  }\n\n  strokeToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    renderState: RenderState,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    const { stroke } = object.parsedStyle;\n    let resetStyle = null as unknown;\n\n    if (Array.isArray(stroke) && stroke.length > 0) {\n      stroke.forEach((gradient) => {\n        const prevStyle = updateContextIfNotHitCache(\n          context,\n          'strokeStyle',\n          getColor(gradient, object, context, this.imagePool),\n          renderState.currentContext,\n        );\n        resetStyle = resetStyle ?? prevStyle;\n\n        context.stroke();\n      });\n    } else {\n      if (isPattern(stroke)) {\n        const pattern = getPattern(\n          stroke,\n          object,\n          context,\n          object.ownerDocument.defaultView.context,\n          plugin,\n          runtime,\n          this.imagePool,\n        );\n        if (pattern) {\n          const prevStyle = updateContextIfNotHitCache(\n            context,\n            'strokeStyle',\n            pattern,\n            renderState.currentContext,\n          );\n          resetStyle = resetStyle ?? prevStyle;\n        }\n      }\n\n      context.stroke();\n    }\n\n    if (resetStyle !== null) {\n      updateContextIfNotHitCache(\n        context,\n        'strokeStyle',\n        resetStyle,\n        renderState.currentContext,\n      );\n    }\n  }\n\n  drawToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    renderState: RenderState,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    const nodeName = object.nodeName as Shape;\n    const style = object.parsedStyle;\n    const {\n      opacity = DEFAULT_STYLE.globalAlpha,\n      fillOpacity = DEFAULT_STYLE.fillOpacity,\n      strokeOpacity = DEFAULT_STYLE.strokeOpacity,\n      lineWidth = DEFAULT_STYLE.lineWidth,\n    } = style;\n\n    const hasFill = style.fill && !(style.fill as CSSRGB).isNone;\n    const hasStroke =\n      style.stroke && !(style.stroke as CSSRGB).isNone && lineWidth > 0;\n\n    if (!hasFill && !hasStroke) {\n      return;\n    }\n\n    const hasShadow = !isNil(style.shadowColor) && style.shadowBlur > 0;\n    const isInnerShadow = style.shadowType === 'inner';\n    const isFillTransparent = (style.fill as CSSRGB)?.alpha === 0;\n    const hasFilter = !!(style.filter && style.filter.length);\n    // Shadows can only be applied to fill() or stroke(), the default is fill()\n    const shouldDrawShadowWithStroke =\n      hasShadow &&\n      hasStroke &&\n      (nodeName === Shape.PATH ||\n        nodeName === Shape.LINE ||\n        nodeName === Shape.POLYLINE ||\n        isFillTransparent ||\n        isInnerShadow);\n\n    // TODO https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/paint-order\n\n    let originGlobalAlpha: number | null = null;\n\n    if (hasFill) {\n      if (!shouldDrawShadowWithStroke) {\n        this.applyShadowAndFilterStyleToContext(\n          context,\n          object,\n          hasShadow,\n          renderState,\n        );\n      }\n\n      const updateOpacity = opacity * fillOpacity;\n\n      originGlobalAlpha = updateContextIfNotHitCache(\n        context,\n        'globalAlpha',\n        updateOpacity,\n        renderState.currentContext,\n      );\n\n      this.fillToContext(context, object, renderState, plugin, runtime);\n\n      if (!shouldDrawShadowWithStroke) {\n        this.clearShadowAndFilterStyleForContext(\n          context,\n          hasShadow,\n          hasFilter,\n          renderState,\n        );\n      }\n    }\n    if (hasStroke) {\n      let clearShadowAndFilter = false;\n      const updateOpacity = opacity * strokeOpacity;\n      const prevOpacity = updateContextIfNotHitCache(\n        context,\n        'globalAlpha',\n        updateOpacity,\n        renderState.currentContext,\n      );\n      originGlobalAlpha = hasFill ? originGlobalAlpha : prevOpacity;\n\n      if (shouldDrawShadowWithStroke) {\n        this.applyShadowAndFilterStyleToContext(\n          context,\n          object,\n          hasShadow,\n          renderState,\n        );\n        clearShadowAndFilter = true;\n\n        if (isInnerShadow) {\n          const originBlend = context.globalCompositeOperation;\n          context.globalCompositeOperation = 'source-atop';\n\n          this.strokeToContext(context, object, renderState, plugin, runtime);\n\n          context.globalCompositeOperation = originBlend;\n          this.clearShadowAndFilterStyleForContext(\n            context,\n            hasShadow,\n            hasFilter,\n            renderState,\n            true,\n          );\n        }\n      }\n\n      this.strokeToContext(context, object, renderState, plugin, runtime);\n\n      if (clearShadowAndFilter) {\n        this.clearShadowAndFilterStyleForContext(\n          context,\n          hasShadow,\n          hasFilter,\n          renderState,\n        );\n      }\n    }\n\n    // clear\n    if (originGlobalAlpha !== null) {\n      updateContextIfNotHitCache(\n        context,\n        'globalAlpha',\n        originGlobalAlpha,\n        renderState.currentContext,\n      );\n    }\n  }\n}\n","import {\n  CanvasContext,\n  CSSGradientValue,\n  CSSRGB,\n  DisplayObject,\n  GlobalRuntime,\n  ParsedBaseStyleProps,\n  Pattern,\n  isPattern,\n  Shape,\n} from '@antv/g-lite';\nimport type { ImagePool } from '@antv/g-plugin-image-loader';\nimport { isNil } from '@antv/util';\nimport { CanvasRendererPlugin } from '../../CanvasRendererPlugin';\nimport { OptimizedDefaultRenderer, DEFAULT_STYLE } from './OptimizedDefault';\nimport { getColor, getPattern } from './helper';\n\nexport class DefaultRenderer extends OptimizedDefaultRenderer {\n  render(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedBaseStyleProps,\n    object: DisplayObject,\n    canvasContext: CanvasContext,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    const {\n      fill,\n      fillRule,\n      opacity = 1,\n      fillOpacity = 1,\n      stroke,\n      strokeOpacity = 1,\n      lineWidth = 1,\n      lineCap,\n      lineJoin,\n      shadowType,\n      shadowColor,\n      shadowBlur,\n      filter,\n      miterLimit,\n    } = parsedStyle;\n    const hasFill = fill && !(fill as CSSRGB).isNone;\n    const hasStroke = stroke && !(stroke as CSSRGB).isNone && lineWidth > 0;\n\n    const isFillTransparent = (fill as CSSRGB)?.alpha === 0;\n    const hasFilter = !!(filter && filter.length);\n    const hasShadow = !isNil(shadowColor) && shadowBlur > 0;\n    const nodeName = object.nodeName as Shape;\n    const isInnerShadow = shadowType === 'inner';\n    const shouldDrawShadowWithStroke =\n      hasStroke &&\n      hasShadow &&\n      (nodeName === Shape.PATH ||\n        nodeName === Shape.LINE ||\n        nodeName === Shape.POLYLINE ||\n        isFillTransparent ||\n        isInnerShadow);\n\n    if (hasFill) {\n      context.globalAlpha = opacity * fillOpacity;\n\n      if (!shouldDrawShadowWithStroke) {\n        setShadowAndFilter(object, context, hasShadow);\n      }\n\n      applyFill(\n        context,\n        object,\n        fill,\n        fillRule,\n        canvasContext,\n        plugin,\n        runtime,\n        this.imagePool,\n      );\n\n      if (!shouldDrawShadowWithStroke) {\n        this.clearShadowAndFilter(context, hasFilter, hasShadow);\n      }\n    }\n\n    if (hasStroke) {\n      context.globalAlpha = opacity * strokeOpacity;\n      context.lineWidth = lineWidth;\n      if (!isNil(miterLimit)) {\n        context.miterLimit = miterLimit;\n      }\n\n      if (!isNil(lineCap)) {\n        context.lineCap = lineCap;\n      }\n\n      if (!isNil(lineJoin)) {\n        context.lineJoin = lineJoin;\n      }\n\n      if (shouldDrawShadowWithStroke) {\n        if (isInnerShadow) {\n          context.globalCompositeOperation = 'source-atop';\n        }\n        setShadowAndFilter(object, context, true);\n\n        if (isInnerShadow) {\n          applyStroke(\n            context,\n            object,\n            stroke,\n            canvasContext,\n            plugin,\n            runtime,\n            this.imagePool,\n          );\n          context.globalCompositeOperation =\n            DEFAULT_STYLE.globalCompositeOperation;\n          this.clearShadowAndFilter(context, hasFilter, true);\n        }\n      }\n\n      applyStroke(\n        context,\n        object,\n        stroke,\n        canvasContext,\n        plugin,\n        runtime,\n        this.imagePool,\n      );\n    }\n  }\n\n  private clearShadowAndFilter(\n    context: CanvasRenderingContext2D,\n    hasFilter: boolean,\n    hasShadow: boolean,\n  ) {\n    if (hasShadow) {\n      context.shadowColor = 'transparent';\n      context.shadowBlur = 0;\n    }\n\n    if (hasFilter) {\n      // save drop-shadow filter\n      const oldFilter = context.filter;\n      if (!isNil(oldFilter) && oldFilter.indexOf('drop-shadow') > -1) {\n        context.filter =\n          oldFilter.replace(/drop-shadow\\([^)]*\\)/, '').trim() || 'none';\n      }\n    }\n  }\n}\n\n/**\n * apply before fill and stroke but only once\n */\nexport function setShadowAndFilter(\n  object: DisplayObject,\n  context: CanvasRenderingContext2D,\n  hasShadow: boolean,\n) {\n  const { filter, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY } =\n    object.parsedStyle;\n\n  if (filter && filter.length) {\n    // use raw filter string\n    context.filter = object.style.filter;\n  }\n\n  if (hasShadow) {\n    context.shadowColor = shadowColor.toString();\n    context.shadowBlur = shadowBlur || 0;\n    context.shadowOffsetX = shadowOffsetX || 0;\n    context.shadowOffsetY = shadowOffsetY || 0;\n  }\n}\n\nexport function applyFill(\n  context: CanvasRenderingContext2D,\n  object: DisplayObject,\n  fill: CSSRGB | CSSGradientValue[] | Pattern,\n  fillRule: 'nonzero' | 'evenodd',\n  canvasContext: CanvasContext,\n  plugin: CanvasRendererPlugin,\n  runtime: GlobalRuntime,\n  imagePool: ImagePool,\n  skipFill = false,\n) {\n  if (Array.isArray(fill)) {\n    fill.forEach((gradient) => {\n      context.fillStyle = getColor(gradient, object, context, imagePool);\n      if (!skipFill) {\n        fillRule ? context.fill(fillRule) : context.fill();\n      }\n    });\n  } else {\n    if (isPattern(fill)) {\n      context.fillStyle = getPattern(\n        fill,\n        object,\n        context,\n        canvasContext,\n        plugin,\n        runtime,\n        imagePool,\n      );\n    }\n    if (!skipFill) {\n      fillRule ? context.fill(fillRule) : context.fill();\n    }\n  }\n}\n\nexport function applyStroke(\n  context: CanvasRenderingContext2D,\n  object: DisplayObject,\n  stroke: CSSRGB | CSSGradientValue[] | Pattern,\n  canvasContext: CanvasContext,\n  plugin: CanvasRendererPlugin,\n  runtime: GlobalRuntime,\n  imagePool: ImagePool,\n  skipStroke = false,\n) {\n  if (Array.isArray(stroke)) {\n    stroke.forEach((gradient) => {\n      context.strokeStyle = getColor(gradient, object, context, imagePool);\n      if (!skipStroke) {\n        context.stroke();\n      }\n    });\n  } else {\n    if (isPattern(stroke)) {\n      context.strokeStyle = getPattern(\n        stroke,\n        object,\n        context,\n        canvasContext,\n        plugin,\n        runtime,\n        imagePool,\n      );\n    }\n    if (!skipStroke) {\n      context.stroke();\n    }\n  }\n}\n","import { vec3, mat4 } from 'gl-matrix';\n\n/**\n * 判断两个点是否重合，点坐标的格式为 [x, y]\n */\nexport function isSamePoint(\n  point1: [number, number],\n  point2: [number, number],\n) {\n  return point1[0] === point2[0] && point1[1] === point2[1];\n}\n\nexport function calculateOverlapRect<\n  Rect extends [number, number, number, number],\n>(rect1: Rect, rect2: Rect): null | Rect {\n  const [x1, y1, w1, h1] = rect1;\n  const [x2, y2, w2, h2] = rect2;\n\n  // 计算重叠区域的左上角和右下角\n  const overlapLeft = Math.max(x1, x2);\n  const overlapTop = Math.max(y1, y2);\n  const overlapRight = Math.min(x1 + w1, x2 + w2);\n  const overlapBottom = Math.min(y1 + h1, y2 + h2);\n\n  if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) {\n    return null;\n  }\n\n  return [\n    overlapLeft,\n    overlapTop,\n    overlapRight - overlapLeft,\n    overlapBottom - overlapTop,\n  ] as Rect;\n}\n\nexport function transformRect<Rect extends [number, number, number, number]>(\n  rect: Rect,\n  matrix: mat4,\n): Rect {\n  const tl = vec3.transformMat4(vec3.create(), [rect[0], rect[1], 0], matrix);\n  const tr = vec3.transformMat4(\n    vec3.create(),\n    [rect[0] + rect[2], rect[1], 0],\n    matrix,\n  );\n  const bl = vec3.transformMat4(\n    vec3.create(),\n    [rect[0], rect[1] + rect[3], 0],\n    matrix,\n  );\n  const br = vec3.transformMat4(\n    vec3.create(),\n    [rect[0] + rect[2], rect[1] + rect[3], 0],\n    matrix,\n  );\n\n  return [\n    Math.min(tl[0], tr[0], bl[0], br[0]),\n    Math.min(tl[1], tr[1], bl[1], br[1]),\n    Math.max(tl[0], tr[0], bl[0], br[0]) - Math.min(tl[0], tr[0], bl[0], br[0]),\n    Math.max(tl[1], tr[1], bl[1], br[1]) - Math.min(tl[1], tr[1], bl[1], br[1]),\n  ] as Rect;\n}\n","import type {\n  DisplayObject,\n  ParsedImageStyleProps,\n  GlobalRuntime,\n} from '@antv/g-lite';\nimport { ImagePool, type ImageCache } from '@antv/g-plugin-image-loader';\nimport { isNil } from '@antv/util';\nimport { mat4 } from 'gl-matrix';\nimport { transformRect, calculateOverlapRect } from '../../utils/math';\nimport { DefaultRenderer, setShadowAndFilter } from './Default';\nimport {\n  CanvasRendererPlugin,\n  type RenderState,\n} from '../../CanvasRendererPlugin';\n\nexport class ImageRenderer extends DefaultRenderer {\n  static renderFull(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedImageStyleProps,\n    object: DisplayObject,\n    data: {\n      image: HTMLImageElement;\n      drawRect: [number, number, number, number];\n    },\n  ) {\n    context.drawImage(\n      data.image,\n      Math.floor(data.drawRect[0]),\n      Math.floor(data.drawRect[1]),\n      Math.ceil(data.drawRect[2]),\n      Math.ceil(data.drawRect[3]),\n    );\n  }\n\n  private renderDownSampled(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedImageStyleProps,\n    object: DisplayObject,\n    data: {\n      src: string | HTMLImageElement;\n      imageCache: ImageCache;\n      drawRect: [number, number, number, number];\n    },\n  ) {\n    const { src, imageCache } = data;\n\n    if (!imageCache.downSampled) {\n      this.imagePool\n        .createDownSampledImage(src, object)\n        .then(() => {\n          // be removed from dom tree\n          if (!object.ownerDocument) {\n            return;\n          }\n\n          // rerender\n          object.dirty();\n          object.ownerDocument.defaultView.context.renderingService.dirtify();\n        })\n        .catch((reason) => {\n          console.error(reason);\n        });\n\n      return;\n    }\n\n    context.drawImage(\n      imageCache.downSampled,\n      Math.floor(data.drawRect[0]),\n      Math.floor(data.drawRect[1]),\n      Math.ceil(data.drawRect[2]),\n      Math.ceil(data.drawRect[3]),\n    );\n  }\n\n  renderTile(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedImageStyleProps,\n    object: DisplayObject,\n    data: {\n      src: string | HTMLImageElement;\n      imageCache: ImageCache;\n      imageRect: [number, number, number, number];\n      drawRect: [number, number, number, number];\n    },\n  ) {\n    const { src, imageCache, imageRect, drawRect } = data;\n    const { size: originalSize } = imageCache;\n    const { a, b, c, d, e, f } = context.getTransform();\n\n    context.resetTransform();\n\n    if (!imageCache?.gridSize) {\n      this.imagePool\n        .createImageTiles(\n          src,\n          [],\n          () => {\n            // be removed from dom tree\n            if (!object.ownerDocument) {\n              return;\n            }\n\n            // rerender\n            object.dirty();\n            object.ownerDocument.defaultView.context.renderingService.dirtify();\n          },\n          object,\n        )\n        .catch((reason) => {\n          console.error(reason);\n        });\n\n      return;\n    }\n\n    const scaleToOrigin = [\n      originalSize[0] / imageRect[2],\n      originalSize[1] / imageRect[3],\n    ];\n    const scaledTileSize = [\n      imageCache.tileSize[0] / scaleToOrigin[0],\n      imageCache.tileSize[1] / scaleToOrigin[1],\n    ];\n    const [startTileX, endTileX] = [\n      Math.floor((drawRect[0] - imageRect[0]) / scaledTileSize[0]),\n      Math.ceil((drawRect[0] + drawRect[2] - imageRect[0]) / scaledTileSize[0]),\n    ];\n    const [startTileY, endTileY] = [\n      Math.floor((drawRect[1] - imageRect[1]) / scaledTileSize[1]),\n      Math.ceil((drawRect[1] + drawRect[3] - imageRect[1]) / scaledTileSize[1]),\n    ];\n\n    for (let tileY = startTileY; tileY <= endTileY; tileY++) {\n      for (let tileX = startTileX; tileX <= endTileX; tileX++) {\n        const item = imageCache.tiles[tileY][tileX];\n\n        if (item) {\n          const tileRect = [\n            Math.floor(imageRect[0] + item.tileX * scaledTileSize[0]),\n            Math.floor(imageRect[1] + item.tileY * scaledTileSize[1]),\n            Math.ceil(scaledTileSize[0]),\n            Math.ceil(scaledTileSize[1]),\n          ];\n\n          context.drawImage(\n            item.data,\n            tileRect[0],\n            tileRect[1],\n            tileRect[2],\n            tileRect[3],\n          );\n        }\n      }\n    }\n\n    context.setTransform(a, b, c, d, e, f);\n  }\n\n  render(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedImageStyleProps,\n    object: DisplayObject,\n  ) {\n    const {\n      x = 0,\n      y = 0,\n      width,\n      height,\n      src,\n      shadowColor,\n      shadowBlur,\n    } = parsedStyle;\n\n    const imageCache = this.imagePool.getImageSync(src, object);\n    const image = imageCache?.img;\n    let iw = width;\n    let ih = height;\n\n    if (!image) {\n      return;\n    }\n\n    iw ||= image.width;\n    ih ||= image.height;\n\n    const hasShadow = !isNil(shadowColor) && shadowBlur > 0;\n    setShadowAndFilter(object, context, hasShadow);\n\n    // node-canvas will throw the following err:\n    // Error: Image given has not completed loading\n    try {\n      const { width: viewWidth, height: viewHeight } =\n        object.ownerDocument.defaultView.getContextService().getDomElement();\n\n      const currentTransform = context.getTransform();\n      const { a, b, c, d, e, f } = currentTransform;\n      // 构建 mat4 矩阵\n      // prettier-ignore\n      const transformMatrix = mat4.fromValues(\n          a, c, 0, 0,\n          b, d, 0, 0,\n          0, 0, 1, 0,\n          e, f, 0, 1,\n        );\n      const imageRect = transformRect([x, y, iw, ih], transformMatrix);\n      const drawRect = calculateOverlapRect(\n        [0, 0, viewWidth, viewHeight],\n        imageRect,\n      );\n\n      if (!drawRect) {\n        return;\n      }\n\n      if (\n        !object.ownerDocument.defaultView.getConfig()\n          .enableLargeImageOptimization\n      ) {\n        ImageRenderer.renderFull(context, parsedStyle, object, {\n          image,\n          drawRect: [x, y, iw, ih],\n        });\n\n        return;\n      }\n\n      const sizeOfOrigin = imageRect[2] / imageCache.size[0];\n\n      if (sizeOfOrigin < (imageCache.downSamplingRate || 0.5)) {\n        this.renderDownSampled(context, parsedStyle, object, {\n          src,\n          imageCache,\n          drawRect: [x, y, iw, ih],\n        });\n\n        return;\n      }\n\n      if (!ImagePool.isSupportTile) {\n        ImageRenderer.renderFull(context, parsedStyle, object, {\n          image,\n          drawRect: [x, y, iw, ih],\n        });\n\n        return;\n      }\n\n      this.renderTile(context, parsedStyle, object, {\n        src,\n        imageCache,\n        imageRect,\n        drawRect,\n      });\n    } catch {\n      // expected error\n    }\n  }\n\n  // ---\n\n  drawToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    renderState: RenderState,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    this.render(context, object.parsedStyle as ParsedImageStyleProps, object);\n  }\n}\n","import {\n  type CSSRGB,\n  type CanvasContext,\n  type DisplayObject,\n  type GlobalRuntime,\n  type ParsedTextStyleProps,\n  type Rectangle,\n  CSSGradientValue,\n  Pattern,\n} from '@antv/g-lite';\nimport { isNil } from '@antv/util';\nimport {\n  DefaultRenderer,\n  applyFill,\n  applyStroke,\n  setShadowAndFilter,\n} from './Default';\nimport {\n  CanvasRendererPlugin,\n  type RenderState,\n} from '../../CanvasRendererPlugin';\n\nexport class TextRenderer extends DefaultRenderer {\n  render(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedTextStyleProps,\n    object: DisplayObject,\n    canvasContext: CanvasContext,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    // Trigger text geometry calculation.\n    object.getBounds();\n    const {\n      lineWidth = 1,\n      textAlign = 'start',\n      textBaseline = 'alphabetic',\n      lineJoin = 'miter',\n      miterLimit = 10,\n      letterSpacing = 0,\n      stroke,\n      fill,\n      fillRule,\n      fillOpacity = 1,\n      strokeOpacity = 1,\n      opacity = 1,\n      metrics,\n      x = 0,\n      y = 0,\n      dx,\n      dy,\n      shadowColor,\n      shadowBlur,\n    } = parsedStyle;\n\n    const { font, lines, height, lineHeight, lineMetrics } = metrics;\n\n    context.font = font;\n    context.lineWidth = lineWidth;\n    context.textAlign = textAlign === 'middle' ? 'center' : textAlign;\n\n    let formattedTextBaseline = textBaseline;\n    if (formattedTextBaseline === 'alphabetic') {\n      formattedTextBaseline = 'bottom';\n    }\n\n    context.lineJoin = lineJoin;\n    if (!isNil(miterLimit)) {\n      context.miterLimit = miterLimit;\n    }\n\n    let linePositionY = y;\n    // handle vertical text baseline\n    if (textBaseline === 'middle') {\n      linePositionY += -height / 2 - lineHeight / 2;\n    } else if (\n      textBaseline === 'bottom' ||\n      textBaseline === 'alphabetic' ||\n      textBaseline === 'ideographic'\n    ) {\n      linePositionY += -height;\n    } else if (textBaseline === 'top' || textBaseline === 'hanging') {\n      linePositionY += -lineHeight;\n    }\n\n    // account for dx & dy\n    const offsetX = x + (dx || 0);\n    linePositionY += dy || 0;\n\n    if (lines.length === 1) {\n      if (formattedTextBaseline === 'bottom') {\n        formattedTextBaseline = 'middle';\n        linePositionY -= 0.5 * height;\n      } else if (formattedTextBaseline === 'top') {\n        formattedTextBaseline = 'middle';\n        linePositionY += 0.5 * height;\n      }\n    }\n    context.textBaseline = formattedTextBaseline;\n\n    const hasShadow = !isNil(shadowColor) && shadowBlur > 0;\n    setShadowAndFilter(object, context, hasShadow);\n\n    // draw lines line by line\n    for (let i = 0; i < lines.length; i++) {\n      const linePositionX = lineWidth / 2 + offsetX;\n      linePositionY += lineHeight;\n\n      // no need to re-position X, cause we already set text align\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign\n      if (!isNil(stroke) && !(stroke as CSSRGB).isNone && lineWidth) {\n        this.drawLetterSpacing(\n          context,\n          object,\n          lines[i],\n          lineMetrics[i],\n          textAlign,\n          linePositionX,\n          linePositionY,\n          letterSpacing,\n          fill,\n          fillRule,\n          fillOpacity,\n          stroke,\n          strokeOpacity,\n          opacity,\n          true,\n          canvasContext,\n          plugin,\n          runtime,\n        );\n      }\n      if (!isNil(fill)) {\n        this.drawLetterSpacing(\n          context,\n          object,\n          lines[i],\n          lineMetrics[i],\n          textAlign,\n          linePositionX,\n          linePositionY,\n          letterSpacing,\n          fill,\n          fillRule,\n          fillOpacity,\n          stroke,\n          strokeOpacity,\n          opacity,\n          false,\n          canvasContext,\n          plugin,\n          runtime,\n        );\n      }\n    }\n  }\n\n  private drawLetterSpacing(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    text: string,\n    lineMetrics: Rectangle,\n    textAlign: CanvasTextAlign | 'middle',\n    x: number,\n    y: number,\n    letterSpacing: number,\n    fill: CSSRGB | CSSGradientValue[] | Pattern,\n    fillRule: 'nonzero' | 'evenodd',\n    fillOpacity: number | undefined,\n    stroke: CSSRGB | CSSGradientValue[] | Pattern,\n    strokeOpacity: number | undefined,\n    opacity: number | undefined,\n    isStroke: boolean,\n    canvasContext: CanvasContext,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ): void {\n    // letterSpacing of 0 means normal, render all texts directly\n    if (letterSpacing === 0) {\n      if (isStroke) {\n        this.strokeText(\n          context,\n          object,\n          text,\n          x,\n          y,\n          stroke,\n          strokeOpacity,\n          canvasContext,\n          plugin,\n          runtime,\n        );\n      } else {\n        this.fillText(\n          context,\n          object,\n          text,\n          x,\n          y,\n          fill,\n          fillRule,\n          fillOpacity,\n          opacity,\n          canvasContext,\n          plugin,\n          runtime,\n        );\n      }\n      return;\n    }\n\n    // draw text using left align\n    const currentTextAlign = context.textAlign;\n    context.textAlign = 'left';\n\n    let currentPosition = x;\n    if (textAlign === 'center' || textAlign === 'middle') {\n      currentPosition = x - lineMetrics.width / 2;\n    } else if (textAlign === 'right' || textAlign === 'end') {\n      currentPosition = x - lineMetrics.width;\n    }\n\n    const stringArray = Array.from(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        this.strokeText(\n          context,\n          object,\n          currentChar,\n          currentPosition,\n          y,\n          stroke,\n          strokeOpacity,\n          canvasContext,\n          plugin,\n          runtime,\n        );\n      } else {\n        this.fillText(\n          context,\n          object,\n          currentChar,\n          currentPosition,\n          y,\n          fill,\n          fillRule,\n          fillOpacity,\n          opacity,\n          canvasContext,\n          plugin,\n          runtime,\n        );\n      }\n      currentWidth = context.measureText(text.substring(i + 1)).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n\n    context.textAlign = currentTextAlign;\n  }\n\n  private fillText(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    text: string,\n    x: number,\n    y: number,\n    fill: CSSRGB | CSSGradientValue[] | Pattern,\n    fillRule: 'nonzero' | 'evenodd',\n    fillOpacity: number | undefined,\n    opacity: number | undefined,\n    canvasContext: CanvasContext,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    applyFill(\n      context,\n      object,\n      fill,\n      fillRule,\n      canvasContext,\n      plugin,\n      runtime,\n      this.imagePool,\n      true,\n    );\n\n    let currentGlobalAlpha: number;\n    const applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;\n    if (applyOpacity) {\n      currentGlobalAlpha = context.globalAlpha;\n      context.globalAlpha = fillOpacity * opacity;\n    }\n    context.fillText(text, x, y);\n    if (applyOpacity) {\n      context.globalAlpha = currentGlobalAlpha;\n    }\n  }\n\n  private strokeText(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    text: string,\n    x: number,\n    y: number,\n    stroke: CSSRGB | CSSGradientValue[] | Pattern,\n    strokeOpacity: number | undefined,\n    canvasContext: CanvasContext,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    applyStroke(\n      context,\n      object,\n      stroke,\n      canvasContext,\n      plugin,\n      runtime,\n      this.imagePool,\n      true,\n    );\n\n    let currentGlobalAlpha: number;\n    const applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;\n    if (applyOpacity) {\n      currentGlobalAlpha = context.globalAlpha;\n      context.globalAlpha = strokeOpacity!;\n    }\n    context.strokeText(text, x, y);\n    if (applyOpacity) {\n      context.globalAlpha = currentGlobalAlpha;\n    }\n  }\n\n  // ---\n\n  drawToContext(\n    context: CanvasRenderingContext2D,\n    object: DisplayObject,\n    renderState: RenderState,\n    plugin: CanvasRendererPlugin,\n    runtime: GlobalRuntime,\n  ) {\n    this.render(\n      context,\n      object.parsedStyle as ParsedTextStyleProps,\n      object,\n      object.ownerDocument.defaultView.context,\n      plugin,\n      runtime,\n    );\n  }\n}\n","import { AbstractRendererPlugin, Shape } from '@antv/g-lite';\nimport type { PathGenerator } from '@antv/g-plugin-canvas-path-generator';\nimport { CanvasRendererPlugin } from './CanvasRendererPlugin';\nimport {\n  type StyleRenderer,\n  DefaultRenderer,\n  TextRenderer,\n  ImageRenderer,\n} from './shapes/styles';\nimport type { CanvasRendererPluginOptions } from './interfaces';\n\nexport * from './shapes/styles';\n\nexport class Plugin extends AbstractRendererPlugin<{\n  defaultStyleRendererFactory: Record<Shape, StyleRenderer>;\n  styleRendererFactory: Record<Shape, StyleRenderer>;\n  pathGeneratorFactory: Record<Shape, PathGenerator<any>>;\n}> {\n  name = 'canvas-renderer';\n\n  constructor(private options: Partial<CanvasRendererPluginOptions> = {}) {\n    super();\n  }\n\n  init(): void {\n    const canvasRendererPluginOptions: CanvasRendererPluginOptions = {\n      dirtyObjectNumThreshold: 500,\n      dirtyObjectRatioThreshold: 0.8,\n      ...this.options,\n    };\n\n    // @ts-ignore\n    const { imagePool } = this.context;\n\n    const defaultRenderer = new DefaultRenderer(imagePool);\n\n    const defaultStyleRendererFactory: Record<Shape, StyleRenderer> = {\n      [Shape.CIRCLE]: defaultRenderer,\n      [Shape.ELLIPSE]: defaultRenderer,\n      [Shape.RECT]: defaultRenderer,\n      [Shape.IMAGE]: new ImageRenderer(imagePool),\n      [Shape.TEXT]: new TextRenderer(imagePool),\n      [Shape.LINE]: defaultRenderer,\n      [Shape.POLYLINE]: defaultRenderer,\n      [Shape.POLYGON]: defaultRenderer,\n      [Shape.PATH]: defaultRenderer,\n      [Shape.GROUP]: undefined,\n      [Shape.HTML]: undefined,\n      [Shape.MESH]: undefined,\n      [Shape.FRAGMENT]: undefined,\n    };\n\n    this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;\n    this.context.styleRendererFactory = defaultStyleRendererFactory;\n\n    this.addRenderingPlugin(\n      new CanvasRendererPlugin(canvasRendererPluginOptions),\n    );\n  }\n  destroy(): void {\n    this.removeAllRenderingPlugins();\n\n    delete this.context.defaultStyleRendererFactory;\n    delete this.context.styleRendererFactory;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}