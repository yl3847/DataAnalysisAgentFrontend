{"ast":null,"code":"/*!\n * @antv/g-math\n * @description Geometry util\n * @version 3.0.1\n * @date 5/9/2025, 8:18:51 AM\n * @author AntVis\n * @docs https://g.antv.antgroup.com/\n */\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { isNumberEqual } from '@antv/util';\nimport { vec2 } from 'gl-matrix';\nfunction distance(x1, y1, x2, y2) {\n  var dx = x1 - x2;\n  var dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\nfunction getBBoxByArray(xArr, yArr) {\n  var minX = Math.min.apply(Math, _toConsumableArray(xArr));\n  var minY = Math.min.apply(Math, _toConsumableArray(yArr));\n  var maxX = Math.max.apply(Math, _toConsumableArray(xArr));\n  var maxY = Math.max.apply(Math, _toConsumableArray(yArr));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction piMod(angle) {\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\nfunction copysign(v1, v2) {\n  var absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\nfunction nearestPoint$4(x, y, rx, ry, x0, y0) {\n  var a = rx;\n  var b = ry;\n  // 假如椭圆半径为0则返回圆心\n  if (a === 0 || b === 0) {\n    return {\n      x: x,\n      y: y\n    };\n  }\n  // 转换成 0， 0 为中心的椭圆计算\n  var relativeX = x0 - x;\n  var relativeY = y0 - y;\n  var px = Math.abs(relativeX);\n  var py = Math.abs(relativeY);\n  var squareA = a * a;\n  var squareB = b * b;\n  // const angle0 = Math.atan2(relativeY, relativeX);\n  var t = Math.PI / 4;\n  var nearestX = 0; // 椭圆上的任一点\n  var nearestY = 0;\n  // 迭代 4 次\n  for (var i = 0; i < 4; i++) {\n    nearestX = a * Math.cos(t);\n    nearestY = b * Math.sin(t);\n    var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;\n    var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;\n    var rx1 = nearestX - ex;\n    var ry1 = nearestY - ey;\n    var qx = px - ex;\n    var qy = py - ey;\n    var r = Math.hypot(ry1, rx1);\n    var q = Math.hypot(qy, qx);\n    var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n    var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n    t += delta_t;\n    t = Math.min(Math.PI / 2, Math.max(0, t));\n  }\n  return {\n    x: x + copysign(nearestX, relativeX),\n    y: y + copysign(nearestY, relativeY)\n  };\n}\n\n// 偏导数 x\nfunction derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n  return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\n}\n\n// 偏导数 y\nfunction derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n  return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\n}\n\n// x 的极值\nfunction xExtrema(rx, ry, xRotation) {\n  return Math.atan(-ry / rx * Math.tan(xRotation));\n}\n\n// y 的极值\nfunction yExtrema(rx, ry, xRotation) {\n  return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n\n// 根据角度求 x 坐标\nfunction xAt(cx, cy, rx, ry, xRotation, angle) {\n  return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\n}\n\n// 根据角度求 y 坐标\nfunction yAt(cx, cy, rx, ry, xRotation, angle) {\n  return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\n}\n\n// 获取点在椭圆上的角度\nfunction getAngle(rx, ry, x0, y0) {\n  var angle = Math.atan2(y0 * rx, x0 * ry);\n  // 转换到 0 - 2PI 内\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n\n// 根据角度获取，x,y\nfunction getPoint(rx, ry, angle) {\n  return {\n    x: rx * Math.cos(angle),\n    y: ry * Math.sin(angle)\n  };\n}\n\n// 旋转\nfunction rotate(x, y, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return [x * cos - y * sin, x * sin + y * cos];\n}\nfunction box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {\n  var xDim = xExtrema(rx, ry, xRotation);\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var xs = [startAngle, endAngle];\n  for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n    var xAngle = xDim + i;\n    if (startAngle < endAngle) {\n      if (startAngle < xAngle && xAngle < endAngle) {\n        xs.push(xAngle);\n      }\n    } else if (endAngle < xAngle && xAngle < startAngle) {\n      xs.push(xAngle);\n    }\n  }\n  for (var _i = 0; _i < xs.length; _i++) {\n    var x = xAt(cx, cy, rx, ry, xRotation, xs[_i]);\n    if (x < minX) {\n      minX = x;\n    }\n    if (x > maxX) {\n      maxX = x;\n    }\n  }\n  var yDim = yExtrema(rx, ry, xRotation);\n  var minY = Infinity;\n  var maxY = -Infinity;\n  var ys = [startAngle, endAngle];\n  for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {\n    var yAngle = yDim + _i2;\n    if (startAngle < endAngle) {\n      if (startAngle < yAngle && yAngle < endAngle) {\n        ys.push(yAngle);\n      }\n    } else if (endAngle < yAngle && yAngle < startAngle) {\n      ys.push(yAngle);\n    }\n  }\n  for (var _i3 = 0; _i3 < ys.length; _i3++) {\n    var y = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);\n    if (y < minY) {\n      minY = y;\n    }\n    if (y > maxY) {\n      maxY = y;\n    }\n  }\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction nearestPoint$3(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n  // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n  var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n  var _relativeVector = _slicedToArray(relativeVector, 2),\n    x1 = _relativeVector[0],\n    y1 = _relativeVector[1];\n  // 计算点到椭圆的最近的点\n  var relativePoint = nearestPoint$4(0, 0, rx, ry, x1, y1);\n  // 获取点在椭圆上的角度\n  var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n  // 点没有在圆弧上\n  if (angle < startAngle) {\n    // 小于起始圆弧\n    relativePoint = getPoint(rx, ry, startAngle);\n  } else if (angle > endAngle) {\n    // 大于结束圆弧\n    relativePoint = getPoint(rx, ry, endAngle);\n  }\n  // 旋转到 xRotation 的角度\n  var vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n  return {\n    x: vector[0] + cx,\n    y: vector[1] + cy\n  };\n}\nfunction tangentAngle$4(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n  var angle = (endAngle - startAngle) * t + startAngle;\n  var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n  var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n  return piMod(Math.atan2(dy, dx));\n}\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nfunction nearestPoint$2(xArr, yArr, x, y, tCallback, length) {\n  var t = -1;\n  var d = Infinity;\n  var v0 = [x, y];\n  var segNum = 20;\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n  var increaseRate = 1 / segNum;\n  var interval = increaseRate / 10;\n  for (var i = 0; i <= segNum; i++) {\n    var _t = i * increaseRate;\n    var v1 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([_t]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([_t])))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n  // 提前终止\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0]\n    };\n  }\n  if (t === 1) {\n    var count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1]\n    };\n  }\n  d = Infinity;\n  for (var _i = 0; _i < 32; _i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n    var prev = t - interval;\n    var next = t + interval;\n    var _v = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([prev]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([prev])))];\n    var _d = distance(v0[0], v0[1], _v[0], _v[1]);\n    if (prev >= 0 && _d < d) {\n      t = prev;\n      d = _d;\n    } else {\n      var v2 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([next]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([next])))];\n      var d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n  return {\n    x: tCallback.apply(void 0, _toConsumableArray(xArr.concat([t]))),\n    y: tCallback.apply(void 0, _toConsumableArray(yArr.concat([t])))\n  };\n}\n\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nfunction snapLength(xArr, yArr) {\n  var totalLength = 0;\n  var count = xArr.length;\n  for (var i = 0; i < count; i++) {\n    var x = xArr[i];\n    var y = yArr[i];\n    var nextX = xArr[(i + 1) % count];\n    var nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n  return totalLength / 2;\n}\nfunction box$4(x1, y1, x2, y2) {\n  return getBBoxByArray([x1, x2], [y1, y2]);\n}\nfunction length$4(x1, y1, x2, y2) {\n  return distance(x1, y1, x2, y2);\n}\nfunction pointAt$3(x1, y1, x2, y2, t) {\n  return {\n    x: (1 - t) * x1 + t * x2,\n    y: (1 - t) * y1 + t * y2\n  };\n}\nfunction pointDistance$4(x1, y1, x2, y2, x, y) {\n  // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n  // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n  var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n  if (cross < 0) {\n    return distance(x1, y1, x, y);\n  }\n  var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  if (cross > lengthSquare) {\n    return distance(x2, y2, x, y);\n  }\n  return pointToLine(x1, y1, x2, y2, x, y);\n}\nfunction pointToLine(x1, y1, x2, y2, x, y) {\n  var d = [x2 - x1, y2 - y1];\n  // 如果端点相等，则判定点到点的距离\n  if (vec2.exactEquals(d, [0, 0])) {\n    return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  }\n  var u = [-d[1], d[0]];\n  vec2.normalize(u, u);\n  var a = [x - x1, y - y1];\n  return Math.abs(vec2.dot(a, u));\n}\nfunction tangentAngle$3(x1, y1, x2, y2) {\n  return Math.atan2(y2 - y1, x2 - x1);\n}\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍\n  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;\n}\nfunction derivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));\n}\nfunction extrema$1(p0, p1, p2, p3) {\n  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n  var b = 6 * p0 - 12 * p1 + 6 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var extremas = [];\n  var t1;\n  var t2;\n  var discSqrt;\n  if (isNumberEqual(a, 0)) {\n    if (!isNumberEqual(b, 0)) {\n      t1 = -c / b;\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n    if (isNumberEqual(disc, 0)) {\n      extremas.push(-b / (2 * a));\n    } else if (disc > 0) {\n      discSqrt = Math.sqrt(disc);\n      t1 = (-b + discSqrt) / (2 * a);\n      t2 = (-b - discSqrt) / (2 * a);\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n      if (t2 >= 0 && t2 <= 1) {\n        extremas.push(t2);\n      }\n    }\n  }\n  return extremas;\n}\n\n// 分割贝塞尔曲线\nfunction divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {\n  // 划分点\n  var xt = cubicAt(x1, x2, x3, x4, t);\n  var yt = cubicAt(y1, y2, y3, y4, t);\n  // 计算两点之间的差值点\n  var c1 = pointAt$3(x1, y1, x2, y2, t);\n  var c2 = pointAt$3(x2, y2, x3, y3, t);\n  var c3 = pointAt$3(x3, y3, x4, y4, t);\n  var c12 = pointAt$3(c1.x, c1.y, c2.x, c2.y, t);\n  var c23 = pointAt$3(c2.x, c2.y, c3.x, c3.y, t);\n  return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];\n}\n\n// 使用迭代法取贝塞尔曲线的长度，二阶和三阶分开写，更清晰和便于调试\nfunction cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {\n  if (iterationCount === 0) {\n    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);\n  }\n  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);\n  var left = [].concat(_toConsumableArray(cubics[0]), [iterationCount - 1]);\n  var right = [].concat(_toConsumableArray(cubics[1]), [iterationCount - 1]);\n  return cubicLength.apply(void 0, _toConsumableArray(left)) + cubicLength.apply(void 0, _toConsumableArray(right));\n}\nfunction box$3(x1, y1, x2, y2, x3, y3, x4, y4) {\n  var xArr = [x1, x4];\n  var yArr = [y1, y4];\n  var xExtrema = extrema$1(x1, x2, x3, x4);\n  var yExtrema = extrema$1(y1, y2, y3, y4);\n  for (var i = 0; i < xExtrema.length; i++) {\n    xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));\n  }\n  for (var _i = 0; _i < yExtrema.length; _i++) {\n    yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[_i]));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nfunction length$3(x1, y1, x2, y2, x3, y3, x4, y4) {\n  // 迭代三次，划分成 8 段求长度\n  return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);\n}\nfunction nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {\n  return nearestPoint$2([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);\n}\nfunction pointDistance$3(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {\n  var point = nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);\n  return distance(point.x, point.y, x0, y0);\n}\nfunction pointAt$2(x1, y1, x2, y2, x3, y3, x4, y4, t) {\n  return {\n    x: cubicAt(x1, x2, x3, x4, t),\n    y: cubicAt(y1, y2, y3, y4, t)\n  };\n}\nfunction tangentAngle$2(x1, y1, x2, y2, x3, y3, x4, y4, t) {\n  var dx = derivativeAt(x1, x2, x3, x4, t);\n  var dy = derivativeAt(y1, y2, y3, y4, t);\n  return piMod(Math.atan2(dy, dx));\n}\nfunction analyzePoints(points) {\n  // 计算每段的长度和总的长度\n  var totalLength = 0;\n  var segments = [];\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    var length = distance(from[0], from[1], to[0], to[1]);\n    var seg = {\n      from: from,\n      to: to,\n      length: length\n    };\n    segments.push(seg);\n    totalLength += length;\n  }\n  return {\n    segments: segments,\n    totalLength: totalLength\n  };\n}\nfunction lengthOfSegment(points) {\n  if (points.length < 2) {\n    return 0;\n  }\n  var totalLength = 0;\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n  return totalLength;\n}\n\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nfunction pointAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n  var _analyzePoints = analyzePoints(points),\n    segments = _analyzePoints.segments,\n    totalLength = _analyzePoints.totalLength;\n  // 多个点有可能重合\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1]\n    };\n  }\n  // 计算比例\n  var startRatio = 0;\n  var point = null;\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n      to = seg.to;\n    var currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      var localRatio = (t - startRatio) / currentRatio;\n      point = pointAt$3(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return point;\n}\n\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nfunction angleAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n  var _analyzePoints2 = analyzePoints(points),\n    segments = _analyzePoints2.segments,\n    totalLength = _analyzePoints2.totalLength;\n  // 计算比例\n  var startRatio = 0;\n  var angle = 0;\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n      to = seg.to;\n    var currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return angle;\n}\nfunction distanceAtSegment(points, x, y) {\n  var minDistance = Infinity;\n  for (var i = 0; i < points.length - 1; i++) {\n    var point = points[i];\n    var nextPoint = points[i + 1];\n    var _distance = pointDistance$4(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n    if (_distance < minDistance) {\n      minDistance = _distance;\n    }\n  }\n  return minDistance;\n}\nfunction box$2(points) {\n  var xArr = [];\n  var yArr = [];\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    xArr.push(point[0]);\n    yArr.push(point[1]);\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nfunction length$2(points) {\n  return lengthOfSegment(points);\n}\nfunction pointAt$1(points, t) {\n  return pointAtSegments(points, t);\n}\nfunction pointDistance$2(points, x, y) {\n  return distanceAtSegment(points, x, y);\n}\nfunction tangentAngle$1(points, t) {\n  return angleAtSegments(points, t);\n}\nfunction getAllPoints(points) {\n  var tmp = points.slice(0);\n  if (points.length) {\n    tmp.push(points[0]);\n  }\n  return tmp;\n}\nfunction box$1(points) {\n  return box$2(points);\n}\nfunction length$1(points) {\n  return lengthOfSegment(getAllPoints(points));\n}\nfunction pointAt(points, t) {\n  return pointAtSegments(getAllPoints(points), t);\n}\nfunction pointDistance$1(points, x, y) {\n  return distanceAtSegment(getAllPoints(points), x, y);\n}\nfunction tangentAngle(points, t) {\n  return angleAtSegments(getAllPoints(points), t);\n}\n\n// 差值公式\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n\n// 求极值\nfunction extrema(p0, p1, p2) {\n  var a = p0 + p2 - 2 * p1;\n  if (isNumberEqual(a, 0)) {\n    return [0.5];\n  }\n  var rst = (p0 - p1) / a;\n  if (rst <= 1 && rst >= 0) {\n    return [rst];\n  }\n  return [];\n}\n\n// 分割贝塞尔曲线\nfunction divideQuadratic(x1, y1, x2, y2, x3, y3, t) {\n  // 划分点\n  var xt = quadraticAt(x1, x2, x3, t);\n  var yt = quadraticAt(y1, y2, y3, t);\n\n  // 分割的第一条曲线的控制点\n  var controlPoint1 = pointAt$3(x1, y1, x2, y2, t);\n  // 分割的第二条曲线的控制点\n  var controlPoint2 = pointAt$3(x2, y2, x3, y3, t);\n  return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];\n}\n\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {\n  if (iterationCount === 0) {\n    return (distance(x1, y1, x2, y2) + distance(x2, y2, x3, y3) + distance(x1, y1, x3, y3)) / 2;\n  }\n  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n  var left = quadratics[0];\n  var right = quadratics[1];\n  left.push(iterationCount - 1);\n  right.push(iterationCount - 1);\n  return quadraticLength.apply(void 0, _toConsumableArray(left)) + quadraticLength.apply(void 0, _toConsumableArray(right));\n}\nfunction box(x1, y1, x2, y2, x3, y3) {\n  var xExtrema = extrema(x1, x2, x3)[0];\n  var yExtrema = extrema(y1, y2, y3)[0];\n  // 控制点不加入 box 的计算\n  var xArr = [x1, x3];\n  var yArr = [y1, y3];\n  if (xExtrema !== undefined) {\n    xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n  }\n  if (yExtrema !== undefined) {\n    yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nfunction length(x1, y1, x2, y2, x3, y3) {\n  return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n}\nfunction nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0) {\n  return nearestPoint$2([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n}\nfunction pointDistance(x1, y1, x2, y2, x3, y3, x0, y0) {\n  var point = nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n  return distance(point.x, point.y, x0, y0);\n}\nexport { box$5 as arcBox, nearestPoint$3 as arcNearestPoint, tangentAngle$4 as arcTangentAngle, box$3 as cubicBox, length$3 as cubicLength, nearestPoint$1 as cubicNearestPoint, pointAt$2 as cubicPointAt, pointDistance$3 as cubicPointDistance, tangentAngle$2 as cubicTangentAngle, distance, box$4 as lineBox, length$4 as lineLength, pointAt$3 as linePointAt, pointDistance$4 as linePointDistance, pointToLine as linePointToLine, tangentAngle$3 as lineTangentAngle, box$1 as polygonBox, length$1 as polygonLength, pointAt as polygonPointAt, pointDistance$1 as polygonPointDistance, tangentAngle as polygonTangentAngle, box$2 as polylineBox, length$2 as polylineLength, pointAt$1 as polylinePointAt, pointDistance$2 as polylinePointDistance, tangentAngle$1 as polylineTangentAngle, box as quadBox, length as quadLength, nearestPoint as quadNearestPoint, pointDistance as quadPointDistance };","map":{"version":3,"names":["distance","x1","y1","x2","y2","dx","dy","Math","sqrt","getBBoxByArray","xArr","yArr","minX","min","apply","_toConsumableArray","minY","maxX","max","maxY","x","y","width","height","piMod","angle","PI","copysign","v1","v2","absv","abs","nearestPoint$4","rx","ry","x0","y0","a","b","relativeX","relativeY","px","py","squareA","squareB","t","nearestX","nearestY","i","cos","sin","ex","pow","ey","rx1","ry1","qx","qy","r","hypot","q","delta_c","asin","delta_t","derivativeXAt","cx","cy","xRotation","startAngle","endAngle","derivativeYAt","xExtrema","atan","tan","yExtrema","xAt","yAt","getAngle","atan2","getPoint","rotate","box$5","xDim","Infinity","xs","xAngle","push","_i","length","yDim","ys","_i2","yAngle","_i3","nearestPoint$3","relativeVector","_relativeVector","_slicedToArray","relativePoint","vector","tangentAngle$4","EPSILON","nearestPoint$2","tCallback","d","v0","segNum","increaseRate","interval","_t","concat","d1","count","prev","next","_v","_d","d2","snapLength","totalLength","nextX","nextY","box$4","length$4","pointAt$3","pointDistance$4","cross","lengthSquare","pointToLine","vec2","exactEquals","u","normalize","dot","tangentAngle$3","cubicAt","p0","p1","p2","p3","onet","derivativeAt","extrema$1","c","extremas","t1","t2","discSqrt","isNumberEqual","disc","divideCubic","x3","y3","x4","y4","xt","yt","c1","c2","c3","c12","c23","cubicLength","iterationCount","cubics","left","right","box$3","length$3","nearestPoint$1","pointDistance$3","point","pointAt$2","tangentAngle$2","analyzePoints","points","segments","from","to","seg","lengthOfSegment","pointAtSegments","_analyzePoints","startRatio","currentRatio","localRatio","angleAtSegments","_analyzePoints2","distanceAtSegment","minDistance","nextPoint","_distance","box$2","length$2","pointAt$1","pointDistance$2","tangentAngle$1","getAllPoints","tmp","slice","box$1","length$1","pointAt","pointDistance$1","tangentAngle","quadraticAt","extrema","rst","divideQuadratic","controlPoint1","controlPoint2","quadraticLength","quadratics","box","undefined","nearestPoint","pointDistance"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/util.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/ellipse.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/arc.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/bezier.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/line.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/cubic.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/segments.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/polyline.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/polygon.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-math/src/quadratic.ts"],"sourcesContent":["import type { BBox } from './types';\n\nexport function distance(x1: number, y1: number, x2: number, y2: number) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function getBBoxByArray(xArr: number[], yArr: number[]): BBox {\n  const minX = Math.min(...xArr);\n  const minY = Math.min(...yArr);\n  const maxX = Math.max(...xArr);\n  const maxY = Math.max(...yArr);\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nexport function getBBoxRange(x1: number, y1: number, x2: number, y2: number) {\n  return {\n    minX: Math.min(x1, x2),\n    maxX: Math.max(x1, x2),\n    minY: Math.min(y1, y2),\n    maxY: Math.max(y1, y2),\n  };\n}\n\nexport function piMod(angle: number) {\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n","import type { BBox, Point } from './types';\nimport { distance, piMod } from './util';\n\nfunction copysign(v1: number, v2: number) {\n  const absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\n\nexport function box(x: number, y: number, rx: number, ry: number): BBox {\n  return {\n    x: x - rx,\n    y: y - ry,\n    width: rx * 2,\n    height: ry * 2,\n  };\n}\nexport function length(x: number, y: number, rx: number, ry: number) {\n  return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n}\nexport function nearestPoint(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  x0: number,\n  y0: number,\n) {\n  const a = rx;\n  const b = ry;\n  // 假如椭圆半径为0则返回圆心\n  if (a === 0 || b === 0) {\n    return {\n      x,\n      y,\n    };\n  }\n  // 转换成 0， 0 为中心的椭圆计算\n  const relativeX = x0 - x;\n  const relativeY = y0 - y;\n  const px = Math.abs(relativeX);\n  const py = Math.abs(relativeY);\n  const squareA = a * a;\n  const squareB = b * b;\n  // const angle0 = Math.atan2(relativeY, relativeX);\n  let t = Math.PI / 4;\n  let nearestX = 0; // 椭圆上的任一点\n  let nearestY = 0;\n  // 迭代 4 次\n  for (let i = 0; i < 4; i++) {\n    nearestX = a * Math.cos(t);\n    nearestY = b * Math.sin(t);\n\n    const ex = ((squareA - squareB) * Math.cos(t) ** 3) / a;\n    const ey = ((squareB - squareA) * Math.sin(t) ** 3) / b;\n    const rx1 = nearestX - ex;\n    const ry1 = nearestY - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n    const r = Math.hypot(ry1, rx1);\n    const q = Math.hypot(qy, qx);\n\n    const delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n    const delta_t =\n      delta_c /\n      Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n\n    t += delta_t;\n    t = Math.min(Math.PI / 2, Math.max(0, t));\n  }\n\n  return {\n    x: x + copysign(nearestX, relativeX),\n    y: y + copysign(nearestY, relativeY),\n  };\n}\nexport function pointDistance(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  x0: number,\n  y0: number,\n) {\n  const np = nearestPoint(x, y, rx, ry, x0, y0);\n  return distance(np.x, np.y, x0, y0);\n}\nexport function pointAt(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  t: number,\n): Point {\n  const angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n  return {\n    x: x + rx * Math.cos(angle),\n    y: y + ry * Math.sin(angle),\n  };\n}\nexport function tangentAngle(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  t: number,\n) {\n  const angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n  // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n  const tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n  // 也可以使用指定点的切线方程计算，成本有些高\n  // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n  // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n  // if (angle >= 0 && angle <= Math.PI) {\n  //   tangentAngle += Math.PI;\n  // }\n\n  return piMod(tangentAngle);\n}\n","import { nearestPoint as ellipseNearestPoint } from './ellipse';\nimport type { BBox, Point } from './types';\nimport { distance, piMod } from './util';\n\n// 偏导数 x\nfunction derivativeXAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  angle: number,\n) {\n  return (\n    -1 * rx * Math.cos(xRotation) * Math.sin(angle) -\n    ry * Math.sin(xRotation) * Math.cos(angle)\n  );\n}\n\n// 偏导数 y\nfunction derivativeYAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  angle: number,\n) {\n  return (\n    -1 * rx * Math.sin(xRotation) * Math.sin(angle) +\n    ry * Math.cos(xRotation) * Math.cos(angle)\n  );\n}\n\n// x 的极值\nfunction xExtrema(rx: number, ry: number, xRotation: number) {\n  return Math.atan((-ry / rx) * Math.tan(xRotation));\n}\n\n// y 的极值\nfunction yExtrema(rx: number, ry: number, xRotation: number) {\n  return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n\n// 根据角度求 x 坐标\nfunction xAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  angle: number,\n) {\n  return (\n    rx * Math.cos(xRotation) * Math.cos(angle) -\n    ry * Math.sin(xRotation) * Math.sin(angle) +\n    cx\n  );\n}\n\n// 根据角度求 y 坐标\nfunction yAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  angle: number,\n) {\n  return (\n    rx * Math.sin(xRotation) * Math.cos(angle) +\n    ry * Math.cos(xRotation) * Math.sin(angle) +\n    cy\n  );\n}\n\n// 获取点在椭圆上的角度\nfunction getAngle(rx: number, ry: number, x0: number, y0: number) {\n  const angle = Math.atan2(y0 * rx, x0 * ry);\n  // 转换到 0 - 2PI 内\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n\n// 根据角度获取，x,y\nfunction getPoint(rx: number, ry: number, angle: number): Point {\n  return {\n    x: rx * Math.cos(angle),\n    y: ry * Math.sin(angle),\n  };\n}\n\n// 旋转\nfunction rotate(x: number, y: number, angle: number) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return [x * cos - y * sin, x * sin + y * cos];\n}\n\nexport function box(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n): BBox {\n  const xDim = xExtrema(rx, ry, xRotation);\n  let minX = Infinity;\n  let maxX = -Infinity;\n  const xs = [startAngle, endAngle];\n  for (let i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n    const xAngle = xDim + i;\n    if (startAngle < endAngle) {\n      if (startAngle < xAngle && xAngle < endAngle) {\n        xs.push(xAngle);\n      }\n    } else if (endAngle < xAngle && xAngle < startAngle) {\n      xs.push(xAngle);\n    }\n  }\n\n  for (let i = 0; i < xs.length; i++) {\n    const x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n    if (x < minX) {\n      minX = x;\n    }\n    if (x > maxX) {\n      maxX = x;\n    }\n  }\n\n  const yDim = yExtrema(rx, ry, xRotation);\n  let minY = Infinity;\n  let maxY = -Infinity;\n  const ys = [startAngle, endAngle];\n  for (let i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n    const yAngle = yDim + i;\n    if (startAngle < endAngle) {\n      if (startAngle < yAngle && yAngle < endAngle) {\n        ys.push(yAngle);\n      }\n    } else if (endAngle < yAngle && yAngle < startAngle) {\n      ys.push(yAngle);\n    }\n  }\n\n  for (let i = 0; i < ys.length; i++) {\n    const y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n    if (y < minY) {\n      minY = y;\n    }\n    if (y > maxY) {\n      maxY = y;\n    }\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nexport function nearestPoint(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  x0: number,\n  y0: number,\n) {\n  // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n  const relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n  const [x1, y1] = relativeVector;\n  // 计算点到椭圆的最近的点\n  let relativePoint = ellipseNearestPoint(0, 0, rx, ry, x1, y1);\n  // 获取点在椭圆上的角度\n  const angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n  // 点没有在圆弧上\n  if (angle < startAngle) {\n    // 小于起始圆弧\n    relativePoint = getPoint(rx, ry, startAngle);\n  } else if (angle > endAngle) {\n    // 大于结束圆弧\n    relativePoint = getPoint(rx, ry, endAngle);\n  }\n  // 旋转到 xRotation 的角度\n  const vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n  return {\n    x: vector[0] + cx,\n    y: vector[1] + cy,\n  };\n}\n\nexport function pointDistance(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  x0: number,\n  y0: number,\n) {\n  const np = nearestPoint(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    x0,\n    y0,\n  );\n  return distance(np.x, np.y, x0, y0);\n}\n\nexport function pointAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  t: number,\n): Point {\n  const angle = (endAngle - startAngle) * t + startAngle;\n  return {\n    x: xAt(cx, cy, rx, ry, xRotation, angle),\n    y: yAt(cx, cy, rx, ry, xRotation, angle),\n  };\n}\n\nexport function tangentAngle(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  t: number,\n) {\n  const angle = (endAngle - startAngle) * t + startAngle;\n  const dx = derivativeXAt(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    angle,\n  );\n  const dy = derivativeYAt(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    angle,\n  );\n  return piMod(Math.atan2(dy, dx));\n}\n","import { distance } from './util';\nimport type { Point, PointTuple } from './types';\n\nconst EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nexport function nearestPoint(\n  xArr: number[],\n  yArr: number[],\n  x: number,\n  y: number,\n  tCallback: (...arr: number[]) => number,\n  length?: number,\n): Point {\n  let t = -1;\n  let d = Infinity;\n  const v0: PointTuple = [x, y];\n\n  let segNum = 20;\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n  const increaseRate = 1 / segNum;\n\n  let interval = increaseRate / 10;\n\n  for (let i = 0; i <= segNum; i++) {\n    const _t = i * increaseRate;\n    const v1: PointTuple = [\n      tCallback(...xArr.concat([_t])),\n      tCallback(...yArr.concat([_t])),\n    ];\n\n    const d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n  // 提前终止\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0],\n    };\n  }\n  if (t === 1) {\n    const count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1],\n    };\n  }\n  d = Infinity;\n\n  for (let i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    const prev = t - interval;\n    const next = t + interval;\n\n    const v1 = [\n      tCallback(...xArr.concat([prev])),\n      tCallback(...yArr.concat([prev])),\n    ];\n\n    const d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      const v2 = [\n        tCallback(...xArr.concat([next])),\n        tCallback(...yArr.concat([next])),\n      ];\n      const d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  return {\n    x: tCallback(...xArr.concat([t])),\n    y: tCallback(...yArr.concat([t])),\n  };\n}\n\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nexport function snapLength(xArr: number[], yArr: number[]) {\n  let totalLength = 0;\n  const count = xArr.length;\n  for (let i = 0; i < count; i++) {\n    const x = xArr[i];\n    const y = yArr[i];\n    const nextX = xArr[(i + 1) % count];\n    const nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n  return totalLength / 2;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { BBox, Point } from './types';\nimport { distance, getBBoxByArray } from './util';\n\nexport function box(x1: number, y1: number, x2: number, y2: number): BBox {\n  return getBBoxByArray([x1, x2], [y1, y2]);\n}\n\nexport function length(x1: number, y1: number, x2: number, y2: number) {\n  return distance(x1, y1, x2, y2);\n}\n\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  t: number,\n): Point {\n  return {\n    x: (1 - t) * x1 + t * x2,\n    y: (1 - t) * y1 + t * y2,\n  };\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x: number,\n  y: number,\n): number {\n  // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n  // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n  const cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n  if (cross < 0) {\n    return distance(x1, y1, x, y);\n  }\n  const lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  if (cross > lengthSquare) {\n    return distance(x2, y2, x, y);\n  }\n  return pointToLine(x1, y1, x2, y2, x, y);\n}\n\nexport function pointToLine(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x: number,\n  y: number,\n) {\n  const d: [number, number] = [x2 - x1, y2 - y1];\n  // 如果端点相等，则判定点到点的距离\n  if (vec2.exactEquals(d, [0, 0])) {\n    return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  }\n  const u: [number, number] = [-d[1], d[0]];\n  vec2.normalize(u, u);\n  const a: [number, number] = [x - x1, y - y1];\n  return Math.abs(vec2.dot(a, u));\n}\n\nexport function tangentAngle(x1: number, y1: number, x2: number, y2: number) {\n  return Math.atan2(y2 - y1, x2 - x1);\n}\n","import { isNumberEqual } from '@antv/util';\nimport { nearestPoint as bezierNearestPoint, snapLength } from './bezier';\nimport { pointAt as linePointAt } from './line';\nimport type { Point } from './types';\nimport { distance, getBBoxByArray, piMod } from './util';\n\nfunction cubicAt(p0: number, p1: number, p2: number, p3: number, t: number) {\n  const onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍\n  return (\n    onet * onet * onet * p0 +\n    3 * p1 * t * onet * onet +\n    3 * p2 * t * t * onet +\n    p3 * t * t * t\n  );\n}\n\nfunction derivativeAt(\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n  t: number,\n) {\n  const onet = 1 - t;\n  return (\n    3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2))\n  );\n}\n\nfunction extrema(p0: number, p1: number, p2: number, p3: number) {\n  const a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n  const b = 6 * p0 - 12 * p1 + 6 * p2;\n  const c = 3 * p1 - 3 * p0;\n  const extremas = [];\n  let t1: number;\n  let t2: number;\n  let discSqrt: number;\n\n  if (isNumberEqual(a, 0)) {\n    if (!isNumberEqual(b, 0)) {\n      t1 = -c / b;\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n    }\n  } else {\n    const disc = b * b - 4 * a * c;\n    if (isNumberEqual(disc, 0)) {\n      extremas.push(-b / (2 * a));\n    } else if (disc > 0) {\n      discSqrt = Math.sqrt(disc);\n      t1 = (-b + discSqrt) / (2 * a);\n      t2 = (-b - discSqrt) / (2 * a);\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n      if (t2 >= 0 && t2 <= 1) {\n        extremas.push(t2);\n      }\n    }\n  }\n  return extremas;\n}\n\n// 分割贝塞尔曲线\nfunction divideCubic(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n): [number, number, number, number, number, number, number, number][] {\n  // 划分点\n  const xt = cubicAt(x1, x2, x3, x4, t);\n  const yt = cubicAt(y1, y2, y3, y4, t);\n  // 计算两点之间的差值点\n  const c1 = linePointAt(x1, y1, x2, y2, t);\n  const c2 = linePointAt(x2, y2, x3, y3, t);\n  const c3 = linePointAt(x3, y3, x4, y4, t);\n  const c12 = linePointAt(c1.x, c1.y, c2.x, c2.y, t);\n  const c23 = linePointAt(c2.x, c2.y, c3.x, c3.y, t);\n  return [\n    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],\n    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4],\n  ];\n}\n\n// 使用迭代法取贝塞尔曲线的长度，二阶和三阶分开写，更清晰和便于调试\nfunction cubicLength(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  iterationCount: number,\n): number {\n  if (iterationCount === 0) {\n    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);\n  }\n  const cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);\n  const left: [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ] = [...cubics[0], iterationCount - 1];\n  const right: [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ] = [...cubics[1], iterationCount - 1];\n  return cubicLength(...left) + cubicLength(...right);\n}\n\nexport function box(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n) {\n  const xArr = [x1, x4];\n  const yArr = [y1, y4];\n  const xExtrema = extrema(x1, x2, x3, x4);\n  const yExtrema = extrema(y1, y2, y3, y4);\n  for (let i = 0; i < xExtrema.length; i++) {\n    xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));\n  }\n  for (let i = 0; i < yExtrema.length; i++) {\n    yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\n\nexport function length(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n) {\n  // 迭代三次，划分成 8 段求长度\n  return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);\n}\n\nexport function nearestPoint(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  x0: number,\n  y0: number,\n  length?: number,\n) {\n  return bezierNearestPoint(\n    [x1, x2, x3, x4],\n    [y1, y2, y3, y4],\n    x0,\n    y0,\n    cubicAt,\n    length,\n  );\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  x0: number,\n  y0: number,\n  length?: number,\n) {\n  const point = nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);\n  return distance(point.x, point.y, x0, y0);\n}\n\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n): Point {\n  return {\n    x: cubicAt(x1, x2, x3, x4, t),\n    y: cubicAt(y1, y2, y3, y4, t),\n  };\n}\n\nexport function divide(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n) {\n  return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);\n}\n\nexport function tangentAngle(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n) {\n  const dx = derivativeAt(x1, x2, x3, x4, t);\n  const dy = derivativeAt(y1, y2, y3, y4, t);\n  return piMod(Math.atan2(dy, dx));\n}\n","import { pointAt, pointDistance } from './line';\nimport type { Point, PointTuple, Segment } from './types';\nimport { distance } from './util';\n\nfunction analyzePoints(points: PointTuple[]) {\n  // 计算每段的长度和总的长度\n  let totalLength = 0;\n  const segments: Segment[] = [];\n  for (let i = 0; i < points.length - 1; i++) {\n    const from = points[i];\n    const to = points[i + 1];\n    const length = distance(from[0], from[1], to[0], to[1]);\n    const seg = {\n      from,\n      to,\n      length,\n    };\n    segments.push(seg);\n    totalLength += length;\n  }\n  return { segments, totalLength };\n}\n\nexport function lengthOfSegment(points: PointTuple[]) {\n  if (points.length < 2) {\n    return 0;\n  }\n  let totalLength = 0;\n  for (let i = 0; i < points.length - 1; i++) {\n    const from = points[i];\n    const to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n  return totalLength;\n}\n\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nexport function pointAtSegments(points: PointTuple[], t: number): Point | null {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n  const { segments, totalLength } = analyzePoints(points);\n  // 多个点有可能重合\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1],\n    };\n  }\n  // 计算比例\n  let startRatio = 0;\n  let point = null;\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    const { from, to } = seg;\n    const currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      const localRatio = (t - startRatio) / currentRatio;\n      point = pointAt(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return point;\n}\n\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nexport function angleAtSegments(points: PointTuple[], t: number) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n  const { segments, totalLength } = analyzePoints(points);\n  // 计算比例\n  let startRatio = 0;\n  let angle = 0;\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    const { from, to } = seg;\n    const currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return angle;\n}\n\nexport function distanceAtSegment(points: PointTuple[], x: number, y: number) {\n  let minDistance = Infinity;\n  for (let i = 0; i < points.length - 1; i++) {\n    const point = points[i];\n    const nextPoint = points[i + 1];\n    const distance = pointDistance(\n      point[0],\n      point[1],\n      nextPoint[0],\n      nextPoint[1],\n      x,\n      y,\n    );\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  }\n  return minDistance;\n}\n","import {\n  angleAtSegments,\n  distanceAtSegment,\n  lengthOfSegment,\n  pointAtSegments,\n} from './segments';\nimport type { BBox, PointTuple } from './types';\nimport { getBBoxByArray } from './util';\n\nexport function box(points: PointTuple[]): BBox {\n  const xArr = [];\n  const yArr = [];\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    xArr.push(point[0]);\n    yArr.push(point[1]);\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nexport function length(points: PointTuple[]) {\n  return lengthOfSegment(points);\n}\nexport function pointAt(points: PointTuple[], t: number) {\n  return pointAtSegments(points, t);\n}\nexport function pointDistance(points: PointTuple[], x: number, y: number) {\n  return distanceAtSegment(points, x, y);\n}\nexport function tangentAngle(points: PointTuple[], t: number) {\n  return angleAtSegments(points, t);\n}\n","import { box as polylineBox } from './polyline';\nimport {\n  angleAtSegments,\n  distanceAtSegment,\n  lengthOfSegment,\n  pointAtSegments,\n} from './segments';\nimport type { PointTuple } from './types';\n\nfunction getAllPoints(points: PointTuple[]) {\n  const tmp = points.slice(0);\n  if (points.length) {\n    tmp.push(points[0]);\n  }\n  return tmp;\n}\n\nexport function box(points: PointTuple[]) {\n  return polylineBox(points);\n}\nexport function length(points: PointTuple[]) {\n  return lengthOfSegment(getAllPoints(points));\n}\nexport function pointAt(points: PointTuple[], t: number) {\n  return pointAtSegments(getAllPoints(points), t);\n}\nexport function pointDistance(points: PointTuple[], x: number, y: number) {\n  return distanceAtSegment(getAllPoints(points), x, y);\n}\nexport function tangentAngle(points: PointTuple[], t: number) {\n  return angleAtSegments(getAllPoints(points), t);\n}\n","import { isNumberEqual } from '@antv/util';\nimport { nearestPoint as nearestPointBezier } from './bezier';\nimport { pointAt as linePointAt } from './line';\nimport type { Point } from './types';\nimport { distance, getBBoxByArray, piMod } from './util';\n\n// 差值公式\nfunction quadraticAt(p0: number, p1: number, p2: number, t: number) {\n  const onet = 1 - t;\n  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n\n// 求极值\nfunction extrema(p0: number, p1: number, p2: number) {\n  const a = p0 + p2 - 2 * p1;\n  if (isNumberEqual(a, 0)) {\n    return [0.5];\n  }\n  const rst = (p0 - p1) / a;\n  if (rst <= 1 && rst >= 0) {\n    return [rst];\n  }\n  return [];\n}\n\nfunction derivativeAt(p0: number, p1: number, p2: number, t: number) {\n  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n}\n\n// 分割贝塞尔曲线\nfunction divideQuadratic(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  // 划分点\n  const xt = quadraticAt(x1, x2, x3, t);\n  const yt = quadraticAt(y1, y2, y3, t);\n\n  // 分割的第一条曲线的控制点\n  const controlPoint1 = linePointAt(x1, y1, x2, y2, t);\n  // 分割的第二条曲线的控制点\n  const controlPoint2 = linePointAt(x2, y2, x3, y3, t);\n  return [\n    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],\n    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3],\n  ];\n}\n\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  iterationCount: number,\n): number {\n  if (iterationCount === 0) {\n    return (\n      (distance(x1, y1, x2, y2) +\n        distance(x2, y2, x3, y3) +\n        distance(x1, y1, x3, y3)) /\n      2\n    );\n  }\n  const quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n  const left = quadratics[0] as [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ];\n  const right = quadratics[1] as [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ];\n  left.push(iterationCount - 1);\n  right.push(iterationCount - 1);\n  return quadraticLength(...left) + quadraticLength(...right);\n}\n\nexport function box(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n) {\n  const xExtrema = extrema(x1, x2, x3)[0];\n  const yExtrema = extrema(y1, y2, y3)[0];\n  // 控制点不加入 box 的计算\n  const xArr = [x1, x3];\n  const yArr = [y1, y3];\n  if (xExtrema !== undefined) {\n    xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n  }\n  if (yExtrema !== undefined) {\n    yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\n\nexport function length(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n) {\n  return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n}\n\nexport function nearestPoint(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x0: number,\n  y0: number,\n) {\n  return nearestPointBezier([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x0: number,\n  y0: number,\n) {\n  const point = nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n  return distance(point.x, point.y, x0, y0);\n}\n\n// interpolationAt: quadraticAt,\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n): Point {\n  return {\n    x: quadraticAt(x1, x2, x3, t),\n    y: quadraticAt(y1, y2, y3, t),\n  };\n}\n\nexport function divide(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  return divideQuadratic(x1, y1, x2, y2, x3, y3, t);\n}\n\nexport function tangentAngle(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  const dx = derivativeAt(x1, x2, x3, t);\n  const dy = derivativeAt(y1, y2, y3, t);\n  const angle = Math.atan2(dy, dx);\n  return piMod(angle);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}