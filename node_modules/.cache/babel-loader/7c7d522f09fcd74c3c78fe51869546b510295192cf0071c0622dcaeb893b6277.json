{"ast":null,"code":"// import { CustomElement, DisplayObjectConfig, Group } from '../../shapes';\n// import { deepMix, isNull } from '@antv/util';\n// import { maybeAppend, normalPadding, select } from '../../util';\n// import { Button } from './button';\n// import { SliderAxis } from './sliderAxis';\n// import { CellAxis } from './cellAxis';\n// import { SpeedControl } from './speedcontrol';\n// import { Checkbox } from './checkbox';\n// import { DEFAULT_TIMELINE_STYLE } from './constants';\n// import type { TimelineStyleProps, PlayAxisStyleProps } from './types';\n// import { normalSelection } from './playAxis';\nvar Timeline = /** @class */function () {\n  function Timeline() {}\n  return Timeline;\n}();\nexport { Timeline };\n// export class Timeline extends CustomElement<TimelineStyleProps> {\n//   private speed = 1;\n//   private singleMode = false;\n//   private playing = false;\n//   private selection: [number, number] = [0, 0];\n//   constructor(options: DisplayObjectConfig<TimelineStyleProps>) {\n//     super(deepMix({}, { style: DEFAULT_TIMELINE_STYLE }, options));\n//     this.singleMode = this.style.singleMode || false;\n//     this.selection = normalSelection(this.style.selection, this.singleMode);\n//   }\n//   public update(cfg: Partial<TimelineStyleProps> = {}) {\n//     this.attr(deepMix({}, this.attributes, cfg));\n//     if (cfg.singleMode !== undefined) {\n//       this.singleMode = cfg.singleMode;\n//     }\n//     if (cfg.selection) {\n//       this.selection = normalSelection(cfg.selection, this.singleMode);\n//     }\n//     this.render();\n//   }\n//   private get styles(): Required<TimelineStyleProps> {\n//     return deepMix({}, DEFAULT_TIMELINE_STYLE, this.attributes);\n//   }\n//   private render() {\n//     const { width, height, controlPosition, speedControl, singleModeControl } = this.styles;\n//     const [pt = 0, pr = 0, pb, pl = pr] = normalPadding(this.styles.padding);\n//     const container = maybeAppend(this, '.container', 'g')\n//       .attr('className', 'container')\n//       .style('x', pl)\n//       .style('y', pt)\n//       .node();\n//     const length = this.style.orientation! === 'vertical' ? height - (pt + pb) : width - (pl + pr);\n//     const layout = layoutControl(controlPosition, length, this.styles);\n//     this.renderAxis(container, layout);\n//     this.renderControlButton(container, layout);\n//     maybeAppend(container, '.timeline-speed-control', () => new SpeedControl({}))\n//       .attr('className', 'timeline-speed-control')\n//       .call((selection) => {\n//         if (speedControl === null) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as SpeedControl).update({\n//           x: layout.speedControl.x,\n//           y: layout.speedControl.y,\n//           ...speedControl,\n//           initialSpeed: this.speed,\n//         });\n//       });\n//     maybeAppend(container, '.timeline-single-control', () => new Checkbox({}))\n//       .attr('className', 'timeline-single-control')\n//       .call((selection) => {\n//         if (singleModeControl === null) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Checkbox).update({\n//           x: layout.singleModeControl.x,\n//           y: layout.singleModeControl.y,\n//           ...singleModeControl,\n//           active: this.singleMode,\n//         });\n//       });\n//   }\n//   private renderAxis(container: Group, layout: Layout) {\n//     const { data: timeData } = this.styles;\n//     const type = this.styles.type || 'slider';\n//     let axis = select(container).select('.timeline-axis').node() as PlayAxis | undefined;\n//     const Ctor = type === 'cell' ? CellAxis : SliderAxis;\n//     if (axis && axis.style.tag !== `${type}-axis`) {\n//       axis.remove();\n//       this.removeChild(axis);\n//     }\n//     axis = maybeAppend(container, '.timeline-axis', () => new Ctor({}))\n//       .attr('className', 'timeline-axis')\n//       .call((selection) => {\n//         (selection.node() as PlayAxis).update({\n//           x: layout.axis.x,\n//           y: layout.axis.y,\n//           length: layout.axis.length,\n//           data: timeData,\n//           selection: this.selection,\n//           orientation: this.style.orientation!,\n//           playInterval: this.style.playInterval! / this.speed,\n//           singleMode: this.singleMode,\n//           ...(this.style.playAxis || {}),\n//         });\n//         (selection.node() as PlayAxis).update({\n//           handleStyle: {\n//             cursor: this.style.orientation === 'vertical' ? 'ns-resize' : 'ew-resize',\n//           },\n//         });\n//       })\n//       .node() as PlayAxis;\n//   }\n//   private renderControlButton(container: Group, layout: Layout) {\n//     const playButtonSize = layout.playBtn.size || 0;\n//     const prevButtonSize = layout.prevBtn.size || 0;\n//     const nextButtonSize = layout.nextBtn?.size || 0;\n//     maybeAppend(container, '.timeline-prev-btn', () => new Button({}))\n//       .attr('className', 'timeline-prev-btn')\n//       .call((selection) => {\n//         if (!prevButtonSize) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.prevBtn || {}),\n//           x: layout.prevBtn.x,\n//           y: layout.prevBtn.y,\n//           size: prevButtonSize,\n//           symbol: 'timeline-prev-button',\n//         });\n//         (selection.node() as Button).update({\n//           markerStyle: {\n//             transformOrigin: 'center',\n//             transform: this.style.orientation === 'vertical' ? 'rotate(90deg)' : '',\n//           },\n//         });\n//       });\n//     maybeAppend(container, '.timeline-play-btn', () => new Button({}))\n//       .attr('className', 'timeline-play-btn')\n//       .call((selection) => {\n//         if (!playButtonSize) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           backgroundStyle: { radius: (layout.playBtn.size || 0) / 2 },\n//         });\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.playBtn || {}),\n//           x: layout.playBtn.x,\n//           y: layout.playBtn.y,\n//           size: playButtonSize,\n//           symbol: !this.playing ? 'timeline-stop-button' : 'timeline-play-button',\n//         });\n//       });\n//     maybeAppend(container, '.timeline-next-btn', () => new Button({}))\n//       .attr('className', 'timeline-next-btn')\n//       .call((selection) => {\n//         if (!nextButtonSize) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.nextBtn || {}),\n//           x: layout.nextBtn.x,\n//           y: layout.nextBtn.y,\n//           size: nextButtonSize,\n//           symbol: 'timeline-next-button',\n//         });\n//         (selection.node() as Button).update({\n//           markerStyle: {\n//             transformOrigin: 'center',\n//             transform: this.style.orientation === 'vertical' ? 'rotate(90deg)' : '',\n//           },\n//         });\n//       });\n//     if (this.style.autoPlay && !this.playing) {\n//       this.playing = true;\n//       select(this)\n//         .select('.timeline-axis')\n//         .call((selection) => (selection.node() as PlayAxis)?.play());\n//       select(this)\n//         .select('.timeline-play-btn')\n//         .call((selection) => (selection.node() as Button)?.update({ symbol: 'timeline-play-button' }));\n//     }\n//     if (!this.style.autoPlay && this.playing) {\n//       this.playing = false;\n//       select(this)\n//         .select('.timeline-axis')\n//         .call((selection) => (selection.node() as PlayAxis)?.stop());\n//       select(this)\n//         .select('.timeline-play-btn')\n//         .call((selection) => (selection.node() as Button)?.update({ symbol: 'timeline-stop-button' }));\n//     }\n//   }\n//   private bindEvents() {\n//     const axis = select(this).select('.timeline-axis').node() as SliderAxis;\n//     const playStopBtn = select(this).select('.timeline-play-btn').node() as Button;\n//     if (playStopBtn) {\n//       select(playStopBtn).on('pointerdown', (evt: any) => {\n//         if (this.playing) {\n//           this.playing = false;\n//           axis.stop();\n//           playStopBtn.update({ symbol: 'timeline-stop-button' });\n//         } else {\n//           this.playing = true;\n//           axis.play();\n//           playStopBtn.update({ symbol: 'timeline-play-button' });\n//         }\n//       });\n//     }\n//     select(this).on('timelineStopped', () => {\n//       this.playing = false;\n//       playStopBtn?.update({ symbol: 'timeline-stop-button' });\n//     });\n//     select(this).on('speedChanged', (evt: any) => {\n//       this.speed = evt.detail.speed;\n//       axis.update({ playInterval: this.style.playInterval! / this.speed });\n//     });\n//     select(this)\n//       .select('.timeline-prev-btn')\n//       .on('pointerdown', () => axis.prev());\n//     select(this)\n//       .select('.timeline-next-btn')\n//       .on('pointerdown', () => axis.next());\n//     select(this).on('singleModeChanged', (evt: any) => {\n//       this.singleMode = evt.detail.active;\n//       this.selection = normalSelection(this.selection, this.singleMode);\n//       this.render();\n//     });\n//     select(this).on('selectionChanged', (evt: any) => {\n//       this.selection = evt.detail.selection;\n//     });\n//   }\n// }","map":{"version":3,"names":["Timeline"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/component/src/ui/timeline/index.ts"],"sourcesContent":["// import { CustomElement, DisplayObjectConfig, Group } from '../../shapes';\n// import { deepMix, isNull } from '@antv/util';\n// import { maybeAppend, normalPadding, select } from '../../util';\n// import { Button } from './button';\n// import { SliderAxis } from './sliderAxis';\n// import { CellAxis } from './cellAxis';\n// import { SpeedControl } from './speedcontrol';\n// import { Checkbox } from './checkbox';\n// import { DEFAULT_TIMELINE_STYLE } from './constants';\n// import type { TimelineStyleProps, PlayAxisStyleProps } from './types';\n// import { normalSelection } from './playAxis';\n\n// export type TimelineOptions = DisplayObjectConfig<TimelineStyleProps>;\n\n// type PlayAxis = SliderAxis | CellAxis;\n// type BBox = { x: number; y: number; length?: number; size?: number };\n// type Layout = {\n//   axis: BBox;\n//   playBtn: BBox;\n//   prevBtn: BBox;\n//   nextBtn: BBox;\n//   speedControl: BBox;\n//   singleModeControl: BBox;\n// };\n\n// function getAxisLabelHeight(options: PlayAxisStyleProps | null | undefined): number {\n//   const cfg: Required<PlayAxisStyleProps['label']> = deepMix({}, DEFAULT_TIMELINE_STYLE.playAxis, options).label;\n//   if (!cfg) return 0;\n\n//   return (cfg.tickLine?.len || 0) + (cfg.tickPadding || 0) + (Number(cfg.style.fontSize) || 0) + 2;\n// }\n\n// function layoutControl(position: string, length: number, props: TimelineStyleProps): Layout {\n//   const cfg: Required<TimelineStyleProps> = deepMix({}, DEFAULT_TIMELINE_STYLE, props);\n//   const { type, playAxis, controlButton, speedControl, singleModeControl } = cfg;\n//   const axisLabelPosition = playAxis?.label?.position || -1;\n//   const axisCellSpacing = playAxis?.spacing ?? (CellAxis.defaultOptions?.style?.spacing || 0);\n//   let axisSize =\n//     playAxis?.size ||\n//     (type === 'cell' ? CellAxis.defaultOptions?.style?.size : SliderAxis.defaultOptions?.style?.size) ||\n//     4;\n//   axisSize += type === 'cell' ? axisCellSpacing : 0;\n//   const [axisPt, axisPr, axisPb, axisPl] = normalPadding(playAxis?.appendPadding || 0);\n\n//   const buttonGap = controlButton?.spacing || 0;\n//   const playButtonSize = isNull(controlButton) || isNull(controlButton?.playBtn) ? 0 : controlButton?.playBtn?.size!;\n//   const prevButtonSize = isNull(controlButton) || isNull(controlButton?.prevBtn) ? 0 : controlButton?.prevBtn?.size!;\n//   const nextButtonSize = isNull(controlButton) || isNull(controlButton?.nextBtn) ? 0 : controlButton?.nextBtn?.size!;\n//   const prevButtonOffset = playButtonSize / 2 + prevButtonSize / 2 + buttonGap;\n//   const nextButtonOffset = playButtonSize / 2 + nextButtonSize / 2 + buttonGap;\n//   const speedControlMarkerSize = speedControl === null ? 0 : speedControl?.markerSize!;\n//   const speedControlSize = speedControlMarkerSize * 2;\n//   const speedControlWidth = speedControl === null ? 0 : speedControl?.width!;\n//   const speedControlHeight = speedControlSize * 2 + speedControlMarkerSize / 2;\n//   const singleControlWidth = singleModeControl === null ? 0 : singleModeControl?.width!;\n//   const singleControlSize = singleModeControl === null ? 0 : singleModeControl?.size! + 2; /** lineWidth of stroke. */\n\n//   if (cfg.orientation === 'vertical') {\n//     // Remain 30px for placing axis label.\n//     const centerX = axisPl + (axisLabelPosition === -1 ? 30 : 0);\n//     const axisX = centerX + (type === 'cell' ? 0 : axisSize / 2);\n//     const buttonX = centerX + axisSize / 2;\n\n//     const singleModeControlY = length - singleControlSize;\n//     const speedControlY = singleModeControlY - 4 - speedControlHeight;\n//     const nextButtonY = speedControlY - buttonGap - nextButtonSize / 2;\n//     const playBtnY = prevButtonSize + buttonGap + playButtonSize / 2;\n//     const axisY = playBtnY + playButtonSize / 2 + buttonGap + axisPt;\n//     const axisEndY = nextButtonY - buttonGap - nextButtonSize / 2 - axisPb;\n//     const axisLength = axisEndY - axisY;\n\n//     return {\n//       axis: { x: axisX, y: axisY, length: axisLength },\n//       prevBtn: { x: buttonX, y: prevButtonSize / 2, size: prevButtonSize },\n//       playBtn: { x: buttonX, y: playBtnY, size: playButtonSize },\n//       nextBtn: { x: buttonX, y: nextButtonY, size: nextButtonSize },\n//       speedControl: { x: centerX - speedControlWidth / 2, y: speedControlY, size: speedControlWidth },\n//       singleModeControl: { x: 0, y: singleModeControlY },\n//     };\n//   }\n\n//   const singleControlX = length - singleControlWidth;\n//   const speedControlX = singleControlX - 8 - speedControlWidth;\n//   const axisLabelHeight = getAxisLabelHeight(playAxis);\n//   const axisY = (axisLabelPosition === -1 ? axisLabelHeight : 0) + (type === 'cell' ? 0 : axisSize / 2) + axisPt;\n\n//   if (position === 'bottom') {\n//     const playBtnX = length / 2;\n//     const playBtnY = axisY + (axisLabelPosition === 1 ? axisLabelHeight : 0) + axisSize + playButtonSize / 2 + axisPb;\n//     const speedControlY = axisY + (axisLabelPosition === 1 ? axisLabelHeight : 0) + axisSize + axisPb;\n//     return {\n//       axis: { x: axisPl, y: axisY, length: length - (axisPl + axisPr) },\n//       playBtn: { x: playBtnX, y: playBtnY, size: playButtonSize },\n//       prevBtn: { x: playBtnX - prevButtonOffset, y: playBtnY, size: prevButtonSize },\n//       nextBtn: { x: playBtnX + nextButtonOffset, y: playBtnY, size: nextButtonSize },\n//       // SpeedControl align playAxis.\n//       speedControl: { x: speedControlX, y: speedControlY, size: speedControlWidth },\n//       singleModeControl: { x: singleControlX, y: speedControlY + speedControlSize - singleControlSize / 2 },\n//     };\n//   }\n\n//   const playBtnY = type === 'cell' ? axisY + axisSize / 2 : axisY;\n//   // PlayButton and speedControl is middle align.\n//   let speedControlY = axisLabelPosition === 1 ? axisY + speedControlMarkerSize / 2 : axisY - speedControlHeight;\n//   if (type === 'cell' && axisLabelPosition === -1) {\n//     speedControlY = axisLabelHeight + axisSize - speedControlHeight;\n//   }\n//   if (position === 'left') {\n//     const prevBtnX = prevButtonSize / 2;\n//     const playBtnX = prevBtnX + prevButtonOffset;\n//     const nextBtnX = playBtnX + nextButtonOffset;\n//     const axisX = nextBtnX + nextButtonSize / 2 + axisPl;\n//     const axisLength = speedControlX - axisPr - axisX;\n//     return {\n//       axis: { x: axisX, y: axisY, length: axisLength },\n//       prevBtn: { x: prevBtnX, y: playBtnY, size: prevButtonSize },\n//       playBtn: { x: playBtnX, y: playBtnY, size: playButtonSize },\n//       nextBtn: { x: nextBtnX, y: playBtnY, size: nextButtonSize },\n//       speedControl: { x: speedControlX, y: speedControlY, size: speedControlWidth },\n//       singleModeControl: { x: singleControlX, y: speedControlY + speedControlSize - singleControlSize / 2 },\n//     };\n//   }\n\n//   const nextBtnX = speedControlX - (nextButtonSize / 2 + buttonGap);\n//   const playBtnX = nextBtnX - nextButtonOffset;\n//   const prevBtnX = playBtnX - prevButtonOffset;\n//   const axisX = axisPl;\n//   return {\n//     axis: { x: axisX, y: axisY, length: prevBtnX - prevButtonSize / 2 - axisPr - axisX },\n//     playBtn: { x: playBtnX, y: playBtnY, size: playButtonSize },\n//     prevBtn: { x: prevBtnX, y: playBtnY, size: prevButtonSize },\n//     nextBtn: { x: nextBtnX, y: playBtnY, size: nextButtonSize },\n//     speedControl: { x: speedControlX, y: speedControlY, size: speedControlWidth },\n//     singleModeControl: { x: singleControlX, y: speedControlY + speedControlSize - singleControlSize / 2 },\n//   };\n// }\n\nexport interface TimelineOptions {}\n\nexport class Timeline {}\n\n// export class Timeline extends CustomElement<TimelineStyleProps> {\n//   private speed = 1;\n\n//   private singleMode = false;\n\n//   private playing = false;\n\n//   private selection: [number, number] = [0, 0];\n\n//   constructor(options: DisplayObjectConfig<TimelineStyleProps>) {\n//     super(deepMix({}, { style: DEFAULT_TIMELINE_STYLE }, options));\n//     this.singleMode = this.style.singleMode || false;\n//     this.selection = normalSelection(this.style.selection, this.singleMode);\n//   }\n\n//   public update(cfg: Partial<TimelineStyleProps> = {}) {\n//     this.attr(deepMix({}, this.attributes, cfg));\n//     if (cfg.singleMode !== undefined) {\n//       this.singleMode = cfg.singleMode;\n//     }\n//     if (cfg.selection) {\n//       this.selection = normalSelection(cfg.selection, this.singleMode);\n//     }\n\n//     this.render();\n//   }\n\n//   private get styles(): Required<TimelineStyleProps> {\n//     return deepMix({}, DEFAULT_TIMELINE_STYLE, this.attributes);\n//   }\n\n//   private render() {\n//     const { width, height, controlPosition, speedControl, singleModeControl } = this.styles;\n//     const [pt = 0, pr = 0, pb, pl = pr] = normalPadding(this.styles.padding);\n\n//     const container = maybeAppend(this, '.container', 'g')\n//       .attr('className', 'container')\n//       .style('x', pl)\n//       .style('y', pt)\n//       .node();\n\n//     const length = this.style.orientation! === 'vertical' ? height - (pt + pb) : width - (pl + pr);\n//     const layout = layoutControl(controlPosition, length, this.styles);\n\n//     this.renderAxis(container, layout);\n//     this.renderControlButton(container, layout);\n\n//     maybeAppend(container, '.timeline-speed-control', () => new SpeedControl({}))\n//       .attr('className', 'timeline-speed-control')\n//       .call((selection) => {\n//         if (speedControl === null) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as SpeedControl).update({\n//           x: layout.speedControl.x,\n//           y: layout.speedControl.y,\n//           ...speedControl,\n//           initialSpeed: this.speed,\n//         });\n//       });\n\n//     maybeAppend(container, '.timeline-single-control', () => new Checkbox({}))\n//       .attr('className', 'timeline-single-control')\n//       .call((selection) => {\n//         if (singleModeControl === null) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Checkbox).update({\n//           x: layout.singleModeControl.x,\n//           y: layout.singleModeControl.y,\n//           ...singleModeControl,\n//           active: this.singleMode,\n//         });\n//       });\n//   }\n\n//   private renderAxis(container: Group, layout: Layout) {\n//     const { data: timeData } = this.styles;\n//     const type = this.styles.type || 'slider';\n\n//     let axis = select(container).select('.timeline-axis').node() as PlayAxis | undefined;\n//     const Ctor = type === 'cell' ? CellAxis : SliderAxis;\n//     if (axis && axis.style.tag !== `${type}-axis`) {\n//       axis.remove();\n//       this.removeChild(axis);\n//     }\n//     axis = maybeAppend(container, '.timeline-axis', () => new Ctor({}))\n//       .attr('className', 'timeline-axis')\n//       .call((selection) => {\n//         (selection.node() as PlayAxis).update({\n//           x: layout.axis.x,\n//           y: layout.axis.y,\n//           length: layout.axis.length,\n//           data: timeData,\n//           selection: this.selection,\n//           orientation: this.style.orientation!,\n//           playInterval: this.style.playInterval! / this.speed,\n//           singleMode: this.singleMode,\n//           ...(this.style.playAxis || {}),\n//         });\n//         (selection.node() as PlayAxis).update({\n//           handleStyle: {\n//             cursor: this.style.orientation === 'vertical' ? 'ns-resize' : 'ew-resize',\n//           },\n//         });\n//       })\n//       .node() as PlayAxis;\n//   }\n\n//   private renderControlButton(container: Group, layout: Layout) {\n//     const playButtonSize = layout.playBtn.size || 0;\n//     const prevButtonSize = layout.prevBtn.size || 0;\n//     const nextButtonSize = layout.nextBtn?.size || 0;\n//     maybeAppend(container, '.timeline-prev-btn', () => new Button({}))\n//       .attr('className', 'timeline-prev-btn')\n//       .call((selection) => {\n//         if (!prevButtonSize) {\n//           selection.remove();\n\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.prevBtn || {}),\n//           x: layout.prevBtn.x,\n//           y: layout.prevBtn.y,\n//           size: prevButtonSize,\n//           symbol: 'timeline-prev-button',\n//         });\n//         (selection.node() as Button).update({\n//           markerStyle: {\n//             transformOrigin: 'center',\n//             transform: this.style.orientation === 'vertical' ? 'rotate(90deg)' : '',\n//           },\n//         });\n//       });\n\n//     maybeAppend(container, '.timeline-play-btn', () => new Button({}))\n//       .attr('className', 'timeline-play-btn')\n//       .call((selection) => {\n//         if (!playButtonSize) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           backgroundStyle: { radius: (layout.playBtn.size || 0) / 2 },\n//         });\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.playBtn || {}),\n//           x: layout.playBtn.x,\n//           y: layout.playBtn.y,\n//           size: playButtonSize,\n//           symbol: !this.playing ? 'timeline-stop-button' : 'timeline-play-button',\n//         });\n//       });\n\n//     maybeAppend(container, '.timeline-next-btn', () => new Button({}))\n//       .attr('className', 'timeline-next-btn')\n//       .call((selection) => {\n//         if (!nextButtonSize) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.nextBtn || {}),\n//           x: layout.nextBtn.x,\n//           y: layout.nextBtn.y,\n//           size: nextButtonSize,\n//           symbol: 'timeline-next-button',\n//         });\n//         (selection.node() as Button).update({\n//           markerStyle: {\n//             transformOrigin: 'center',\n//             transform: this.style.orientation === 'vertical' ? 'rotate(90deg)' : '',\n//           },\n//         });\n//       });\n\n//     if (this.style.autoPlay && !this.playing) {\n//       this.playing = true;\n//       select(this)\n//         .select('.timeline-axis')\n//         .call((selection) => (selection.node() as PlayAxis)?.play());\n//       select(this)\n//         .select('.timeline-play-btn')\n//         .call((selection) => (selection.node() as Button)?.update({ symbol: 'timeline-play-button' }));\n//     }\n//     if (!this.style.autoPlay && this.playing) {\n//       this.playing = false;\n//       select(this)\n//         .select('.timeline-axis')\n//         .call((selection) => (selection.node() as PlayAxis)?.stop());\n//       select(this)\n//         .select('.timeline-play-btn')\n//         .call((selection) => (selection.node() as Button)?.update({ symbol: 'timeline-stop-button' }));\n//     }\n//   }\n\n//   private bindEvents() {\n//     const axis = select(this).select('.timeline-axis').node() as SliderAxis;\n//     const playStopBtn = select(this).select('.timeline-play-btn').node() as Button;\n//     if (playStopBtn) {\n//       select(playStopBtn).on('pointerdown', (evt: any) => {\n//         if (this.playing) {\n//           this.playing = false;\n//           axis.stop();\n//           playStopBtn.update({ symbol: 'timeline-stop-button' });\n//         } else {\n//           this.playing = true;\n//           axis.play();\n//           playStopBtn.update({ symbol: 'timeline-play-button' });\n//         }\n//       });\n//     }\n\n//     select(this).on('timelineStopped', () => {\n//       this.playing = false;\n//       playStopBtn?.update({ symbol: 'timeline-stop-button' });\n//     });\n\n//     select(this).on('speedChanged', (evt: any) => {\n//       this.speed = evt.detail.speed;\n//       axis.update({ playInterval: this.style.playInterval! / this.speed });\n//     });\n\n//     select(this)\n//       .select('.timeline-prev-btn')\n//       .on('pointerdown', () => axis.prev());\n//     select(this)\n//       .select('.timeline-next-btn')\n//       .on('pointerdown', () => axis.next());\n\n//     select(this).on('singleModeChanged', (evt: any) => {\n//       this.singleMode = evt.detail.active;\n//       this.selection = normalSelection(this.selection, this.singleMode);\n//       this.render();\n//     });\n\n//     select(this).on('selectionChanged', (evt: any) => {\n//       this.selection = evt.detail.selection;\n//     });\n//   }\n// }\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiIA,IAAAA,QAAA;EAAA,SAAAA,SAAA,GAAuB;EAAA,OAAAA,QAAC;AAAD,CAAC,CAAxB;;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}