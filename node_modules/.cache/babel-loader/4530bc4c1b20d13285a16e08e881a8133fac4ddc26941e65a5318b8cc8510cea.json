{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { clone, isEqual, clamp } from '@antv/util';\nimport { catmullRom2Bezier } from '../../util';\n/**\n * 根据数据获得每条线各点x，y值\n */\nexport function dataToLines(data, scales) {\n  var _a;\n  var x = scales.x,\n    y = scales.y;\n  var _b = __read(y.getOptions().range || [0, 0], 2),\n    max = _b[0],\n    min = _b[1];\n  if (min > max) _a = __read([max, min], 2), min = _a[0], max = _a[1];\n  return data.map(function (points) {\n    var lines = points.map(function (val, idx) {\n      return [x.map(idx), clamp(y.map(val), min, max)];\n    });\n    return lines;\n  });\n}\n/**\n * 根据线的点数据生成折线path\n */\nexport function lineToLinePath(line, reverse) {\n  if (reverse === void 0) {\n    reverse = false;\n  }\n  var M = reverse ? line.length - 1 : 0;\n  var linePath = line.map(function (point, idx) {\n    return __spreadArray([idx === M ? 'M' : 'L'], __read(point), false);\n  });\n  return reverse ? linePath.reverse() : linePath;\n}\n/**\n * 根据点数据生成曲线path\n * @param points 点数据\n * @param reverse 是否倒序生成\n */\nexport function lineToCurvePath(line, reverse) {\n  if (reverse === void 0) {\n    reverse = false;\n  }\n  if (line.length <= 2) {\n    return lineToLinePath(line);\n  }\n  var data = [];\n  var len = line.length;\n  for (var idx = 0; idx < len; idx += 1) {\n    var point = reverse ? line[len - idx - 1] : line[idx];\n    if (!isEqual(point, data.slice(-2))) {\n      data.push.apply(data, __spreadArray([], __read(point), false));\n    }\n  }\n  var path = catmullRom2Bezier(data, false);\n  if (reverse) {\n    path.unshift(__spreadArray(['M'], __read(line[len - 1]), false));\n  } else {\n    path.unshift(__spreadArray(['M'], __read(line[0]), false));\n  }\n  return path;\n}\n/**\n * 根据baseline将path闭合\n */\nexport function closePathByBaseLine(path, width, baseline) {\n  var closedPath = clone(path);\n  closedPath.push(['L', width, baseline], ['L', 0, baseline], ['Z']);\n  return closedPath;\n}\n/**\n * 将多条线的点数据生成区域path\n * 可以是折线或曲线\n */\nexport function linesToAreaPaths(lines, smooth, width, baseline) {\n  return lines.map(function (line) {\n    return closePathByBaseLine(smooth ? lineToCurvePath(line) : lineToLinePath(line), width, baseline);\n  });\n}\n/**\n * 生成折线堆叠区域封闭图形路径\n */\nexport function linesToStackAreaPaths(lines, width, baseline) {\n  var paths = [];\n  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {\n    var currLine = lines[idx];\n    var currCurvePath = lineToLinePath(currLine);\n    var path = void 0;\n    if (idx === 0) {\n      // 最底部的线直接与y=0连接成闭合区域\n      path = closePathByBaseLine(currCurvePath, width, baseline);\n    } else {\n      // 计算下一根曲线的反向路径\n      var belowLine = lines[idx - 1];\n      var belowCurvePath = lineToLinePath(belowLine, true);\n      belowCurvePath[0][0] = 'L';\n      // 连接路径\n      path = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [['Z']], false);\n    }\n    paths.push(path);\n  }\n  return paths;\n}\n/**\n * 生成曲线堆叠区域封闭图形路径\n */\nexport function linesToStackCurveAreaPaths(lines, width, baseline) {\n  var paths = [];\n  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {\n    var currLine = lines[idx];\n    var currCurvePath = lineToCurvePath(currLine);\n    var path = void 0;\n    if (idx === 0) {\n      // 最底部的线直接与y=0连接成闭合区域\n      path = closePathByBaseLine(currCurvePath, width, baseline);\n    } else {\n      // 计算下一根曲线的反向路径\n      var belowLine = lines[idx - 1];\n      var belowCurvePath = lineToCurvePath(belowLine, true);\n      /**\n       * 将线条连接成闭合路径\n       *  M C C C C C\n       *  A ～ -> ～ B\n       *  ⬆        ⬇\n       *  D ～ <- ～ C\n       *  C C C C C M\n       *\n       */\n      var A = currLine[0];\n      // const B = currLine[currLine.length - 1];\n      // const C = belowLine[belowLine.length - 1];\n      // const D = belowLine[0];\n      // 将反向曲线开头 M X Y 改为 L X Y\n      belowCurvePath[0][0] = 'L';\n      // 连接路径\n      path = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(['M'], __read(A), false), ['Z']], false);\n    }\n    paths.push(path);\n  }\n  return paths;\n}","map":{"version":3,"names":["clone","isEqual","clamp","catmullRom2Bezier","dataToLines","data","scales","x","y","_b","__read","getOptions","range","max","min","_a","map","points","lines","val","idx","lineToLinePath","line","reverse","M","length","linePath","point","__spreadArray","lineToCurvePath","len","slice","push","apply","path","unshift","closePathByBaseLine","width","baseline","closedPath","linesToAreaPaths","smooth","linesToStackAreaPaths","paths","currLine","currCurvePath","belowLine","belowCurvePath","linesToStackCurveAreaPaths","A"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/component/src/ui/sparkline/path.ts"],"sourcesContent":["import { clone, isEqual, clamp } from '@antv/util';\nimport { catmullRom2Bezier } from '../../util';\nimport type { Data, Line, Point, Scales } from './types';\n\n/**\n * 根据数据获得每条线各点x，y值\n */\nexport function dataToLines(data: Data, scales: Scales): Line[] {\n  const { x, y } = scales;\n\n  let [max, min] = (y.getOptions().range || [0, 0]) as [number, number];\n  if (min > max) [min, max] = [max, min];\n\n  return data.map((points) => {\n    const lines = points.map((val: number, idx: number) => {\n      return [x.map(idx), clamp(y.map(val), min, max)] as Point;\n    });\n    return lines;\n  });\n}\n\n/**\n * 根据线的点数据生成折线path\n */\nexport function lineToLinePath(line: Line, reverse = false) {\n  const M = reverse ? line.length - 1 : 0;\n  const linePath = line.map((point: Point, idx: number) => [idx === M ? 'M' : 'L', ...point]) as any[];\n  return reverse ? linePath.reverse() : linePath;\n}\n\n/**\n * 根据点数据生成曲线path\n * @param points 点数据\n * @param reverse 是否倒序生成\n */\nexport function lineToCurvePath(line: Line, reverse = false) {\n  if (line.length <= 2) {\n    return lineToLinePath(line);\n  }\n  const data = [];\n  const len = line.length;\n  for (let idx = 0; idx < len; idx += 1) {\n    const point = reverse ? line[len - idx - 1] : line[idx];\n    if (!isEqual(point, data.slice(-2))) {\n      data.push(...point);\n    }\n  }\n  const path = catmullRom2Bezier(data, false);\n  if (reverse) {\n    path.unshift(['M', ...line[len - 1]]);\n  } else {\n    path.unshift(['M', ...line[0]]);\n  }\n  return path as any[];\n}\n\n/**\n * 根据baseline将path闭合\n */\nexport function closePathByBaseLine(path: any[], width: number, baseline: number) {\n  const closedPath = clone(path);\n  closedPath.push(['L', width, baseline], ['L', 0, baseline], ['Z']);\n  return closedPath;\n}\n\n/**\n * 将多条线的点数据生成区域path\n * 可以是折线或曲线\n */\nexport function linesToAreaPaths(lines: Line[], smooth: boolean, width: number, baseline: number) {\n  return lines.map((line) => {\n    return closePathByBaseLine(smooth ? lineToCurvePath(line) : lineToLinePath(line), width, baseline);\n  });\n}\n\n/**\n * 生成折线堆叠区域封闭图形路径\n */\nexport function linesToStackAreaPaths(lines: Line[], width: number, baseline: number) {\n  const paths: any[][] = [];\n  for (let idx = lines.length - 1; idx >= 0; idx -= 1) {\n    const currLine = lines[idx];\n    const currCurvePath = lineToLinePath(currLine);\n    let path: any[];\n    if (idx === 0) {\n      // 最底部的线直接与y=0连接成闭合区域\n      path = closePathByBaseLine(currCurvePath, width, baseline);\n    } else {\n      // 计算下一根曲线的反向路径\n      const belowLine = lines[idx - 1];\n      const belowCurvePath = lineToLinePath(belowLine, true);\n      belowCurvePath[0][0] = 'L';\n\n      // 连接路径\n      path = [...currCurvePath, ...belowCurvePath, ['Z']];\n    }\n    paths.push(path);\n  }\n\n  return paths;\n}\n\n/**\n * 生成曲线堆叠区域封闭图形路径\n */\nexport function linesToStackCurveAreaPaths(lines: Line[], width: number, baseline: number) {\n  const paths: any[][] = [];\n  for (let idx = lines.length - 1; idx >= 0; idx -= 1) {\n    const currLine = lines[idx];\n    const currCurvePath = lineToCurvePath(currLine);\n    let path: any[];\n    if (idx === 0) {\n      // 最底部的线直接与y=0连接成闭合区域\n      path = closePathByBaseLine(currCurvePath, width, baseline);\n    } else {\n      // 计算下一根曲线的反向路径\n      const belowLine = lines[idx - 1];\n      const belowCurvePath = lineToCurvePath(belowLine, true);\n\n      /**\n       * 将线条连接成闭合路径\n       *  M C C C C C\n       *  A ～ -> ～ B\n       *  ⬆        ⬇\n       *  D ～ <- ～ C\n       *  C C C C C M\n       *\n       */\n      const A = currLine[0];\n      // const B = currLine[currLine.length - 1];\n      // const C = belowLine[belowLine.length - 1];\n      // const D = belowLine[0];\n\n      // 将反向曲线开头 M X Y 改为 L X Y\n      belowCurvePath[0][0] = 'L';\n      // 连接路径\n      path = [...currCurvePath, ...belowCurvePath, ['M', ...A], ['Z']];\n    }\n    paths.push(path);\n  }\n  return paths;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}