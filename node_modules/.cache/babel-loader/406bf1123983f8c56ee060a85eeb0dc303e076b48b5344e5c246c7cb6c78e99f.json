{"ast":null,"code":"import dfs from './dfs';\nimport getConnectedComponents, { detectStrongConnectComponents } from './connected-component';\nimport { getNeighbors } from './util';\nvar detectDirectedCycle = function detectDirectedCycle(graphData) {\n  var cycle = null;\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a;\n  var dfsParentMap = {};\n  // 所有没有被访问的节点集合\n  var unvisitedSet = {};\n  // 正在被访问的节点集合\n  var visitingSet = {};\n  // 所有已经被访问过的节点集合\n  var visitedSet = {};\n  // 初始化 unvisitedSet\n  nodes.forEach(function (node) {\n    unvisitedSet[node.id] = node;\n  });\n  var callbacks = {\n    enter: function enter(_a) {\n      var currentNode = _a.current,\n        previousNode = _a.previous;\n      if (visitingSet[currentNode]) {\n        // 如果当前节点正在访问中，则说明检测到环路了\n        cycle = {};\n        var currentCycleNode = currentNode;\n        var previousCycleNode = previousNode;\n        while (previousCycleNode !== currentNode) {\n          cycle[currentCycleNode] = previousCycleNode;\n          currentCycleNode = previousCycleNode;\n          previousCycleNode = dfsParentMap[previousCycleNode];\n        }\n        cycle[currentCycleNode] = previousCycleNode;\n      } else {\n        // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除\n        visitingSet[currentNode] = currentNode;\n        delete unvisitedSet[currentNode];\n        // 更新 DSF parents 列表\n        dfsParentMap[currentNode] = previousNode;\n      }\n    },\n    leave: function leave(_a) {\n      var currentNode = _a.current;\n      // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，\n      // 同时也意味着当前节点的所有邻居节点都被访问过了\n      visitedSet[currentNode] = currentNode;\n      delete visitingSet[currentNode];\n    },\n    allowTraversal: function allowTraversal(_a) {\n      var nextNode = _a.next;\n      // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历\n      if (cycle) {\n        return false;\n      }\n      // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了\n      return !visitedSet[nextNode];\n    }\n  };\n  // 开始遍历节点\n  while (Object.keys(unvisitedSet).length) {\n    // 从第一个节点开始进行 DFS 遍历\n    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\n    dfs(graphData, firsetUnVisitedKey, callbacks);\n  }\n  return cycle;\n};\n/**\n * 检测无向图中的所有Base cycles\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回一组base cycles\n */\nexport var detectAllUndirectedCycle = function detectAllUndirectedCycle(graphData, nodeIds, include) {\n  var _a, _b;\n  if (include === void 0) {\n    include = true;\n  }\n  var allCycles = [];\n  var components = getConnectedComponents(graphData, false);\n  // loop through all connected components\n  for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {\n    var component = components_1[_i];\n    if (!component.length) continue;\n    var root = component[0];\n    var rootId = root.id;\n    var stack = [root];\n    var parent_1 = (_a = {}, _a[rootId] = root, _a);\n    var used = (_b = {}, _b[rootId] = new Set(), _b);\n    // walk a spanning tree to find cycles\n    while (stack.length > 0) {\n      var curNode = stack.pop();\n      var curNodeId = curNode.id;\n      var neighbors = getNeighbors(curNodeId, graphData.edges);\n      var _loop_1 = function _loop_1(i) {\n        var _c;\n        var neighborId = neighbors[i];\n        var neighbor = graphData.nodes.find(function (node) {\n          return node.id === neighborId;\n        });\n        // const neighborId = neighbor.get('id');\n        if (neighborId === curNodeId) {\n          // 自环\n          allCycles.push((_c = {}, _c[neighborId] = curNode, _c));\n        } else if (!(neighborId in used)) {\n          // visit a new node\n          parent_1[neighborId] = curNode;\n          stack.push(neighbor);\n          used[neighborId] = new Set([curNode]);\n        } else if (!used[curNodeId].has(neighbor)) {\n          // a cycle found\n          var cycleValid = true;\n          var cyclePath = [neighbor, curNode];\n          var p = parent_1[curNodeId];\n          while (used[neighborId].size && !used[neighborId].has(p)) {\n            cyclePath.push(p);\n            if (p === parent_1[p.id]) break;else p = parent_1[p.id];\n          }\n          cyclePath.push(p);\n          if (nodeIds && include) {\n            // 如果有指定包含的节点\n            cycleValid = false;\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.id) > -1;\n            }) > -1) {\n              cycleValid = true;\n            }\n          } else if (nodeIds && !include) {\n            // 如果有指定不包含的节点\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.id) > -1;\n            }) > -1) {\n              cycleValid = false;\n            }\n          }\n          // 把 node list 形式转换为 cycle 的格式\n          if (cycleValid) {\n            var cycle = {};\n            for (var index = 1; index < cyclePath.length; index += 1) {\n              cycle[cyclePath[index - 1].id] = cyclePath[index];\n            }\n            if (cyclePath.length) {\n              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];\n            }\n            allCycles.push(cycle);\n          }\n          used[neighborId].add(curNode);\n        }\n      };\n      for (var i = 0; i < neighbors.length; i += 1) {\n        _loop_1(i);\n      }\n    }\n  }\n  return allCycles;\n};\n/**\n * Johnson's algorithm, 时间复杂度 O((V + E)(C + 1))$ and space bounded by O(V + E)\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回所有的 simple cycles\n */\nexport var detectAllDirectedCycle = function detectAllDirectedCycle(graphData, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n  var path = []; // stack of nodes in current path\n  var blocked = new Set();\n  var B = []; // remember portions of the graph that yield no elementary circuit\n  var allCycles = [];\n  var idx2Node = {};\n  var node2Idx = {};\n  // 辅助函数： unblock all blocked nodes\n  var unblock = function unblock(thisNode) {\n    var stack = [thisNode];\n    while (stack.length > 0) {\n      var node = stack.pop();\n      if (blocked.has(node)) {\n        blocked.delete(node);\n        B[node.id].forEach(function (n) {\n          stack.push(n);\n        });\n        B[node.id].clear();\n      }\n    }\n  };\n  var circuit = function circuit(node, start, adjList) {\n    var closed = false; // whether a path is closed\n    if (nodeIds && include === false && nodeIds.indexOf(node.id) > -1) return closed;\n    path.push(node);\n    blocked.add(node);\n    var neighbors = adjList[node.id];\n    for (var i = 0; i < neighbors.length; i += 1) {\n      var neighbor = idx2Node[neighbors[i]];\n      if (neighbor === start) {\n        var cycle = {};\n        for (var index = 1; index < path.length; index += 1) {\n          cycle[path[index - 1].id] = path[index];\n        }\n        if (path.length) {\n          cycle[path[path.length - 1].id] = path[0];\n        }\n        allCycles.push(cycle);\n        closed = true;\n      } else if (!blocked.has(neighbor)) {\n        if (circuit(neighbor, start, adjList)) {\n          closed = true;\n        }\n      }\n    }\n    if (closed) {\n      unblock(node);\n    } else {\n      for (var i = 0; i < neighbors.length; i += 1) {\n        var neighbor = idx2Node[neighbors[i]];\n        if (!B[neighbor.id].has(node)) {\n          B[neighbor.id].add(node);\n        }\n      }\n    }\n    path.pop();\n    return closed;\n  };\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a;\n  // Johnson's algorithm 要求给节点赋顺序，先按节点在数组中的顺序\n  for (var i = 0; i < nodes.length; i += 1) {\n    var node = nodes[i];\n    var nodeId = node.id;\n    node2Idx[nodeId] = i;\n    idx2Node[i] = node;\n  }\n  // 如果有指定包含的节点，则把指定节点排序在前，以便提早结束搜索\n  if (nodeIds && include) {\n    var _loop_2 = function _loop_2(i) {\n      var nodeId = nodeIds[i];\n      node2Idx[nodes[i].id] = node2Idx[nodeId];\n      node2Idx[nodeId] = 0;\n      idx2Node[0] = nodes.find(function (node) {\n        return node.id === nodeId;\n      });\n      idx2Node[node2Idx[nodes[i].id]] = nodes[i];\n    };\n    for (var i = 0; i < nodeIds.length; i++) {\n      _loop_2(i);\n    }\n  }\n  // 返回 节点顺序 >= nodeOrder 的强连通分量的adjList\n  var getMinComponentAdj = function getMinComponentAdj(components) {\n    var _a;\n    var minCompIdx;\n    var minIdx = Infinity;\n    // Find least component and the lowest node\n    for (var i = 0; i < components.length; i += 1) {\n      var comp = components[i];\n      for (var j = 0; j < comp.length; j++) {\n        var nodeIdx_1 = node2Idx[comp[j].id];\n        if (nodeIdx_1 < minIdx) {\n          minIdx = nodeIdx_1;\n          minCompIdx = i;\n        }\n      }\n    }\n    var component = components[minCompIdx];\n    var adjList = [];\n    for (var i = 0; i < component.length; i += 1) {\n      var node = component[i];\n      adjList[node.id] = [];\n      for (var _i = 0, _b = getNeighbors(node.id, graphData.edges, 'target').filter(function (n) {\n          return component.map(function (c) {\n            return c.id;\n          }).indexOf(n) > -1;\n        }); _i < _b.length; _i++) {\n        var neighbor = _b[_i];\n        // 对自环情况 (点连向自身) 特殊处理：记录自环，但不加入adjList\n        if (neighbor === node.id && !(include === false && nodeIds.indexOf(node.id) > -1)) {\n          allCycles.push((_a = {}, _a[node.id] = node, _a));\n        } else {\n          adjList[node.id].push(node2Idx[neighbor]);\n        }\n      }\n    }\n    return {\n      component: component,\n      adjList: adjList,\n      minIdx: minIdx\n    };\n  };\n  var nodeIdx = 0;\n  while (nodeIdx < nodes.length) {\n    var subgraphNodes = nodes.filter(function (n) {\n      return node2Idx[n.id] >= nodeIdx;\n    });\n    var sccs = detectStrongConnectComponents({\n      nodes: subgraphNodes,\n      edges: graphData.edges\n    }).filter(function (component) {\n      return component.length > 1;\n    });\n    if (sccs.length === 0) break;\n    var scc = getMinComponentAdj(sccs);\n    var minIdx = scc.minIdx,\n      adjList = scc.adjList,\n      component = scc.component;\n    if (component.length > 1) {\n      component.forEach(function (node) {\n        B[node.id] = new Set();\n      });\n      var startNode = idx2Node[minIdx];\n      // startNode 不在指定要包含的节点中，提前结束搜索\n      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;\n      circuit(startNode, startNode, adjList);\n      nodeIdx = minIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return allCycles;\n};\n/**\n * 查找图中所有满足要求的圈\n * @param graph\n * @param directed 是否为有向图\n * @param nodeIds 节点 ID 的数组，若不指定，则返回图中所有的圈\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: Node}] 包含所有环的数组，每个环用一个Object表示，其中key为节点id，value为该节点在环中指向的下一个节点\n */\nexport var detectAllCycles = function detectAllCycles(graphData, directed, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n  if (directed) return detectAllDirectedCycle(graphData, nodeIds, include);\n  return detectAllUndirectedCycle(graphData, nodeIds, include);\n};\nexport default detectDirectedCycle;","map":{"version":3,"names":["dfs","getConnectedComponents","detectStrongConnectComponents","getNeighbors","detectDirectedCycle","graphData","cycle","_a","nodes","dfsParentMap","unvisitedSet","visitingSet","visitedSet","forEach","node","id","callbacks","enter","currentNode","current","previousNode","previous","currentCycleNode","previousCycleNode","leave","allowTraversal","nextNode","next","Object","keys","length","firsetUnVisitedKey","detectAllUndirectedCycle","nodeIds","include","_b","allCycles","components","_i","components_1","component","root","rootId","stack","parent_1","used","Set","curNode","pop","curNodeId","neighbors","edges","_loop_1","i","_c","neighborId","neighbor","find","push","has","cycleValid","cyclePath","p","size","findIndex","indexOf","index","add","detectAllDirectedCycle","path","blocked","B","idx2Node","node2Idx","unblock","thisNode","delete","n","clear","circuit","start","adjList","closed","nodeId","_loop_2","getMinComponentAdj","minCompIdx","minIdx","Infinity","comp","j","nodeIdx_1","filter","map","c","nodeIdx","subgraphNodes","sccs","scc","startNode","detectAllCycles","directed"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/algorithm/es/detect-cycle.js"],"sourcesContent":["import dfs from './dfs';\nimport getConnectedComponents, { detectStrongConnectComponents } from './connected-component';\nimport { getNeighbors } from './util';\nvar detectDirectedCycle = function detectDirectedCycle(graphData) {\n  var cycle = null;\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a;\n  var dfsParentMap = {};\n  // 所有没有被访问的节点集合\n  var unvisitedSet = {};\n  // 正在被访问的节点集合\n  var visitingSet = {};\n  // 所有已经被访问过的节点集合\n  var visitedSet = {};\n  // 初始化 unvisitedSet\n  nodes.forEach(function (node) {\n    unvisitedSet[node.id] = node;\n  });\n  var callbacks = {\n    enter: function enter(_a) {\n      var currentNode = _a.current,\n        previousNode = _a.previous;\n      if (visitingSet[currentNode]) {\n        // 如果当前节点正在访问中，则说明检测到环路了\n        cycle = {};\n        var currentCycleNode = currentNode;\n        var previousCycleNode = previousNode;\n        while (previousCycleNode !== currentNode) {\n          cycle[currentCycleNode] = previousCycleNode;\n          currentCycleNode = previousCycleNode;\n          previousCycleNode = dfsParentMap[previousCycleNode];\n        }\n        cycle[currentCycleNode] = previousCycleNode;\n      } else {\n        // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除\n        visitingSet[currentNode] = currentNode;\n        delete unvisitedSet[currentNode];\n        // 更新 DSF parents 列表\n        dfsParentMap[currentNode] = previousNode;\n      }\n    },\n    leave: function leave(_a) {\n      var currentNode = _a.current;\n      // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，\n      // 同时也意味着当前节点的所有邻居节点都被访问过了\n      visitedSet[currentNode] = currentNode;\n      delete visitingSet[currentNode];\n    },\n    allowTraversal: function allowTraversal(_a) {\n      var nextNode = _a.next;\n      // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历\n      if (cycle) {\n        return false;\n      }\n      // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了\n      return !visitedSet[nextNode];\n    }\n  };\n  // 开始遍历节点\n  while (Object.keys(unvisitedSet).length) {\n    // 从第一个节点开始进行 DFS 遍历\n    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\n    dfs(graphData, firsetUnVisitedKey, callbacks);\n  }\n  return cycle;\n};\n/**\n * 检测无向图中的所有Base cycles\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回一组base cycles\n */\nexport var detectAllUndirectedCycle = function detectAllUndirectedCycle(graphData, nodeIds, include) {\n  var _a, _b;\n  if (include === void 0) {\n    include = true;\n  }\n  var allCycles = [];\n  var components = getConnectedComponents(graphData, false);\n  // loop through all connected components\n  for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {\n    var component = components_1[_i];\n    if (!component.length) continue;\n    var root = component[0];\n    var rootId = root.id;\n    var stack = [root];\n    var parent_1 = (_a = {}, _a[rootId] = root, _a);\n    var used = (_b = {}, _b[rootId] = new Set(), _b);\n    // walk a spanning tree to find cycles\n    while (stack.length > 0) {\n      var curNode = stack.pop();\n      var curNodeId = curNode.id;\n      var neighbors = getNeighbors(curNodeId, graphData.edges);\n      var _loop_1 = function _loop_1(i) {\n        var _c;\n        var neighborId = neighbors[i];\n        var neighbor = graphData.nodes.find(function (node) {\n          return node.id === neighborId;\n        });\n        // const neighborId = neighbor.get('id');\n        if (neighborId === curNodeId) {\n          // 自环\n          allCycles.push((_c = {}, _c[neighborId] = curNode, _c));\n        } else if (!(neighborId in used)) {\n          // visit a new node\n          parent_1[neighborId] = curNode;\n          stack.push(neighbor);\n          used[neighborId] = new Set([curNode]);\n        } else if (!used[curNodeId].has(neighbor)) {\n          // a cycle found\n          var cycleValid = true;\n          var cyclePath = [neighbor, curNode];\n          var p = parent_1[curNodeId];\n          while (used[neighborId].size && !used[neighborId].has(p)) {\n            cyclePath.push(p);\n            if (p === parent_1[p.id]) break;else p = parent_1[p.id];\n          }\n          cyclePath.push(p);\n          if (nodeIds && include) {\n            // 如果有指定包含的节点\n            cycleValid = false;\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.id) > -1;\n            }) > -1) {\n              cycleValid = true;\n            }\n          } else if (nodeIds && !include) {\n            // 如果有指定不包含的节点\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.id) > -1;\n            }) > -1) {\n              cycleValid = false;\n            }\n          }\n          // 把 node list 形式转换为 cycle 的格式\n          if (cycleValid) {\n            var cycle = {};\n            for (var index = 1; index < cyclePath.length; index += 1) {\n              cycle[cyclePath[index - 1].id] = cyclePath[index];\n            }\n            if (cyclePath.length) {\n              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];\n            }\n            allCycles.push(cycle);\n          }\n          used[neighborId].add(curNode);\n        }\n      };\n      for (var i = 0; i < neighbors.length; i += 1) {\n        _loop_1(i);\n      }\n    }\n  }\n  return allCycles;\n};\n/**\n * Johnson's algorithm, 时间复杂度 O((V + E)(C + 1))$ and space bounded by O(V + E)\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回所有的 simple cycles\n */\nexport var detectAllDirectedCycle = function detectAllDirectedCycle(graphData, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n  var path = []; // stack of nodes in current path\n  var blocked = new Set();\n  var B = []; // remember portions of the graph that yield no elementary circuit\n  var allCycles = [];\n  var idx2Node = {};\n  var node2Idx = {};\n  // 辅助函数： unblock all blocked nodes\n  var unblock = function unblock(thisNode) {\n    var stack = [thisNode];\n    while (stack.length > 0) {\n      var node = stack.pop();\n      if (blocked.has(node)) {\n        blocked.delete(node);\n        B[node.id].forEach(function (n) {\n          stack.push(n);\n        });\n        B[node.id].clear();\n      }\n    }\n  };\n  var circuit = function circuit(node, start, adjList) {\n    var closed = false; // whether a path is closed\n    if (nodeIds && include === false && nodeIds.indexOf(node.id) > -1) return closed;\n    path.push(node);\n    blocked.add(node);\n    var neighbors = adjList[node.id];\n    for (var i = 0; i < neighbors.length; i += 1) {\n      var neighbor = idx2Node[neighbors[i]];\n      if (neighbor === start) {\n        var cycle = {};\n        for (var index = 1; index < path.length; index += 1) {\n          cycle[path[index - 1].id] = path[index];\n        }\n        if (path.length) {\n          cycle[path[path.length - 1].id] = path[0];\n        }\n        allCycles.push(cycle);\n        closed = true;\n      } else if (!blocked.has(neighbor)) {\n        if (circuit(neighbor, start, adjList)) {\n          closed = true;\n        }\n      }\n    }\n    if (closed) {\n      unblock(node);\n    } else {\n      for (var i = 0; i < neighbors.length; i += 1) {\n        var neighbor = idx2Node[neighbors[i]];\n        if (!B[neighbor.id].has(node)) {\n          B[neighbor.id].add(node);\n        }\n      }\n    }\n    path.pop();\n    return closed;\n  };\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a;\n  // Johnson's algorithm 要求给节点赋顺序，先按节点在数组中的顺序\n  for (var i = 0; i < nodes.length; i += 1) {\n    var node = nodes[i];\n    var nodeId = node.id;\n    node2Idx[nodeId] = i;\n    idx2Node[i] = node;\n  }\n  // 如果有指定包含的节点，则把指定节点排序在前，以便提早结束搜索\n  if (nodeIds && include) {\n    var _loop_2 = function _loop_2(i) {\n      var nodeId = nodeIds[i];\n      node2Idx[nodes[i].id] = node2Idx[nodeId];\n      node2Idx[nodeId] = 0;\n      idx2Node[0] = nodes.find(function (node) {\n        return node.id === nodeId;\n      });\n      idx2Node[node2Idx[nodes[i].id]] = nodes[i];\n    };\n    for (var i = 0; i < nodeIds.length; i++) {\n      _loop_2(i);\n    }\n  }\n  // 返回 节点顺序 >= nodeOrder 的强连通分量的adjList\n  var getMinComponentAdj = function getMinComponentAdj(components) {\n    var _a;\n    var minCompIdx;\n    var minIdx = Infinity;\n    // Find least component and the lowest node\n    for (var i = 0; i < components.length; i += 1) {\n      var comp = components[i];\n      for (var j = 0; j < comp.length; j++) {\n        var nodeIdx_1 = node2Idx[comp[j].id];\n        if (nodeIdx_1 < minIdx) {\n          minIdx = nodeIdx_1;\n          minCompIdx = i;\n        }\n      }\n    }\n    var component = components[minCompIdx];\n    var adjList = [];\n    for (var i = 0; i < component.length; i += 1) {\n      var node = component[i];\n      adjList[node.id] = [];\n      for (var _i = 0, _b = getNeighbors(node.id, graphData.edges, 'target').filter(function (n) {\n          return component.map(function (c) {\n            return c.id;\n          }).indexOf(n) > -1;\n        }); _i < _b.length; _i++) {\n        var neighbor = _b[_i];\n        // 对自环情况 (点连向自身) 特殊处理：记录自环，但不加入adjList\n        if (neighbor === node.id && !(include === false && nodeIds.indexOf(node.id) > -1)) {\n          allCycles.push((_a = {}, _a[node.id] = node, _a));\n        } else {\n          adjList[node.id].push(node2Idx[neighbor]);\n        }\n      }\n    }\n    return {\n      component: component,\n      adjList: adjList,\n      minIdx: minIdx\n    };\n  };\n  var nodeIdx = 0;\n  while (nodeIdx < nodes.length) {\n    var subgraphNodes = nodes.filter(function (n) {\n      return node2Idx[n.id] >= nodeIdx;\n    });\n    var sccs = detectStrongConnectComponents({\n      nodes: subgraphNodes,\n      edges: graphData.edges\n    }).filter(function (component) {\n      return component.length > 1;\n    });\n    if (sccs.length === 0) break;\n    var scc = getMinComponentAdj(sccs);\n    var minIdx = scc.minIdx,\n      adjList = scc.adjList,\n      component = scc.component;\n    if (component.length > 1) {\n      component.forEach(function (node) {\n        B[node.id] = new Set();\n      });\n      var startNode = idx2Node[minIdx];\n      // startNode 不在指定要包含的节点中，提前结束搜索\n      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;\n      circuit(startNode, startNode, adjList);\n      nodeIdx = minIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return allCycles;\n};\n/**\n * 查找图中所有满足要求的圈\n * @param graph\n * @param directed 是否为有向图\n * @param nodeIds 节点 ID 的数组，若不指定，则返回图中所有的圈\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: Node}] 包含所有环的数组，每个环用一个Object表示，其中key为节点id，value为该节点在环中指向的下一个节点\n */\nexport var detectAllCycles = function detectAllCycles(graphData, directed, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n  if (directed) return detectAllDirectedCycle(graphData, nodeIds, include);\n  return detectAllUndirectedCycle(graphData, nodeIds, include);\n};\nexport default detectDirectedCycle;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}