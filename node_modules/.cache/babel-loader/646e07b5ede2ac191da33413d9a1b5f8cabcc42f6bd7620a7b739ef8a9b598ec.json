{"ast":null,"code":"import { doBFS, doDFS } from './utils/traverse';\nconst defaultFilter = () => true;\nexport class GraphView {\n  graph;\n  nodeFilter;\n  edgeFilter;\n  // caches\n  cacheEnabled;\n  inEdgesMap = new Map();\n  outEdgesMap = new Map();\n  bothEdgesMap = new Map();\n  allNodesMap = new Map();\n  allEdgesMap = new Map();\n  constructor(options) {\n    this.graph = options.graph;\n    const nodeFilter = options.nodeFilter || defaultFilter;\n    const edgeFilter = options.edgeFilter || defaultFilter;\n    this.nodeFilter = nodeFilter;\n    this.edgeFilter = edge => {\n      const {\n        source,\n        target\n      } = this.graph.getEdgeDetail(edge.id);\n      if (!nodeFilter(source) || !nodeFilter(target)) {\n        return false;\n      }\n      return edgeFilter(edge, source, target);\n    };\n    if (options.cache === 'auto') {\n      this.cacheEnabled = true;\n      this.startAutoCache();\n    } else if (options.cache === 'manual') {\n      this.cacheEnabled = true;\n    } else {\n      this.cacheEnabled = false;\n    }\n  }\n  /**\n   * Clear all cache data. Therefore `getAllNodes()` will return `[]`.\n   * If you want to disable caching, use `graphView.cacheEnabled = false` instead.\n   */\n  clearCache = () => {\n    this.inEdgesMap.clear();\n    this.outEdgesMap.clear();\n    this.bothEdgesMap.clear();\n    this.allNodesMap.clear();\n    this.allEdgesMap.clear();\n  };\n  /**\n   * Fully refresh all cache data to the current graph state.\n   */\n  refreshCache = () => {\n    this.clearCache();\n    this.updateCache(this.graph.getAllNodes().map(node => node.id));\n  };\n  /**\n   * Instead of a fully refreshment, this method partially update the cache data by specifying\n   * involved(added, removed, updated) nodes. It's more efficient when handling small changes\n   * on a large graph.\n   */\n  updateCache = involvedNodeIds => {\n    const involvedEdgeIds = new Set();\n    involvedNodeIds.forEach(id => {\n      // Collect all involved old edges.\n      const oldEdgesSet = this.bothEdgesMap.get(id);\n      if (oldEdgesSet) {\n        oldEdgesSet.forEach(edge => involvedEdgeIds.add(edge.id));\n      }\n      if (!this.hasNode(id)) {\n        // When an involved node becomes unvisitable:\n        // 1. Delete its related edges cache.\n        this.inEdgesMap.delete(id);\n        this.outEdgesMap.delete(id);\n        this.bothEdgesMap.delete(id);\n        // 2. Delete it from the allNodesMap.\n        this.allNodesMap.delete(id);\n      } else {\n        // When an involved node becomes or stays visitable:\n        // 1. Collect its new edges.\n        const inEdges = this.graph.getRelatedEdges(id, 'in').filter(this.edgeFilter);\n        const outEdges = this.graph.getRelatedEdges(id, 'out').filter(this.edgeFilter);\n        const bothEdges = Array.from(new Set([...inEdges, ...outEdges]));\n        bothEdges.forEach(edge => involvedEdgeIds.add(edge.id));\n        // 2. Update its related edges cache.\n        this.inEdgesMap.set(id, inEdges);\n        this.outEdgesMap.set(id, outEdges);\n        this.bothEdgesMap.set(id, bothEdges);\n        // 3. Add to allNodesMap.\n        this.allNodesMap.set(id, this.graph.getNode(id));\n      }\n    });\n    // Update allEdgesMap.\n    involvedEdgeIds.forEach(id => {\n      if (this.hasEdge(id)) {\n        this.allEdgesMap.set(id, this.graph.getEdge(id));\n      } else {\n        this.allEdgesMap.delete(id);\n      }\n    });\n  };\n  startAutoCache() {\n    this.refreshCache();\n    this.graph.on('changed', this.handleGraphChanged);\n  }\n  stopAutoCache() {\n    this.graph.off('changed', this.handleGraphChanged);\n  }\n  handleGraphChanged = event => {\n    // Collect all involved nodes.\n    const involvedNodeIds = new Set();\n    event.changes.forEach(change => {\n      switch (change.type) {\n        case 'NodeAdded':\n          involvedNodeIds.add(change.value.id);\n          break;\n        case 'NodeDataUpdated':\n          involvedNodeIds.add(change.id);\n          break;\n        case 'EdgeAdded':\n          involvedNodeIds.add(change.value.source);\n          involvedNodeIds.add(change.value.target);\n          break;\n        case 'EdgeUpdated':\n          if (change.propertyName === 'source' || change.propertyName === 'target') {\n            involvedNodeIds.add(change.oldValue);\n            involvedNodeIds.add(change.newValue);\n          }\n          break;\n        case 'EdgeDataUpdated':\n          if (event.graph.hasEdge(change.id)) {\n            const edge = event.graph.getEdge(change.id);\n            involvedNodeIds.add(edge.source);\n            involvedNodeIds.add(edge.target);\n          }\n          break;\n        case 'EdgeRemoved':\n          involvedNodeIds.add(change.value.source);\n          involvedNodeIds.add(change.value.target);\n          break;\n        case 'NodeRemoved':\n          involvedNodeIds.add(change.value.id);\n          break;\n        default:\n          break;\n      }\n    });\n    // Update their caches.\n    this.updateCache(involvedNodeIds);\n  };\n  // ================= Node =================\n  checkNodeExistence(id) {\n    this.getNode(id);\n  }\n  hasNode(id) {\n    if (!this.graph.hasNode(id)) return false;\n    const node = this.graph.getNode(id);\n    return this.nodeFilter(node);\n  }\n  areNeighbors(firstNodeId, secondNodeId) {\n    this.checkNodeExistence(firstNodeId);\n    return this.getNeighbors(secondNodeId).some(neighbor => neighbor.id === firstNodeId);\n  }\n  getNode(id) {\n    const node = this.graph.getNode(id);\n    if (!this.nodeFilter(node)) {\n      throw new Error('Node not found for id: ' + id);\n    }\n    return node;\n  }\n  getRelatedEdges(id, direction) {\n    this.checkNodeExistence(id);\n    if (this.cacheEnabled) {\n      if (direction === 'in') {\n        return this.inEdgesMap.get(id);\n      } else if (direction === 'out') {\n        return this.outEdgesMap.get(id);\n      } else {\n        return this.bothEdgesMap.get(id);\n      }\n    }\n    const edges = this.graph.getRelatedEdges(id, direction);\n    return edges.filter(this.edgeFilter);\n  }\n  getDegree(id, direction) {\n    return this.getRelatedEdges(id, direction).length;\n  }\n  getSuccessors(id) {\n    const outEdges = this.getRelatedEdges(id, 'out');\n    const targets = outEdges.map(edge => this.getNode(edge.target));\n    return Array.from(new Set(targets));\n  }\n  getPredecessors(id) {\n    const inEdges = this.getRelatedEdges(id, 'in');\n    const sources = inEdges.map(edge => this.getNode(edge.source));\n    return Array.from(new Set(sources));\n  }\n  getNeighbors(id) {\n    const predecessors = this.getPredecessors(id);\n    const successors = this.getSuccessors(id);\n    return Array.from(new Set([...predecessors, ...successors]));\n  }\n  // ================= Edge =================\n  hasEdge(id) {\n    if (!this.graph.hasEdge(id)) return false;\n    const edge = this.graph.getEdge(id);\n    return this.edgeFilter(edge);\n  }\n  getEdge(id) {\n    const edge = this.graph.getEdge(id);\n    if (!this.edgeFilter(edge)) {\n      throw new Error('Edge not found for id: ' + id);\n    }\n    return edge;\n  }\n  getEdgeDetail(id) {\n    const edge = this.getEdge(id);\n    return {\n      edge,\n      source: this.getNode(edge.source),\n      target: this.getNode(edge.target)\n    };\n  }\n  // ================= Tree =================\n  hasTreeStructure(treeKey) {\n    return this.graph.hasTreeStructure(treeKey);\n  }\n  getRoots(treeKey) {\n    return this.graph.getRoots(treeKey).filter(this.nodeFilter);\n  }\n  getChildren(id, treeKey) {\n    this.checkNodeExistence(id);\n    return this.graph.getChildren(id, treeKey).filter(this.nodeFilter);\n  }\n  getParent(id, treeKey) {\n    this.checkNodeExistence(id);\n    const parent = this.graph.getParent(id, treeKey);\n    if (!parent || !this.nodeFilter(parent)) return null;\n    return parent;\n  }\n  // ================= Graph =================\n  getAllNodes() {\n    if (this.cacheEnabled) {\n      return Array.from(this.allNodesMap.values());\n    }\n    return this.graph.getAllNodes().filter(this.nodeFilter);\n  }\n  getAllEdges() {\n    if (this.cacheEnabled) {\n      return Array.from(this.allEdgesMap.values());\n    }\n    return this.graph.getAllEdges().filter(this.edgeFilter);\n  }\n  bfs(id, fn, direction = 'out') {\n    const navigator = {\n      in: this.getPredecessors.bind(this),\n      out: this.getSuccessors.bind(this),\n      both: this.getNeighbors.bind(this)\n    }[direction];\n    doBFS([this.getNode(id)], new Set(), fn, navigator);\n  }\n  dfs(id, fn, direction = 'out') {\n    const navigator = {\n      in: this.getPredecessors.bind(this),\n      out: this.getSuccessors.bind(this),\n      both: this.getNeighbors.bind(this)\n    }[direction];\n    doDFS(this.getNode(id), new Set(), fn, navigator);\n  }\n}","map":{"version":3,"names":["doBFS","doDFS","defaultFilter","GraphView","graph","nodeFilter","edgeFilter","cacheEnabled","inEdgesMap","Map","outEdgesMap","bothEdgesMap","allNodesMap","allEdgesMap","constructor","options","edge","source","target","getEdgeDetail","id","cache","startAutoCache","clearCache","clear","refreshCache","updateCache","getAllNodes","map","node","involvedNodeIds","involvedEdgeIds","Set","forEach","oldEdgesSet","get","add","hasNode","delete","inEdges","getRelatedEdges","filter","outEdges","bothEdges","Array","from","set","getNode","hasEdge","getEdge","on","handleGraphChanged","stopAutoCache","off","event","changes","change","type","value","propertyName","oldValue","newValue","checkNodeExistence","areNeighbors","firstNodeId","secondNodeId","getNeighbors","some","neighbor","Error","direction","edges","getDegree","length","getSuccessors","targets","getPredecessors","sources","predecessors","successors","hasTreeStructure","treeKey","getRoots","getChildren","getParent","parent","values","getAllEdges","bfs","fn","navigator","in","bind","out","both","dfs"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/graphlib/src/graphView.ts"],"sourcesContent":["import { Graph } from './graph';\nimport {\n  Edge,\n  GraphChangedEvent,\n  GraphViewOptions,\n  ID,\n  Node,\n  PlainObject,\n} from './types';\nimport { doBFS, doDFS } from './utils/traverse';\n\nconst defaultFilter = () => true;\n\nexport class GraphView<N extends PlainObject, E extends PlainObject> {\n  private graph: Graph<N, E>;\n  private nodeFilter: (node: Node<N>) => boolean;\n  private edgeFilter: (edge: Edge<E>) => boolean;\n\n  // caches\n  public cacheEnabled: boolean;\n  private inEdgesMap: Map<ID, Array<Edge<E>>> = new Map();\n  private outEdgesMap: Map<ID, Array<Edge<E>>> = new Map();\n  private bothEdgesMap: Map<ID, Array<Edge<E>>> = new Map();\n  private allNodesMap: Map<ID, Node<N>> = new Map();\n  private allEdgesMap: Map<ID, Edge<E>> = new Map();\n\n  constructor(options: GraphViewOptions<N, E>) {\n    this.graph = options.graph;\n    const nodeFilter = options.nodeFilter || defaultFilter;\n    const edgeFilter = options.edgeFilter || defaultFilter;\n\n    this.nodeFilter = nodeFilter;\n    this.edgeFilter = (edge) => {\n      const { source, target } = this.graph.getEdgeDetail(edge.id);\n      if (!nodeFilter(source) || !nodeFilter(target)) {\n        return false;\n      }\n      return edgeFilter(edge, source, target);\n    };\n\n    if (options.cache === 'auto') {\n      this.cacheEnabled = true;\n      this.startAutoCache();\n    } else if (options.cache === 'manual') {\n      this.cacheEnabled = true;\n    } else {\n      this.cacheEnabled = false;\n    }\n  }\n\n  /**\n   * Clear all cache data. Therefore `getAllNodes()` will return `[]`.\n   * If you want to disable caching, use `graphView.cacheEnabled = false` instead.\n   */\n  public clearCache = (): void => {\n    this.inEdgesMap.clear();\n    this.outEdgesMap.clear();\n    this.bothEdgesMap.clear();\n    this.allNodesMap.clear();\n    this.allEdgesMap.clear();\n  };\n\n  /**\n   * Fully refresh all cache data to the current graph state.\n   */\n  public refreshCache = (): void => {\n    this.clearCache();\n    this.updateCache(this.graph.getAllNodes().map((node) => node.id));\n  };\n\n  /**\n   * Instead of a fully refreshment, this method partially update the cache data by specifying\n   * involved(added, removed, updated) nodes. It's more efficient when handling small changes\n   * on a large graph.\n   */\n  public updateCache = (involvedNodeIds: Set<ID> | Array<ID>): void => {\n    const involvedEdgeIds = new Set<ID>();\n    involvedNodeIds.forEach((id) => {\n      // Collect all involved old edges.\n      const oldEdgesSet = this.bothEdgesMap.get(id);\n      if (oldEdgesSet) {\n        oldEdgesSet.forEach((edge) => involvedEdgeIds.add(edge.id));\n      }\n\n      if (!this.hasNode(id)) {\n        // When an involved node becomes unvisitable:\n        // 1. Delete its related edges cache.\n        this.inEdgesMap.delete(id);\n        this.outEdgesMap.delete(id);\n        this.bothEdgesMap.delete(id);\n        // 2. Delete it from the allNodesMap.\n        this.allNodesMap.delete(id);\n      } else {\n        // When an involved node becomes or stays visitable:\n        // 1. Collect its new edges.\n        const inEdges = this.graph\n          .getRelatedEdges(id, 'in')\n          .filter(this.edgeFilter);\n        const outEdges = this.graph\n          .getRelatedEdges(id, 'out')\n          .filter(this.edgeFilter);\n        const bothEdges = Array.from(new Set([...inEdges, ...outEdges]));\n        bothEdges.forEach((edge) => involvedEdgeIds.add(edge.id));\n\n        // 2. Update its related edges cache.\n        this.inEdgesMap.set(id, inEdges);\n        this.outEdgesMap.set(id, outEdges);\n        this.bothEdgesMap.set(id, bothEdges);\n\n        // 3. Add to allNodesMap.\n        this.allNodesMap.set(id, this.graph.getNode(id));\n      }\n    });\n\n    // Update allEdgesMap.\n    involvedEdgeIds.forEach((id) => {\n      if (this.hasEdge(id)) {\n        this.allEdgesMap.set(id, this.graph.getEdge(id));\n      } else {\n        this.allEdgesMap.delete(id);\n      }\n    });\n  };\n\n  public startAutoCache() {\n    this.refreshCache();\n    this.graph.on('changed', this.handleGraphChanged);\n  }\n\n  public stopAutoCache() {\n    this.graph.off('changed', this.handleGraphChanged);\n  }\n\n  private handleGraphChanged = (event: GraphChangedEvent<N, E>) => {\n    // Collect all involved nodes.\n    const involvedNodeIds: Set<ID> = new Set();\n    event.changes.forEach((change) => {\n      switch (change.type) {\n        case 'NodeAdded':\n          involvedNodeIds.add(change.value.id);\n          break;\n        case 'NodeDataUpdated':\n          involvedNodeIds.add(change.id);\n          break;\n        case 'EdgeAdded':\n          involvedNodeIds.add(change.value.source);\n          involvedNodeIds.add(change.value.target);\n          break;\n        case 'EdgeUpdated':\n          if (\n            change.propertyName === 'source' ||\n            change.propertyName === 'target'\n          ) {\n            involvedNodeIds.add(change.oldValue);\n            involvedNodeIds.add(change.newValue);\n          }\n          break;\n        case 'EdgeDataUpdated':\n          if (event.graph.hasEdge(change.id)) {\n            const edge = event.graph.getEdge(change.id);\n            involvedNodeIds.add(edge.source);\n            involvedNodeIds.add(edge.target);\n          }\n          break;\n        case 'EdgeRemoved':\n          involvedNodeIds.add(change.value.source);\n          involvedNodeIds.add(change.value.target);\n          break;\n        case 'NodeRemoved':\n          involvedNodeIds.add(change.value.id);\n          break;\n        default:\n          break;\n      }\n    });\n    // Update their caches.\n    this.updateCache(involvedNodeIds);\n  };\n\n  // ================= Node =================\n  private checkNodeExistence(id: ID): void {\n    this.getNode(id);\n  }\n\n  hasNode(id: ID): boolean {\n    if (!this.graph.hasNode(id)) return false;\n    const node = this.graph.getNode(id);\n    return this.nodeFilter(node);\n  }\n\n  public areNeighbors(firstNodeId: ID, secondNodeId: ID): boolean {\n    this.checkNodeExistence(firstNodeId);\n    return this.getNeighbors(secondNodeId).some(\n      (neighbor) => neighbor.id === firstNodeId,\n    );\n  }\n\n  public getNode(id: ID): Node<N> {\n    const node = this.graph.getNode(id);\n    if (!this.nodeFilter(node)) {\n      throw new Error('Node not found for id: ' + id);\n    }\n    return node;\n  }\n\n  public getRelatedEdges(id: ID, direction?: 'in' | 'out' | 'both'): Edge<E>[] {\n    this.checkNodeExistence(id);\n    if (this.cacheEnabled) {\n      if (direction === 'in') {\n        return this.inEdgesMap.get(id)!;\n      } else if (direction === 'out') {\n        return this.outEdgesMap.get(id)!;\n      } else {\n        return this.bothEdgesMap.get(id)!;\n      }\n    }\n    const edges = this.graph.getRelatedEdges(id, direction);\n    return edges.filter(this.edgeFilter);\n  }\n\n  public getDegree(id: ID, direction?: 'in' | 'out' | 'both'): number {\n    return this.getRelatedEdges(id, direction).length;\n  }\n\n  public getSuccessors(id: ID): Node<N>[] {\n    const outEdges = this.getRelatedEdges(id, 'out');\n    const targets = outEdges.map((edge) => this.getNode(edge.target));\n    return Array.from(new Set(targets));\n  }\n\n  public getPredecessors(id: ID): Node<N>[] {\n    const inEdges = this.getRelatedEdges(id, 'in');\n    const sources = inEdges.map((edge) => this.getNode(edge.source));\n    return Array.from(new Set(sources));\n  }\n\n  public getNeighbors(id: ID): Node<N>[] {\n    const predecessors = this.getPredecessors(id);\n    const successors = this.getSuccessors(id);\n    return Array.from(new Set([...predecessors, ...successors]));\n  }\n\n  // ================= Edge =================\n  public hasEdge(id: ID): boolean {\n    if (!this.graph.hasEdge(id)) return false;\n    const edge = this.graph.getEdge(id);\n    return this.edgeFilter(edge);\n  }\n\n  public getEdge(id: ID): Edge<E> {\n    const edge = this.graph.getEdge(id);\n    if (!this.edgeFilter(edge)) {\n      throw new Error('Edge not found for id: ' + id);\n    }\n    return edge;\n  }\n\n  public getEdgeDetail(id: ID): {\n    edge: Edge<E>;\n    source: Node<N>;\n    target: Node<N>;\n  } {\n    const edge = this.getEdge(id);\n    return {\n      edge,\n      source: this.getNode(edge.source),\n      target: this.getNode(edge.target),\n    };\n  }\n\n  // ================= Tree =================\n  public hasTreeStructure(treeKey: string | undefined): boolean {\n    return this.graph.hasTreeStructure(treeKey);\n  }\n\n  public getRoots(treeKey?: string): Node<N>[] {\n    return this.graph.getRoots(treeKey).filter(this.nodeFilter);\n  }\n\n  public getChildren(id: ID, treeKey?: string): Node<N>[] {\n    this.checkNodeExistence(id);\n    return this.graph.getChildren(id, treeKey).filter(this.nodeFilter);\n  }\n\n  public getParent(id: ID, treeKey?: string): Node<N> | null {\n    this.checkNodeExistence(id);\n    const parent = this.graph.getParent(id, treeKey);\n    if (!parent || !this.nodeFilter(parent)) return null;\n    return parent;\n  }\n\n  // ================= Graph =================\n  public getAllNodes(): Node<N>[] {\n    if (this.cacheEnabled) {\n      return Array.from(this.allNodesMap.values());\n    }\n    return this.graph.getAllNodes().filter(this.nodeFilter);\n  }\n\n  public getAllEdges(): Edge<E>[] {\n    if (this.cacheEnabled) {\n      return Array.from(this.allEdgesMap.values());\n    }\n    return this.graph.getAllEdges().filter(this.edgeFilter);\n  }\n\n  public bfs(\n    id: ID,\n    fn: (node: Node<N>) => void,\n    direction: 'in' | 'out' | 'both' = 'out',\n  ): void {\n    const navigator = {\n      in: this.getPredecessors.bind(this),\n      out: this.getSuccessors.bind(this),\n      both: this.getNeighbors.bind(this),\n    }[direction];\n    doBFS([this.getNode(id)], new Set(), fn, navigator);\n  }\n\n  public dfs(\n    id: ID,\n    fn: (node: Node<N>) => void,\n    direction: 'in' | 'out' | 'both' = 'out',\n  ): void {\n    const navigator = {\n      in: this.getPredecessors.bind(this),\n      out: this.getSuccessors.bind(this),\n      both: this.getNeighbors.bind(this),\n    }[direction];\n    doDFS(this.getNode(id), new Set(), fn, navigator);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}