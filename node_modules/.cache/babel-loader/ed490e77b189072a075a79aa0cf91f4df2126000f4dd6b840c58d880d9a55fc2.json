{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { cloneFormatData, formatNumberFn, formatSizeFn } from './util';\nimport { handleSingleNodeGraph } from './util/common';\nconst DEFAULTS_LAYOUT_OPTIONS = {\n  radius: null,\n  startRadius: null,\n  endRadius: null,\n  startAngle: 0,\n  endAngle: 2 * Math.PI,\n  clockwise: true,\n  divisions: 1,\n  ordering: null,\n  angleRatio: 1\n};\n/**\n * <zh/> 环形布局\n *\n * <en/> Circular layout\n */\nexport class CircularLayout {\n  constructor(options = {}) {\n    this.options = options;\n    this.id = 'circular';\n    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);\n  }\n  /**\n   * Return the positions of nodes and edges(if needed).\n   */\n  execute(graph, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.genericCircularLayout(false, graph, options);\n    });\n  }\n  /**\n   * To directly assign the positions to the nodes.\n   */\n  assign(graph, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.genericCircularLayout(true, graph, options);\n    });\n  }\n  genericCircularLayout(assign, graph, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const mergedOptions = Object.assign(Object.assign({}, this.options), options);\n      const {\n        width,\n        height,\n        center,\n        divisions,\n        startAngle = 0,\n        endAngle = 2 * Math.PI,\n        angleRatio,\n        ordering,\n        clockwise,\n        nodeSpacing: paramNodeSpacing,\n        nodeSize: paramNodeSize\n      } = mergedOptions;\n      const nodes = graph.getAllNodes();\n      const edges = graph.getAllEdges();\n      // Calculate center according to `window` if not provided.\n      const [calculatedWidth, calculatedHeight, calculatedCenter] = calculateCenter(width, height, center);\n      const n = nodes === null || nodes === void 0 ? void 0 : nodes.length;\n      if (!n || n === 1) {\n        return handleSingleNodeGraph(graph, assign, calculatedCenter);\n      }\n      const angleStep = (endAngle - startAngle) / n;\n      let {\n        radius,\n        startRadius,\n        endRadius\n      } = mergedOptions;\n      if (paramNodeSpacing) {\n        const nodeSpacing = formatNumberFn(10, paramNodeSpacing);\n        const nodeSize = formatSizeFn(10, paramNodeSize);\n        let maxNodeSize = -Infinity;\n        nodes.forEach(node => {\n          const nSize = nodeSize(node);\n          if (maxNodeSize < nSize) maxNodeSize = nSize;\n        });\n        let perimeter = 0;\n        nodes.forEach((node, i) => {\n          if (i === 0) perimeter += maxNodeSize || 10;else perimeter += (nodeSpacing(node) || 0) + (maxNodeSize || 10);\n        });\n        radius = perimeter / (2 * Math.PI);\n      } else if (!radius && !startRadius && !endRadius) {\n        radius = Math.min(calculatedHeight, calculatedWidth) / 2;\n      } else if (!startRadius && endRadius) {\n        startRadius = endRadius;\n      } else if (startRadius && !endRadius) {\n        endRadius = startRadius;\n      }\n      const astep = angleStep * angleRatio;\n      // calculated nodes as temporary result\n      let layoutNodes = [];\n      if (ordering === 'topology') {\n        // layout according to the topology\n        layoutNodes = topologyOrdering(graph, nodes);\n      } else if (ordering === 'topology-directed') {\n        // layout according to the topology\n        layoutNodes = topologyOrdering(graph, nodes, true);\n      } else if (ordering === 'degree') {\n        // layout according to the descent order of degrees\n        layoutNodes = degreeOrdering(graph, nodes);\n      } else {\n        // layout according to the original order in the data.nodes\n        layoutNodes = nodes.map(node => cloneFormatData(node));\n      }\n      const divN = Math.ceil(n / divisions); // node number in each division\n      for (let i = 0; i < n; ++i) {\n        let r = radius;\n        if (!r && startRadius !== null && endRadius !== null) {\n          r = startRadius + i * (endRadius - startRadius) / (n - 1);\n        }\n        if (!r) {\n          r = 10 + i * 100 / (n - 1);\n        }\n        let angle = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);\n        if (!clockwise) {\n          angle = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);\n        }\n        layoutNodes[i].data.x = calculatedCenter[0] + Math.cos(angle) * r;\n        layoutNodes[i].data.y = calculatedCenter[1] + Math.sin(angle) * r;\n      }\n      if (assign) {\n        layoutNodes.forEach(node => {\n          graph.mergeNodeData(node.id, {\n            x: node.data.x,\n            y: node.data.y\n          });\n        });\n      }\n      const result = {\n        nodes: layoutNodes,\n        edges\n      };\n      return result;\n    });\n  }\n}\n/**\n * order the nodes acoording to the graph topology\n * @param graph\n * @param nodes\n * @param directed\n * @returns\n */\nconst topologyOrdering = (graph, nodes, directed = false) => {\n  const orderedCNodes = [cloneFormatData(nodes[0])];\n  const pickFlags = {};\n  const n = nodes.length;\n  pickFlags[nodes[0].id] = true;\n  // write children into cnodes\n  let k = 0;\n  nodes.forEach((node, i) => {\n    if (i !== 0) {\n      if ((i === n - 1 || graph.getDegree(node.id, 'both') !== graph.getDegree(nodes[i + 1].id, 'both') || graph.areNeighbors(orderedCNodes[k].id, node.id)) && !pickFlags[node.id]) {\n        orderedCNodes.push(cloneFormatData(node));\n        pickFlags[node.id] = true;\n        k++;\n      } else {\n        const children = directed ? graph.getSuccessors(orderedCNodes[k].id) : graph.getNeighbors(orderedCNodes[k].id);\n        let foundChild = false;\n        for (let j = 0; j < children.length; j++) {\n          const child = children[j];\n          if (graph.getDegree(child.id) === graph.getDegree(node.id) && !pickFlags[child.id]) {\n            orderedCNodes.push(cloneFormatData(child));\n            pickFlags[child.id] = true;\n            foundChild = true;\n            break;\n          }\n        }\n        let ii = 0;\n        while (!foundChild) {\n          if (!pickFlags[nodes[ii].id]) {\n            orderedCNodes.push(cloneFormatData(nodes[ii]));\n            pickFlags[nodes[ii].id] = true;\n            foundChild = true;\n          }\n          ii++;\n          if (ii === n) {\n            break;\n          }\n        }\n      }\n    }\n  });\n  return orderedCNodes;\n};\n/**\n * order the nodes according to their degree\n * @param graph\n * @param nodes\n * @returns\n */\nfunction degreeOrdering(graph, nodes) {\n  const orderedNodes = [];\n  nodes.forEach((node, i) => {\n    orderedNodes.push(cloneFormatData(node));\n  });\n  orderedNodes.sort((nodeA, nodeB) => graph.getDegree(nodeA.id, 'both') - graph.getDegree(nodeB.id, 'both'));\n  return orderedNodes;\n}\n/**\n * format the invalide width and height, and get the center position\n * @param width\n * @param height\n * @param center\n * @returns\n */\nconst calculateCenter = (width, height, center) => {\n  let calculatedWidth = width;\n  let calculatedHeight = height;\n  let calculatedCenter = center;\n  if (!calculatedWidth && typeof window !== 'undefined') {\n    calculatedWidth = window.innerWidth;\n  }\n  if (!calculatedHeight && typeof window !== 'undefined') {\n    calculatedHeight = window.innerHeight;\n  }\n  if (!calculatedCenter) {\n    calculatedCenter = [calculatedWidth / 2, calculatedHeight / 2];\n  }\n  return [calculatedWidth, calculatedHeight, calculatedCenter];\n};","map":{"version":3,"names":["cloneFormatData","formatNumberFn","formatSizeFn","handleSingleNodeGraph","DEFAULTS_LAYOUT_OPTIONS","radius","startRadius","endRadius","startAngle","endAngle","Math","PI","clockwise","divisions","ordering","angleRatio","CircularLayout","constructor","options","id","Object","assign","execute","graph","genericCircularLayout","mergedOptions","width","height","center","nodeSpacing","paramNodeSpacing","nodeSize","paramNodeSize","nodes","getAllNodes","edges","getAllEdges","calculatedWidth","calculatedHeight","calculatedCenter","calculateCenter","n","length","angleStep","maxNodeSize","Infinity","forEach","node","nSize","perimeter","i","min","astep","layoutNodes","topologyOrdering","degreeOrdering","map","divN","ceil","r","angle","floor","data","x","cos","y","sin","mergeNodeData","result","directed","orderedCNodes","pickFlags","k","getDegree","areNeighbors","push","children","getSuccessors","getNeighbors","foundChild","j","child","ii","orderedNodes","sort","nodeA","nodeB","window","innerWidth","innerHeight"],"sources":["../src/circular.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}