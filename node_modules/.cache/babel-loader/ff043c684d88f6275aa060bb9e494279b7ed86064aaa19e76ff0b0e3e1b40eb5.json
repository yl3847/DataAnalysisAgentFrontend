{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix } from '@antv/util';\n/**\n * Adaptor return default options for raw options.\n */\nexport function useDefaultAdaptor(adaptor) {\n  return (options, ...rest) => deepMix({}, adaptor(options, ...rest), options);\n}\n/**\n * Adaptor return options override raw options.\n */\nexport function useOverrideAdaptor(adaptor) {\n  return (options, ...rest) => deepMix({}, options, adaptor(options, ...rest));\n}\nexport function isObject(d) {\n  if (d instanceof Date) return false;\n  return typeof d === 'object';\n}\nexport function mergeData(dataDescriptor, dataValue) {\n  if (!dataDescriptor) return dataValue;\n  if (Array.isArray(dataDescriptor)) return dataDescriptor;\n  if (isObject(dataDescriptor)) {\n    const {\n        value = dataValue\n      } = dataDescriptor,\n      rest = __rest(dataDescriptor, [\"value\"]);\n    return Object.assign(Object.assign({}, rest), {\n      value\n    });\n  }\n  return dataDescriptor;\n}","map":{"version":3,"names":["deepMix","useDefaultAdaptor","adaptor","options","rest","useOverrideAdaptor","isObject","d","Date","mergeData","dataDescriptor","dataValue","Array","isArray","value","__rest","Object","assign"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/composition/utils.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\n\ntype Adapter<T> = (options: T, ...rest: any[]) => T;\n\n/**\n * Adaptor return default options for raw options.\n */\nexport function useDefaultAdaptor<T>(adaptor: Adapter<T>): Adapter<T> {\n  return (options?, ...rest) => deepMix({}, adaptor(options, ...rest), options);\n}\n\n/**\n * Adaptor return options override raw options.\n */\nexport function useOverrideAdaptor<T>(adaptor: Adapter<T>): Adapter<T> {\n  return (options?, ...rest) => deepMix({}, options, adaptor(options, ...rest));\n}\n\nexport function isObject(d) {\n  if (d instanceof Date) return false;\n  return typeof d === 'object';\n}\n\nexport function mergeData(\n  dataDescriptor: any[] | { value: any; [key: string]: any },\n  dataValue: any[],\n) {\n  if (!dataDescriptor) return dataValue;\n  if (Array.isArray(dataDescriptor)) return dataDescriptor;\n  if (isObject(dataDescriptor)) {\n    const { value = dataValue, ...rest } = dataDescriptor;\n    return { ...rest, value };\n  }\n  return dataDescriptor;\n}\n"],"mappings":";;;;;;;;AAAA,SAASA,OAAO,QAAQ,YAAY;AAIpC;;;AAGA,OAAM,SAAUC,iBAAiBA,CAAIC,OAAmB;EACtD,OAAO,CAACC,OAAQ,EAAE,GAAGC,IAAI,KAAKJ,OAAO,CAAC,EAAE,EAAEE,OAAO,CAACC,OAAO,EAAE,GAAGC,IAAI,CAAC,EAAED,OAAO,CAAC;AAC/E;AAEA;;;AAGA,OAAM,SAAUE,kBAAkBA,CAAIH,OAAmB;EACvD,OAAO,CAACC,OAAQ,EAAE,GAAGC,IAAI,KAAKJ,OAAO,CAAC,EAAE,EAAEG,OAAO,EAAED,OAAO,CAACC,OAAO,EAAE,GAAGC,IAAI,CAAC,CAAC;AAC/E;AAEA,OAAM,SAAUE,QAAQA,CAACC,CAAC;EACxB,IAAIA,CAAC,YAAYC,IAAI,EAAE,OAAO,KAAK;EACnC,OAAO,OAAOD,CAAC,KAAK,QAAQ;AAC9B;AAEA,OAAM,SAAUE,SAASA,CACvBC,cAA0D,EAC1DC,SAAgB;EAEhB,IAAI,CAACD,cAAc,EAAE,OAAOC,SAAS;EACrC,IAAIC,KAAK,CAACC,OAAO,CAACH,cAAc,CAAC,EAAE,OAAOA,cAAc;EACxD,IAAIJ,QAAQ,CAACI,cAAc,CAAC,EAAE;IAC5B,MAAM;QAAEI,KAAK,GAAGH;MAAS,IAAcD,cAAc;MAAvBN,IAAI,GAAAW,MAAA,CAAKL,cAAc,EAA/C,SAA8B,CAAiB;IACrD,OAAAM,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAYb,IAAI;MAAEU;IAAK;;EAEzB,OAAOJ,cAAc;AACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}