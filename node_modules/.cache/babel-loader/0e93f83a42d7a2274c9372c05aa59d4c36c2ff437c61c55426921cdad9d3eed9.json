{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { idOf } from '../utils/id';\nimport { getLayoutProperty, invokeLayoutMethod } from '../utils/layout';\nimport { print } from '../utils/print';\nimport { add } from '../utils/vector';\nimport { DragElement } from './drag-element';\n/**\n * <zh/> 调用力导布局拖拽元素的交互\n *\n * <en/> Call d3-force layout to drag element behavior\n * @remarks\n * <zh/> 只能在使用 d3-force 布局时使用该交互，在拖拽过程中会实时重新计算布局。\n *\n * <en/> This behavior can only be used with d3-force layout. The layout will be recalculated in real time during dragging.\n */\nexport class DragElementForce extends DragElement {\n  get forceLayoutInstance() {\n    return this.context.layout.getLayoutInstance().find(layout => ['d3-force', 'd3-force-3d'].includes(layout === null || layout === void 0 ? void 0 : layout.id));\n  }\n  /**\n   * Whether the behavior is enabled\n   * @param event - The event object\n   * @returns Is the behavior enabled\n   * @internal\n   */\n  validate(event) {\n    if (!this.context.layout) return false;\n    // 未使用力导布局 / The force layout is not used\n    if (!this.forceLayoutInstance) {\n      print.warn('DragElementForce only works with d3-force or d3-force-3d layout');\n      return false;\n    }\n    return super.validate(event);\n  }\n  /**\n   * Move selected elements by offset\n   * @param ids - The selected element IDs\n   * @param offset - The offset to move\n   * @internal\n   */\n  moveElement(ids, offset) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const layout = this.forceLayoutInstance;\n      this.context.graph.getNodeData(ids).forEach((element, index) => {\n        const {\n          x = 0,\n          y = 0\n        } = element.style || {};\n        if (layout) invokeLayoutMethod(layout, 'setFixedPosition', ids[index], [...add([+x, +y], offset)]);\n      });\n    });\n  }\n  /**\n   * Triggered when the drag starts\n   * @param event - The event object\n   * @internal\n   */\n  onDragStart(event) {\n    this.enable = this.validate(event);\n    if (!this.enable) return;\n    this.target = this.getSelectedNodeIDs([event.target.id]);\n    this.hideEdge();\n    this.context.graph.frontElement(this.target);\n    const layout = this.forceLayoutInstance;\n    if (layout) getLayoutProperty(layout, 'simulation').alphaTarget(0.3).restart();\n    this.context.graph.getNodeData(this.target).forEach(element => {\n      const {\n        x = 0,\n        y = 0\n      } = element.style || {};\n      if (layout) invokeLayoutMethod(layout, 'setFixedPosition', idOf(element), [+x, +y]);\n    });\n  }\n  /**\n   * Triggered when dragging\n   * @param event - The event object\n   * @internal\n   */\n  onDrag(event) {\n    if (!this.enable) return;\n    const delta = this.getDelta(event);\n    this.moveElement(this.target, delta);\n  }\n  /**\n   * Triggered when the drag ends\n   * @internal\n   */\n  onDragEnd() {\n    const layout = this.forceLayoutInstance;\n    if (layout) getLayoutProperty(layout, 'simulation').alphaTarget(0);\n    if (this.options.fixed) return;\n    this.context.graph.getNodeData(this.target).forEach(element => {\n      if (layout) invokeLayoutMethod(layout, 'setFixedPosition', idOf(element), [null, null, null]);\n    });\n  }\n}","map":{"version":3,"names":["idOf","getLayoutProperty","invokeLayoutMethod","print","add","DragElement","DragElementForce","forceLayoutInstance","context","layout","getLayoutInstance","find","includes","id","validate","event","warn","moveElement","ids","offset","graph","getNodeData","forEach","element","index","x","y","style","onDragStart","enable","target","getSelectedNodeIDs","hideEdge","frontElement","alphaTarget","restart","onDrag","delta","getDelta","onDragEnd","options","fixed"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/behaviors/drag-element-force.ts"],"sourcesContent":["import type { ID, IElementDragEvent, Point } from '../types';\nimport { idOf } from '../utils/id';\nimport { getLayoutProperty, invokeLayoutMethod } from '../utils/layout';\nimport { print } from '../utils/print';\nimport { add } from '../utils/vector';\nimport type { DragElementOptions } from './drag-element';\nimport { DragElement } from './drag-element';\n\n/**\n * <zh/> 调用力导布局拖拽元素交互配置项\n *\n * <en/> Call d3-force layout to drag element behavior options\n */\nexport interface DragElementForceOptions extends Omit<DragElementOptions, 'animation' | 'dropEffect' | 'shadow'> {\n  /**\n   * <zh/> 在拖拽结束后，节点是否保持固定位置\n   * - `true`: 在拖拽结束后，节点的位置将保持固定，不受布局算法的影响\n   * - `false`: 在拖拽结束后，节点的位置将继续受到布局算法的影响\n   *\n   * <en/> Whether the node remains in a fixed position after dragging ends\n   * - `true`: After dragging ends, the node's position will remain fixed and will not be affected by the layout algorithm\n   * - `false`: After dragging ends, the node's position will continue to be affected by the layout algorithm\n   */\n  fixed?: boolean;\n}\n\n/**\n * <zh/> 调用力导布局拖拽元素的交互\n *\n * <en/> Call d3-force layout to drag element behavior\n * @remarks\n * <zh/> 只能在使用 d3-force 布局时使用该交互，在拖拽过程中会实时重新计算布局。\n *\n * <en/> This behavior can only be used with d3-force layout. The layout will be recalculated in real time during dragging.\n */\nexport class DragElementForce extends DragElement {\n  private get forceLayoutInstance() {\n    return this.context.layout!.getLayoutInstance().find((layout) => ['d3-force', 'd3-force-3d'].includes(layout?.id));\n  }\n\n  /**\n   * Whether the behavior is enabled\n   * @param event - The event object\n   * @returns Is the behavior enabled\n   * @internal\n   */\n  protected validate(event: IElementDragEvent): boolean {\n    if (!this.context.layout) return false;\n\n    // 未使用力导布局 / The force layout is not used\n    if (!this.forceLayoutInstance) {\n      print.warn('DragElementForce only works with d3-force or d3-force-3d layout');\n      return false;\n    }\n\n    return super.validate(event);\n  }\n\n  /**\n   * Move selected elements by offset\n   * @param ids - The selected element IDs\n   * @param offset - The offset to move\n   * @internal\n   */\n  protected async moveElement(ids: ID[], offset: Point) {\n    const layout = this.forceLayoutInstance;\n    this.context.graph.getNodeData(ids).forEach((element, index) => {\n      const { x = 0, y = 0 } = element.style || {};\n      if (layout) invokeLayoutMethod(layout, 'setFixedPosition', ids[index], [...add([+x, +y], offset)]);\n    });\n  }\n\n  /**\n   * Triggered when the drag starts\n   * @param event - The event object\n   * @internal\n   */\n  protected onDragStart(event: IElementDragEvent) {\n    this.enable = this.validate(event);\n    if (!this.enable) return;\n\n    this.target = this.getSelectedNodeIDs([event.target.id]);\n    this.hideEdge();\n    this.context.graph.frontElement(this.target);\n\n    const layout = this.forceLayoutInstance;\n    if (layout) getLayoutProperty(layout, 'simulation').alphaTarget(0.3).restart();\n\n    this.context.graph.getNodeData(this.target).forEach((element) => {\n      const { x = 0, y = 0 } = element.style || {};\n      if (layout) invokeLayoutMethod(layout, 'setFixedPosition', idOf(element), [+x, +y]);\n    });\n  }\n\n  /**\n   * Triggered when dragging\n   * @param event - The event object\n   * @internal\n   */\n  protected onDrag(event: IElementDragEvent) {\n    if (!this.enable) return;\n\n    const delta = this.getDelta(event);\n    this.moveElement(this.target, delta);\n  }\n\n  /**\n   * Triggered when the drag ends\n   * @internal\n   */\n  protected onDragEnd() {\n    const layout = this.forceLayoutInstance;\n    if (layout) getLayoutProperty(layout, 'simulation').alphaTarget(0);\n\n    if (this.options.fixed) return;\n\n    this.context.graph.getNodeData(this.target).forEach((element) => {\n      if (layout) invokeLayoutMethod(layout, 'setFixedPosition', idOf(element), [null, null, null]);\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}