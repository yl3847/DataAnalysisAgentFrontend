{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { CanvasEvent, Canvas as GCanvas } from '@antv/g';\nimport { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Plugin as DragNDropPlugin } from '@antv/g-plugin-dragndrop';\nimport { createDOM } from '@antv/util';\nimport { getBBoxSize, getCombinedBBox } from '../utils/bbox';\nimport { parsePoint, toPointObject } from '../utils/point';\nconst SINGLE_LAYER_NAME = ['main'];\nconst MULTI_LAYER_NAME = ['background', 'main', 'label', 'transient'];\n/**\n * <zh/> 获取主画布图层\n *\n * <en/> Get the main canvas layer\n * @param layers - <zh/> 画布图层 | <en/> Canvas layer\n * @returns <zh/> 主画布图层 | <en/> Main canvas layer\n */\nfunction getMainLayerOf(layers) {\n  return layers.main;\n}\nexport class Canvas {\n  getConfig() {\n    return this.config;\n  }\n  getLayer(layer = 'main') {\n    return this.extends.layers[layer] || getMainLayerOf(this.getLayers());\n  }\n  /**\n   * <zh/> 获取所有图层\n   *\n   * <en/> Get all layers\n   * @returns <zh/> 图层 <en/> Layer\n   */\n  getLayers() {\n    return this.extends.layers;\n  }\n  /**\n   * <zh/> 获取渲染器\n   *\n   * <en/> Get renderer\n   * @param layer - <zh/> 图层 <en/> Layer\n   * @returns <zh/> 渲染器 <en/> Renderer\n   */\n  getRenderer(layer) {\n    return this.extends.renderers[layer];\n  }\n  /**\n   * <zh/> 获取相机\n   *\n   * <en/> Get camera\n   * @param layer - <zh/> 图层 <en/> Layer\n   * @returns <zh/> 相机 <en/> Camera\n   */\n  getCamera(layer = 'main') {\n    return this.getLayer(layer).getCamera();\n  }\n  getRoot(layer = 'main') {\n    return this.getLayer(layer).getRoot();\n  }\n  getContextService(layer = 'main') {\n    return this.getLayer(layer).getContextService();\n  }\n  setCursor(cursor) {\n    this.config.cursor = cursor;\n    this.getLayer().setCursor(cursor);\n  }\n  get document() {\n    return this.getLayer().document;\n  }\n  get context() {\n    return this.getLayer().context;\n  }\n  constructor(config) {\n    this.config = {\n      enableMultiLayer: true\n    };\n    Object.assign(this.config, config);\n    const _a = this.config,\n      {\n        renderer,\n        background,\n        cursor,\n        enableMultiLayer\n      } = _a,\n      restConfig = __rest(_a, [\"renderer\", \"background\", \"cursor\", \"enableMultiLayer\"]);\n    const layersName = enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME;\n    const renderers = createRenderers(renderer, layersName);\n    const layers = Object.fromEntries(layersName.map(layer => {\n      const canvas = new GCanvas(Object.assign(Object.assign({}, restConfig), {\n        supportsMutipleCanvasesInOneContainer: enableMultiLayer,\n        renderer: renderers[layer],\n        background: enableMultiLayer ? layer === 'background' ? background : undefined : background\n      }));\n      return [layer, canvas];\n    }));\n    configCanvasDom(layers);\n    this.extends = {\n      config: this.config,\n      renderer,\n      renderers,\n      layers\n    };\n  }\n  get ready() {\n    return Promise.all(Object.entries(this.getLayers()).map(([, canvas]) => canvas.ready));\n  }\n  resize(width, height) {\n    Object.assign(this.extends.config, {\n      width,\n      height\n    });\n    Object.values(this.getLayers()).forEach(canvas => {\n      const camera = canvas.getCamera();\n      const position = camera.getPosition();\n      const focalPoint = camera.getFocalPoint();\n      canvas.resize(width, height);\n      camera.setPosition(position);\n      camera.setFocalPoint(focalPoint);\n    });\n  }\n  /**\n   * <zh/> 获取画布边界\n   *\n   * <en/> Get canvas boundary\n   * @param group\n   * <zh/> 元素分组\n   * - undefined: 获取整个画布边界\n   * - 'elements': 仅获取元素边界\n   * - 'plugins': 仅获取插件边界\n   *\n   * <en/> Element group\n   * - undefined: Get the entire canvas boundary\n   * - 'elements': Get only the element boundary\n   * - 'plugins': Get only the plugin boundary\n   * @returns <zh/> 边界 <en/> Boundary\n   */\n  getBounds(group) {\n    return getCombinedBBox(Object.values(this.getLayers()).map(canvas => {\n      const g = group ? canvas.getRoot().childNodes.find(node => node.classList.includes(group)) : canvas.getRoot();\n      return g;\n    }).filter(el => (el === null || el === void 0 ? void 0 : el.childNodes.length) > 0).map(el => el.getBounds()));\n  }\n  getContainer() {\n    const container = this.extends.config.container;\n    return typeof container === 'string' ? document.getElementById(container) : container;\n  }\n  getSize() {\n    return [this.extends.config.width || 0, this.extends.config.height || 0];\n  }\n  appendChild(child, index) {\n    var _a;\n    const layer = ((_a = child.style) === null || _a === void 0 ? void 0 : _a.$layer) || 'main';\n    return this.getLayer(layer).appendChild(child, index);\n  }\n  setRenderer(renderer) {\n    if (renderer === this.extends.renderer) return;\n    const renderers = createRenderers(renderer, this.config.enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME);\n    this.extends.renderers = renderers;\n    Object.entries(renderers).forEach(([layer, instance]) => this.getLayer(layer).setRenderer(instance));\n    configCanvasDom(this.getLayers());\n  }\n  getCanvasByViewport(point) {\n    return parsePoint(this.getLayer().viewport2Canvas(toPointObject(point)));\n  }\n  getViewportByCanvas(point) {\n    return parsePoint(this.getLayer().canvas2Viewport(toPointObject(point)));\n  }\n  getViewportByClient(point) {\n    return parsePoint(this.getLayer().client2Viewport(toPointObject(point)));\n  }\n  getClientByViewport(point) {\n    return parsePoint(this.getLayer().viewport2Client(toPointObject(point)));\n  }\n  getClientByCanvas(point) {\n    return this.getClientByViewport(this.getViewportByCanvas(point));\n  }\n  getCanvasByClient(point) {\n    const main = this.getLayer();\n    const viewportPoint = main.client2Viewport(toPointObject(point));\n    return parsePoint(main.viewport2Canvas(viewportPoint));\n  }\n  toDataURL() {\n    return __awaiter(this, arguments, void 0, function* (options = {}) {\n      const devicePixelRatio = globalThis.devicePixelRatio || 1;\n      const {\n          mode = 'viewport'\n        } = options,\n        restOptions = __rest(options, [\"mode\"]);\n      let [startX, startY, width, height] = [0, 0, 0, 0];\n      if (mode === 'viewport') {\n        [width, height] = this.getSize();\n      } else if (mode === 'overall') {\n        const bounds = this.getBounds();\n        const size = getBBoxSize(bounds);\n        [startX, startY] = bounds.min;\n        [width, height] = size;\n      }\n      const container = createDOM('<div id=\"virtual-image\"></div>');\n      const offscreenCanvas = new GCanvas({\n        width,\n        height,\n        renderer: new CanvasRenderer(),\n        devicePixelRatio,\n        container,\n        background: this.extends.config.background\n      });\n      yield offscreenCanvas.ready;\n      offscreenCanvas.appendChild(this.getLayer('background').getRoot().cloneNode(true));\n      offscreenCanvas.appendChild(this.getRoot().cloneNode(true));\n      // Handle label canvas\n      const label = this.getLayer('label').getRoot().cloneNode(true);\n      const originCanvasPosition = offscreenCanvas.viewport2Canvas({\n        x: 0,\n        y: 0\n      });\n      const currentCanvasPosition = this.getCanvasByViewport([0, 0]);\n      label.translate([currentCanvasPosition[0] - originCanvasPosition.x, currentCanvasPosition[1] - originCanvasPosition.y]);\n      label.scale(1 / this.getCamera().getZoom());\n      offscreenCanvas.appendChild(label);\n      offscreenCanvas.appendChild(this.getLayer('transient').getRoot().cloneNode(true));\n      const camera = this.getCamera();\n      const offscreenCamera = offscreenCanvas.getCamera();\n      if (mode === 'viewport') {\n        offscreenCamera.setZoom(camera.getZoom());\n        offscreenCamera.setPosition(camera.getPosition());\n        offscreenCamera.setFocalPoint(camera.getFocalPoint());\n      } else if (mode === 'overall') {\n        const [x, y, z] = offscreenCamera.getPosition();\n        const [fx, fy, fz] = offscreenCamera.getFocalPoint();\n        offscreenCamera.setPosition([x + startX, y + startY, z]);\n        offscreenCamera.setFocalPoint([fx + startX, fy + startY, fz]);\n      }\n      const contextService = offscreenCanvas.getContextService();\n      return new Promise(resolve => {\n        offscreenCanvas.addEventListener(CanvasEvent.RERENDER, () => __awaiter(this, void 0, void 0, function* () {\n          // 等待图片渲染完成 / Wait for the image to render\n          yield new Promise(r => setTimeout(r, 300));\n          const url = yield contextService.toDataURL(restOptions);\n          resolve(url);\n        }));\n      });\n    });\n  }\n  destroy() {\n    Object.values(this.getLayers()).forEach(canvas => {\n      const camera = canvas.getCamera();\n      camera.cancelLandmarkAnimation();\n      canvas.destroy();\n    });\n  }\n}\n/**\n * <zh/> 创建渲染器\n *\n * <en/> Create renderers\n * @param renderer - <zh/> 渲染器创建器 <en/> Renderer creator\n * @param layersName - <zh/> 图层名称 <en/> Layer name\n * @returns <zh/> 渲染器 <en/> Renderer\n */\nfunction createRenderers(renderer, layersName) {\n  return Object.fromEntries(layersName.map(layer => {\n    const instance = (renderer === null || renderer === void 0 ? void 0 : renderer(layer)) || new CanvasRenderer();\n    if (instance instanceof CanvasRenderer) {\n      instance.setConfig({\n        enableDirtyRectangleRendering: false\n      });\n    }\n    if (layer === 'main') {\n      instance.registerPlugin(new DragNDropPlugin({\n        isDocumentDraggable: true,\n        isDocumentDroppable: true,\n        dragstartDistanceThreshold: 10,\n        dragstartTimeThreshold: 100\n      }));\n    } else {\n      instance.unregisterPlugin(instance.getPlugin('dom-interaction'));\n    }\n    return [layer, instance];\n  }));\n}\n/**\n * <zh/> 配置画布 DOM\n *\n * <en/> Configure canvas DOM\n * @param layers - <zh/> 画布 <en/> Canvas\n */\nfunction configCanvasDom(layers) {\n  Object.entries(layers).forEach(([layer, canvas]) => {\n    const domElement = canvas.getContextService().getDomElement();\n    // 浏览器环境下，设置画布样式\n    // Set canvas style in browser environment\n    if (domElement === null || domElement === void 0 ? void 0 : domElement.style) {\n      domElement.style.gridArea = '1 / 1 / 2 / 2';\n      domElement.style.outline = 'none';\n      domElement.tabIndex = 1;\n      if (layer !== 'main') domElement.style.pointerEvents = 'none';\n    }\n    if (domElement === null || domElement === void 0 ? void 0 : domElement.parentElement) {\n      domElement.parentElement.style.display = 'grid';\n      // 给父元素设置独立的层叠上下文，避免外部元素影响内部的层叠逻辑\n      domElement.parentElement.style.isolation = 'isolate';\n    }\n  });\n}","map":{"version":3,"names":["CanvasEvent","Canvas","GCanvas","Renderer","CanvasRenderer","Plugin","DragNDropPlugin","createDOM","getBBoxSize","getCombinedBBox","parsePoint","toPointObject","SINGLE_LAYER_NAME","MULTI_LAYER_NAME","getMainLayerOf","layers","main","getConfig","config","getLayer","layer","extends","getLayers","getRenderer","renderers","getCamera","getRoot","getContextService","setCursor","cursor","document","context","constructor","enableMultiLayer","Object","assign","_a","renderer","background","restConfig","__rest","layersName","createRenderers","fromEntries","map","canvas","supportsMutipleCanvasesInOneContainer","undefined","configCanvasDom","ready","Promise","all","entries","resize","width","height","values","forEach","camera","position","getPosition","focalPoint","getFocalPoint","setPosition","setFocalPoint","getBounds","group","g","childNodes","find","node","classList","includes","filter","el","length","getContainer","container","getElementById","getSize","appendChild","child","index","style","$layer","setRenderer","instance","getCanvasByViewport","point","viewport2Canvas","getViewportByCanvas","canvas2Viewport","getViewportByClient","client2Viewport","getClientByViewport","viewport2Client","getClientByCanvas","getCanvasByClient","viewportPoint","toDataURL","options","devicePixelRatio","globalThis","mode","restOptions","startX","startY","bounds","size","min","offscreenCanvas","cloneNode","label","originCanvasPosition","x","y","currentCanvasPosition","translate","scale","getZoom","offscreenCamera","setZoom","z","fx","fy","fz","contextService","resolve","addEventListener","RERENDER","__awaiter","r","setTimeout","url","destroy","cancelLandmarkAnimation","setConfig","enableDirtyRectangleRendering","registerPlugin","isDocumentDraggable","isDocumentDroppable","dragstartDistanceThreshold","dragstartTimeThreshold","unregisterPlugin","getPlugin","domElement","getDomElement","gridArea","outline","tabIndex","pointerEvents","parentElement","display","isolation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/runtime/canvas.ts"],"sourcesContent":["import type { Cursor, DisplayObject, CanvasConfig as GCanvasConfig, IChildNode } from '@antv/g';\nimport { CanvasEvent, Canvas as GCanvas } from '@antv/g';\nimport { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Plugin as DragNDropPlugin } from '@antv/g-plugin-dragndrop';\nimport { createDOM } from '@antv/util';\nimport type { CanvasOptions } from '../spec/canvas';\nimport type { CanvasLayer, Point } from '../types';\nimport { getBBoxSize, getCombinedBBox } from '../utils/bbox';\nimport { parsePoint, toPointObject } from '../utils/point';\n\nexport interface CanvasConfig\n  extends Pick<GCanvasConfig, 'container' | 'devicePixelRatio' | 'width' | 'height' | 'cursor' | 'background'> {\n  /**\n   * <zh/> 渲染器\n   *\n   * <en/> renderer\n   */\n  renderer?: CanvasOptions['renderer'];\n  /**\n   * <zh/> 是否启用多图层\n   *\n   * <en/> Whether to enable multiple layers\n   * @defaultValue true\n   * @remarks\n   * <zh/> 非动态参数，仅在初始化时生效\n   *\n   * <en/> Non-dynamic parameters, only take effect during initialization\n   */\n  enableMultiLayer?: boolean;\n}\n\nexport interface DataURLOptions {\n  /**\n   * <zh/> 导出模式\n   *  - viewport: 导出视口内容\n   *  - overall: 导出整个画布\n   *\n   * <en/> export mode\n   *  - viewport: export the content of the viewport\n   *  - overall: export the entire canvas\n   */\n  mode?: 'viewport' | 'overall';\n  /**\n   * <zh/> 图片类型\n   *\n   * <en/> image type\n   * @defaultValue 'image/png'\n   */\n  type: 'image/png' | 'image/jpeg' | 'image/webp' | 'image/bmp';\n  /**\n   * <zh/> 图片质量, 仅对 image/jpeg 和 image/webp 有效，取值范围 0 ~ 1\n   *\n   * <en/> image quality, only valid for image/jpeg and image/webp, range 0 ~ 1\n   */\n  encoderOptions: number;\n}\n\nconst SINGLE_LAYER_NAME: CanvasLayer[] = ['main'];\nconst MULTI_LAYER_NAME: CanvasLayer[] = ['background', 'main', 'label', 'transient'];\n\n/**\n * <zh/> 获取主画布图层\n *\n * <en/> Get the main canvas layer\n * @param layers - <zh/> 画布图层 | <en/> Canvas layer\n * @returns <zh/> 主画布图层 | <en/> Main canvas layer\n */\nfunction getMainLayerOf(layers: Record<CanvasLayer, GCanvas>) {\n  return layers.main;\n}\n\nexport class Canvas {\n  private extends: {\n    config: CanvasConfig;\n    renderer: CanvasOptions['renderer'];\n    renderers: Record<CanvasLayer, CanvasRenderer>;\n    layers: Record<CanvasLayer, GCanvas>;\n  };\n\n  private config: CanvasConfig = {\n    enableMultiLayer: true,\n  };\n\n  public getConfig() {\n    return this.config;\n  }\n\n  public getLayer(layer: CanvasLayer = 'main') {\n    return this.extends.layers[layer] || getMainLayerOf(this.getLayers());\n  }\n\n  /**\n   * <zh/> 获取所有图层\n   *\n   * <en/> Get all layers\n   * @returns <zh/> 图层 <en/> Layer\n   */\n  public getLayers() {\n    return this.extends.layers;\n  }\n\n  /**\n   * <zh/> 获取渲染器\n   *\n   * <en/> Get renderer\n   * @param layer - <zh/> 图层 <en/> Layer\n   * @returns <zh/> 渲染器 <en/> Renderer\n   */\n  public getRenderer(layer: CanvasLayer) {\n    return this.extends.renderers[layer];\n  }\n\n  /**\n   * <zh/> 获取相机\n   *\n   * <en/> Get camera\n   * @param layer - <zh/> 图层 <en/> Layer\n   * @returns <zh/> 相机 <en/> Camera\n   */\n  public getCamera(layer: CanvasLayer = 'main') {\n    return this.getLayer(layer).getCamera();\n  }\n\n  public getRoot(layer: CanvasLayer = 'main') {\n    return this.getLayer(layer).getRoot();\n  }\n\n  public getContextService(layer: CanvasLayer = 'main') {\n    return this.getLayer(layer).getContextService();\n  }\n\n  public setCursor(cursor: Cursor): void {\n    this.config.cursor = cursor;\n    this.getLayer().setCursor(cursor);\n  }\n\n  public get document() {\n    return this.getLayer().document;\n  }\n\n  public get context() {\n    return this.getLayer().context;\n  }\n\n  constructor(config: CanvasConfig) {\n    Object.assign(this.config, config);\n\n    const { renderer, background, cursor, enableMultiLayer, ...restConfig } = this.config;\n    const layersName = enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME;\n    const renderers = createRenderers(renderer, layersName);\n    const layers = Object.fromEntries(\n      layersName.map((layer) => {\n        const canvas = new GCanvas({\n          ...restConfig,\n          supportsMutipleCanvasesInOneContainer: enableMultiLayer,\n          renderer: renderers[layer],\n          background: enableMultiLayer ? (layer === 'background' ? background : undefined) : background,\n        });\n\n        return [layer, canvas];\n      }),\n    ) as Record<CanvasLayer, GCanvas>;\n\n    configCanvasDom(layers);\n\n    this.extends = {\n      config: this.config,\n      renderer,\n      renderers,\n      layers,\n    };\n  }\n\n  public get ready() {\n    return Promise.all(Object.entries(this.getLayers()).map(([, canvas]) => canvas.ready));\n  }\n\n  public resize(width: number, height: number) {\n    Object.assign(this.extends.config, { width, height });\n    Object.values(this.getLayers()).forEach((canvas) => {\n      const camera = canvas.getCamera();\n      const position = camera.getPosition();\n      const focalPoint = camera.getFocalPoint();\n\n      canvas.resize(width, height);\n\n      camera.setPosition(position);\n      camera.setFocalPoint(focalPoint);\n    });\n  }\n\n  /**\n   * <zh/> 获取画布边界\n   *\n   * <en/> Get canvas boundary\n   * @param group\n   * <zh/> 元素分组\n   * - undefined: 获取整个画布边界\n   * - 'elements': 仅获取元素边界\n   * - 'plugins': 仅获取插件边界\n   *\n   * <en/> Element group\n   * - undefined: Get the entire canvas boundary\n   * - 'elements': Get only the element boundary\n   * - 'plugins': Get only the plugin boundary\n   * @returns <zh/> 边界 <en/> Boundary\n   */\n  public getBounds(group?: 'elements' | 'plugins') {\n    return getCombinedBBox(\n      Object.values(this.getLayers())\n        .map((canvas) => {\n          const g = group\n            ? (canvas\n                .getRoot()\n                .childNodes.find((node) => (node as DisplayObject).classList.includes(group)) as DisplayObject)\n            : canvas.getRoot();\n          return g;\n        })\n        .filter((el) => el?.childNodes.length > 0)\n        .map((el) => el.getBounds()),\n    );\n  }\n\n  public getContainer() {\n    const container = this.extends.config.container!;\n    return typeof container === 'string' ? document.getElementById(container!) : container;\n  }\n\n  public getSize(): [number, number] {\n    return [this.extends.config.width || 0, this.extends.config.height || 0];\n  }\n\n  public appendChild<T extends IChildNode>(child: T, index?: number): T {\n    const layer = ((child as unknown as DisplayObject).style?.$layer || 'main') as CanvasLayer;\n    return this.getLayer(layer).appendChild(child, index);\n  }\n\n  public setRenderer(renderer: CanvasOptions['renderer']) {\n    if (renderer === this.extends.renderer) return;\n    const renderers = createRenderers(renderer, this.config.enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME);\n    this.extends.renderers = renderers;\n    Object.entries(renderers).forEach(([layer, instance]) => this.getLayer(layer as CanvasLayer).setRenderer(instance));\n    configCanvasDom(this.getLayers());\n  }\n\n  public getCanvasByViewport(point: Point): Point {\n    return parsePoint(this.getLayer().viewport2Canvas(toPointObject(point)));\n  }\n\n  public getViewportByCanvas(point: Point): Point {\n    return parsePoint(this.getLayer().canvas2Viewport(toPointObject(point)));\n  }\n\n  public getViewportByClient(point: Point): Point {\n    return parsePoint(this.getLayer().client2Viewport(toPointObject(point)));\n  }\n\n  public getClientByViewport(point: Point): Point {\n    return parsePoint(this.getLayer().viewport2Client(toPointObject(point)));\n  }\n\n  public getClientByCanvas(point: Point): Point {\n    return this.getClientByViewport(this.getViewportByCanvas(point));\n  }\n\n  public getCanvasByClient(point: Point): Point {\n    const main = this.getLayer();\n    const viewportPoint = main.client2Viewport(toPointObject(point));\n    return parsePoint(main.viewport2Canvas(viewportPoint));\n  }\n\n  public async toDataURL(options: Partial<DataURLOptions> = {}) {\n    const devicePixelRatio = globalThis.devicePixelRatio || 1;\n    const { mode = 'viewport', ...restOptions } = options;\n    let [startX, startY, width, height] = [0, 0, 0, 0];\n\n    if (mode === 'viewport') {\n      [width, height] = this.getSize();\n    } else if (mode === 'overall') {\n      const bounds = this.getBounds();\n      const size = getBBoxSize(bounds);\n      [startX, startY] = bounds.min;\n      [width, height] = size;\n    }\n\n    const container: HTMLElement = createDOM('<div id=\"virtual-image\"></div>');\n\n    const offscreenCanvas = new GCanvas({\n      width,\n      height,\n      renderer: new CanvasRenderer(),\n      devicePixelRatio,\n      container,\n      background: this.extends.config.background,\n    });\n\n    await offscreenCanvas.ready;\n\n    offscreenCanvas.appendChild(this.getLayer('background').getRoot().cloneNode(true));\n    offscreenCanvas.appendChild(this.getRoot().cloneNode(true));\n\n    // Handle label canvas\n    const label = this.getLayer('label').getRoot().cloneNode(true);\n    const originCanvasPosition = offscreenCanvas.viewport2Canvas({ x: 0, y: 0 });\n    const currentCanvasPosition = this.getCanvasByViewport([0, 0]);\n    label.translate([\n      currentCanvasPosition[0] - originCanvasPosition.x,\n      currentCanvasPosition[1] - originCanvasPosition.y,\n    ]);\n    label.scale(1 / this.getCamera().getZoom());\n    offscreenCanvas.appendChild(label);\n\n    offscreenCanvas.appendChild(this.getLayer('transient').getRoot().cloneNode(true));\n\n    const camera = this.getCamera();\n    const offscreenCamera = offscreenCanvas.getCamera();\n\n    if (mode === 'viewport') {\n      offscreenCamera.setZoom(camera.getZoom());\n      offscreenCamera.setPosition(camera.getPosition());\n      offscreenCamera.setFocalPoint(camera.getFocalPoint());\n    } else if (mode === 'overall') {\n      const [x, y, z] = offscreenCamera.getPosition();\n      const [fx, fy, fz] = offscreenCamera.getFocalPoint();\n      offscreenCamera.setPosition([x + startX, y + startY, z]);\n      offscreenCamera.setFocalPoint([fx + startX, fy + startY, fz]);\n    }\n\n    const contextService = offscreenCanvas.getContextService();\n\n    return new Promise<string>((resolve) => {\n      offscreenCanvas.addEventListener(CanvasEvent.RERENDER, async () => {\n        // 等待图片渲染完成 / Wait for the image to render\n        await new Promise((r) => setTimeout(r, 300));\n        const url = await contextService.toDataURL(restOptions);\n        resolve(url);\n      });\n    });\n  }\n\n  public destroy() {\n    Object.values(this.getLayers()).forEach((canvas) => {\n      const camera = canvas.getCamera();\n      camera.cancelLandmarkAnimation();\n      canvas.destroy();\n    });\n  }\n}\n\n/**\n * <zh/> 创建渲染器\n *\n * <en/> Create renderers\n * @param renderer - <zh/> 渲染器创建器 <en/> Renderer creator\n * @param layersName - <zh/> 图层名称 <en/> Layer name\n * @returns <zh/> 渲染器 <en/> Renderer\n */\nfunction createRenderers(renderer: CanvasConfig['renderer'], layersName: CanvasLayer[]) {\n  return Object.fromEntries(\n    layersName.map((layer) => {\n      const instance = renderer?.(layer) || new CanvasRenderer();\n\n      if (instance instanceof CanvasRenderer) {\n        instance.setConfig({ enableDirtyRectangleRendering: false });\n      }\n\n      if (layer === 'main') {\n        instance.registerPlugin(\n          new DragNDropPlugin({\n            isDocumentDraggable: true,\n            isDocumentDroppable: true,\n            dragstartDistanceThreshold: 10,\n            dragstartTimeThreshold: 100,\n          }),\n        );\n      } else {\n        instance.unregisterPlugin(instance.getPlugin('dom-interaction'));\n      }\n\n      return [layer, instance];\n    }),\n  ) as Record<CanvasLayer, CanvasRenderer>;\n}\n\n/**\n * <zh/> 配置画布 DOM\n *\n * <en/> Configure canvas DOM\n * @param layers - <zh/> 画布 <en/> Canvas\n */\nfunction configCanvasDom(layers: Record<CanvasLayer, GCanvas>) {\n  Object.entries(layers).forEach(([layer, canvas]) => {\n    const domElement = canvas.getContextService().getDomElement() as unknown as HTMLElement;\n\n    // 浏览器环境下，设置画布样式\n    // Set canvas style in browser environment\n    if (domElement?.style) {\n      domElement.style.gridArea = '1 / 1 / 2 / 2';\n      domElement.style.outline = 'none';\n      domElement.tabIndex = 1;\n\n      if (layer !== 'main') domElement.style.pointerEvents = 'none';\n    }\n\n    if (domElement?.parentElement) {\n      domElement.parentElement.style.display = 'grid';\n      // 给父元素设置独立的层叠上下文，避免外部元素影响内部的层叠逻辑\n      domElement.parentElement.style.isolation = 'isolate';\n    }\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}