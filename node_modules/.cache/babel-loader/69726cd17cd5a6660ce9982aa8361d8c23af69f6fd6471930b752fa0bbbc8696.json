{"ast":null,"code":"import { norm2, scale, weightedSum } from './blas1';\nimport { wolfeLineSearch } from './linesearch';\nexport function gradientDescent(f, initial, params) {\n  params = params || {};\n  const maxIterations = params.maxIterations || initial.length * 100;\n  const learnRate = params.learnRate || 0.001;\n  const current = {\n    x: initial.slice(),\n    fx: 0,\n    fxprime: initial.slice()\n  };\n  for (let i = 0; i < maxIterations; ++i) {\n    current.fx = f(current.x, current.fxprime);\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice()\n      });\n    }\n    weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n    if (norm2(current.fxprime) <= 1e-5) {\n      break;\n    }\n  }\n  return current;\n}\nexport function gradientDescentLineSearch(f, initial, params) {\n  params = params || {};\n  let current = {\n    x: initial.slice(),\n    fx: 0,\n    fxprime: initial.slice()\n  };\n  let next = {\n    x: initial.slice(),\n    fx: 0,\n    fxprime: initial.slice()\n  };\n  const maxIterations = params.maxIterations || initial.length * 100;\n  let learnRate = params.learnRate || 1;\n  const pk = initial.slice();\n  const c1 = params.c1 || 1e-3;\n  const c2 = params.c2 || 0.1;\n  let temp;\n  let functionCalls = [];\n  if (params.history) {\n    // wrap the function call to track linesearch samples\n    const inner = f;\n    f = (x, fxprime) => {\n      functionCalls.push(x.slice());\n      return inner(x, fxprime);\n    };\n  }\n  current.fx = f(current.x, current.fxprime);\n  for (let i = 0; i < maxIterations; ++i) {\n    scale(pk, current.fxprime, -1);\n    learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        functionCalls: functionCalls,\n        learnRate: learnRate,\n        alpha: learnRate\n      });\n      functionCalls = [];\n    }\n    temp = current;\n    current = next;\n    next = temp;\n    if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;\n  }\n  return current;\n}","map":{"version":3,"names":["norm2","scale","weightedSum","wolfeLineSearch","gradientDescent","f","initial","params","maxIterations","length","learnRate","current","x","slice","fx","fxprime","i","history","push","gradientDescentLineSearch","next","pk","c1","c2","temp","functionCalls","inner","alpha"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/data/utils/venn/fmin/gradientDescent.ts"],"sourcesContent":["import { dot, norm2, scale, weightedSum, zeros } from './blas1';\nimport { wolfeLineSearch } from './linesearch';\n\nexport function gradientDescent(f, initial, params) {\n  params = params || {};\n  const maxIterations = params.maxIterations || initial.length * 100;\n  const learnRate = params.learnRate || 0.001;\n  const current = { x: initial.slice(), fx: 0, fxprime: initial.slice() };\n\n  for (let i = 0; i < maxIterations; ++i) {\n    current.fx = f(current.x, current.fxprime);\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n      });\n    }\n\n    weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n    if (norm2(current.fxprime) <= 1e-5) {\n      break;\n    }\n  }\n\n  return current;\n}\n\nexport function gradientDescentLineSearch(f, initial, params) {\n  params = params || {};\n  let current = { x: initial.slice(), fx: 0, fxprime: initial.slice() };\n  let next = { x: initial.slice(), fx: 0, fxprime: initial.slice() };\n  const maxIterations = params.maxIterations || initial.length * 100;\n  let learnRate = params.learnRate || 1;\n  const pk = initial.slice();\n  const c1 = params.c1 || 1e-3;\n  const c2 = params.c2 || 0.1;\n  let temp;\n  let functionCalls = [];\n\n  if (params.history) {\n    // wrap the function call to track linesearch samples\n    const inner = f;\n    f = (x, fxprime) => {\n      functionCalls.push(x.slice());\n      return inner(x, fxprime);\n    };\n  }\n\n  current.fx = f(current.x, current.fxprime);\n  for (let i = 0; i < maxIterations; ++i) {\n    scale(pk, current.fxprime, -1);\n    learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        functionCalls: functionCalls,\n        learnRate: learnRate,\n        alpha: learnRate,\n      });\n      functionCalls = [];\n    }\n\n    temp = current;\n    current = next;\n    next = temp;\n\n    if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;\n  }\n\n  return current;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}