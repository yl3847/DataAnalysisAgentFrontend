{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix } from '@antv/util';\nimport { extent } from '@antv/vendor/d3-array';\nimport { columnOf, column } from './utils/helper';\nimport { createGroups } from './utils/order';\n/**\n * The SymmetryY transform apply offset for y channels, say to transform\n * them to be symmetry.\n */\nexport const SymmetryY = (options = {}) => {\n  const {\n    groupBy = 'x'\n  } = options;\n  return (I, mark) => {\n    const {\n      encode\n    } = mark;\n    const {\n        x\n      } = encode,\n      rest = __rest(encode, [\"x\"]);\n    // Extract and create new channels starts with y, such as y, y1.\n    const Yn = Object.entries(rest).filter(([k]) => k.startsWith('y')).map(([k]) => [k, columnOf(encode, k)[0]]);\n    const newYn = Yn.map(([k]) => [k, new Array(I.length)]);\n    // Group marks into series by specified keys.\n    const groups = createGroups(groupBy, I, mark);\n    const MY = new Array(groups.length);\n    for (let i = 0; i < groups.length; i++) {\n      const I = groups[i];\n      const Y = I.flatMap(i => Yn.map(([, V]) => +V[i]));\n      const [minY, maxY] = extent(Y);\n      MY[i] = (minY + maxY) / 2;\n    }\n    const maxMiddleY = Math.max(...MY);\n    for (let m = 0; m < groups.length; m++) {\n      const offset = maxMiddleY - MY[m];\n      const I = groups[m];\n      for (const i of I) {\n        for (let j = 0; j < Yn.length; j++) {\n          const [, V] = Yn[j];\n          const [, newV] = newYn[j];\n          newV[i] = +V[i] + offset;\n        }\n      }\n    }\n    return [I, deepMix({}, mark, {\n      encode: Object.fromEntries(newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])]))\n    })];\n  };\n};\nSymmetryY.props = {};","map":{"version":3,"names":["deepMix","extent","columnOf","column","createGroups","SymmetryY","options","groupBy","I","mark","encode","x","rest","__rest","Yn","Object","entries","filter","k","startsWith","map","newYn","Array","length","groups","MY","i","Y","flatMap","V","minY","maxY","maxMiddleY","Math","max","m","offset","j","newV","fromEntries","v","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/symmetryY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { extent } from '@antv/vendor/d3-array';\nimport { TransformComponent as TC } from '../runtime';\nimport { SymmetryYTransform } from '../spec';\nimport { columnOf, column } from './utils/helper';\nimport { createGroups } from './utils/order';\n\nexport type SymmetryYOptions = Omit<SymmetryYTransform, 'type'>;\n\n/**\n * The SymmetryY transform apply offset for y channels, say to transform\n * them to be symmetry.\n */\nexport const SymmetryY: TC<SymmetryYOptions> = (options = {}) => {\n  const { groupBy = 'x' } = options;\n  return (I, mark) => {\n    const { encode } = mark;\n    const { x, ...rest } = encode;\n\n    // Extract and create new channels starts with y, such as y, y1.\n    const Yn = Object.entries(rest)\n      .filter(([k]) => k.startsWith('y'))\n      .map(([k]) => [k, columnOf(encode, k)[0]] as const);\n    const newYn = Yn.map(([k]) => [k, new Array(I.length)] as const);\n\n    // Group marks into series by specified keys.\n    const groups = createGroups(groupBy, I, mark);\n    const MY = new Array(groups.length);\n    for (let i = 0; i < groups.length; i++) {\n      const I = groups[i];\n      const Y = I.flatMap((i) => Yn.map(([, V]) => +V[i]));\n      const [minY, maxY] = extent(Y);\n      MY[i] = (minY + maxY) / 2;\n    }\n\n    const maxMiddleY = Math.max(...MY);\n    for (let m = 0; m < groups.length; m++) {\n      const offset = maxMiddleY - MY[m];\n      const I = groups[m];\n      for (const i of I) {\n        for (let j = 0; j < Yn.length; j++) {\n          const [, V] = Yn[j];\n          const [, newV] = newYn[j];\n          newV[i] = +V[i] + offset;\n        }\n      }\n    }\n\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: Object.fromEntries(\n          newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])]),\n        ),\n      }),\n    ];\n  };\n};\n\nSymmetryY.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}