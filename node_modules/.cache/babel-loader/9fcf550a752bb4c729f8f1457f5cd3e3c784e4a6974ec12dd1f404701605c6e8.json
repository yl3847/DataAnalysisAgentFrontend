{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix, isNumber } from '@antv/util';\nimport { Group } from '@antv/g';\nimport { filterPrefixObject, isUnset, subObject } from '../utils/helper';\nimport { getTransformOptions } from '../utils/coordinate';\nimport { Radial } from '../coordinate';\nimport { applyStyle, getOrigin } from '../shape/utils';\nimport { select } from '../utils/selection';\nimport { GaugeRound } from '../shape';\nconst indicatorShape = (options, context) => {\n  const {\n      shape,\n      radius\n    } = options,\n    style = __rest(options, [\"shape\", \"radius\"]);\n  const pointerStyle = subObject(style, 'pointer');\n  const pinStyle = subObject(style, 'pin');\n  const {\n      shape: pointerShape\n    } = pointerStyle,\n    resPointerStyle = __rest(pointerStyle, [\"shape\"]);\n  const {\n      shape: pinShape\n    } = pinStyle,\n    resPinStyle = __rest(pinStyle, [\"shape\"]);\n  const {\n    coordinate,\n    theme\n  } = context;\n  return (points, value) => {\n    // Invert points.\n    const invertedPoints = points.map(p => coordinate.invert(p));\n    // Get new coordinate.\n    const [startAngle, endAngle, innerRadius] = getTransformOptions(coordinate, 'polar');\n    const newCoordinate = coordinate.clone();\n    const {\n      color: stroke\n    } = value;\n    const newTransformations = Radial({\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius: radius\n    });\n    newTransformations.push(['cartesian']);\n    newCoordinate.update({\n      transformations: newTransformations\n    });\n    const newPoints = invertedPoints.map(p => newCoordinate.map(p));\n    const [x, y] = getOrigin(newPoints);\n    const [cx, cy] = coordinate.getCenter();\n    const pointerAttrs = Object.assign(Object.assign({\n      x1: x,\n      y1: y,\n      x2: cx,\n      y2: cy,\n      stroke\n    }, resPointerStyle), style);\n    const pinAttrs = Object.assign(Object.assign({\n      cx,\n      cy,\n      stroke\n    }, resPinStyle), style);\n    const indicatorGroup = select(new Group());\n    if (!isUnset(pointerShape)) {\n      typeof pointerShape === 'function' ? indicatorGroup.append(() => pointerShape(newPoints, value, newCoordinate, theme)) : indicatorGroup.append('line').call(applyStyle, pointerAttrs).node();\n    }\n    if (!isUnset(pinShape)) {\n      typeof pinShape === 'function' ? indicatorGroup.append(() => pinShape(newPoints, value, newCoordinate, theme)) : indicatorGroup.append('circle').call(applyStyle, pinAttrs).node();\n    }\n    return indicatorGroup.node();\n  };\n};\nconst DEFAULT_OPTIONS = {\n  coordinate: {\n    type: 'radial',\n    innerRadius: 0.9,\n    outerRadius: 1,\n    startAngle: -11 / 10 * Math.PI,\n    endAngle: 1 / 10 * Math.PI\n  },\n  axis: {\n    x: false\n  },\n  legend: false,\n  tooltip: false,\n  encode: {\n    x: 'x',\n    y: 'y',\n    color: 'color'\n  },\n  scale: {\n    color: {\n      range: ['#30BF78', '#D0D0D0']\n    }\n  }\n};\nconst DEFAULT_INDICATOR_OPTIONS = {\n  style: {\n    shape: indicatorShape,\n    lineWidth: 4,\n    pointerLineCap: 'round',\n    pinR: 10,\n    pinFill: '#fff',\n    radius: 0.6\n  }\n};\nconst DEFAULT_TEXT_OPTIONS = {\n  type: 'text',\n  style: {\n    x: '50%',\n    y: '60%',\n    textAlign: 'center',\n    textBaseline: 'middle',\n    fontSize: 20,\n    fontWeight: 800,\n    fill: '#888'\n  },\n  tooltip: false\n};\nfunction getGaugeData(data) {\n  if (isNumber(data)) {\n    // Percent range [0, 1].\n    const percent = Math.max(0, Math.min(data, 1));\n    return {\n      percent,\n      target: percent,\n      total: 1\n    };\n  }\n  return data;\n}\nfunction dataTransform(data, scale) {\n  const {\n    name = 'score',\n    target,\n    total,\n    percent,\n    thresholds = []\n  } = getGaugeData(data);\n  const _target = percent || target;\n  const _total = percent ? 1 : total;\n  const newScale = Object.assign({\n    y: {\n      domain: [0, _total]\n    }\n  }, scale);\n  if (!thresholds.length) {\n    return {\n      targetData: [{\n        x: name,\n        y: _target,\n        color: 'target'\n      }],\n      totalData: [{\n        x: name,\n        y: _target,\n        color: 'target'\n      }, {\n        x: name,\n        y: _total - _target,\n        color: 'total'\n      }],\n      target: _target,\n      total: _total,\n      scale: newScale\n    };\n  }\n  return {\n    targetData: [{\n      x: name,\n      y: _target,\n      color: 'target'\n    }],\n    totalData: thresholds.map((d, i) => ({\n      x: name,\n      y: i >= 1 ? d - thresholds[i - 1] : d,\n      color: i\n    })),\n    target: _target,\n    total: _total,\n    scale: newScale\n  };\n}\nfunction getTextContent(textStyle, {\n  target,\n  total\n}) {\n  const {\n    content\n  } = textStyle;\n  return content ? content(target, total) : target.toString();\n}\nexport const Gauge = options => {\n  const {\n      data = {},\n      scale = {},\n      style = {},\n      animate = {},\n      transform = []\n    } = options,\n    resOptions = __rest(options, [\"data\", \"scale\", \"style\", \"animate\", \"transform\"]);\n  const {\n    targetData,\n    totalData,\n    target,\n    total,\n    scale: newScale\n  } = dataTransform(data, scale);\n  const _a = subObject(style, 'text'),\n    {\n      tooltip\n    } = _a,\n    textStyle = __rest(_a, [\"tooltip\"]);\n  // pointer + pin\n  const indicatorStyle = filterPrefixObject(style, ['pointer', 'pin']);\n  const arcStyle = subObject(style, 'arc');\n  const shape = arcStyle.shape;\n  return [deepMix({}, DEFAULT_OPTIONS, Object.assign({\n    type: 'interval',\n    transform: [{\n      type: 'stackY'\n    }],\n    data: totalData,\n    scale: newScale,\n    style: shape === 'round' ? Object.assign(Object.assign({}, arcStyle), {\n      shape: GaugeRound\n    }) : arcStyle,\n    animate: typeof animate === 'object' ? subObject(animate, 'arc') : animate\n  }, resOptions)), deepMix({}, DEFAULT_OPTIONS, DEFAULT_INDICATOR_OPTIONS, Object.assign({\n    type: 'point',\n    data: targetData,\n    scale: newScale,\n    style: indicatorStyle,\n    animate: typeof animate === 'object' ? subObject(animate, 'indicator') : animate\n  }, resOptions)), deepMix({}, DEFAULT_TEXT_OPTIONS, {\n    style: Object.assign({\n      text: getTextContent(textStyle, {\n        target,\n        total\n      })\n    }, textStyle),\n    tooltip,\n    animate: typeof animate === 'object' ? subObject(animate, 'text') : animate\n  })];\n};\nGauge.props = {};","map":{"version":3,"names":["deepMix","isNumber","Group","filterPrefixObject","isUnset","subObject","getTransformOptions","Radial","applyStyle","getOrigin","select","GaugeRound","indicatorShape","options","context","shape","radius","style","__rest","pointerStyle","pinStyle","pointerShape","resPointerStyle","pinShape","resPinStyle","coordinate","theme","points","value","invertedPoints","map","p","invert","startAngle","endAngle","innerRadius","newCoordinate","clone","color","stroke","newTransformations","outerRadius","push","update","transformations","newPoints","x","y","cx","cy","getCenter","pointerAttrs","Object","assign","x1","y1","x2","y2","pinAttrs","indicatorGroup","append","call","node","DEFAULT_OPTIONS","type","Math","PI","axis","legend","tooltip","encode","scale","range","DEFAULT_INDICATOR_OPTIONS","lineWidth","pointerLineCap","pinR","pinFill","DEFAULT_TEXT_OPTIONS","textAlign","textBaseline","fontSize","fontWeight","fill","getGaugeData","data","percent","max","min","target","total","dataTransform","name","thresholds","_target","_total","newScale","domain","length","targetData","totalData","d","i","getTextContent","textStyle","content","toString","Gauge","animate","transform","resOptions","_a","indicatorStyle","arcStyle","text","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/mark/gauge.ts"],"sourcesContent":["import { deepMix, isNumber } from '@antv/util';\nimport { Vector2 } from '@antv/coord';\nimport { Group } from '@antv/g';\nimport { filterPrefixObject, isUnset, subObject } from '../utils/helper';\nimport { CompositeMarkComponent as CC, ShapeComponent as SC } from '../runtime';\nimport { ColorOptions } from '../shape/point/color';\nimport { GaugeMark } from '../spec';\nimport { getTransformOptions } from '../utils/coordinate';\nimport { Radial } from '../coordinate';\nimport { applyStyle, getOrigin } from '../shape/utils';\nimport { select } from '../utils/selection';\nimport { GaugeRound } from '../shape';\n\nconst indicatorShape: SC<ColorOptions> = (options, context) => {\n  const { shape, radius, ...style } = options;\n  const pointerStyle = subObject(style, 'pointer');\n  const pinStyle = subObject(style, 'pin');\n  const { shape: pointerShape, ...resPointerStyle } = pointerStyle;\n  const { shape: pinShape, ...resPinStyle } = pinStyle;\n  const { coordinate, theme } = context;\n  return (points, value) => {\n    // Invert points.\n    const invertedPoints = points.map((p) => coordinate.invert(p));\n    // Get new coordinate.\n    const [startAngle, endAngle, innerRadius] = getTransformOptions(\n      coordinate,\n      'polar',\n    ) as number[];\n    const newCoordinate = coordinate.clone();\n    const { color: stroke } = value;\n    const newTransformations = Radial({\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius: radius,\n    });\n    newTransformations.push(['cartesian']);\n    newCoordinate.update({\n      transformations: newTransformations,\n    });\n    const newPoints = invertedPoints.map((p) => newCoordinate.map(p));\n    const [x, y] = getOrigin(newPoints as Vector2[]);\n    const [cx, cy] = coordinate.getCenter();\n    const pointerAttrs = {\n      x1: x,\n      y1: y,\n      x2: cx,\n      y2: cy,\n      stroke,\n      ...resPointerStyle,\n      ...style,\n    };\n    const pinAttrs = {\n      cx,\n      cy,\n      stroke,\n      ...resPinStyle,\n      ...style,\n    };\n    const indicatorGroup = select(new Group());\n    if (!isUnset(pointerShape)) {\n      typeof pointerShape === 'function'\n        ? indicatorGroup.append(() =>\n            pointerShape(newPoints, value, newCoordinate, theme),\n          )\n        : indicatorGroup.append('line').call(applyStyle, pointerAttrs).node();\n    }\n    if (!isUnset(pinShape)) {\n      typeof pinShape === 'function'\n        ? indicatorGroup.append(() =>\n            pinShape(newPoints, value, newCoordinate, theme),\n          )\n        : indicatorGroup.append('circle').call(applyStyle, pinAttrs).node();\n    }\n    return indicatorGroup.node();\n  };\n};\n\nconst DEFAULT_OPTIONS = {\n  coordinate: {\n    type: 'radial',\n    innerRadius: 0.9,\n    outerRadius: 1,\n    startAngle: (-11 / 10) * Math.PI,\n    endAngle: (1 / 10) * Math.PI,\n  },\n  axis: {\n    x: false,\n  },\n  legend: false,\n  tooltip: false,\n  encode: {\n    x: 'x',\n    y: 'y',\n    color: 'color',\n  },\n  scale: {\n    color: {\n      range: ['#30BF78', '#D0D0D0'],\n    },\n  },\n};\n\nconst DEFAULT_INDICATOR_OPTIONS = {\n  style: {\n    shape: indicatorShape,\n    lineWidth: 4,\n    pointerLineCap: 'round',\n    pinR: 10,\n    pinFill: '#fff',\n    radius: 0.6,\n  },\n};\n\nconst DEFAULT_TEXT_OPTIONS = {\n  type: 'text',\n  style: {\n    x: '50%',\n    y: '60%',\n    textAlign: 'center',\n    textBaseline: 'middle',\n    fontSize: 20,\n    fontWeight: 800,\n    fill: '#888',\n  },\n  tooltip: false,\n};\n\nexport type GaugeData =\n  | {\n      target?: number;\n      total?: number;\n      percent?: number;\n      name?: string;\n      thresholds?: number[];\n    }\n  | number;\n\nfunction getGaugeData(data: GaugeData) {\n  if (isNumber(data)) {\n    // Percent range [0, 1].\n    const percent = Math.max(0, Math.min(data, 1));\n    return {\n      percent,\n      target: percent,\n      total: 1,\n    };\n  }\n  return data;\n}\n\nfunction dataTransform(data: GaugeData, scale) {\n  const {\n    name = 'score',\n    target,\n    total,\n    percent,\n    thresholds = [],\n  } = getGaugeData(data);\n  const _target = percent || target;\n  const _total = percent ? 1 : total;\n  const newScale = {\n    y: {\n      domain: [0, _total],\n    },\n    ...scale,\n  };\n  if (!thresholds.length) {\n    return {\n      targetData: [{ x: name, y: _target, color: 'target' }],\n      totalData: [\n        { x: name, y: _target, color: 'target' },\n        { x: name, y: _total - _target, color: 'total' },\n      ],\n      target: _target,\n      total: _total,\n      scale: newScale,\n    };\n  }\n  return {\n    targetData: [{ x: name, y: _target, color: 'target' }],\n    totalData: thresholds.map((d, i) => ({\n      x: name,\n      y: i >= 1 ? d - thresholds[i - 1] : d,\n      color: i,\n    })),\n    target: _target,\n    total: _total,\n    scale: newScale,\n  };\n}\n\nfunction getTextContent(textStyle, { target, total }) {\n  const { content } = textStyle;\n  return content ? content(target, total) : target.toString();\n}\n\nexport type GaugeOptions = Omit<GaugeMark, 'type'>;\n\nexport const Gauge: CC<GaugeOptions> = (options) => {\n  const {\n    data = {},\n    scale = {},\n    style = {},\n    animate = {},\n    transform = [],\n    ...resOptions\n  } = options;\n  const {\n    targetData,\n    totalData,\n    target,\n    total,\n    scale: newScale,\n  } = dataTransform(data, scale);\n  const { tooltip, ...textStyle } = subObject(style, 'text');\n  // pointer + pin\n  const indicatorStyle = filterPrefixObject(style, ['pointer', 'pin']);\n\n  const arcStyle = subObject(style, 'arc');\n  const shape = arcStyle.shape;\n\n  return [\n    deepMix({}, DEFAULT_OPTIONS, {\n      type: 'interval',\n      transform: [{ type: 'stackY' }],\n      data: totalData,\n      scale: newScale,\n      style: shape === 'round' ? { ...arcStyle, shape: GaugeRound } : arcStyle,\n      animate:\n        typeof animate === 'object' ? subObject(animate, 'arc') : animate,\n      ...resOptions,\n    }),\n    deepMix({}, DEFAULT_OPTIONS, DEFAULT_INDICATOR_OPTIONS, {\n      type: 'point',\n      data: targetData,\n      scale: newScale,\n      style: indicatorStyle,\n      animate:\n        typeof animate === 'object' ? subObject(animate, 'indicator') : animate,\n      ...resOptions,\n    }),\n    deepMix({}, DEFAULT_TEXT_OPTIONS, {\n      style: {\n        text: getTextContent(textStyle, { target, total }),\n        ...textStyle,\n      },\n      tooltip,\n      animate:\n        typeof animate === 'object' ? subObject(animate, 'text') : animate,\n    }),\n  ];\n};\n\nGauge.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}