{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Rect, Path } from '@antv/g';\nimport { subObject, omitPrefixObject } from '../utils/helper';\nimport { selectionOf, pixelsOf } from '../utils/scale';\nimport { createElement } from '../utils/createElement';\nimport { select } from '../utils/selection';\nimport { selectG2Elements, selectPlotArea, createDatumof, useState, createValueof, setCursor, brushMousePosition, selectFacetG2Elements, mergeState, selectFacetViews } from './utils';\nfunction intersect(bbox1, bbox2) {\n  const [minX1, minY1, maxX1, maxY1] = bbox1;\n  const [minX2, minY2, maxX2, maxY2] = bbox2;\n  return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);\n}\nfunction normalizeBounds(x, y, x1, y1, extent) {\n  const [minX, minY, maxX, maxY] = extent;\n  return [Math.max(minX, Math.min(x, x1)), Math.max(minY, Math.min(y, y1)), Math.min(maxX, Math.max(x, x1)), Math.min(maxY, Math.max(y, y1))];\n}\nfunction bboxOf(root) {\n  const {\n    width,\n    height\n  } = root.getBBox();\n  return [0, 0, width, height];\n}\nfunction applyStyle(selection, style) {\n  for (const [key, value] of Object.entries(style)) {\n    selection.style(key, value);\n  }\n}\nconst ResizableMask = createElement(g => {\n  const _a = g.attributes,\n    {\n      x,\n      y,\n      width,\n      height,\n      class: className,\n      renders = {},\n      handleSize: size = 10,\n      document\n    } = _a,\n    style = __rest(_a, [\"x\", \"y\", \"width\", \"height\", \"class\", \"renders\", \"handleSize\", \"document\"]);\n  if (!document || width === undefined || height === undefined || x === undefined || y === undefined) return;\n  const half = size / 2;\n  const renderRect = (g, options, document) => {\n    if (!g.handle) {\n      g.handle = document.createElement('rect');\n      g.append(g.handle);\n    }\n    const {\n      handle\n    } = g;\n    handle.attr(options);\n    return handle;\n  };\n  const _b = subObject(omitPrefixObject(style, 'handleNW', 'handleNE'), 'handleN'),\n    {\n      render: handleNRender = renderRect\n    } = _b,\n    handleNStyle = __rest(_b, [\"render\"]);\n  const _c = subObject(style, 'handleE'),\n    {\n      render: handleERender = renderRect\n    } = _c,\n    handleEStyle = __rest(_c, [\"render\"]);\n  const _d = subObject(omitPrefixObject(style, 'handleSE', 'handleSW'), 'handleS'),\n    {\n      render: handleSRender = renderRect\n    } = _d,\n    handleSStyle = __rest(_d, [\"render\"]);\n  const _e = subObject(style, 'handleW'),\n    {\n      render: handleWRender = renderRect\n    } = _e,\n    handleWStyle = __rest(_e, [\"render\"]);\n  const _f = subObject(style, 'handleNW'),\n    {\n      render: handleNWRender = renderRect\n    } = _f,\n    handleNWStyle = __rest(_f, [\"render\"]);\n  const _g = subObject(style, 'handleNE'),\n    {\n      render: handleNERender = renderRect\n    } = _g,\n    handleNEStyle = __rest(_g, [\"render\"]);\n  const _h = subObject(style, 'handleSE'),\n    {\n      render: handleSERender = renderRect\n    } = _h,\n    handleSEStyle = __rest(_h, [\"render\"]);\n  const _j = subObject(style, 'handleSW'),\n    {\n      render: handleSWRender = renderRect\n    } = _j,\n    handleSWStyle = __rest(_j, [\"render\"]);\n  const renderHandle = (g, renderNode) => {\n    const {\n      id\n    } = g;\n    const handle = renderNode(g, g.attributes, document);\n    handle.id = id;\n    handle.style.draggable = true;\n  };\n  const appendHandle = handleRender => {\n    return () => {\n      const Node = createElement(g => renderHandle(g, handleRender));\n      return new Node({});\n    };\n  };\n  const container = select(g).attr('className', className).style('transform', `translate(${x}, ${y})`).style('draggable', true);\n  container.maybeAppend('selection', 'rect').style('draggable', true).style('fill', 'transparent').call(applyStyle, Object.assign(Object.assign({\n    width,\n    height\n  }, omitPrefixObject(style, 'handle')), {\n    transform: undefined\n  }));\n  container.maybeAppend('handle-n', appendHandle(handleNRender)).style('x', half).style('y', -half).style('width', width - size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNStyle);\n  container.maybeAppend('handle-e', appendHandle(handleERender)).style('x', width - half).style('y', half).style('width', size).style('height', height - size).style('fill', 'transparent').call(applyStyle, handleEStyle);\n  container.maybeAppend('handle-s', appendHandle(handleSRender)).style('x', half).style('y', height - half).style('width', width - size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSStyle);\n  container.maybeAppend('handle-w', appendHandle(handleWRender)).style('x', -half).style('y', half).style('width', size).style('height', height - size).style('fill', 'transparent').call(applyStyle, handleWStyle);\n  container.maybeAppend('handle-nw', appendHandle(handleNWRender)).style('x', -half).style('y', -half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNWStyle);\n  container.maybeAppend('handle-ne', appendHandle(handleNERender)).style('x', width - half).style('y', -half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleNEStyle);\n  container.maybeAppend('handle-se', appendHandle(handleSERender)).style('x', width - half).style('y', height - half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSEStyle);\n  container.maybeAppend('handle-sw', appendHandle(handleSWRender)).style('x', -half).style('y', height - half).style('width', size).style('height', size).style('fill', 'transparent').call(applyStyle, handleSWStyle);\n});\nexport function brush(root, _a) {\n  var {\n      brushed = () => {},\n      brushended = () => {},\n      brushcreated = () => {},\n      brushstarted = () => {},\n      brushupdated = () => {},\n      extent = bboxOf(root),\n      brushRegion = (x, y, x1, y1, extent) => [x, y, x1, y1],\n      reverse = false,\n      fill = '#777',\n      fillOpacity = '0.3',\n      stroke = '#fff',\n      selectedHandles = ['handle-n', 'handle-e', 'handle-s', 'handle-w', 'handle-nw', 'handle-ne', 'handle-se', 'handle-sw']\n    } = _a,\n    style = __rest(_a, [\"brushed\", \"brushended\", \"brushcreated\", \"brushstarted\", \"brushupdated\", \"extent\", \"brushRegion\", \"reverse\", \"fill\", \"fillOpacity\", \"stroke\", \"selectedHandles\"]);\n  let start = null; // Start point of mask.\n  let end = null; // End point of mask.\n  let moveStart = null; // Start point of moving mask.\n  let mask = null; // Mask instance.\n  let background = null;\n  let creating = false;\n  const [originX, originY, width, height] = extent;\n  setCursor(root, 'crosshair');\n  root.style.draggable = true; // Make it response to drag event.\n  // Remove old mask and init new mask.\n  const initMask = (x, y, event) => {\n    brushstarted(event);\n    if (mask) mask.remove();\n    if (background) background.remove();\n    start = [x, y];\n    if (reverse) return initReverseMask();\n    initNormalMask();\n  };\n  const initReverseMask = () => {\n    background = new Path({\n      style: Object.assign(Object.assign({}, style), {\n        fill,\n        fillOpacity,\n        stroke,\n        pointerEvents: 'none'\n      })\n    });\n    mask = new ResizableMask({\n      // @ts-ignore\n      style: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        draggable: true,\n        document: root.ownerDocument\n      },\n      className: 'mask'\n    });\n    root.appendChild(background);\n    root.appendChild(mask);\n  };\n  const initNormalMask = () => {\n    mask = new ResizableMask({\n      // @ts-ignore\n      style: Object.assign(Object.assign({\n        document: root.ownerDocument,\n        x: 0,\n        y: 0\n      }, style), {\n        fill,\n        fillOpacity,\n        stroke,\n        draggable: true\n      }),\n      className: 'mask'\n    });\n    root.appendChild(mask);\n  };\n  // Remove mask and reset states.\n  const removeMask = (emit = true) => {\n    if (mask) mask.remove();\n    if (background) background.remove();\n    start = null;\n    end = null;\n    moveStart = null;\n    creating = false;\n    mask = null;\n    background = null;\n    brushended(emit);\n  };\n  // Update mask and invoke brushended callback.\n  const updateMask = (start, end, emit = true) => {\n    const [x, y, x1, y1] = normalizeBounds(start[0], start[1], end[0], end[1], extent);\n    const [fx, fy, fx1, fy1] = brushRegion(x, y, x1, y1, extent);\n    if (reverse) updateReverseMask(fx, fy, fx1, fy1);else updateNormalMask(fx, fy, fx1, fy1);\n    brushed(fx, fy, fx1, fy1, emit);\n    return [fx, fy, fx1, fy1];\n  };\n  const updateNormalMask = (x, y, x1, y1) => {\n    mask.style.x = x;\n    mask.style.y = y;\n    mask.style.width = x1 - x;\n    mask.style.height = y1 - y;\n  };\n  const updateReverseMask = (x, y, x1, y1) => {\n    background.style.d = `\n      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z\n      M${x},${y}L${x},${y1}L${x1},${y1}L${x1},${y}Z\n    `;\n    mask.style.x = x;\n    mask.style.y = y;\n    mask.style.width = x1 - x;\n    mask.style.height = y1 - y;\n  };\n  // Move and update mask.\n  const moveMask = current => {\n    const clip = (dt, start, end, min, max) => {\n      if (dt + start < min) return min - start;\n      if (dt + end > max) return max - end;\n      return dt;\n    };\n    const dx = current[0] - moveStart[0];\n    const dy = current[1] - moveStart[1];\n    const dx1 = clip(dx, start[0], end[0], originX, width);\n    const dy1 = clip(dy, start[1], end[1], originY, height);\n    const currentStart = [start[0] + dx1, start[1] + dy1];\n    const currentEnd = [end[0] + dx1, end[1] + dy1];\n    updateMask(currentStart, currentEnd);\n  };\n  const handles = {\n    'handle-n': {\n      vector: [0, 1, 0, 0],\n      cursor: 'ns-resize'\n    },\n    'handle-e': {\n      vector: [0, 0, 1, 0],\n      cursor: 'ew-resize'\n    },\n    'handle-s': {\n      vector: [0, 0, 0, 1],\n      cursor: 'ns-resize'\n    },\n    'handle-w': {\n      vector: [1, 0, 0, 0],\n      cursor: 'ew-resize'\n    },\n    'handle-nw': {\n      vector: [1, 1, 0, 0],\n      cursor: 'nwse-resize'\n    },\n    'handle-ne': {\n      vector: [0, 1, 1, 0],\n      cursor: 'nesw-resize'\n    },\n    'handle-se': {\n      vector: [0, 0, 1, 1],\n      cursor: 'nwse-resize'\n    },\n    'handle-sw': {\n      vector: [1, 0, 0, 1],\n      cursor: 'nesw-resize'\n    }\n  };\n  const isMask = target => {\n    return isSelection(target) || isHandle(target);\n  };\n  const isHandle = target => {\n    const {\n      id\n    } = target;\n    if (selectedHandles.indexOf(id) === -1) return false;\n    return new Set(Object.keys(handles)).has(id);\n  };\n  const isSelection = target => {\n    return target === mask.getElementById('selection');\n  };\n  // If target is plot area, create mask.\n  // If target is mask, about to update position.\n  const dragstart = event => {\n    const {\n      target\n    } = event;\n    const [offsetX, offsetY] = brushMousePosition(root, event);\n    if (!mask || !isMask(target)) {\n      initMask(offsetX, offsetY, event);\n      creating = true;\n      return;\n    }\n    if (isMask(target)) {\n      moveStart = [offsetX, offsetY];\n    }\n  };\n  const drag = event => {\n    const {\n      target\n    } = event;\n    const mouse = brushMousePosition(root, event);\n    if (!start) return;\n    // If target is plot area, resize mask.\n    if (!moveStart) return updateMask(start, mouse);\n    // If target is selection area, move mask.\n    if (isSelection(target)) return moveMask(mouse);\n    // If target is handle area, resize mask.\n    const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];\n    const {\n      id\n    } = target;\n    if (handles[id]) {\n      const [sx, sy, ex, ey] = handles[id].vector;\n      return updateMask([start[0] + dx * sx, start[1] + dy * sy], [end[0] + dx * ex, end[1] + dy * ey]);\n    }\n  };\n  // If target is plot area, finish creating.\n  // If target is mask, finish moving mask.\n  const dragend = event => {\n    if (moveStart) {\n      moveStart = null;\n      // Update start and end;\n      const {\n        x,\n        y,\n        width,\n        height\n      } = mask.style;\n      start = [x, y];\n      end = [x + width, y + height];\n      brushupdated(x, y, x + width, y + height, event);\n      return;\n    }\n    end = brushMousePosition(root, event);\n    const [fx, fy, fx1, fy1] = updateMask(start, end);\n    creating = false;\n    brushcreated(fx, fy, fx1, fy1, event);\n  };\n  // Hide mask.\n  const click = event => {\n    const {\n      target\n    } = event;\n    if (mask && !isMask(target)) removeMask();\n  };\n  // Update cursor depends on hovered element.\n  const pointermove = event => {\n    const {\n      target\n    } = event;\n    if (!mask || !isMask(target) || creating) setCursor(root, 'crosshair');else if (isSelection(target)) setCursor(root, 'move');else if (isHandle(target)) setCursor(root, handles[target.id].cursor);\n  };\n  const pointerleave = () => {\n    setCursor(root, 'default');\n  };\n  root.addEventListener('dragstart', dragstart);\n  root.addEventListener('drag', drag);\n  root.addEventListener('dragend', dragend);\n  root.addEventListener('click', click);\n  root.addEventListener('pointermove', pointermove);\n  root.addEventListener('pointerleave', pointerleave);\n  return {\n    mask,\n    move(x, y, x1, y1, emit = true) {\n      if (!mask) initMask(x, y, {});\n      start = [x, y];\n      end = [x1, y1];\n      updateMask([x, y], [x1, y1], emit);\n    },\n    remove(emit = true) {\n      if (mask) removeMask(emit);\n    },\n    destroy() {\n      // Do not emit brush:end event.\n      if (mask) removeMask(false);\n      setCursor(root, 'default');\n      root.removeEventListener('dragstart', dragstart);\n      root.removeEventListener('drag', drag);\n      root.removeEventListener('dragend', dragend);\n      root.removeEventListener('click', click);\n      root.removeEventListener('pointermove', pointermove);\n      root.removeEventListener('pointerleave', pointerleave);\n    }\n  };\n}\nfunction selectSiblingViews(target, viewInstances, brushKey) {\n  return viewInstances.filter(d => {\n    if (d === target) return false;\n    const {\n      interaction = {}\n    } = d.options;\n    return Object.values(interaction).find(d => d.brushKey === brushKey);\n  });\n}\nfunction selectSiblingContainers(target, viewInstances, brushKey) {\n  return selectSiblingViews(target, viewInstances, brushKey).map(d => selectPlotArea(d.container));\n}\nfunction selectSiblingOptions(target, viewInstances, brushKey) {\n  return selectSiblingViews(target, viewInstances, brushKey).map(d => d.options);\n}\n/**\n * @todo Brush over view for series view.\n * @todo Test perf.\n */\nexport function brushHighlight(root, _a) {\n  var {\n      elements: elementof,\n      selectedHandles,\n      siblings: siblingsof = root => [],\n      datum,\n      brushRegion,\n      extent: optionalExtent,\n      reverse,\n      scale,\n      coordinate,\n      series = false,\n      key = d => d,\n      bboxOf = root => {\n        const {\n          x,\n          y,\n          width,\n          height\n        } = root.style;\n        return {\n          x,\n          y,\n          width,\n          height\n        };\n      },\n      state = {},\n      emitter\n    } = _a,\n    rest = __rest(_a, [\"elements\", \"selectedHandles\", \"siblings\", \"datum\", \"brushRegion\", \"extent\", \"reverse\", \"scale\", \"coordinate\", \"series\", \"key\", \"bboxOf\", \"state\", \"emitter\"]);\n  const elements = elementof(root);\n  const siblings = siblingsof(root);\n  const siblingElements = siblings.flatMap(elementof);\n  const valueof = createValueof(elements, datum);\n  const brushStyle = subObject(rest, 'mask');\n  const {\n    setState,\n    removeState\n  } = useState(state, valueof);\n  const clonedElement = new Map();\n  const {\n    width: rootWidth,\n    height: rootHeight,\n    x: ordinalX = 0,\n    y: ordinalY = 0\n  } = bboxOf(root);\n  const extent = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];\n  const brushended = () => {\n    for (const element of [...elements, ...siblingElements]) {\n      removeState(element, 'active', 'inactive');\n    }\n  };\n  const brushed = (x, y, x1, y1) => {\n    var _a;\n    // Hide brush for the sibling view.\n    for (const sibling of siblings) (_a = sibling.brush) === null || _a === void 0 ? void 0 : _a.remove();\n    // Store the key of the active element.\n    const keys = new Set();\n    // Highlight and store selected elements.\n    for (const element of elements) {\n      const {\n        min,\n        max\n      } = element.getLocalBounds();\n      const [ex, ey] = min;\n      const [ex1, ey1] = max;\n      if (!intersect([ex, ey, ex1, ey1], [x, y, x1, y1])) {\n        setState(element, 'inactive');\n      } else {\n        setState(element, 'active');\n        keys.add(key(element));\n      }\n    }\n    // Highlight elements with same key in sibling view.\n    for (const element of siblingElements) {\n      if (keys.has(key(element))) setState(element, 'active');else setState(element, 'inactive');\n    }\n  };\n  const seriesBrushend = () => {\n    for (const element of elements) removeState(element, 'inactive');\n    for (const cloned of clonedElement.values()) cloned.remove();\n    clonedElement.clear();\n  };\n  const seriesBrushed = (x, y, x1, y1) => {\n    const clone = element => {\n      const cloned = element.cloneNode();\n      cloned.__data__ = element.__data__;\n      element.parentNode.appendChild(cloned);\n      clonedElement.set(element, cloned);\n      return cloned;\n    };\n    // Create a clipPath shared between all children.\n    const clipPath = new Rect({\n      style: {\n        x: x + ordinalX,\n        y: y + ordinalY,\n        width: x1 - x,\n        height: y1 - y\n      }\n    });\n    root.appendChild(clipPath);\n    for (const element of elements) {\n      const cloned = clonedElement.get(element) || clone(element);\n      cloned.style.clipPath = clipPath;\n      setState(element, 'inactive');\n      setState(cloned, 'active');\n    }\n  };\n  const brushHandler = brush(root, Object.assign(Object.assign({}, brushStyle), {\n    extent,\n    brushRegion,\n    reverse,\n    selectedHandles,\n    brushended: emit => {\n      const handler = series ? seriesBrushend : brushended;\n      if (emit) {\n        emitter.emit('brush:remove', {\n          nativeEvent: true\n        });\n      }\n      handler();\n    },\n    brushed: (x, y, x1, y1, emit) => {\n      const selection = selectionOf(x, y, x1, y1, scale, coordinate);\n      if (emit) {\n        emitter.emit('brush:highlight', {\n          nativeEvent: true,\n          data: {\n            selection\n          }\n        });\n      }\n      const handler = series ? seriesBrushed : brushed;\n      handler(x, y, x1, y1);\n    },\n    brushcreated: (x, y, x1, y1, event) => {\n      const selection = selectionOf(x, y, x1, y1, scale, coordinate);\n      emitter.emit('brush:end', Object.assign(Object.assign({}, event), {\n        nativeEvent: true,\n        data: {\n          selection\n        }\n      }));\n    },\n    brushupdated: (x, y, x1, y1, event) => {\n      const selection = selectionOf(x, y, x1, y1, scale, coordinate);\n      emitter.emit('brush:end', Object.assign(Object.assign({}, event), {\n        nativeEvent: true,\n        data: {\n          selection\n        }\n      }));\n    },\n    brushstarted: e => {\n      emitter.emit('brush:start', e);\n    }\n  }));\n  // Move brush and highlight data.\n  const onHighlight = ({\n    nativeEvent,\n    data\n  }) => {\n    if (nativeEvent) return;\n    const {\n      selection\n    } = data;\n    const [x, y, x1, y1] = pixelsOf(selection, scale, coordinate);\n    brushHandler.move(x, y, x1, y1, false);\n  };\n  emitter.on('brush:highlight', onHighlight);\n  // Remove brush and reset data.\n  const onRemove = ({\n    nativeEvent\n  } = {}) => {\n    if (nativeEvent) return;\n    brushHandler.remove(false);\n  };\n  emitter.on('brush:remove', onRemove);\n  // Remove event handlers.\n  const preBrushDestroy = brushHandler.destroy.bind(brushHandler);\n  brushHandler.destroy = () => {\n    emitter.off('brush:highlight', onHighlight);\n    emitter.off('brush:remove', onRemove);\n    preBrushDestroy();\n  };\n  return brushHandler;\n}\nexport function BrushHighlight(_a) {\n  var {\n      facet,\n      brushKey\n    } = _a,\n    rest = __rest(_a, [\"facet\", \"brushKey\"]);\n  return (target, viewInstances, emitter) => {\n    const {\n      container,\n      view,\n      options\n    } = target;\n    const plotArea = selectPlotArea(container);\n    const defaultOptions = {\n      maskFill: '#777',\n      maskFillOpacity: '0.3',\n      maskStroke: '#fff',\n      reverse: false\n    };\n    const defaultStates = ['active', ['inactive', {\n      opacity: 0.5\n    }]];\n    const {\n      scale,\n      coordinate\n    } = view;\n    if (facet) {\n      const bbox = plotArea.getBounds();\n      const x = bbox.min[0];\n      const y = bbox.min[1];\n      const x1 = bbox.max[0];\n      const y1 = bbox.max[1];\n      return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({\n        elements: () => selectFacetG2Elements(target, viewInstances),\n        datum: createDatumof(selectFacetViews(target, viewInstances).map(d => d.view)),\n        brushRegion: (x, y, x1, y1) => [x, y, x1, y1],\n        extent: [x, y, x1, y1],\n        state: mergeState(selectFacetViews(target, viewInstances).map(d => d.options), defaultStates),\n        emitter,\n        scale,\n        coordinate,\n        selectedHandles: undefined\n      }, defaultOptions), rest));\n    }\n    const brush = brushHighlight(plotArea, Object.assign(Object.assign({\n      elements: selectG2Elements,\n      key: element => element.__data__.key,\n      siblings: () => selectSiblingContainers(target, viewInstances, brushKey),\n      datum: createDatumof([view, ...selectSiblingViews(target, viewInstances, brushKey).map(d => d.view)]),\n      brushRegion: (x, y, x1, y1) => [x, y, x1, y1],\n      extent: undefined,\n      state: mergeState([options, ...selectSiblingOptions(target, viewInstances, brushKey)], defaultStates),\n      emitter,\n      scale,\n      coordinate,\n      selectedHandles: undefined\n    }, defaultOptions), rest));\n    // Bind brush to the view it belongs to.\n    //@ts-ignore\n    plotArea.brush = brush;\n    return () => brush.destroy();\n  };\n}","map":{"version":3,"names":["Rect","Path","subObject","omitPrefixObject","selectionOf","pixelsOf","createElement","select","selectG2Elements","selectPlotArea","createDatumof","useState","createValueof","setCursor","brushMousePosition","selectFacetG2Elements","mergeState","selectFacetViews","intersect","bbox1","bbox2","minX1","minY1","maxX1","maxY1","minX2","minY2","maxX2","maxY2","normalizeBounds","x","y","x1","y1","extent","minX","minY","maxX","maxY","Math","max","min","bboxOf","root","width","height","getBBox","applyStyle","selection","style","key","value","Object","entries","ResizableMask","g","_a","attributes","class","className","renders","handleSize","size","document","__rest","undefined","half","renderRect","options","handle","append","attr","_b","render","handleNRender","handleNStyle","_c","handleERender","handleEStyle","_d","handleSRender","handleSStyle","_e","handleWRender","handleWStyle","_f","handleNWRender","handleNWStyle","_g","handleNERender","handleNEStyle","_h","handleSERender","handleSEStyle","_j","handleSWRender","handleSWStyle","renderHandle","renderNode","id","draggable","appendHandle","handleRender","Node","container","maybeAppend","call","assign","transform","brush","brushed","brushended","brushcreated","brushstarted","brushupdated","brushRegion","reverse","fill","fillOpacity","stroke","selectedHandles","start","end","moveStart","mask","background","creating","originX","originY","initMask","event","remove","initReverseMask","initNormalMask","pointerEvents","ownerDocument","appendChild","removeMask","emit","updateMask","fx","fy","fx1","fy1","updateReverseMask","updateNormalMask","d","moveMask","current","clip","dt","dx","dy","dx1","dy1","currentStart","currentEnd","handles","vector","cursor","isMask","target","isSelection","isHandle","indexOf","Set","keys","has","getElementById","dragstart","offsetX","offsetY","drag","mouse","sx","sy","ex","ey","dragend","click","pointermove","pointerleave","addEventListener","move","destroy","removeEventListener","selectSiblingViews","viewInstances","brushKey","filter","interaction","values","find","selectSiblingContainers","map","selectSiblingOptions","brushHighlight","elements","elementof","siblings","siblingsof","datum","optionalExtent","scale","coordinate","series","state","emitter","rest","siblingElements","flatMap","valueof","brushStyle","setState","removeState","clonedElement","Map","rootWidth","rootHeight","ordinalX","ordinalY","element","sibling","getLocalBounds","ex1","ey1","add","seriesBrushend","cloned","clear","seriesBrushed","clone","cloneNode","__data__","parentNode","set","clipPath","get","brushHandler","handler","nativeEvent","data","e","onHighlight","on","onRemove","preBrushDestroy","bind","off","BrushHighlight","facet","view","plotArea","defaultOptions","maskFill","maskFillOpacity","maskStroke","defaultStates","opacity","bbox","getBounds"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/brushHighlight.ts"],"sourcesContent":["import { DisplayObject, Rect, Path } from '@antv/g';\nimport { subObject, omitPrefixObject } from '../utils/helper';\nimport { selectionOf, pixelsOf } from '../utils/scale';\nimport { createElement } from '../utils/createElement';\nimport { G2Element, select, Selection } from '../utils/selection';\nimport {\n  selectG2Elements,\n  selectPlotArea,\n  createDatumof,\n  useState,\n  createValueof,\n  setCursor,\n  brushMousePosition,\n  selectFacetG2Elements,\n  mergeState,\n  selectFacetViews,\n} from './utils';\n\nfunction intersect(bbox1: any, bbox2: any) {\n  const [minX1, minY1, maxX1, maxY1] = bbox1;\n  const [minX2, minY2, maxX2, maxY2] = bbox2;\n  return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);\n}\n\nfunction normalizeBounds(x, y, x1, y1, extent) {\n  const [minX, minY, maxX, maxY] = extent;\n  return [\n    Math.max(minX, Math.min(x, x1)),\n    Math.max(minY, Math.min(y, y1)),\n    Math.min(maxX, Math.max(x, x1)),\n    Math.min(maxY, Math.max(y, y1)),\n  ];\n}\n\nfunction bboxOf(root: DisplayObject) {\n  const { width, height } = root.getBBox();\n  return [0, 0, width, height];\n}\n\nfunction applyStyle(selection: Selection, style: Record<string, any>) {\n  for (const [key, value] of Object.entries(style)) {\n    selection.style(key, value);\n  }\n}\n\nconst ResizableMask = createElement((g) => {\n  const {\n    x,\n    y,\n    width,\n    height,\n    class: className,\n    renders = {},\n    handleSize: size = 10,\n    document,\n    ...style\n  } = g.attributes;\n\n  if (\n    !document ||\n    width === undefined ||\n    height === undefined ||\n    x === undefined ||\n    y === undefined\n  )\n    return;\n\n  const half = size / 2;\n\n  const renderRect = (g, options, document) => {\n    if (!g.handle) {\n      g.handle = document.createElement('rect');\n      g.append(g.handle);\n    }\n    const { handle } = g;\n    handle.attr(options);\n    return handle;\n  };\n\n  const { render: handleNRender = renderRect, ...handleNStyle } = subObject(\n    omitPrefixObject(style, 'handleNW', 'handleNE'),\n    'handleN',\n  );\n\n  const { render: handleERender = renderRect, ...handleEStyle } = subObject(\n    style,\n    'handleE',\n  );\n  const { render: handleSRender = renderRect, ...handleSStyle } = subObject(\n    omitPrefixObject(style, 'handleSE', 'handleSW'),\n    'handleS',\n  );\n  const { render: handleWRender = renderRect, ...handleWStyle } = subObject(\n    style,\n    'handleW',\n  );\n  const { render: handleNWRender = renderRect, ...handleNWStyle } = subObject(\n    style,\n    'handleNW',\n  );\n  const { render: handleNERender = renderRect, ...handleNEStyle } = subObject(\n    style,\n    'handleNE',\n  );\n  const { render: handleSERender = renderRect, ...handleSEStyle } = subObject(\n    style,\n    'handleSE',\n  );\n  const { render: handleSWRender = renderRect, ...handleSWStyle } = subObject(\n    style,\n    'handleSW',\n  );\n\n  const renderHandle = (g, renderNode) => {\n    const { id } = g;\n    const handle = renderNode(g, g.attributes, document);\n    handle.id = id;\n    handle.style.draggable = true;\n  };\n\n  const appendHandle = (handleRender) => {\n    return () => {\n      const Node = createElement((g) => renderHandle(g, handleRender));\n      return new Node({});\n    };\n  };\n\n  const container = select(g)\n    .attr('className', className)\n    .style('transform', `translate(${x}, ${y})`)\n    .style('draggable', true);\n\n  container\n    .maybeAppend('selection', 'rect')\n    .style('draggable', true)\n    .style('fill', 'transparent')\n    .call(applyStyle, {\n      width,\n      height,\n      ...omitPrefixObject(style, 'handle'),\n      transform: undefined,\n    });\n\n  container\n    .maybeAppend('handle-n', appendHandle(handleNRender))\n    .style('x', half)\n    .style('y', -half)\n    .style('width', width - size)\n    .style('height', size)\n    .style('fill', 'transparent')\n    .call(applyStyle, handleNStyle);\n\n  container\n    .maybeAppend('handle-e', appendHandle(handleERender))\n    .style('x', width - half)\n    .style('y', half)\n    .style('width', size)\n    .style('height', height - size)\n    .style('fill', 'transparent')\n    .call(applyStyle, handleEStyle);\n\n  container\n    .maybeAppend('handle-s', appendHandle(handleSRender))\n    .style('x', half)\n    .style('y', height - half)\n    .style('width', width - size)\n    .style('height', size)\n    .style('fill', 'transparent')\n    .call(applyStyle, handleSStyle);\n\n  container\n    .maybeAppend('handle-w', appendHandle(handleWRender))\n    .style('x', -half)\n    .style('y', half)\n    .style('width', size)\n    .style('height', height - size)\n    .style('fill', 'transparent')\n    .call(applyStyle, handleWStyle);\n\n  container\n    .maybeAppend('handle-nw', appendHandle(handleNWRender))\n    .style('x', -half)\n    .style('y', -half)\n    .style('width', size)\n    .style('height', size)\n    .style('fill', 'transparent')\n    .call(applyStyle, handleNWStyle);\n\n  container\n    .maybeAppend('handle-ne', appendHandle(handleNERender))\n    .style('x', width - half)\n    .style('y', -half)\n    .style('width', size)\n    .style('height', size)\n    .style('fill', 'transparent')\n    .call(applyStyle, handleNEStyle);\n\n  container\n    .maybeAppend('handle-se', appendHandle(handleSERender))\n    .style('x', width - half)\n    .style('y', height - half)\n    .style('width', size)\n    .style('height', size)\n    .style('fill', 'transparent')\n    .call(applyStyle, handleSEStyle);\n\n  container\n    .maybeAppend('handle-sw', appendHandle(handleSWRender))\n    .style('x', -half)\n    .style('y', height - half)\n    .style('width', size)\n    .style('height', size)\n    .style('fill', 'transparent')\n    .call(applyStyle, handleSWStyle);\n});\n\nexport function brush(\n  root: DisplayObject,\n  {\n    brushed = () => {},\n    brushended = () => {},\n    brushcreated = () => {},\n    brushstarted = () => {},\n    brushupdated = () => {},\n    extent = bboxOf(root),\n    brushRegion = (x, y, x1, y1, extent) => [x, y, x1, y1],\n    reverse = false,\n    fill = '#777',\n    fillOpacity = '0.3',\n    stroke = '#fff',\n    selectedHandles = [\n      'handle-n',\n      'handle-e',\n      'handle-s',\n      'handle-w',\n      'handle-nw',\n      'handle-ne',\n      'handle-se',\n      'handle-sw',\n    ],\n    ...style\n  }: Record<string, any>,\n) {\n  let start = null; // Start point of mask.\n  let end = null; // End point of mask.\n  let moveStart = null; // Start point of moving mask.\n  let mask = null; // Mask instance.\n  let background = null;\n  let creating = false;\n\n  const [originX, originY, width, height] = extent;\n\n  setCursor(root, 'crosshair');\n  root.style.draggable = true; // Make it response to drag event.\n\n  // Remove old mask and init new mask.\n  const initMask = (x, y, event) => {\n    brushstarted(event);\n    if (mask) mask.remove();\n    if (background) background.remove();\n    start = [x, y];\n    if (reverse) return initReverseMask();\n    initNormalMask();\n  };\n\n  const initReverseMask = () => {\n    background = new Path({\n      style: {\n        ...style,\n        fill,\n        fillOpacity,\n        stroke,\n        pointerEvents: 'none',\n      },\n    });\n    mask = new ResizableMask({\n      // @ts-ignore\n      style: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        draggable: true,\n        document: root.ownerDocument,\n      },\n      className: 'mask',\n    });\n    root.appendChild(background);\n    root.appendChild(mask);\n  };\n\n  const initNormalMask = () => {\n    mask = new ResizableMask({\n      // @ts-ignore\n      style: {\n        document: root.ownerDocument,\n        x: 0,\n        y: 0,\n        ...style,\n        fill,\n        fillOpacity,\n        stroke,\n        draggable: true, // Make it response to drag event.\n      },\n      className: 'mask',\n    });\n    root.appendChild(mask);\n  };\n\n  // Remove mask and reset states.\n  const removeMask = (emit = true) => {\n    if (mask) mask.remove();\n    if (background) background.remove();\n    start = null;\n    end = null;\n    moveStart = null;\n    creating = false;\n    mask = null;\n    background = null;\n    brushended(emit);\n  };\n\n  // Update mask and invoke brushended callback.\n  const updateMask = (start, end, emit = true) => {\n    const [x, y, x1, y1] = normalizeBounds(\n      start[0],\n      start[1],\n      end[0],\n      end[1],\n      extent,\n    );\n    const [fx, fy, fx1, fy1] = brushRegion(x, y, x1, y1, extent);\n    if (reverse) updateReverseMask(fx, fy, fx1, fy1);\n    else updateNormalMask(fx, fy, fx1, fy1);\n    brushed(fx, fy, fx1, fy1, emit);\n    return [fx, fy, fx1, fy1];\n  };\n\n  const updateNormalMask = (x, y, x1, y1) => {\n    mask.style.x = x;\n    mask.style.y = y;\n    mask.style.width = x1 - x;\n    mask.style.height = y1 - y;\n  };\n\n  const updateReverseMask = (x, y, x1, y1) => {\n    background.style.d = `\n      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z\n      M${x},${y}L${x},${y1}L${x1},${y1}L${x1},${y}Z\n    `;\n    mask.style.x = x;\n    mask.style.y = y;\n    mask.style.width = x1 - x;\n    mask.style.height = y1 - y;\n  };\n\n  // Move and update mask.\n  const moveMask = (current) => {\n    const clip = (dt, start, end, min, max) => {\n      if (dt + start < min) return min - start;\n      if (dt + end > max) return max - end;\n      return dt;\n    };\n    const dx = current[0] - moveStart[0];\n    const dy = current[1] - moveStart[1];\n    const dx1 = clip(dx, start[0], end[0], originX, width);\n    const dy1 = clip(dy, start[1], end[1], originY, height);\n    const currentStart = [start[0] + dx1, start[1] + dy1];\n    const currentEnd = [end[0] + dx1, end[1] + dy1];\n    updateMask(currentStart, currentEnd);\n  };\n\n  const handles = {\n    'handle-n': { vector: [0, 1, 0, 0], cursor: 'ns-resize' },\n    'handle-e': { vector: [0, 0, 1, 0], cursor: 'ew-resize' },\n    'handle-s': { vector: [0, 0, 0, 1], cursor: 'ns-resize' },\n    'handle-w': { vector: [1, 0, 0, 0], cursor: 'ew-resize' },\n    'handle-nw': { vector: [1, 1, 0, 0], cursor: 'nwse-resize' },\n    'handle-ne': { vector: [0, 1, 1, 0], cursor: 'nesw-resize' },\n    'handle-se': { vector: [0, 0, 1, 1], cursor: 'nwse-resize' },\n    'handle-sw': { vector: [1, 0, 0, 1], cursor: 'nesw-resize' },\n  };\n\n  const isMask = (target) => {\n    return isSelection(target) || isHandle(target);\n  };\n\n  const isHandle = (target) => {\n    const { id } = target;\n    if (selectedHandles.indexOf(id) === -1) return false;\n    return new Set(Object.keys(handles)).has(id);\n  };\n\n  const isSelection = (target) => {\n    return target === mask.getElementById('selection');\n  };\n\n  // If target is plot area, create mask.\n  // If target is mask, about to update position.\n  const dragstart = (event) => {\n    const { target } = event;\n    const [offsetX, offsetY] = brushMousePosition(root, event);\n    if (!mask || !isMask(target)) {\n      initMask(offsetX, offsetY, event);\n      creating = true;\n      return;\n    }\n    if (isMask(target)) {\n      moveStart = [offsetX, offsetY];\n    }\n  };\n\n  const drag = (event) => {\n    const { target } = event;\n    const mouse = brushMousePosition(root, event);\n    if (!start) return;\n    // If target is plot area, resize mask.\n    if (!moveStart) return updateMask(start, mouse);\n\n    // If target is selection area, move mask.\n    if (isSelection(target)) return moveMask(mouse);\n\n    // If target is handle area, resize mask.\n    const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];\n    const { id } = target;\n    if (handles[id]) {\n      const [sx, sy, ex, ey] = handles[id].vector;\n      return updateMask(\n        [start[0] + dx * sx, start[1] + dy * sy],\n        [end[0] + dx * ex, end[1] + dy * ey],\n      );\n    }\n  };\n\n  // If target is plot area, finish creating.\n  // If target is mask, finish moving mask.\n  const dragend = (event) => {\n    if (moveStart) {\n      moveStart = null;\n      // Update start and end;\n      const { x, y, width, height } = mask.style;\n      start = [x, y];\n      end = [x + width, y + height];\n      brushupdated(x, y, x + width, y + height, event);\n      return;\n    }\n    end = brushMousePosition(root, event);\n    const [fx, fy, fx1, fy1] = updateMask(start, end);\n    creating = false;\n    brushcreated(fx, fy, fx1, fy1, event);\n  };\n\n  // Hide mask.\n  const click = (event) => {\n    const { target } = event;\n    if (mask && !isMask(target)) removeMask();\n  };\n\n  // Update cursor depends on hovered element.\n  const pointermove = (event) => {\n    const { target } = event;\n    if (!mask || !isMask(target) || creating) setCursor(root, 'crosshair');\n    else if (isSelection(target)) setCursor(root, 'move');\n    else if (isHandle(target)) setCursor(root, handles[target.id].cursor);\n  };\n\n  const pointerleave = () => {\n    setCursor(root, 'default');\n  };\n\n  root.addEventListener('dragstart', dragstart);\n  root.addEventListener('drag', drag);\n  root.addEventListener('dragend', dragend);\n  root.addEventListener('click', click);\n  root.addEventListener('pointermove', pointermove);\n  root.addEventListener('pointerleave', pointerleave);\n\n  return {\n    mask,\n    move(x, y, x1, y1, emit = true) {\n      if (!mask) initMask(x, y, {});\n      start = [x, y];\n      end = [x1, y1];\n      updateMask([x, y], [x1, y1], emit);\n    },\n    remove(emit = true) {\n      if (mask) removeMask(emit);\n    },\n    destroy() {\n      // Do not emit brush:end event.\n      if (mask) removeMask(false);\n      setCursor(root, 'default');\n      root.removeEventListener('dragstart', dragstart);\n      root.removeEventListener('drag', drag);\n      root.removeEventListener('dragend', dragend);\n      root.removeEventListener('click', click);\n      root.removeEventListener('pointermove', pointermove);\n      root.removeEventListener('pointerleave', pointerleave);\n    },\n  };\n}\n\nfunction selectSiblingViews(target, viewInstances, brushKey) {\n  return viewInstances.filter((d) => {\n    if (d === target) return false;\n    const { interaction = {} } = d.options;\n    return Object.values(interaction as Record<string, any>).find(\n      (d) => d.brushKey === brushKey,\n    );\n  });\n}\n\nfunction selectSiblingContainers(target, viewInstances, brushKey) {\n  return selectSiblingViews(target, viewInstances, brushKey).map((d) =>\n    selectPlotArea(d.container),\n  );\n}\n\nfunction selectSiblingOptions(target, viewInstances, brushKey) {\n  return selectSiblingViews(target, viewInstances, brushKey).map(\n    (d) => d.options,\n  );\n}\n\n/**\n * @todo Brush over view for series view.\n * @todo Test perf.\n */\nexport function brushHighlight(\n  root,\n  {\n    elements: elementof,\n    selectedHandles,\n    siblings: siblingsof = (root) => [],\n    datum,\n    brushRegion,\n    extent: optionalExtent,\n    reverse,\n    scale,\n    coordinate,\n    series = false,\n    key = (d) => d,\n    bboxOf = (root) => {\n      const { x, y, width, height } = root.style;\n      return { x, y, width, height };\n    },\n    state = {},\n    emitter,\n    ...rest\n  },\n) {\n  const elements = elementof(root);\n  const siblings = siblingsof(root);\n  const siblingElements = siblings.flatMap(elementof);\n  const valueof = createValueof(elements, datum);\n  const brushStyle = subObject(rest, 'mask');\n  const { setState, removeState } = useState(state, valueof);\n  const clonedElement = new Map();\n  const {\n    width: rootWidth,\n    height: rootHeight,\n    x: ordinalX = 0,\n    y: ordinalY = 0,\n  } = bboxOf(root);\n  const extent = optionalExtent\n    ? optionalExtent\n    : [0, 0, rootWidth, rootHeight];\n\n  const brushended = () => {\n    for (const element of [...elements, ...siblingElements]) {\n      removeState(element, 'active', 'inactive');\n    }\n  };\n\n  const brushed = (x, y, x1, y1) => {\n    // Hide brush for the sibling view.\n    for (const sibling of siblings) sibling.brush?.remove();\n\n    // Store the key of the active element.\n    const keys = new Set();\n\n    // Highlight and store selected elements.\n    for (const element of elements) {\n      const { min, max } = element.getLocalBounds();\n      const [ex, ey] = min;\n      const [ex1, ey1] = max;\n      if (!intersect([ex, ey, ex1, ey1], [x, y, x1, y1])) {\n        setState(element, 'inactive');\n      } else {\n        setState(element, 'active');\n        keys.add(key(element));\n      }\n    }\n\n    // Highlight elements with same key in sibling view.\n    for (const element of siblingElements) {\n      if (keys.has(key(element))) setState(element, 'active');\n      else setState(element, 'inactive');\n    }\n  };\n\n  const seriesBrushend = () => {\n    for (const element of elements) removeState(element, 'inactive');\n    for (const cloned of clonedElement.values()) cloned.remove();\n    clonedElement.clear();\n  };\n\n  const seriesBrushed = (x, y, x1, y1) => {\n    const clone = (element) => {\n      const cloned = element.cloneNode();\n      cloned.__data__ = element.__data__;\n      element.parentNode.appendChild(cloned);\n      clonedElement.set(element, cloned);\n      return cloned;\n    };\n\n    // Create a clipPath shared between all children.\n    const clipPath = new Rect({\n      style: {\n        x: x + ordinalX,\n        y: y + ordinalY,\n        width: x1 - x,\n        height: y1 - y,\n      },\n    });\n    root.appendChild(clipPath);\n\n    for (const element of elements) {\n      const cloned = clonedElement.get(element) || clone(element);\n      cloned.style.clipPath = clipPath;\n      setState(element, 'inactive');\n      setState(cloned, 'active');\n    }\n  };\n\n  const brushHandler = brush(root, {\n    ...brushStyle,\n    extent,\n    brushRegion,\n    reverse,\n    selectedHandles,\n    brushended: (emit) => {\n      const handler = series ? seriesBrushend : brushended;\n      if (emit) {\n        emitter.emit('brush:remove', { nativeEvent: true });\n      }\n      handler();\n    },\n    brushed: (x, y, x1, y1, emit) => {\n      const selection = selectionOf(x, y, x1, y1, scale, coordinate);\n      if (emit) {\n        emitter.emit('brush:highlight', {\n          nativeEvent: true,\n          data: { selection },\n        });\n      }\n      const handler = series ? seriesBrushed : brushed;\n      handler(x, y, x1, y1);\n    },\n    brushcreated: (x, y, x1, y1, event) => {\n      const selection = selectionOf(x, y, x1, y1, scale, coordinate);\n      emitter.emit('brush:end', {\n        ...event,\n        nativeEvent: true,\n        data: { selection },\n      });\n    },\n    brushupdated: (x, y, x1, y1, event) => {\n      const selection = selectionOf(x, y, x1, y1, scale, coordinate);\n      emitter.emit('brush:end', {\n        ...event,\n        nativeEvent: true,\n        data: { selection },\n      });\n    },\n    brushstarted: (e) => {\n      emitter.emit('brush:start', e);\n    },\n  });\n\n  // Move brush and highlight data.\n  const onHighlight = ({ nativeEvent, data }) => {\n    if (nativeEvent) return;\n    const { selection } = data;\n    const [x, y, x1, y1] = pixelsOf(selection, scale, coordinate);\n    brushHandler.move(x, y, x1, y1, false);\n  };\n  emitter.on('brush:highlight', onHighlight);\n\n  // Remove brush and reset data.\n  const onRemove = ({ nativeEvent }: any = {}) => {\n    if (nativeEvent) return;\n    brushHandler.remove(false);\n  };\n  emitter.on('brush:remove', onRemove);\n\n  // Remove event handlers.\n  const preBrushDestroy = brushHandler.destroy.bind(brushHandler);\n  brushHandler.destroy = () => {\n    emitter.off('brush:highlight', onHighlight);\n    emitter.off('brush:remove', onRemove);\n    preBrushDestroy();\n  };\n\n  return brushHandler;\n}\n\nexport function BrushHighlight({ facet, brushKey, ...rest }) {\n  return (target, viewInstances, emitter) => {\n    const { container, view, options } = target;\n    const plotArea = selectPlotArea(container);\n    const defaultOptions = {\n      maskFill: '#777',\n      maskFillOpacity: '0.3',\n      maskStroke: '#fff',\n      reverse: false,\n    };\n    const defaultStates = ['active', ['inactive', { opacity: 0.5 }]];\n    const { scale, coordinate } = view;\n\n    if (facet) {\n      const bbox = plotArea.getBounds();\n      const x = bbox.min[0];\n      const y = bbox.min[1];\n      const x1 = bbox.max[0];\n      const y1 = bbox.max[1];\n      return brushHighlight(plotArea.parentNode.parentNode, {\n        elements: () => selectFacetG2Elements(target, viewInstances),\n        datum: createDatumof(\n          selectFacetViews(target, viewInstances).map((d) => d.view),\n        ),\n        brushRegion: (x, y, x1, y1) => [x, y, x1, y1],\n        extent: [x, y, x1, y1],\n        state: mergeState(\n          selectFacetViews(target, viewInstances).map((d) => d.options),\n          defaultStates,\n        ),\n        emitter,\n        scale,\n        coordinate,\n        selectedHandles: undefined,\n        ...defaultOptions,\n        ...rest,\n      });\n    }\n\n    const brush = brushHighlight(plotArea, {\n      elements: selectG2Elements,\n      key: (element) => element.__data__.key,\n      siblings: () => selectSiblingContainers(target, viewInstances, brushKey),\n      datum: createDatumof([\n        view,\n        ...selectSiblingViews(target, viewInstances, brushKey).map(\n          (d) => d.view,\n        ),\n      ]),\n      brushRegion: (x, y, x1, y1) => [x, y, x1, y1],\n      extent: undefined,\n      state: mergeState(\n        [options, ...selectSiblingOptions(target, viewInstances, brushKey)],\n        defaultStates,\n      ),\n      emitter,\n      scale,\n      coordinate,\n      selectedHandles: undefined,\n      ...defaultOptions,\n      ...rest,\n    });\n\n    // Bind brush to the view it belongs to.\n    //@ts-ignore\n    plotArea.brush = brush;\n\n    return () => brush.destroy();\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}