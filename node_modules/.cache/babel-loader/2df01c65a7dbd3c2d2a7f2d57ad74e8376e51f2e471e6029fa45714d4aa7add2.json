{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { deepMix, throttle } from '@antv/util';\nimport { subObject } from '../utils/helper';\nimport { useState, setCursor, restoreCursor } from './utils';\nexport const CATEGORY_LEGEND_CLASS_NAME = 'legend-category';\nexport const CONTINUOUS_LEGEND_CLASS_NAME = 'legend-continuous';\nexport const LEGEND_ITEMS_CLASS_NAME = 'items-item';\nexport const LEGEND_MAKER_CLASS_NAME = 'legend-category-item-marker';\nexport const LEGEND_LABEL_CLASS_NAME = 'legend-category-item-label';\nexport function markerOf(item) {\n  return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];\n}\nexport function labelOf(item) {\n  return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];\n}\nexport function itemsOf(root) {\n  return root.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);\n}\nexport function legendsOf(root) {\n  return root.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);\n}\nexport function legendsContinuousOf(root) {\n  return root.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);\n}\nexport function legendClearSetState(root, setState) {\n  const legends = [...legendsOf(root), ...legendsContinuousOf(root)];\n  legends.forEach(legend => {\n    setState(legend, v => v);\n  });\n}\nexport function dataOf(root) {\n  // legend -> layout -> container\n  let parent = root.parentNode;\n  while (parent && !parent.__data__) {\n    parent = parent.parentNode;\n  }\n  return parent.__data__;\n}\nexport function attributesOf(root) {\n  let child = root;\n  while (child && !child.attr('class').startsWith('legend')) {\n    child = child.children[0];\n  }\n  return child.attributes;\n}\nfunction legendFilterOrdinal(root, {\n  legends,\n  // given the root of chart returns legends to be manipulated\n  marker: markerOf,\n  // given the legend returns the marker\n  label: labelOf,\n  // given the legend returns the label\n  datum,\n  // given the legend returns the value\n  filter,\n  // invoke when dispatch filter event,\n  emitter,\n  channel,\n  state = {} // state options\n}) {\n  // Index handler by item.\n  const itemClick = new Map();\n  const itemPointerenter = new Map();\n  const itemPointerout = new Map();\n  const {\n    unselected = {\n      markerStroke: '#aaa',\n      markerFill: '#aaa',\n      labelFill: '#aaa'\n    }\n  } = state;\n  const markerStyle = {\n    unselected: subObject(unselected, 'marker')\n  };\n  const labelStyle = {\n    unselected: subObject(unselected, 'label')\n  };\n  const {\n    setState: setM,\n    removeState: removeM\n  } = useState(markerStyle, undefined);\n  const {\n    setState: setL,\n    removeState: removeL\n  } = useState(labelStyle, undefined);\n  const items = Array.from(legends(root));\n  let selectedValues = items.map(datum);\n  const updateLegendState = () => {\n    for (const item of items) {\n      const value = datum(item);\n      const marker = markerOf(item);\n      const label = labelOf(item);\n      if (!selectedValues.includes(value)) {\n        setM(marker, 'unselected');\n        setL(label, 'unselected');\n      } else {\n        removeM(marker, 'unselected');\n        removeL(label, 'unselected');\n      }\n    }\n  };\n  for (const item of items) {\n    // Defined handlers.\n    const pointerenter = () => {\n      setCursor(root, 'pointer');\n    };\n    const pointerout = () => {\n      restoreCursor(root);\n    };\n    const click = event => __awaiter(this, void 0, void 0, function* () {\n      const value = datum(item);\n      const index = selectedValues.indexOf(value);\n      if (index === -1) selectedValues.push(value);else selectedValues.splice(index, 1);\n      yield filter(selectedValues);\n      updateLegendState();\n      const {\n        nativeEvent = true\n      } = event;\n      if (!nativeEvent) return;\n      if (selectedValues.length === items.length) {\n        emitter.emit('legend:reset', {\n          nativeEvent\n        });\n      } else {\n        // Emit events.\n        emitter.emit('legend:filter', Object.assign(Object.assign({}, event), {\n          nativeEvent,\n          data: {\n            channel,\n            values: selectedValues\n          }\n        }));\n      }\n    });\n    // Bind and store handlers.\n    item.addEventListener('click', click);\n    item.addEventListener('pointerenter', pointerenter);\n    item.addEventListener('pointerout', pointerout);\n    itemClick.set(item, click);\n    itemPointerenter.set(item, pointerenter);\n    itemPointerout.set(item, pointerout);\n  }\n  const onFilter = event => __awaiter(this, void 0, void 0, function* () {\n    const {\n      nativeEvent\n    } = event;\n    if (nativeEvent) return;\n    const {\n      data\n    } = event;\n    const {\n      channel: specifiedChannel,\n      values\n    } = data;\n    if (specifiedChannel !== channel) return;\n    selectedValues = values;\n    yield filter(selectedValues);\n    updateLegendState();\n  });\n  const onEnd = event => __awaiter(this, void 0, void 0, function* () {\n    const {\n      nativeEvent\n    } = event;\n    if (nativeEvent) return;\n    selectedValues = items.map(datum);\n    yield filter(selectedValues);\n    updateLegendState();\n  });\n  emitter.on('legend:filter', onFilter);\n  emitter.on('legend:reset', onEnd);\n  return () => {\n    for (const item of items) {\n      item.removeEventListener('click', itemClick.get(item));\n      item.removeEventListener('pointerenter', itemPointerenter.get(item));\n      item.removeEventListener('pointerout', itemPointerout.get(item));\n      emitter.off('legend:filter', onFilter);\n      emitter.off('legend:reset', onEnd);\n    }\n  };\n}\nfunction legendFilterContinuous(_, {\n  legend,\n  filter,\n  emitter,\n  channel\n}) {\n  const onValueChange = ({\n    detail: {\n      value\n    }\n  }) => {\n    filter(value);\n    emitter.emit({\n      nativeEvent: true,\n      data: {\n        channel,\n        values: value\n      }\n    });\n  };\n  legend.addEventListener('valuechange', onValueChange);\n  return () => {\n    legend.removeEventListener('valuechange', onValueChange);\n  };\n}\nfunction filterView(context,\n// View instance,\n{\n  legend,\n  // Legend instance.\n  channel,\n  // Filter Channel.\n  value,\n  // Filtered Values.\n  ordinal,\n  // Data type of the legend.\n  channels,\n  // Channels for this legend.\n  allChannels,\n  // Channels for all legends.\n  facet = false // For facet.\n}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      view,\n      update,\n      setState\n    } = context;\n    setState(legend, viewOptions => {\n      const {\n        marks\n      } = viewOptions;\n      // Add filter transform for every marks,\n      // which will skip for mark without color channel.\n      const newMarks = marks.map(mark => {\n        if (mark.type === 'legends') return mark;\n        // Inset after aggregate transform, such as group, and bin.\n        const {\n          transform = [],\n          data = []\n        } = mark;\n        const index = transform.findIndex(({\n          type\n        }) => type.startsWith('group') || type.startsWith('bin'));\n        const newTransform = [...transform];\n        if (data.length) {\n          newTransform.splice(index + 1, 0, {\n            type: 'filter',\n            [channel]: {\n              value,\n              ordinal\n            }\n          });\n        }\n        // Set domain of scale to preserve encoding.\n        const newScale = Object.fromEntries(channels.map(channel => [channel, {\n          domain: view.scale[channel].getOptions().domain\n        }]));\n        return deepMix({}, mark, Object.assign(Object.assign({\n          transform: newTransform,\n          scale: newScale\n        }, !ordinal && {\n          animate: false\n        }), {\n          legend: facet ? false : Object.fromEntries(allChannels.map(d => [d, {\n            preserve: true\n          }]))\n        }));\n      });\n      return Object.assign(Object.assign({}, viewOptions), {\n        marks: newMarks\n      });\n    });\n    yield update();\n  });\n}\nfunction filterFacets(facets, options) {\n  for (const facet of facets) {\n    filterView(facet, Object.assign(Object.assign({}, options), {\n      facet: true\n    }));\n  }\n}\nexport function LegendFilter() {\n  return (context, contexts, emitter) => {\n    const {\n      container\n    } = context;\n    const facets = contexts.filter(d => d !== context);\n    const isFacet = facets.length > 0;\n    const channelsOf = legend => {\n      return dataOf(legend).scales.map(d => d.name);\n    };\n    const legends = [...legendsOf(container), ...legendsContinuousOf(container)];\n    const allChannels = legends.flatMap(channelsOf);\n    const filter = isFacet ? throttle(filterFacets, 50, {\n      trailing: true\n    }) : throttle(filterView, 50, {\n      trailing: true\n    });\n    const removes = legends.map(legend => {\n      const {\n        name: channel,\n        domain\n      } = dataOf(legend).scales[0];\n      const channels = channelsOf(legend);\n      const common = {\n        legend,\n        channel,\n        channels,\n        allChannels\n      };\n      if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {\n        return legendFilterOrdinal(container, {\n          legends: itemsOf,\n          marker: markerOf,\n          label: labelOf,\n          datum: d => {\n            const {\n              __data__: datum\n            } = d;\n            const {\n              index\n            } = datum;\n            return domain[index];\n          },\n          filter: value => {\n            const options = Object.assign(Object.assign({}, common), {\n              value,\n              ordinal: true\n            });\n            if (isFacet) filter(facets, options);else filter(context, options);\n          },\n          state: legend.attributes.state,\n          channel,\n          emitter\n        });\n      } else {\n        return legendFilterContinuous(container, {\n          legend,\n          filter: value => {\n            const options = Object.assign(Object.assign({}, common), {\n              value,\n              ordinal: false\n            });\n            if (isFacet) filter(facets, options);else filter(context, options);\n          },\n          emitter,\n          channel\n        });\n      }\n    });\n    return () => {\n      removes.forEach(remove => remove());\n    };\n  };\n}","map":{"version":3,"names":["deepMix","throttle","subObject","useState","setCursor","restoreCursor","CATEGORY_LEGEND_CLASS_NAME","CONTINUOUS_LEGEND_CLASS_NAME","LEGEND_ITEMS_CLASS_NAME","LEGEND_MAKER_CLASS_NAME","LEGEND_LABEL_CLASS_NAME","markerOf","item","getElementsByClassName","labelOf","itemsOf","root","legendsOf","legendsContinuousOf","legendClearSetState","setState","legends","forEach","legend","v","dataOf","parent","parentNode","__data__","attributesOf","child","attr","startsWith","children","attributes","legendFilterOrdinal","marker","label","datum","filter","emitter","channel","state","itemClick","Map","itemPointerenter","itemPointerout","unselected","markerStroke","markerFill","labelFill","markerStyle","labelStyle","setM","removeState","removeM","undefined","setL","removeL","items","Array","from","selectedValues","map","updateLegendState","value","includes","pointerenter","pointerout","click","event","__awaiter","index","indexOf","push","splice","nativeEvent","length","emit","Object","assign","data","values","addEventListener","set","onFilter","specifiedChannel","onEnd","on","removeEventListener","get","off","legendFilterContinuous","_","onValueChange","detail","filterView","context","ordinal","channels","allChannels","facet","view","update","viewOptions","marks","newMarks","mark","type","transform","findIndex","newTransform","newScale","fromEntries","domain","scale","getOptions","animate","d","preserve","filterFacets","facets","options","LegendFilter","contexts","container","isFacet","channelsOf","scales","name","flatMap","trailing","removes","common","className","remove"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/legendFilter.ts"],"sourcesContent":["import { DisplayObject } from '@antv/g';\nimport { deepMix, throttle } from '@antv/util';\nimport { subObject } from '../utils/helper';\nimport { useState, setCursor, restoreCursor } from './utils';\n\nexport const CATEGORY_LEGEND_CLASS_NAME = 'legend-category';\n\nexport const CONTINUOUS_LEGEND_CLASS_NAME = 'legend-continuous';\n\nexport const LEGEND_ITEMS_CLASS_NAME = 'items-item';\n\nexport const LEGEND_MAKER_CLASS_NAME = 'legend-category-item-marker';\n\nexport const LEGEND_LABEL_CLASS_NAME = 'legend-category-item-label';\n\nexport function markerOf(item) {\n  return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];\n}\n\nexport function labelOf(item) {\n  return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];\n}\n\nexport function itemsOf(root) {\n  return root.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);\n}\n\nexport function legendsOf(root) {\n  return root.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);\n}\n\nexport function legendsContinuousOf(root) {\n  return root.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);\n}\n\nexport function legendClearSetState(root, setState) {\n  const legends = [...legendsOf(root), ...legendsContinuousOf(root)];\n\n  legends.forEach((legend) => {\n    setState(legend, (v) => v);\n  });\n}\n\nexport function dataOf(root) {\n  // legend -> layout -> container\n  let parent = root.parentNode;\n  while (parent && !parent.__data__) {\n    parent = parent.parentNode;\n  }\n  return parent.__data__;\n}\n\nexport function attributesOf(root) {\n  let child = root;\n  while (child && !child.attr('class').startsWith('legend')) {\n    child = child.children[0];\n  }\n  return child.attributes;\n}\n\nfunction legendFilterOrdinal(\n  root: DisplayObject,\n  {\n    legends, // given the root of chart returns legends to be manipulated\n    marker: markerOf, // given the legend returns the marker\n    label: labelOf, // given the legend returns the label\n    datum, // given the legend returns the value\n    filter, // invoke when dispatch filter event,\n    emitter,\n    channel,\n    state = {} as Record<string, any>, // state options\n  },\n) {\n  // Index handler by item.\n  const itemClick = new Map();\n  const itemPointerenter = new Map();\n  const itemPointerout = new Map();\n\n  const {\n    unselected = {\n      markerStroke: '#aaa',\n      markerFill: '#aaa',\n      labelFill: '#aaa',\n    },\n  } = state;\n  const markerStyle = { unselected: subObject(unselected, 'marker') };\n  const labelStyle = { unselected: subObject(unselected, 'label') };\n  const { setState: setM, removeState: removeM } = useState(\n    markerStyle,\n    undefined,\n  );\n  const { setState: setL, removeState: removeL } = useState(\n    labelStyle,\n    undefined,\n  );\n\n  const items: DisplayObject[] = Array.from(legends(root));\n  let selectedValues = items.map(datum);\n  const updateLegendState = () => {\n    for (const item of items) {\n      const value = datum(item);\n      const marker = markerOf(item);\n      const label = labelOf(item);\n      if (!selectedValues.includes(value)) {\n        setM(marker, 'unselected');\n        setL(label, 'unselected');\n      } else {\n        removeM(marker, 'unselected');\n        removeL(label, 'unselected');\n      }\n    }\n  };\n\n  for (const item of items) {\n    // Defined handlers.\n    const pointerenter = () => {\n      setCursor(root, 'pointer');\n    };\n\n    const pointerout = () => {\n      restoreCursor(root);\n    };\n\n    const click = async (event) => {\n      const value = datum(item);\n      const index = selectedValues.indexOf(value);\n      if (index === -1) selectedValues.push(value);\n      else selectedValues.splice(index, 1);\n      await filter(selectedValues);\n      updateLegendState();\n\n      const { nativeEvent = true } = event;\n      if (!nativeEvent) return;\n      if (selectedValues.length === items.length) {\n        emitter.emit('legend:reset', { nativeEvent });\n      } else {\n        // Emit events.\n        emitter.emit('legend:filter', {\n          ...event,\n          nativeEvent,\n          data: {\n            channel,\n            values: selectedValues,\n          },\n        });\n      }\n    };\n\n    // Bind and store handlers.\n    item.addEventListener('click', click);\n    item.addEventListener('pointerenter', pointerenter);\n    item.addEventListener('pointerout', pointerout);\n    itemClick.set(item, click);\n    itemPointerenter.set(item, pointerenter);\n    itemPointerout.set(item, pointerout);\n  }\n\n  const onFilter = async (event) => {\n    const { nativeEvent } = event;\n    if (nativeEvent) return;\n    const { data } = event;\n    const { channel: specifiedChannel, values } = data;\n    if (specifiedChannel !== channel) return;\n    selectedValues = values;\n    await filter(selectedValues);\n    updateLegendState();\n  };\n\n  const onEnd = async (event) => {\n    const { nativeEvent } = event;\n    if (nativeEvent) return;\n    selectedValues = items.map(datum);\n    await filter(selectedValues);\n    updateLegendState();\n  };\n\n  emitter.on('legend:filter', onFilter);\n  emitter.on('legend:reset', onEnd);\n\n  return () => {\n    for (const item of items) {\n      item.removeEventListener('click', itemClick.get(item));\n      item.removeEventListener('pointerenter', itemPointerenter.get(item));\n      item.removeEventListener('pointerout', itemPointerout.get(item));\n      emitter.off('legend:filter', onFilter);\n      emitter.off('legend:reset', onEnd);\n    }\n  };\n}\n\nfunction legendFilterContinuous(_, { legend, filter, emitter, channel }) {\n  const onValueChange = ({ detail: { value } }) => {\n    filter(value);\n    emitter.emit({\n      nativeEvent: true,\n      data: {\n        channel,\n        values: value,\n      },\n    });\n  };\n  legend.addEventListener('valuechange', onValueChange);\n  return () => {\n    legend.removeEventListener('valuechange', onValueChange);\n  };\n}\n\nasync function filterView(\n  context, // View instance,\n  {\n    legend, // Legend instance.\n    channel, // Filter Channel.\n    value, // Filtered Values.\n    ordinal, // Data type of the legend.\n    channels, // Channels for this legend.\n    allChannels, // Channels for all legends.\n    facet = false, // For facet.\n  },\n) {\n  const { view, update, setState } = context;\n  setState(legend, (viewOptions) => {\n    const { marks } = viewOptions;\n    // Add filter transform for every marks,\n    // which will skip for mark without color channel.\n    const newMarks = marks.map((mark) => {\n      if (mark.type === 'legends') return mark;\n\n      // Inset after aggregate transform, such as group, and bin.\n      const { transform = [], data = [] } = mark;\n      const index = transform.findIndex(\n        ({ type }) => type.startsWith('group') || type.startsWith('bin'),\n      );\n      const newTransform = [...transform];\n      if (data.length) {\n        newTransform.splice(index + 1, 0, {\n          type: 'filter',\n          [channel]: { value, ordinal },\n        });\n      }\n\n      // Set domain of scale to preserve encoding.\n      const newScale = Object.fromEntries(\n        channels.map((channel) => [\n          channel,\n          { domain: view.scale[channel].getOptions().domain },\n        ]),\n      );\n      return deepMix({}, mark, {\n        transform: newTransform,\n        scale: newScale,\n        ...(!ordinal && { animate: false }),\n        legend: facet\n          ? false\n          : Object.fromEntries(allChannels.map((d) => [d, { preserve: true }])),\n      });\n    });\n    return { ...viewOptions, marks: newMarks };\n  });\n  await update();\n}\n\nfunction filterFacets(facets, options) {\n  for (const facet of facets) {\n    filterView(facet, { ...options, facet: true });\n  }\n}\n\nexport function LegendFilter() {\n  return (context, contexts, emitter) => {\n    const { container } = context;\n    const facets = contexts.filter((d) => d !== context);\n    const isFacet = facets.length > 0;\n\n    const channelsOf = (legend) => {\n      return dataOf(legend).scales.map((d) => d.name);\n    };\n    const legends = [\n      ...legendsOf(container),\n      ...legendsContinuousOf(container),\n    ];\n    const allChannels = legends.flatMap(channelsOf);\n\n    const filter = isFacet\n      ? throttle(filterFacets, 50, { trailing: true })\n      : throttle(filterView, 50, { trailing: true });\n\n    const removes = legends.map((legend) => {\n      const { name: channel, domain } = dataOf(legend).scales[0];\n      const channels = channelsOf(legend);\n      const common = {\n        legend,\n        channel,\n        channels,\n        allChannels,\n      };\n      if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {\n        return legendFilterOrdinal(container, {\n          legends: itemsOf,\n          marker: markerOf,\n          label: labelOf,\n          datum: (d) => {\n            const { __data__: datum } = d;\n            const { index } = datum;\n            return domain[index];\n          },\n          filter: (value) => {\n            const options = { ...common, value, ordinal: true };\n            if (isFacet) filter(facets, options);\n            else filter(context, options);\n          },\n          state: legend.attributes.state,\n          channel,\n          emitter,\n        });\n      } else {\n        return legendFilterContinuous(container, {\n          legend,\n          filter: (value) => {\n            const options = { ...common, value, ordinal: false };\n            if (isFacet) filter(facets, options);\n            else filter(context, options);\n          },\n          emitter,\n          channel,\n        });\n      }\n    });\n    return () => {\n      removes.forEach((remove) => remove());\n    };\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}