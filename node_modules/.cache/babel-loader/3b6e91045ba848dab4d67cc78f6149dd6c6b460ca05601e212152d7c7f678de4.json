{"ast":null,"code":"import { isEqual } from '@antv/util';\nimport { getBBoxHeight, getBBoxWidth } from './bbox';\nimport { getLinesIntersection, isLinesParallel } from './line';\nimport { getXYByPlacement } from './position';\nimport { add, distance, divide, normalize, subtract, toVector2 } from './vector';\n/**\n * <zh/> 将对象坐标转换为数组坐标\n * <en/> Convert object coordinates to array coordinates\n * @param point - <zh/> 对象坐标 | <en/> object coordinates\n * @returns <zh/> 数组坐标 | <en/> array coordinates\n */\nexport function parsePoint(point) {\n  var _a;\n  return [point.x, point.y, (_a = point.z) !== null && _a !== void 0 ? _a : 0];\n}\n/**\n * <zh/> 将数组坐标转换为对象坐标\n *\n * <en/> Convert array coordinates to object coordinates\n * @param point - <zh/> 数组坐标 | <en/> array coordinates\n * @returns <zh/> 对象坐标 | <en/> object coordinates\n */\nexport function toPointObject(point) {\n  var _a;\n  return {\n    x: point[0],\n    y: point[1],\n    z: (_a = point[2]) !== null && _a !== void 0 ? _a : 0\n  };\n}\n/**\n * <zh/> 根据 X 轴坐标排序\n * <en/> Sort by X-axis coordinates\n * @param points - <zh/> 点集 | <en/> point set\n * @returns <zh/> 排序后的点集 | <en/> sorted point set\n */\nexport function sortByX(points) {\n  return points.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n}\n/**\n * <zh/> 点集去重\n *\n * <en/> Deduplicate point set\n * @param points - <zh/> 点集 | <en/> pointset\n * @returns <zh/> 去重后的点集 | <en/> deduplicated pointset\n */\nexport function deduplicate(points) {\n  const set = new Set();\n  return points.filter(p => {\n    const key = p.join(',');\n    if (set.has(key)) return false;\n    set.add(key);\n    return true;\n  });\n}\n/**\n * <zh/> 对点格式化，精确到 `digits` 位的数字\n *\n * <en/> Round the point to the given precision\n * @param point - <zh/> 要舍入的点 | <en/> the point to round\n * @param digits - <zh/> 小数点后的位数 | <en/> the number of digits after the decimal point\n * @returns <zh/> 舍入后的点 | <en/> the rounded point\n */\nexport function round(point, digits = 0) {\n  return point.map(p => parseFloat(p.toFixed(digits)));\n}\n/**\n * <zh/> 移动点，将点朝向参考点移动一定的距离\n *\n * <en/> Move `p` point along the line starting from `ref` to this point by a certain `distance`\n * @param p - <zh/> 要移动的点 | <en/> the point to move\n * @param ref - <zh/> 参考点 | <en/> the reference point\n * @param distance - <zh/> 移动的距离 | <en/> the distance to move\n * @param reverse\n * @returns <zh/> 移动后的点 | <en/> the moved point\n */\nexport function moveTo(p, ref, distance, reverse = false) {\n  if (isEqual(p, ref)) return p;\n  const direction = reverse ? subtract(p, ref) : subtract(ref, p);\n  const normalizedDirection = normalize(direction);\n  const moveVector = [normalizedDirection[0] * distance, normalizedDirection[1] * distance];\n  return add(toVector2(p), moveVector);\n}\n/**\n * <zh/> 判断两个点是否在同一水平线上\n *\n * <en/> whether two points are on the same horizontal line\n * @param p1 - <zh/> 第一个点 | <en/> the first point\n * @param p2 - <zh/> 第二个点 | <en/> the second point\n * @returns <zh/> 返回两个点是否在同一水平线上 | <en/> is horizontal or not\n */\nexport function isHorizontal(p1, p2) {\n  return p1[1] === p2[1];\n}\n/**\n * <zh/> 判断两个点是否在同一垂直线上\n *\n * <en/> whether two points are on the same vertical line\n * @param p1 - <zh/> 第一个点 | <en/> the first point\n * @param p2 - <zh/> 第二个点 | <en/> the second point\n * @returns <zh/> 返回两个点是否在同一垂直线上 | <en/> is vertical or not\n */\nexport function isVertical(p1, p2) {\n  return p1[0] === p2[0];\n}\n/**\n * <zh/> 判断两个点是否正交，即是否在同一水平线或垂直线上\n *\n * <en/> Judges whether two points are orthogonal, that is, whether they are on the same horizontal or vertical line\n * @param p1 - <zh/> 第一个点 | <en/> the first point\n * @param p2 - <zh/> 第二个点 | <en/> the second point\n * @returns <zh/> 是否正交 | <en/> whether orthogonal or not\n */\nexport function isOrthogonal(p1, p2) {\n  return isHorizontal(p1, p2) || isVertical(p1, p2);\n}\n/**\n * <zh/> 判断是否三点共线\n *\n * <en/> Judge whether three points are collinear\n * @param p1 - <zh/> 第一个点 | <en/> the first point\n * @param p2 - <zh/> 第二个点 | <en/> the second point\n * @param p3 - <zh/> 第三个点 | <en/> the third point\n * @returns <zh/> 是否三点共线 | <en/> whether three points are collinear\n */\nexport function isCollinear(p1, p2, p3) {\n  return isLinesParallel([p1, p2], [p2, p3]);\n}\n/**\n * <zh/> 计算一个点相对于另一个点的中心对称点\n *\n * <en/> Calculate the center symmetric point of a point relative to another point\n * @param p - <zh/> 要计算的点 | <en/> the point to calculate\n * @param center - <zh/> 中心点 | <en/> the center point\n * @returns <zh/> 中心对称点 | <en/> the center symmetric point\n */\nexport function getSymmetricPoint(p, center) {\n  return [2 * center[0] - p[0], 2 * center[1] - p[1]];\n}\n/**\n * <zh/> 获取从多边形中心到给定点的连线与多边形边缘的交点\n *\n * <en/> Gets the intersection point between the line from the center of a polygon to a given point and the polygon's edge\n * @param p - <zh/> 从多边形中心到多边形边缘的连线的外部点 | <en/> The point outside the polygon from which the line to the polygon's center is drawn\n * @param center - <zh/> 多边形中心 | <en/> the center of the polygon\n * @param points - <zh/> 多边形顶点 | <en/> the vertices of the polygon\n * @param isRelativePos - <zh/> 顶点坐标是否相对中心点 | <en/> whether the vertex coordinates are relative to the center point\n * @param useExtendedLine - <zh/> 是否使用延长线 | <en/> whether to use the extended line\n * @returns <zh/> 交点与相交线段 | <en/> intersection and intersecting line segment\n */\nexport function getPolygonIntersectPoint(p, center, points, isRelativePos = true, useExtendedLine = false) {\n  for (let i = 0; i < points.length; i++) {\n    let start = points[i];\n    let end = points[(i + 1) % points.length];\n    if (isRelativePos) {\n      start = add(center, start);\n      end = add(center, end);\n    }\n    const refP = useExtendedLine ? getSymmetricPoint(p, center) : p;\n    const intersect = getLinesIntersection([center, refP], [start, end]);\n    if (intersect) {\n      return {\n        point: intersect,\n        line: [start, end]\n      };\n    }\n  }\n  return {\n    point: center,\n    line: undefined\n  };\n}\n/**\n * <zh/> 判断点是否在多边形内部\n *\n * <en/> Whether point is inside the polygon (ray algo)\n * @param point - <zh/> 点 | <en/> point\n * @param points - <zh/> 多边形顶点 | <en/> polygon vertices\n * @param start - <zh/> 起始索引 | <en/> start index\n * @param end - <zh/> 结束索引 | <en/> end index\n * @returns <zh/> 是否在多边形内部 | <en/> whether inside the polygon\n */\nexport function isPointInPolygon(point, points, start, end) {\n  const x = point[0];\n  const y = point[1];\n  let inside = false;\n  if (start === undefined) start = 0;\n  if (end === undefined) end = points.length;\n  const len = end - start;\n  for (let i = 0, j = len - 1; i < len; j = i++) {\n    const xi = points[i + start][0];\n    const yi = points[i + start][1];\n    const xj = points[j + start][0];\n    const yj = points[j + start][1];\n    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\n/**\n * <zh/> 获取给定点到矩形中心的连线与矩形边缘的交点\n *\n * <en/> Gets the intersection point between the line from the center of a rectangle to a given point and the rectangle's edge\n * @param p - <zh/> 从矩形中心到矩形边缘的连线的外部点 | <en/> The point outside the rectangle from which the line to the rectangle's center is drawn\n * @param bbox - <zh/> 矩形包围盒 | <en/> the bounding box of the rectangle\n * @param useExtendedLine - <zh/> 是否使用延长线 | <en/> whether to use the extended line\n * @returns <zh/> 交点 | <en/> intersection\n */\nexport function getRectIntersectPoint(p, bbox, useExtendedLine = false) {\n  const center = getXYByPlacement(bbox, 'center');\n  const corners = [getXYByPlacement(bbox, 'left-top'), getXYByPlacement(bbox, 'right-top'), getXYByPlacement(bbox, 'right-bottom'), getXYByPlacement(bbox, 'left-bottom')];\n  return getPolygonIntersectPoint(p, center, corners, false, useExtendedLine).point;\n}\n/**\n * <zh/> 获取给定点到椭圆中心的连线与椭圆边缘的交点\n *\n * <en/> Gets the intersection point between the line from the center of an ellipse to a given point and the ellipse's edge\n * @param p - <zh/> 从椭圆中心到椭圆边缘的连线的外部点 | <en/> The point outside the ellipse from which the line to the ellipse's center is drawn\n * The point outside the ellipse from which the line to the ellipse's center is drawn.\n * @param bbox - <zh/> 椭圆包围盒 | <en/> the bounding box of the ellipse\n * @param useExtendedLine - <zh/> 是否使用延长线 | <en/> whether to use the extended line\n * @returns <zh/> 交点 | <en/> intersection\n */\nexport function getEllipseIntersectPoint(p, bbox, useExtendedLine = false) {\n  const center = bbox.center;\n  const refP = useExtendedLine ? getSymmetricPoint(p, center) : p;\n  const vec = subtract(refP, bbox.center);\n  const angle = Math.atan2(vec[1], vec[0]);\n  if (isNaN(angle)) return center;\n  const rx = getBBoxWidth(bbox) / 2;\n  const ry = getBBoxHeight(bbox) / 2;\n  const intersectX = center[0] + rx * Math.cos(angle);\n  const intersectY = center[1] + ry * Math.sin(angle);\n  return [intersectX, intersectY];\n}\n/**\n * <zh/> 从两组点中找到距离最近的两个点\n * @param group1 - <zh/> 第一组点 | <en/> the first group of points\n * @param group2 - <zh/> 第二组点 | <en/> the second group of points\n * @returns <zh/> 距离最近的两个点 | <en/> the nearest two points\n */\nexport function findNearestPoints(group1, group2) {\n  let minDistance = Infinity;\n  let nearestPoints = [group1[0], group2[0]];\n  group1.forEach(p1 => {\n    group2.forEach(p2 => {\n      const dist = distance(p1, p2);\n      if (dist < minDistance) {\n        minDistance = dist;\n        nearestPoints = [p1, p2];\n      }\n    });\n  });\n  return nearestPoints;\n}\n/**\n * <zh/> 从一组线段中找到距离给定点最近的线段\n *\n * <en/> Find the line segment closest to the given point from a group of line segments\n * @param point - <zh/> 给定点 | <en/> the given point\n * @param lines - <zh/> 一组线段 | <en/> a group of line segments\n * @returns <zh/> 距离最近的线段 | <en/> the nearest line segment\n */\nexport function findNearestLine(point, lines) {\n  let minDistance = Infinity;\n  let nearestLine = [[0, 0], [0, 0]];\n  lines.forEach(line => {\n    const distance = getDistanceToLine(point, line);\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearestLine = line;\n    }\n  });\n  return nearestLine;\n}\n/**\n * <zh/> 获取点到线段的距离\n *\n * <en/> Get the distance from a point to a line segment\n * @param point - <zh/> 点 | <en/> the point\n * @param line - <zh/> 线段 | <en/> the line segment\n * @returns <zh/> 点到线段的距离 | <en/> the distance from the point to the line segment\n */\nexport function getDistanceToLine(point, line) {\n  const nearestPoint = findNearestPointOnLine(point, line);\n  return distance(point, nearestPoint);\n}\n/**\n * <zh/> 获取线段上距离给定点最近的点\n *\n * <en/> Get the point on the line segment closest to the given point\n * @param point - <zh/> 给定点 | <en/> the given point\n * @param line - <zh/> 线段 | <en/> the line segment\n * @returns <zh/> 线段上距离给定点最近的点 | <en/> the point on the line segment closest to the given point\n */\nexport function findNearestPointOnLine(point, line) {\n  const [x1, y1] = line[0];\n  const [x2, y2] = line[1];\n  const [x3, y3] = point;\n  const px = x2 - x1;\n  const py = y2 - y1;\n  // 若线段实际上是一个点 | If the line segment is actually a point\n  if (px === 0 && py === 0) {\n    return [x1, y1];\n  }\n  let u = ((x3 - x1) * px + (y3 - y1) * py) / (px * px + py * py);\n  if (u > 1) {\n    u = 1;\n  } else if (u < 0) {\n    u = 0;\n  }\n  const x = x1 + u * px;\n  const y = y1 + u * py;\n  return [x, y];\n}\n/**\n * <zh/> 获取点集的中心点\n *\n * <en/> Get the center point of a set of points\n * @param points - <zh/> 点集 | <en/> point set\n * @returns <zh/> 中心点 | <en/> center point\n */\nexport function centerOf(points) {\n  const totalPosition = points.reduce((acc, p) => add(acc, p), [0, 0]);\n  return divide(totalPosition, points.length);\n}\n/**\n * <zh/> 按顺时针或逆时针方向对点集排序\n *\n * <en/> Sort the point set in a clockwise or counterclockwise direction\n * @param points - <zh/> 点集 | <en/> point set\n * @param clockwise - <zh/> 是否顺时针 | <en/> whether clockwise\n * @returns <zh/> 排序后的点集 | <en/> sorted point set\n */\nexport function sortByClockwise(points, clockwise = true) {\n  const center = centerOf(points);\n  return points.sort(([x1, y1], [x2, y2]) => {\n    const angle1 = Math.atan2(y1 - center[1], x1 - center[0]);\n    const angle2 = Math.atan2(y2 - center[1], x2 - center[0]);\n    return clockwise ? angle2 - angle1 : angle1 - angle2;\n  });\n}\n/**\n * <zh/> 给定的起点和终点，返回一个由这两个点和它们的对角点组成的数组\n * @param start - <zh/> 起点 | <en/> start point\n * @param end - <zh/> 终点 | <en/> end point\n * @returns <zh/> 由这两个点和它们的对角点组成的数组 | <en/> an array consisting of these two points and their diagonal points\n */\nexport function getBoundingPoints(start, end) {\n  return [start, [start[0], end[1]], end, [end[0], start[1]]];\n}","map":{"version":3,"names":["isEqual","getBBoxHeight","getBBoxWidth","getLinesIntersection","isLinesParallel","getXYByPlacement","add","distance","divide","normalize","subtract","toVector2","parsePoint","point","x","y","_a","z","toPointObject","sortByX","points","sort","a","b","deduplicate","set","Set","filter","p","key","join","has","round","digits","map","parseFloat","toFixed","moveTo","ref","reverse","direction","normalizedDirection","moveVector","isHorizontal","p1","p2","isVertical","isOrthogonal","isCollinear","p3","getSymmetricPoint","center","getPolygonIntersectPoint","isRelativePos","useExtendedLine","i","length","start","end","refP","intersect","line","undefined","isPointInPolygon","inside","len","j","xi","yi","xj","yj","getRectIntersectPoint","bbox","corners","getEllipseIntersectPoint","vec","angle","Math","atan2","isNaN","rx","ry","intersectX","cos","intersectY","sin","findNearestPoints","group1","group2","minDistance","Infinity","nearestPoints","forEach","dist","findNearestLine","lines","nearestLine","getDistanceToLine","nearestPoint","findNearestPointOnLine","x1","y1","x2","y2","x3","y3","px","py","u","centerOf","totalPosition","reduce","acc","sortByClockwise","clockwise","angle1","angle2","getBoundingPoints"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/point.ts"],"sourcesContent":["import type { AABB } from '@antv/g';\nimport { isEqual } from '@antv/util';\nimport type { Point, PointObject } from '../types';\nimport { getBBoxHeight, getBBoxWidth } from './bbox';\nimport type { LineSegment } from './line';\nimport { getLinesIntersection, isLinesParallel } from './line';\nimport { getXYByPlacement } from './position';\nimport { add, distance, divide, normalize, subtract, toVector2 } from './vector';\n\n/**\n * <zh/> 将对象坐标转换为数组坐标\n * <en/> Convert object coordinates to array coordinates\n * @param point - <zh/> 对象坐标 | <en/> object coordinates\n * @returns <zh/> 数组坐标 | <en/> array coordinates\n */\nexport function parsePoint(point: PointObject): Point {\n  return [point.x, point.y, point.z ?? 0];\n}\n\n/**\n * <zh/> 将数组坐标转换为对象坐标\n *\n * <en/> Convert array coordinates to object coordinates\n * @param point - <zh/> 数组坐标 | <en/> array coordinates\n * @returns <zh/> 对象坐标 | <en/> object coordinates\n */\nexport function toPointObject(point: Point): PointObject {\n  return { x: point[0], y: point[1], z: point[2] ?? 0 };\n}\n\n/**\n * <zh/> 根据 X 轴坐标排序\n * <en/> Sort by X-axis coordinates\n * @param points - <zh/> 点集 | <en/> point set\n * @returns <zh/> 排序后的点集 | <en/> sorted point set\n */\nexport function sortByX(points: Point[]): Point[] {\n  return points.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n}\n\n/**\n * <zh/> 点集去重\n *\n * <en/> Deduplicate point set\n * @param points - <zh/> 点集 | <en/> pointset\n * @returns <zh/> 去重后的点集 | <en/> deduplicated pointset\n */\nexport function deduplicate(points: Point[]): Point[] {\n  const set = new Set<string>();\n  return points.filter((p) => {\n    const key = p.join(',');\n    if (set.has(key)) return false;\n    set.add(key);\n    return true;\n  });\n}\n\n/**\n * <zh/> 对点格式化，精确到 `digits` 位的数字\n *\n * <en/> Round the point to the given precision\n * @param point - <zh/> 要舍入的点 | <en/> the point to round\n * @param digits - <zh/> 小数点后的位数 | <en/> the number of digits after the decimal point\n * @returns <zh/> 舍入后的点 | <en/> the rounded point\n */\nexport function round(point: Point, digits = 0): Point {\n  return point.map((p) => parseFloat(p.toFixed(digits))) as Point;\n}\n\n/**\n * <zh/> 移动点，将点朝向参考点移动一定的距离\n *\n * <en/> Move `p` point along the line starting from `ref` to this point by a certain `distance`\n * @param p - <zh/> 要移动的点 | <en/> the point to move\n * @param ref - <zh/> 参考点 | <en/> the reference point\n * @param distance - <zh/> 移动的距离 | <en/> the distance to move\n * @param reverse\n * @returns <zh/> 移动后的点 | <en/> the moved point\n */\nexport function moveTo(p: Point, ref: Point, distance: number, reverse = false): Point {\n  if (isEqual(p, ref)) return p;\n  const direction = reverse ? subtract(p, ref) : subtract(ref, p);\n  const normalizedDirection = normalize(direction);\n  const moveVector: Point = [normalizedDirection[0] * distance, normalizedDirection[1] * distance];\n  return add(toVector2(p), moveVector);\n}\n\n/**\n * <zh/> 判断两个点是否在同一水平线上\n *\n * <en/> whether two points are on the same horizontal line\n * @param p1 - <zh/> 第一个点 | <en/> the first point\n * @param p2 - <zh/> 第二个点 | <en/> the second point\n * @returns <zh/> 返回两个点是否在同一水平线上 | <en/> is horizontal or not\n */\nexport function isHorizontal(p1: Point, p2: Point): boolean {\n  return p1[1] === p2[1];\n}\n\n/**\n * <zh/> 判断两个点是否在同一垂直线上\n *\n * <en/> whether two points are on the same vertical line\n * @param p1 - <zh/> 第一个点 | <en/> the first point\n * @param p2 - <zh/> 第二个点 | <en/> the second point\n * @returns <zh/> 返回两个点是否在同一垂直线上 | <en/> is vertical or not\n */\nexport function isVertical(p1: Point, p2: Point): boolean {\n  return p1[0] === p2[0];\n}\n\n/**\n * <zh/> 判断两个点是否正交，即是否在同一水平线或垂直线上\n *\n * <en/> Judges whether two points are orthogonal, that is, whether they are on the same horizontal or vertical line\n * @param p1 - <zh/> 第一个点 | <en/> the first point\n * @param p2 - <zh/> 第二个点 | <en/> the second point\n * @returns <zh/> 是否正交 | <en/> whether orthogonal or not\n */\nexport function isOrthogonal(p1: Point, p2: Point): boolean {\n  return isHorizontal(p1, p2) || isVertical(p1, p2);\n}\n\n/**\n * <zh/> 判断是否三点共线\n *\n * <en/> Judge whether three points are collinear\n * @param p1 - <zh/> 第一个点 | <en/> the first point\n * @param p2 - <zh/> 第二个点 | <en/> the second point\n * @param p3 - <zh/> 第三个点 | <en/> the third point\n * @returns <zh/> 是否三点共线 | <en/> whether three points are collinear\n */\nexport function isCollinear(p1: Point, p2: Point, p3: Point): boolean {\n  return isLinesParallel([p1, p2], [p2, p3]);\n}\n\n/**\n * <zh/> 计算一个点相对于另一个点的中心对称点\n *\n * <en/> Calculate the center symmetric point of a point relative to another point\n * @param p - <zh/> 要计算的点 | <en/> the point to calculate\n * @param center - <zh/> 中心点 | <en/> the center point\n * @returns <zh/> 中心对称点 | <en/> the center symmetric point\n */\nexport function getSymmetricPoint(p: Point, center: Point): Point {\n  return [2 * center[0] - p[0], 2 * center[1] - p[1]];\n}\n\n/**\n * <zh/> 获取从多边形中心到给定点的连线与多边形边缘的交点\n *\n * <en/> Gets the intersection point between the line from the center of a polygon to a given point and the polygon's edge\n * @param p - <zh/> 从多边形中心到多边形边缘的连线的外部点 | <en/> The point outside the polygon from which the line to the polygon's center is drawn\n * @param center - <zh/> 多边形中心 | <en/> the center of the polygon\n * @param points - <zh/> 多边形顶点 | <en/> the vertices of the polygon\n * @param isRelativePos - <zh/> 顶点坐标是否相对中心点 | <en/> whether the vertex coordinates are relative to the center point\n * @param useExtendedLine - <zh/> 是否使用延长线 | <en/> whether to use the extended line\n * @returns <zh/> 交点与相交线段 | <en/> intersection and intersecting line segment\n */\nexport function getPolygonIntersectPoint(\n  p: Point,\n  center: Point,\n  points: Point[],\n  isRelativePos = true,\n  useExtendedLine = false,\n): { point: Point; line?: LineSegment } {\n  for (let i = 0; i < points.length; i++) {\n    let start = points[i];\n    let end = points[(i + 1) % points.length];\n\n    if (isRelativePos) {\n      start = add(center, start);\n      end = add(center, end);\n    }\n\n    const refP = useExtendedLine ? getSymmetricPoint(p, center) : p;\n    const intersect = getLinesIntersection([center, refP], [start, end]);\n    if (intersect) {\n      return {\n        point: intersect,\n        line: [start, end],\n      };\n    }\n  }\n  return {\n    point: center,\n    line: undefined,\n  };\n}\n\n/**\n * <zh/> 判断点是否在多边形内部\n *\n * <en/> Whether point is inside the polygon (ray algo)\n * @param point - <zh/> 点 | <en/> point\n * @param points - <zh/> 多边形顶点 | <en/> polygon vertices\n * @param start - <zh/> 起始索引 | <en/> start index\n * @param end - <zh/> 结束索引 | <en/> end index\n * @returns <zh/> 是否在多边形内部 | <en/> whether inside the polygon\n */\nexport function isPointInPolygon(point: Point, points: Point[], start?: number, end?: number): boolean {\n  const x = point[0];\n  const y = point[1];\n  let inside = false;\n  if (start === undefined) start = 0;\n  if (end === undefined) end = points.length;\n  const len = end - start;\n  for (let i = 0, j = len - 1; i < len; j = i++) {\n    const xi = points[i + start][0];\n    const yi = points[i + start][1];\n    const xj = points[j + start][0];\n    const yj = points[j + start][1];\n    const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\n\n/**\n * <zh/> 获取给定点到矩形中心的连线与矩形边缘的交点\n *\n * <en/> Gets the intersection point between the line from the center of a rectangle to a given point and the rectangle's edge\n * @param p - <zh/> 从矩形中心到矩形边缘的连线的外部点 | <en/> The point outside the rectangle from which the line to the rectangle's center is drawn\n * @param bbox - <zh/> 矩形包围盒 | <en/> the bounding box of the rectangle\n * @param useExtendedLine - <zh/> 是否使用延长线 | <en/> whether to use the extended line\n * @returns <zh/> 交点 | <en/> intersection\n */\nexport function getRectIntersectPoint(p: Point, bbox: AABB, useExtendedLine = false): Point {\n  const center = getXYByPlacement(bbox, 'center');\n  const corners = [\n    getXYByPlacement(bbox, 'left-top'),\n    getXYByPlacement(bbox, 'right-top'),\n    getXYByPlacement(bbox, 'right-bottom'),\n    getXYByPlacement(bbox, 'left-bottom'),\n  ];\n  return getPolygonIntersectPoint(p, center, corners, false, useExtendedLine).point;\n}\n\n/**\n * <zh/> 获取给定点到椭圆中心的连线与椭圆边缘的交点\n *\n * <en/> Gets the intersection point between the line from the center of an ellipse to a given point and the ellipse's edge\n * @param p - <zh/> 从椭圆中心到椭圆边缘的连线的外部点 | <en/> The point outside the ellipse from which the line to the ellipse's center is drawn\n * The point outside the ellipse from which the line to the ellipse's center is drawn.\n * @param bbox - <zh/> 椭圆包围盒 | <en/> the bounding box of the ellipse\n * @param useExtendedLine - <zh/> 是否使用延长线 | <en/> whether to use the extended line\n * @returns <zh/> 交点 | <en/> intersection\n */\nexport function getEllipseIntersectPoint(p: Point, bbox: AABB, useExtendedLine = false): Point {\n  const center = bbox.center;\n  const refP = useExtendedLine ? getSymmetricPoint(p, center) : p;\n  const vec = subtract(refP, bbox.center);\n  const angle = Math.atan2(vec[1], vec[0]);\n  if (isNaN(angle)) return center;\n\n  const rx = getBBoxWidth(bbox) / 2;\n  const ry = getBBoxHeight(bbox) / 2;\n  const intersectX = center[0] + rx * Math.cos(angle);\n  const intersectY = center[1] + ry * Math.sin(angle);\n\n  return [intersectX, intersectY];\n}\n\n/**\n * <zh/> 从两组点中找到距离最近的两个点\n * @param group1 - <zh/> 第一组点 | <en/> the first group of points\n * @param group2 - <zh/> 第二组点 | <en/> the second group of points\n * @returns <zh/> 距离最近的两个点 | <en/> the nearest two points\n */\nexport function findNearestPoints(group1: Point[], group2: Point[]): [Point, Point] {\n  let minDistance = Infinity;\n  let nearestPoints: [Point, Point] = [group1[0], group2[0]];\n  group1.forEach((p1) => {\n    group2.forEach((p2) => {\n      const dist = distance(p1, p2);\n      if (dist < minDistance) {\n        minDistance = dist;\n        nearestPoints = [p1, p2];\n      }\n    });\n  });\n  return nearestPoints;\n}\n\n/**\n * <zh/> 从一组线段中找到距离给定点最近的线段\n *\n * <en/> Find the line segment closest to the given point from a group of line segments\n * @param point - <zh/> 给定点 | <en/> the given point\n * @param lines - <zh/> 一组线段 | <en/> a group of line segments\n * @returns <zh/> 距离最近的线段 | <en/> the nearest line segment\n */\nexport function findNearestLine(point: Point, lines: LineSegment[]) {\n  let minDistance = Infinity;\n  let nearestLine: [Point, Point] = [\n    [0, 0],\n    [0, 0],\n  ];\n  lines.forEach((line) => {\n    const distance = getDistanceToLine(point, line);\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearestLine = line;\n    }\n  });\n  return nearestLine;\n}\n\n/**\n * <zh/> 获取点到线段的距离\n *\n * <en/> Get the distance from a point to a line segment\n * @param point - <zh/> 点 | <en/> the point\n * @param line - <zh/> 线段 | <en/> the line segment\n * @returns <zh/> 点到线段的距离 | <en/> the distance from the point to the line segment\n */\nexport function getDistanceToLine(point: Point, line: LineSegment) {\n  const nearestPoint = findNearestPointOnLine(point, line);\n  return distance(point, nearestPoint);\n}\n\n/**\n * <zh/> 获取线段上距离给定点最近的点\n *\n * <en/> Get the point on the line segment closest to the given point\n * @param point - <zh/> 给定点 | <en/> the given point\n * @param line - <zh/> 线段 | <en/> the line segment\n * @returns <zh/> 线段上距离给定点最近的点 | <en/> the point on the line segment closest to the given point\n */\nexport function findNearestPointOnLine(point: Point, line: LineSegment): Point {\n  const [x1, y1] = line[0];\n  const [x2, y2] = line[1];\n  const [x3, y3] = point;\n\n  const px = x2 - x1;\n  const py = y2 - y1;\n\n  // 若线段实际上是一个点 | If the line segment is actually a point\n  if (px === 0 && py === 0) {\n    return [x1, y1];\n  }\n\n  let u = ((x3 - x1) * px + (y3 - y1) * py) / (px * px + py * py);\n\n  if (u > 1) {\n    u = 1;\n  } else if (u < 0) {\n    u = 0;\n  }\n\n  const x = x1 + u * px;\n  const y = y1 + u * py;\n\n  return [x, y];\n}\n\n/**\n * <zh/> 获取点集的中心点\n *\n * <en/> Get the center point of a set of points\n * @param points - <zh/> 点集 | <en/> point set\n * @returns <zh/> 中心点 | <en/> center point\n */\nexport function centerOf(points: Point[]): Point {\n  const totalPosition = points.reduce((acc, p) => add(acc, p), [0, 0]);\n  return divide(totalPosition, points.length);\n}\n\n/**\n * <zh/> 按顺时针或逆时针方向对点集排序\n *\n * <en/> Sort the point set in a clockwise or counterclockwise direction\n * @param points - <zh/> 点集 | <en/> point set\n * @param clockwise - <zh/> 是否顺时针 | <en/> whether clockwise\n * @returns <zh/> 排序后的点集 | <en/> sorted point set\n */\nexport function sortByClockwise(points: Point[], clockwise = true): Point[] {\n  const center = centerOf(points);\n  return points.sort(([x1, y1], [x2, y2]) => {\n    const angle1 = Math.atan2(y1 - center[1], x1 - center[0]);\n    const angle2 = Math.atan2(y2 - center[1], x2 - center[0]);\n    return clockwise ? angle2 - angle1 : angle1 - angle2;\n  });\n}\n\n/**\n * <zh/> 给定的起点和终点，返回一个由这两个点和它们的对角点组成的数组\n * @param start - <zh/> 起点 | <en/> start point\n * @param end - <zh/> 终点 | <en/> end point\n * @returns <zh/> 由这两个点和它们的对角点组成的数组 | <en/> an array consisting of these two points and their diagonal points\n */\nexport function getBoundingPoints(start: Point, end: Point): Point[] {\n  return [start, [start[0], end[1]], end, [end[0], start[1]]];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}