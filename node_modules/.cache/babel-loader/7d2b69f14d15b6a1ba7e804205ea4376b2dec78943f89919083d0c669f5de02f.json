{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Container } from '../utils/container';\nimport { angleWithQuadrant, angleBetween, dist, sub } from '../utils/vector';\nimport { inferColor, setAnimation, setStyle, toCell, setChildren, setData } from './facetRect';\nimport { useDefaultAdaptor } from './utils';\nconst setScale = useDefaultAdaptor(options => {\n  return {\n    scale: {\n      x: {\n        guide: {\n          type: 'axisArc'\n        },\n        paddingOuter: 0,\n        paddingInner: 0.1\n      },\n      y: {\n        guide: null,\n        range: [0, 1],\n        paddingOuter: 0,\n        paddingInner: 0.1\n      }\n    }\n  };\n});\nconst setCoordinate = useDefaultAdaptor(options => {\n  return {\n    coordinate: {\n      type: 'polar'\n    }\n  };\n});\nconst setEncode = options => {\n  const {\n      encode\n    } = options,\n    rest = __rest(options, [\"encode\"]);\n  const {\n    position\n  } = encode;\n  return Object.assign(Object.assign({}, rest), {\n    encode: {\n      x: position\n    }\n  });\n};\n/**\n * Every facet should do not show both axisX and axisY by default.\n */\nfunction createGuideFacetCircle(guide) {\n  return facet => null;\n}\n/**\n * Use the inscribed circle of the sector as the\n * circumscribed circle of the new bbox.\n */\nfunction subLayoutFacetCircle(data) {\n  const {\n    points\n  } = data;\n  const [p0, p1, p2, p3] = points;\n  const sr = dist(p0, p3); // radius of sector\n  const v0 = sub(p0, p3);\n  const v1 = sub(p1, p2);\n  const a01 = angleBetween(v0, v1);\n  // sr = ir + ir / sin(theta/2)\n  const t = 1 / Math.sin(a01 / 2);\n  const ir = sr / (1 + t); // radius of inscribed circle\n  const s = ir * Math.sqrt(2); // size of the bbox.\n  // This assume the innerRadius of polar is 0.\n  // @todo Compute the right origin if it's not 0,\n  // or maybe pass the coordinates to get the right center.\n  const [x0, y0] = p2;\n  const a0 = angleWithQuadrant(v0);\n  const a3 = a0 + a01 / 2;\n  const d = ir * t;\n  const cx = x0 + d * Math.sin(a3); // center x of inscribed circle\n  const cy = y0 - d * Math.cos(a3); // center y of inscribed circle\n  return [cx - s / 2, cy - s / 2, s, s];\n}\n/**\n * @todo Pack.\n */\nexport const FacetCircle = () => {\n  return options => {\n    const newOptions = Container.of(options).call(toCell).call(setEncode).call(inferColor).call(setCoordinate).call(setData).call(setChildren, subLayoutFacetCircle, createGuideFacetCircle, createGuideFacetCircle, {\n      frame: false\n    }).call(setAnimation).call(setStyle).call(setScale).value();\n    return [newOptions];\n  };\n};","map":{"version":3,"names":["Container","angleWithQuadrant","angleBetween","dist","sub","inferColor","setAnimation","setStyle","toCell","setChildren","setData","useDefaultAdaptor","setScale","options","scale","x","guide","type","paddingOuter","paddingInner","y","range","setCoordinate","coordinate","setEncode","encode","rest","__rest","position","Object","assign","createGuideFacetCircle","facet","subLayoutFacetCircle","data","points","p0","p1","p2","p3","sr","v0","v1","a01","t","Math","sin","ir","s","sqrt","x0","y0","a0","a3","d","cx","cy","cos","FacetCircle","newOptions","of","call","frame","value"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/composition/facetCircle.ts"],"sourcesContent":["import { CompositionComponent as CC, G2ViewTree } from '../runtime';\nimport { FacetCircleComposition } from '../spec';\nimport { Container } from '../utils/container';\nimport { angleWithQuadrant, angleBetween, dist, sub } from '../utils/vector';\nimport {\n  inferColor,\n  setAnimation,\n  setStyle,\n  toCell,\n  setChildren,\n  setData,\n} from './facetRect';\nimport { useDefaultAdaptor } from './utils';\n\nexport type FacetCircleOptions = Omit<FacetCircleComposition, 'type'>;\n\nconst setScale = useDefaultAdaptor<G2ViewTree>((options) => {\n  return {\n    scale: {\n      x: { guide: { type: 'axisArc' }, paddingOuter: 0, paddingInner: 0.1 },\n      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 },\n    },\n  };\n});\n\nconst setCoordinate = useDefaultAdaptor((options: G2ViewTree) => {\n  return {\n    coordinate: { type: 'polar' },\n  };\n});\n\nconst setEncode = (options) => {\n  const { encode, ...rest } = options;\n  const { position } = encode;\n  return {\n    ...rest,\n    encode: { x: position },\n  };\n};\n\n/**\n * Every facet should do not show both axisX and axisY by default.\n */\nfunction createGuideFacetCircle(guide) {\n  return (facet) => null;\n}\n\n/**\n * Use the inscribed circle of the sector as the\n * circumscribed circle of the new bbox.\n */\nfunction subLayoutFacetCircle(data) {\n  const { points } = data;\n  const [p0, p1, p2, p3] = points;\n\n  const sr = dist(p0, p3); // radius of sector\n  const v0 = sub(p0, p3);\n  const v1 = sub(p1, p2);\n  const a01 = angleBetween(v0, v1);\n\n  // sr = ir + ir / sin(theta/2)\n  const t = 1 / Math.sin(a01 / 2);\n  const ir = sr / (1 + t); // radius of inscribed circle\n  const s = ir * Math.sqrt(2); // size of the bbox.\n\n  // This assume the innerRadius of polar is 0.\n  // @todo Compute the right origin if it's not 0,\n  // or maybe pass the coordinates to get the right center.\n  const [x0, y0] = p2;\n  const a0 = angleWithQuadrant(v0);\n  const a3 = a0 + a01 / 2;\n  const d = ir * t;\n  const cx = x0 + d * Math.sin(a3); // center x of inscribed circle\n  const cy = y0 - d * Math.cos(a3); // center y of inscribed circle\n  return [cx - s / 2, cy - s / 2, s, s];\n}\n\n/**\n * @todo Pack.\n */\nexport const FacetCircle: CC<FacetCircleComposition> = () => {\n  return (options) => {\n    const newOptions = Container.of<G2ViewTree>(options)\n      .call(toCell)\n      .call(setEncode)\n      .call(inferColor)\n      .call(setCoordinate)\n      .call(setData)\n      .call(\n        setChildren,\n        subLayoutFacetCircle,\n        createGuideFacetCircle,\n        createGuideFacetCircle,\n        { frame: false },\n      )\n      .call(setAnimation)\n      .call(setStyle)\n      .call(setScale)\n      .value();\n    return [newOptions];\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}