{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport EventEmitter from '@antv/event-emitter';\nimport { debounce, isEqual, isFunction, isNumber, isObject, isString, omit } from '@antv/util';\nimport { COMBO_KEY, GraphEvent } from '../constants';\nimport { isCollapsed } from '../utils/collapsibility';\nimport { sizeOf } from '../utils/dom';\nimport { getSubgraphRelatedEdges } from '../utils/edge';\nimport { GraphLifeCycleEvent, emit } from '../utils/event';\nimport { idOf } from '../utils/id';\nimport { isPreLayout } from '../utils/layout';\nimport { format } from '../utils/print';\nimport { subtract } from '../utils/vector';\nimport { getZIndexOf } from '../utils/z-index';\nimport { Animation } from './animation';\nimport { BatchController } from './batch';\nimport { BehaviorController } from './behavior';\nimport { Canvas } from './canvas';\nimport { DataController } from './data';\nimport { ElementController } from './element';\nimport { LayoutController } from './layout';\nimport { inferOptions } from './options';\nimport { PluginController } from './plugin';\nimport { TransformController } from './transform';\nimport { ViewportController } from './viewport';\nexport class Graph extends EventEmitter {\n  constructor(options) {\n    var _a;\n    super();\n    this.options = {};\n    /**\n     * <zh/> 当前图实例是否已经渲染\n     *\n     * <en/> Whether the current graph instance has been rendered\n     */\n    this.rendered = false;\n    /**\n     * <zh/> 当前图实例是否已经被销毁\n     *\n     * <en/> Whether the current graph instance has been destroyed\n     */\n    this.destroyed = false;\n    // @ts-expect-error will be initialized in createRuntime\n    this.context = {\n      model: new DataController()\n    };\n    this.isCollapsingExpanding = false;\n    this.onResize = debounce(() => {\n      this.resize();\n    }, 300);\n    this._setOptions(Object.assign({}, Graph.defaultOptions, options), true);\n    this.context.graph = this;\n    // Listening resize to autoResize.\n    this.options.autoResize && ((_a = globalThis.addEventListener) === null || _a === void 0 ? void 0 : _a.call(globalThis, 'resize', this.onResize));\n  }\n  /**\n   * <zh/> 获取配置项\n   *\n   * <en/> Get options\n   * @returns <zh/> 配置项 | <en/> options\n   * @apiCategory option\n   */\n  getOptions() {\n    return this.options;\n  }\n  /**\n   * <zh/> 设置配置项\n   *\n   * <en/> Set options\n   * @param options - <zh/> 配置项 | <en/> options\n   * @remarks\n   * <zh/> 要更新 devicePixelRatio、container 属性请销毁后重新创建实例\n   *\n   * <en/> To update devicePixelRatio and container properties, please destroy and recreate the instance\n   * @apiCategory option\n   */\n  setOptions(options) {\n    this._setOptions(options, false);\n  }\n  _setOptions(options, isInit) {\n    this.updateCanvas(options);\n    Object.assign(this.options, inferOptions(options));\n    if (isInit) {\n      const {\n        data\n      } = options;\n      if (data) this.addData(data);\n      return;\n    }\n    const {\n      behaviors,\n      combo,\n      data,\n      edge,\n      layout,\n      node,\n      plugins,\n      theme,\n      transforms\n    } = options;\n    if (behaviors) this.setBehaviors(behaviors);\n    if (data) this.setData(data);\n    if (node) this.setNode(node);\n    if (edge) this.setEdge(edge);\n    if (combo) this.setCombo(combo);\n    if (layout) this.setLayout(layout);\n    if (theme) this.setTheme(theme);\n    if (plugins) this.setPlugins(plugins);\n    if (transforms) this.setTransforms(transforms);\n  }\n  /**\n   * <zh/> 获取当前画布容器的尺寸\n   *\n   * <en/> Get the size of the current canvas container\n   * @returns <zh/> 画布尺寸 | <en/> canvas size\n   * @apiCategory canvas\n   */\n  getSize() {\n    if (this.context.canvas) return this.context.canvas.getSize();\n    return [this.options.width || 0, this.options.height || 0];\n  }\n  /**\n   * <zh/> 设置当前画布容器的尺寸\n   *\n   * <en/> Set the size of the current canvas container\n   * @param width - <zh/> 画布宽度 | <en/> canvas width\n   * @param height - <zh/> 画布高度 | <en/> canvas height\n   * @apiCategory canvas\n   */\n  setSize(width, height) {\n    if (width) this.options.width = width;\n    if (height) this.options.height = height;\n    this.resize(width, height);\n  }\n  /**\n   * <zh/> 设置当前图的缩放区间\n   *\n   * <en/> Get the zoom range of the current graph\n   * @param zoomRange - <zh/> 缩放区间 | <en/> zoom range\n   * @apiCategory viewport\n   */\n  setZoomRange(zoomRange) {\n    this.options.zoomRange = zoomRange;\n  }\n  /**\n   * <zh/> 获取当前图的缩放区间\n   *\n   * <en/> Get the zoom range of the current graph\n   * @returns <zh/> 缩放区间 | <en/> zoom range\n   * @apiCategory viewport\n   */\n  getZoomRange() {\n    return this.options.zoomRange;\n  }\n  /**\n   * <zh/> 设置节点样式映射\n   *\n   * <en/> Set node mapper\n   * @param node - <zh/> 节点配置 | <en/> node options\n   * @remarks\n   * <zh/> 即 `options.node` 的值\n   *\n   * <en/> The value of `options.node`\n   * @apiCategory element\n   */\n  setNode(node) {\n    this.options.node = node;\n    this.context.model.refreshData();\n  }\n  /**\n   * <zh/> 设置边样式映射\n   *\n   * <en/> Set edge mapper\n   * @param edge - <zh/> 边配置 | <en/> edge options\n   * @remarks\n   * <zh/> 即 `options.edge` 的值\n   *\n   * <en/> The value of `options.edge`\n   * @apiCategory element\n   */\n  setEdge(edge) {\n    this.options.edge = edge;\n    this.context.model.refreshData();\n  }\n  /**\n   * <zh/> 设置组合样式映射\n   *\n   * <en/> Set combo mapper\n   * @param combo - <zh/> 组合配置 | <en/> combo options\n   * @remarks\n   * <zh/> 即 `options.combo` 的值\n   *\n   * <en/> The value of `options.combo`\n   * @apiCategory element\n   */\n  setCombo(combo) {\n    this.options.combo = combo;\n    this.context.model.refreshData();\n  }\n  /**\n   * <zh/> 获取主题\n   *\n   * <en/> Get theme\n   * @returns <zh/> 当前主题 | <en/> current theme\n   * @apiCategory theme\n   */\n  getTheme() {\n    return this.options.theme;\n  }\n  /**\n   * <zh/> 设置主题\n   *\n   * <en/> Set theme\n   * @param theme - <zh/> 主题名 | <en/> theme name\n   * @example\n   * ```ts\n   * graph.setTheme('dark');\n   * ```\n   * @apiCategory theme\n   */\n  setTheme(theme) {\n    this.options.theme = isFunction(theme) ? theme(this.getTheme()) : theme;\n  }\n  /**\n   * <zh/> 设置布局\n   *\n   * <en/> Set layout\n   * @param layout - <zh/> 布局配置 | <en/> layout options\n   * @example\n   * ```ts\n   * graph.setLayout({\n   *  type: 'dagre',\n   * })\n   * ```\n   * @apiCategory layout\n   */\n  setLayout(layout) {\n    this.options.layout = isFunction(layout) ? layout(this.getLayout()) : layout;\n  }\n  /**\n   * <zh/> 获取布局配置\n   *\n   * <en/> Get layout options\n   * @returns <zh/> 布局配置 | <en/> layout options\n   * @apiCategory layout\n   */\n  getLayout() {\n    return this.options.layout;\n  }\n  /**\n   * <zh/> 设置交互\n   *\n   * <en/> Set behaviors\n   * @param behaviors - <zh/> 交互配置 | <en/> behavior options\n   * @remarks\n   * <zh/> 设置的交互会全量替换原有的交互，如果需要新增交互可以使用如下方式：\n   *\n   * <en/> The set behavior will completely replace the original behavior. If you need to add behavior, you can use the following method:\n   *\n   * ```ts\n   * graph.setBehaviors((behaviors) => [...behaviors, { type: 'zoom-canvas' }])\n   * ```\n   * @apiCategory behavior\n   */\n  setBehaviors(behaviors) {\n    var _a;\n    this.options.behaviors = isFunction(behaviors) ? behaviors(this.getBehaviors()) : behaviors;\n    (_a = this.context.behavior) === null || _a === void 0 ? void 0 : _a.setBehaviors(this.options.behaviors);\n  }\n  /**\n   * <zh/> 更新指定的交互配置\n   *\n   * <en/> Update specified behavior options\n   * @param behavior - <zh/> 交互配置 | <en/> behavior options\n   * @remarks\n   * <zh/> 如果要更新一个交互，那么必须在交互配置中指定 key 字段，例如：\n   *\n   * <en/> If you want to update a behavior, you must specify the key field in the behavior options, for example:\n   * ```ts\n   * {\n   *   behaviors: [{ type: 'zoom-canvas', key: 'zoom-canvas' }]\n   * }\n   *\n   * graph.updateBehavior({ key: 'zoom-canvas', enable: false })\n   * ```\n   * @apiCategory behavior\n   */\n  updateBehavior(behavior) {\n    this.setBehaviors(behaviors => behaviors.map(_behavior => {\n      if (typeof _behavior === 'object' && _behavior.key === behavior.key) {\n        return Object.assign(Object.assign({}, _behavior), behavior);\n      }\n      return _behavior;\n    }));\n  }\n  /**\n   * <zh/> 获取交互配置\n   *\n   * <en/> Get behaviors options\n   * @returns <zh/> 交互配置 | <en/> behavior options\n   * @apiCategory behavior\n   */\n  getBehaviors() {\n    return this.options.behaviors || [];\n  }\n  /**\n   * <zh/> 设置插件配置\n   *\n   * <en/> Set plugins options\n   * @param plugins - <zh/> 插件配置 | <en/> plugin options\n   * @remarks\n   * <zh/> 设置的插件会全量替换原有的插件配置，如果需要新增插件可以使用如下方式：\n   *\n   * <en/> The set plugin will completely replace the original plugin configuration. If you need to add a plugin, you can use the following method:\n   * ```ts\n   * graph.setPlugins((plugins) => [...plugins, { key: 'grid-line' }])\n   * ```\n   * @apiCategory plugin\n   */\n  setPlugins(plugins) {\n    var _a;\n    this.options.plugins = isFunction(plugins) ? plugins(this.getPlugins()) : plugins;\n    (_a = this.context.plugin) === null || _a === void 0 ? void 0 : _a.setPlugins(this.options.plugins);\n  }\n  /**\n   * <zh/> 更新插件配置\n   *\n   * <en/> Update plugin options\n   * @param plugin - <zh/> 插件配置 | <en/> plugin options\n   * @remarks\n   * <zh/> 如果要更新一个插件，那么必须在插件配置中指定 key 字段，例如：\n   *\n   * <en/> If you want to update a plugin, you must specify the key field in the plugin options, for example:\n   * ```ts\n   * {\n   *   plugins: [{ key: 'grid-line' }]\n   * }\n   *\n   * graph.updatePlugin({ key: 'grid-line', follow: true })\n   * ```\n   * @apiCategory plugin\n   */\n  updatePlugin(plugin) {\n    this.setPlugins(plugins => plugins.map(_plugin => {\n      if (typeof _plugin === 'object' && _plugin.key === plugin.key) {\n        return Object.assign(Object.assign({}, _plugin), plugin);\n      }\n      return _plugin;\n    }));\n  }\n  /**\n   * <zh/> 获取插件配置\n   *\n   * <en/> Get plugins options\n   * @returns <zh/> 插件配置 | <en/> plugin options\n   * @apiCategory plugin\n   */\n  getPlugins() {\n    return this.options.plugins || [];\n  }\n  /**\n   * <zh/> 获取插件实例\n   *\n   * <en/> Get plugin instance\n   * @param key - <zh/> 插件 key（在配置 plugin 时需要手动传入指定） | <en/> plugin key(need to be specified manually when configuring plugin)\n   * @returns <zh/> 插件实例 | <en/> plugin instance\n   * @remarks\n   * <zh/> 一些插件提供了 API 方法可供调用，例如全屏插件可以调用 `request` 和 `exit` 方法来请求和退出全屏\n   *\n   * <en/> Some plugins provide API methods for calling, such as the full-screen plugin can call the `request` and `exit` methods to request and exit full-screen\n   * ```ts\n   * const fullscreen = graph.getPluginInstance('fullscreen');\n   *\n   * fullscreen.request();\n   *\n   * fullscreen.exit();\n   * ```\n   * @apiCategory plugin\n   */\n  getPluginInstance(key) {\n    return this.context.plugin.getPluginInstance(key);\n  }\n  /**\n   * <zh/> 设置数据转换器\n   *\n   * <en/> Set data transforms\n   * @param transforms - <zh/> 数据转换配置 | <en/> data transform options\n   * @remarks\n   * <zh/> 数据转换器能够在图渲染过程中执行数据转换，目前支持在渲染前对绘制数据进行转化。\n   *\n   * <en/> Data transforms can perform data transformation during the rendering process of the graph. Currently, it supports transforming the drawing data before rendering.\n   * @apiCategory transform\n   */\n  setTransforms(transforms) {\n    var _a;\n    this.options.transforms = isFunction(transforms) ? transforms(this.getTransforms()) : transforms;\n    (_a = this.context.transform) === null || _a === void 0 ? void 0 : _a.setTransforms(this.options.transforms);\n  }\n  /**\n   * <zh/> 更新数据转换器\n   *\n   * <en/> Update data transform\n   * @param transform - <zh/> 数据转换器配置 | <en/> data transform options\n   * @apiCategory transform\n   */\n  updateTransform(transform) {\n    this.setTransforms(transforms => transforms.map(_transform => {\n      if (typeof _transform === 'object' && _transform.key === transform.key) {\n        return Object.assign(Object.assign({}, _transform), transform);\n      }\n      return _transform;\n    }));\n    this.context.model.refreshData();\n  }\n  /**\n   * <zh/> 获取数据转换器配置\n   *\n   * <en/> Get data transforms options\n   * @returns <zh/> 数据转换配置 | <en/> data transform options\n   * @apiCategory transform\n   */\n  getTransforms() {\n    return this.options.transforms || [];\n  }\n  /**\n   * <zh/> 获取图数据\n   *\n   * <en/> Get graph data\n   * @returns <zh/> 图数据 | <en/> Graph data\n   * <zh/> 获取当前图的数据，包括节点、边、组合数据\n   *\n   * <en/> Get the data of the current graph, including node, edge, and combo data\n   * @apiCategory data\n   */\n  getData() {\n    return this.context.model.getData();\n  }\n  getElementData(ids) {\n    if (Array.isArray(ids)) return ids.map(id => this.context.model.getElementDataById(id));\n    return this.context.model.getElementDataById(ids);\n  }\n  getNodeData(id) {\n    if (id === undefined) return this.context.model.getNodeData();\n    if (Array.isArray(id)) return this.context.model.getNodeData(id);\n    return this.context.model.getNodeLikeDatum(id);\n  }\n  getEdgeData(id) {\n    if (id === undefined) return this.context.model.getEdgeData();\n    if (Array.isArray(id)) return this.context.model.getEdgeData(id);\n    return this.context.model.getEdgeDatum(id);\n  }\n  getComboData(id) {\n    if (id === undefined) return this.context.model.getComboData();\n    if (Array.isArray(id)) return this.context.model.getComboData(id);\n    return this.context.model.getNodeLikeDatum(id);\n  }\n  /**\n   * <zh/> 设置全量数据\n   *\n   * <en/> Set full data\n   * @param data - <zh/> 数据 | <en/> data\n   * @remarks\n   * <zh/> 设置全量数据会替换当前图中的所有数据，G6 会自动进行数据差异计算\n   *\n   * <en/> Setting full data will replace all data in the current graph, and G6 will automatically calculate the data difference\n   * @apiCategory data\n   */\n  setData(data) {\n    this.context.model.setData(isFunction(data) ? data(this.getData()) : data);\n  }\n  /**\n   * <zh/> 新增元素数据\n   *\n   * <en/> Add element data\n   * @param data - <zh/> 元素数据 | <en/> element data\n   * @example\n   * ```ts\n   * graph.addData({\n   *  nodes: [{ id: 'node-1' }, { id: 'node-2' }],\n   *  edges: [{ source: 'node-1', target: 'node-2' }],\n   * });\n   * ```\n   * @apiCategory data\n   */\n  addData(data) {\n    this.context.model.addData(isFunction(data) ? data(this.getData()) : data);\n  }\n  /**\n   * <zh/> 新增节点数据\n   *\n   * <en/> Add node data\n   * @param data - <zh/> 节点数据 | <en/> node data\n   * @example\n   * ```ts\n   * graph.addNodeData([{ id: 'node-1' }, { id: 'node-2' }]);\n   * ```\n   * @apiCategory data\n   */\n  addNodeData(data) {\n    this.context.model.addNodeData(isFunction(data) ? data(this.getNodeData()) : data);\n  }\n  /**\n   * <zh/> 新增边数据\n   *\n   * <en/> Add edge data\n   * @param data - <zh/> 边数据 | <en/> edge data\n   * @example\n   * ```ts\n   * graph.addEdgeData([{ source: 'node-1', target: 'node-2' }]);\n   * ```\n   * @apiCategory data\n   */\n  addEdgeData(data) {\n    this.context.model.addEdgeData(isFunction(data) ? data(this.getEdgeData()) : data);\n  }\n  /**\n   * <zh/> 新增组合数据\n   *\n   * <en/> Add combo data\n   * @param data - <zh/> 组合数据 | <en/> combo data\n   * @example\n   * ```ts\n   * graph.addComboData([{ id: 'combo-1' }]);\n   * ```\n   * @apiCategory data\n   */\n  addComboData(data) {\n    this.context.model.addComboData(isFunction(data) ? data(this.getComboData()) : data);\n  }\n  /**\n   * <zh/> 为树图节点添加子节点数据\n   *\n   * <en/> Add child node data to the tree node\n   * @param parentId - <zh/> 父节点 ID | <en/> parent node ID\n   * @param childrenData - <zh/> 子节点数据 | <en/> child node data\n   * @remarks\n   * <zh/> 为组合添加子节点使用 addNodeData / addComboData 方法\n   *\n   * <en/> Use addNodeData / addComboData method to add child nodes to the combo\n   * @apiCategory data\n   */\n  addChildrenData(parentId, childrenData) {\n    this.context.model.addChildrenData(parentId, childrenData);\n  }\n  /**\n   * <zh/> 更新元素数据\n   *\n   * <en/> Update element data\n   * @param data - <zh/> 元素数据 | <en/> element data\n   * @remarks\n   * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据\n   *\n   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data\n   * @example\n   * ```ts\n   * graph.updateData({\n   *   nodes: [{ id: 'node-1', style: { x: 100, y: 100 } }],\n   *   edges: [{ id: 'edge-1', style: { lineWidth: 2 } }]\n   * });\n   * ```\n   * @apiCategory data\n   */\n  updateData(data) {\n    this.context.model.updateData(isFunction(data) ? data(this.getData()) : data);\n  }\n  /**\n   * <zh/> 更新节点数据\n   *\n   * <en/> Update node data\n   * @param data - <zh/> 节点数据 | <en/> node data\n   * @remarks\n   * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据\n   *\n   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data\n   * @example\n   * ```ts\n   * graph.updateNodeData([{ id: 'node-1', style: { x: 100, y: 100 } }]);\n   * ```\n   * @apiCategory data\n   */\n  updateNodeData(data) {\n    this.context.model.updateNodeData(isFunction(data) ? data(this.getNodeData()) : data);\n  }\n  /**\n   * <zh/> 更新边数据\n   *\n   * <en/> Update edge data\n   * @param data - <zh/> 边数据 | <en/> edge data\n   * @remarks\n   * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据\n   *\n   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data\n   * @example\n   * ```ts\n   * graph.updateEdgeData([{ id: 'edge-1', style: { lineWidth: 2 } }]);\n   * ```\n   * @apiCategory data\n   */\n  updateEdgeData(data) {\n    this.context.model.updateEdgeData(isFunction(data) ? data(this.getEdgeData()) : data);\n  }\n  /**\n   * <zh/> 更新组合数据\n   *\n   * <en/> Update combo data\n   * @param data - <zh/> 组合数据 | <en/> combo data\n   * @remarks\n   * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据\n   *\n   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data\n   * @example\n   * ```ts\n   * graph.updateComboData([{ id: 'combo-1', style: { x: 100, y: 100 } }]);\n   * ```\n   * @apiCategory data\n   */\n  updateComboData(data) {\n    this.context.model.updateComboData(isFunction(data) ? data(this.getComboData()) : data);\n  }\n  /**\n   * <zh/> 删除元素数据\n   *\n   * <en/> Remove element data\n   * @param ids - <zh/> 元素 ID 数组 | <en/> element ID array\n   * @example\n   * ```ts\n   * graph.removeData({\n   *   nodes: ['node-1', 'node-2'],\n   *   edges: ['edge-1'],\n   * });\n   * ```\n   * @apiCategory data\n   */\n  removeData(ids) {\n    this.context.model.removeData(isFunction(ids) ? ids(this.getData()) : ids);\n  }\n  /**\n   * <zh/> 删除节点数据\n   *\n   * <en/> Remove node data\n   * @param ids - <zh/> 节点 ID 数组 | <en/> node ID array\n   * @example\n   * ```ts\n   * graph.removeNodeData(['node-1', 'node-2']);\n   * ```\n   * @apiCategory data\n   */\n  removeNodeData(ids) {\n    this.context.model.removeNodeData(isFunction(ids) ? ids(this.getNodeData()) : ids);\n  }\n  /**\n   * <zh/> 删除边数据\n   *\n   * <en/> Remove edge data\n   * @param ids - <zh/> 边 ID 数组 | <en/> edge ID array\n   * @remarks\n   * <zh/> 如果传入边数据时仅提供了 source 和 target，那么需要通过 `idOf` 方法获取边的实际 ID\n   *\n   * <en/> If only the source and target are provided when passing in the edge data, you need to get the actual ID of the edge through the `idOf` method\n   * @example\n   * ```ts\n   * graph.removeEdgeData(['edge-1']);\n   * ```\n   * @apiCategory data\n   */\n  removeEdgeData(ids) {\n    this.context.model.removeEdgeData(isFunction(ids) ? ids(this.getEdgeData()) : ids);\n  }\n  /**\n   * <zh/> 删除组合数据\n   *\n   * <en/> Remove combo data\n   * @param ids - <zh/> 组合 ID 数组 | <en/> 组合 ID array\n   * @example\n   * ```ts\n   * graph.removeComboData(['combo-1']);\n   * ```\n   * @apiCategory data\n   */\n  removeComboData(ids) {\n    this.context.model.removeComboData(isFunction(ids) ? ids(this.getComboData()) : ids);\n  }\n  /**\n   * <zh/> 获取元素类型\n   *\n   * <en/> Get element type\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素类型 | <en/> element type\n   * @apiCategory element\n   */\n  getElementType(id) {\n    return this.context.model.getElementType(id);\n  }\n  /**\n   * <zh/> 获取节点或组合关联边的数据\n   *\n   * <en/> Get edge data related to the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @param direction - <zh/> 边的方向 | <en/> edge direction\n   * @returns <zh/> 边数据 | <en/> edge data\n   * @apiCategory data\n   */\n  getRelatedEdgesData(id, direction = 'both') {\n    return this.context.model.getRelatedEdgesData(id, direction);\n  }\n  /**\n   * <zh/> 获取节点或组合的一跳邻居节点数据\n   *\n   * <en/> Get the one-hop neighbor node data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @returns <zh/> 邻居节点数据 | <en/> neighbor node data\n   * @apiCategory data\n   */\n  getNeighborNodesData(id) {\n    return this.context.model.getNeighborNodesData(id);\n  }\n  /**\n   * <zh/> 获取节点或组合的祖先元素数据\n   *\n   * <en/> Get the ancestor element data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @param hierarchy - <zh/> 指定树图层级关系还是组合层级关系 | <en/> specify tree or combo hierarchy relationship\n   * @returns <zh/> 祖先元素数据 | <en/> ancestor element data\n   * @remarks\n   * <zh/> 数组中的顺序是从父节点到祖先节点\n   *\n   * <en/> The order in the array is from the parent node to the ancestor node\n   * @apiCategory data\n   */\n  getAncestorsData(id, hierarchy) {\n    return this.context.model.getAncestorsData(id, hierarchy);\n  }\n  /**\n   * <zh/> 获取节点或组合的父元素数据\n   *\n   * <en/> Get the parent element data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @param hierarchy - <zh/> 指定树图层级关系还是组合层级关系 | <en/> specify tree or combo hierarchy relationship\n   * @returns <zh/> 父元素数据 | <en/> parent element data\n   * @apiCategory data\n   */\n  getParentData(id, hierarchy) {\n    return this.context.model.getParentData(id, hierarchy);\n  }\n  /**\n   * <zh/> 获取节点或组合的子元素数据\n   *\n   * <en/> Get the child element data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @returns <zh/> 子元素数据 | <en/> child element data\n   * @apiCategory data\n   */\n  getChildrenData(id) {\n    return this.context.model.getChildrenData(id);\n  }\n  /**\n   * <zh/> 获取节点或组合的后代元素数据\n   *\n   * <en/> Get the descendant element data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @returns <zh/> 后代元素数据 | <en/> descendant element data\n   * @apiCategory data\n   */\n  getDescendantsData(id) {\n    return this.context.model.getDescendantsData(id);\n  }\n  getElementDataByState(elementType, state) {\n    return this.context.model.getElementDataByState(elementType, state);\n  }\n  initCanvas() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (this.context.canvas) return yield this.context.canvas.ready;\n      const {\n        container = 'container',\n        width,\n        height,\n        renderer,\n        cursor,\n        background,\n        canvas: canvasOptions,\n        devicePixelRatio = (_a = globalThis.devicePixelRatio) !== null && _a !== void 0 ? _a : 1\n      } = this.options;\n      if (container instanceof Canvas) {\n        this.context.canvas = container;\n        if (cursor) container.setCursor(cursor);\n        if (renderer) container.setRenderer(renderer);\n        yield container.ready;\n      } else {\n        const $container = isString(container) ? document.getElementById(container) : container;\n        const containerSize = sizeOf($container);\n        this.emit(GraphEvent.BEFORE_CANVAS_INIT, {\n          container: $container,\n          width,\n          height\n        });\n        const options = Object.assign(Object.assign({}, canvasOptions), {\n          container: $container,\n          width: width || containerSize[0],\n          height: height || containerSize[1],\n          background,\n          renderer,\n          cursor,\n          devicePixelRatio\n        });\n        const canvas = new Canvas(options);\n        this.context.canvas = canvas;\n        yield canvas.ready;\n        this.emit(GraphEvent.AFTER_CANVAS_INIT, {\n          canvas\n        });\n      }\n    });\n  }\n  updateCanvas(options) {\n    var _a, _b;\n    const {\n      renderer,\n      cursor,\n      height,\n      width\n    } = options;\n    const canvas = this.context.canvas;\n    if (!canvas) return;\n    if (renderer) {\n      this.emit(GraphEvent.BEFORE_RENDERER_CHANGE, {\n        renderer: this.options.renderer\n      });\n      canvas.setRenderer(renderer);\n      this.emit(GraphEvent.AFTER_RENDERER_CHANGE, {\n        renderer\n      });\n    }\n    if (cursor) canvas.setCursor(cursor);\n    if (isNumber(width) || isNumber(height)) this.setSize((_a = width !== null && width !== void 0 ? width : this.options.width) !== null && _a !== void 0 ? _a : 0, (_b = height !== null && height !== void 0 ? height : this.options.height) !== null && _b !== void 0 ? _b : 0);\n  }\n  initRuntime() {\n    this.context.options = this.options;\n    if (!this.context.batch) this.context.batch = new BatchController(this.context);\n    if (!this.context.plugin) this.context.plugin = new PluginController(this.context);\n    if (!this.context.viewport) this.context.viewport = new ViewportController(this.context);\n    if (!this.context.transform) this.context.transform = new TransformController(this.context);\n    if (!this.context.element) this.context.element = new ElementController(this.context);\n    if (!this.context.animation) this.context.animation = new Animation(this.context);\n    if (!this.context.layout) this.context.layout = new LayoutController(this.context);\n    if (!this.context.behavior) this.context.behavior = new BehaviorController(this.context);\n  }\n  prepare() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // 等待同步任务执行完成，避免 render 后立即调用 destroy 导致的问题\n      // Wait for synchronous tasks to complete, to avoid problems caused by calling destroy immediately after render\n      yield Promise.resolve();\n      if (this.destroyed) {\n        // 如果图实例已经被销毁，则不再执行任何操作\n        // If the graph instance has been destroyed, no further operations will be performed\n        // eslint-disable-next-line no-console\n        console.error(format('The graph instance has been destroyed'));\n        return;\n      }\n      yield this.initCanvas();\n      this.initRuntime();\n    });\n  }\n  /**\n   * <zh/> 执行渲染\n   *\n   * <en/> Render\n   * @remarks\n   * <zh/> 此过程会执行数据更新、绘制元素、执行布局\n   *\n   * > ⚠️ render 为异步方法，如果需要在 render 后执行一些操作，可以使用 `await graph.render()` 或者监听 GraphEvent.AFTER_RENDER 事件\n   *\n   * <en/> This process will execute data update, element rendering, and layout execution\n   *\n   * > ⚠️ render is an asynchronous method. If you need to perform some operations after render, you can use `await graph.render()` or listen to the GraphEvent.AFTER_RENDER event\n   * @apiCategory render\n   */\n  render() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.prepare();\n      emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_RENDER));\n      if (!this.options.layout) {\n        const animation = this.context.element.draw({\n          type: 'render'\n        });\n        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.autoFit()]);\n      } else if (!this.rendered && isPreLayout(this.options.layout)) {\n        const animation = yield this.context.element.preLayoutDraw({\n          type: 'render'\n        });\n        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.autoFit()]);\n      } else {\n        const animation = this.context.element.draw({\n          type: 'render'\n        });\n        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.context.layout.postLayout()]);\n        yield this.autoFit();\n      }\n      this.rendered = true;\n      emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_RENDER));\n    });\n  }\n  /**\n   * <zh/> 绘制元素\n   *\n   * <en/> Draw elements\n   * @returns <zh/> 渲染结果 | <en/> draw result\n   * @remarks\n   * <zh/> 仅执行元素绘制，不会重新布局\n   *\n   * <zh/> ⚠️ draw 为异步方法，如果需要在 draw 后执行一些操作，可以使用 `await graph.draw()` 或者监听 GraphEvent.AFTER_DRAW 事件\n   *\n   * <en/> Only execute element drawing, no re-layout\n   *\n   * <en/> ⚠️ draw is an asynchronous method. If you need to perform some operations after draw, you can use `await graph.draw()` or listen to the GraphEvent.AFTER_DRAW event\n   * @apiCategory render\n   */\n  draw() {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield this.prepare();\n      yield (_a = this.context.element.draw()) === null || _a === void 0 ? void 0 : _a.finished;\n    });\n  }\n  /**\n   * <zh/> 执行布局\n   *\n   * <en/> Execute layout\n   * @param layoutOptions - <zh/> 布局配置项 | <en/> Layout options\n   * @apiCategory layout\n   */\n  layout(layoutOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.context.layout.postLayout(layoutOptions);\n    });\n  }\n  /**\n   * <zh/> 停止布局\n   *\n   * <en/> Stop layout\n   * @remarks\n   * <zh/> 适用于带有迭代动画的布局，目前有 `force` 属于此类布局，即停止力导布局的迭代，一般用于布局迭代时间过长情况下的手动停止迭代动画，例如在点击画布/节点的监听中调用\n   *\n   * <en/> Suitable for layouts with iterative animations. Currently, `force` belongs to this type of layout, that is, stop the iteration of the force-directed layout. It is generally used to manually stop the iteration animation when the layout iteration time is too long, such as calling in the click canvas/node listener\n   * @apiCategory layout\n   */\n  stopLayout() {\n    this.context.layout.stopLayout();\n  }\n  /**\n   * <zh/> 清空画布元素\n   *\n   * <en/> Clear canvas elements\n   * @apiCategory canvas\n   */\n  clear() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        model,\n        element\n      } = this.context;\n      model.setData({});\n      model.clearChanges();\n      element === null || element === void 0 ? void 0 : element.clear();\n    });\n  }\n  /**\n   * <zh/> 销毁当前图实例\n   *\n   * <en/> Destroy the current graph instance\n   * @remarks\n   * <zh/> 销毁后无法进行任何操作，如果需要重新使用，需要重新创建一个新的图实例\n   *\n   * <en/> After destruction, no operations can be performed. If you need to reuse it, you need to create a new graph instance\n   * @apiCategory instance\n   */\n  destroy() {\n    var _a;\n    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_DESTROY));\n    const {\n      layout,\n      animation,\n      element,\n      model,\n      canvas,\n      behavior,\n      plugin\n    } = this.context;\n    plugin === null || plugin === void 0 ? void 0 : plugin.destroy();\n    behavior === null || behavior === void 0 ? void 0 : behavior.destroy();\n    layout === null || layout === void 0 ? void 0 : layout.destroy();\n    animation === null || animation === void 0 ? void 0 : animation.destroy();\n    element === null || element === void 0 ? void 0 : element.destroy();\n    model.destroy();\n    canvas === null || canvas === void 0 ? void 0 : canvas.destroy();\n    this.options = {};\n    // @ts-expect-error force delete\n    this.context = {};\n    this.off();\n    (_a = globalThis.removeEventListener) === null || _a === void 0 ? void 0 : _a.call(globalThis, 'resize', this.onResize);\n    this.destroyed = true;\n    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_DESTROY));\n  }\n  /**\n   * <zh/> 获取画布实例\n   *\n   * <en/> Get canvas instance\n   * @returns - <zh/> 画布实例 | <en/> canvas instance\n   * @apiCategory canvas\n   */\n  getCanvas() {\n    return this.context.canvas;\n  }\n  resize(width, height) {\n    var _a;\n    const containerSize = sizeOf((_a = this.context.canvas) === null || _a === void 0 ? void 0 : _a.getContainer());\n    const specificSize = [width || containerSize[0], height || containerSize[1]];\n    if (!this.context.canvas) return;\n    const canvasSize = this.context.canvas.getSize();\n    if (isEqual(specificSize, canvasSize)) return;\n    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_SIZE_CHANGE, {\n      size: specificSize\n    }));\n    this.context.canvas.resize(...specificSize);\n    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_SIZE_CHANGE, {\n      size: specificSize\n    }));\n  }\n  /**\n   * <zh/> 将图缩放至合适大小并平移至视口中心\n   *\n   * <en/> Zoom the graph to fit the viewport and move it to the center of the viewport\n   * @param options - <zh/> 适配配置 | <en/> fit options\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory viewport\n   */\n  fitView(options, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.context.viewport) === null || _a === void 0 ? void 0 : _a.fitView(options, animation);\n    });\n  }\n  /**\n   * <zh/> 将图平移至视口中心\n   *\n   * <en/> Move the graph to the center of the viewport\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory viewport\n   */\n  fitCenter(animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.context.viewport) === null || _a === void 0 ? void 0 : _a.fitCenter({\n        animation\n      });\n    });\n  }\n  autoFit() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        autoFit\n      } = this.context.options;\n      if (!autoFit) return;\n      if (isString(autoFit)) {\n        if (autoFit === 'view') yield this.fitView();else if (autoFit === 'center') yield this.fitCenter();\n      } else {\n        const {\n          type,\n          animation\n        } = autoFit;\n        if (type === 'view') yield this.fitView(autoFit.options, animation);else if (type === 'center') yield this.fitCenter(animation);\n      }\n    });\n  }\n  /**\n   * <zh/> 聚焦元素\n   *\n   * <en/> Focus on element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @remarks\n   * <zh/> 移动图，使得元素对齐到视口中心\n   *\n   * <en/> Move the graph so that the element is aligned to the center of the viewport\n   * @apiCategory viewport\n   */\n  focusElement(id, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      yield (_a = this.context.viewport) === null || _a === void 0 ? void 0 : _a.focusElements(Array.isArray(id) ? id : [id], {\n        animation\n      });\n    });\n  }\n  /**\n   * <zh/> 基于当前缩放比例进行缩放（相对缩放）\n   *\n   * <en/> Zoom based on the current zoom ratio (relative zoom)\n   * @param ratio - <zh/> 缩放比例 | <en/> zoom ratio\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @param origin - <zh/> 缩放中心(视口坐标) | <en/> zoom center(viewport coordinates)\n   * @remarks\n   * <zh/>\n   * - ratio > 1 放大\n   * - ratio < 1 缩小\n   *\n   * <en/>\n   * - ratio > 1 zoom in\n   * - ratio < 1 zoom out\n   * @apiCategory viewport\n   */\n  zoomBy(ratio, animation, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.context.viewport.transform({\n        mode: 'relative',\n        scale: ratio,\n        origin\n      }, animation);\n    });\n  }\n  /**\n   * <zh/> 缩放画布至指定比例（绝对缩放）\n   *\n   * <en/> Zoom the canvas to the specified ratio (absolute zoom)\n   * @param zoom - <zh/> 指定缩放比例 | <en/> specified zoom ratio\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @param origin - <zh/> 缩放中心(视口坐标) | <en/> zoom center(viewport coordinates)\n   * @remarks\n   * <zh/>\n   * - zoom = 1 默认大小\n   * - zoom > 1 放大\n   * - zoom < 1 缩小\n   *\n   * <en/>\n   * - zoom = 1 default size\n   * - zoom > 1 zoom in\n   * - zoom < 1 zoom out\n   * @apiCategory viewport\n   */\n  zoomTo(zoom, animation, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.context.viewport.transform({\n        mode: 'absolute',\n        scale: zoom,\n        origin\n      }, animation);\n    });\n  }\n  /**\n   * <zh/> 获取当前缩放比例\n   *\n   * <en/> Get the current zoom ratio\n   * @returns <zh/> 缩放比例 | <en/> zoom ratio\n   * @apiCategory viewport\n   */\n  getZoom() {\n    return this.context.viewport.getZoom();\n  }\n  /**\n   * <zh/> 基于当前旋转角度进行旋转（相对旋转）\n   *\n   * <en/> Rotate based on the current rotation angle (relative rotation)\n   * @param angle - <zh/> 旋转角度 | <en/> rotation angle\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @param origin - <zh/> 旋转中心(视口坐标) | <en/> rotation center(viewport coordinates)\n   * @apiCategory viewport\n   */\n  rotateBy(angle, animation, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.context.viewport.transform({\n        mode: 'relative',\n        rotate: angle,\n        origin\n      }, animation);\n    });\n  }\n  /**\n   * <zh/> 旋转画布至指定角度 (绝对旋转)\n   *\n   * <en/> Rotate the canvas to the specified angle (absolute rotation)\n   * @param angle - <zh/> 目标角度 | <en/> target angle\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @param origin - <zh/> 旋转中心(视口坐标) | <en/> rotation center(viewport coordinates)\n   * @apiCategory viewport\n   */\n  rotateTo(angle, animation, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.context.viewport.transform({\n        mode: 'absolute',\n        rotate: angle,\n        origin\n      }, animation);\n    });\n  }\n  /**\n   * <zh/> 获取当前旋转角度\n   *\n   * <en/> Get the current rotation angle\n   * @returns <zh/> 旋转角度 | <en/> rotation angle\n   * @apiCategory viewport\n   */\n  getRotation() {\n    return this.context.viewport.getRotation();\n  }\n  /**\n   * <zh/> 将图平移指定距离 (相对平移)\n   *\n   * <en/> Translate the graph by the specified distance (relative translation)\n   * @param offset - <zh/> 偏移量 | <en/> offset\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory viewport\n   */\n  translateBy(offset, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.context.viewport.transform({\n        mode: 'relative',\n        translate: offset\n      }, animation);\n    });\n  }\n  /**\n   * <zh/> 将图平移至指定位置 (绝对平移)\n   *\n   * <en/> Translate the graph to the specified position (absolute translation)\n   * @param position - <zh/> 指定位置 | <en/> specified position\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory viewport\n   */\n  translateTo(position, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.context.viewport.transform({\n        mode: 'absolute',\n        translate: position\n      }, animation);\n    });\n  }\n  /**\n   * <zh/> 获取图的位置\n   *\n   * <en/> Get the position of the graph\n   * @returns <zh/> 图的位置 | <en/> position of the graph\n   * @remarks\n   * <zh/> 即画布原点在视口坐标系下的位置。默认状态下，图的位置为 [0, 0]\n   *\n   * <en/> That is, the position of the canvas origin in the viewport coordinate system. By default, the position of the graph is [0, 0]\n   * @apiCategory viewport\n   */\n  getPosition() {\n    return subtract([0, 0], this.getCanvasByViewport([0, 0]));\n  }\n  translateElementBy(args1_1, args2_1) {\n    return __awaiter(this, arguments, void 0, function* (args1, args2, args3 = true) {\n      var _a, _b;\n      const [config, animation] = isObject(args1) ? [args1, (_a = args2) !== null && _a !== void 0 ? _a : true] : [{\n        [args1]: args2\n      }, args3];\n      Object.entries(config).forEach(([id, offset]) => this.context.model.translateNodeLikeBy(id, offset));\n      yield (_b = this.context.element.draw({\n        animation,\n        stage: 'translate'\n      })) === null || _b === void 0 ? void 0 : _b.finished;\n    });\n  }\n  translateElementTo(args1_1, args2_1) {\n    return __awaiter(this, arguments, void 0, function* (args1, args2, args3 = true) {\n      var _a, _b;\n      const [config, animation] = isObject(args1) ? [args1, (_a = args2) !== null && _a !== void 0 ? _a : true] : [{\n        [args1]: args2\n      }, args3];\n      Object.entries(config).forEach(([id, position]) => this.context.model.translateNodeLikeTo(id, position));\n      yield (_b = this.context.element.draw({\n        animation,\n        stage: 'translate'\n      })) === null || _b === void 0 ? void 0 : _b.finished;\n    });\n  }\n  /**\n   * <zh/> 获取元素位置\n   *\n   * <en/> Get element position\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素位置 | <en/> element position\n   * @apiCategory element\n   */\n  getElementPosition(id) {\n    return this.context.model.getElementPosition(id);\n  }\n  /**\n   * <zh/> 获取元素渲染样式\n   *\n   * <en/> Get element rendering style\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素渲染样式 | <en/> element rendering style\n   * @apiCategory element\n   */\n  getElementRenderStyle(id) {\n    return omit(this.context.element.getElement(id).attributes, ['context']);\n  }\n  setElementVisibility(args1_1, args2_1) {\n    return __awaiter(this, arguments, void 0, function* (args1, args2, args3 = true) {\n      var _a, _b;\n      const [config, animation] = isObject(args1) ? [args1, (_a = args2) !== null && _a !== void 0 ? _a : true] : [{\n        [args1]: args2\n      }, args3];\n      const dataToUpdate = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      Object.entries(config).forEach(([id, value]) => {\n        const elementType = this.getElementType(id);\n        dataToUpdate[`${elementType}s`].push({\n          id,\n          style: {\n            visibility: value\n          }\n        });\n      });\n      const {\n        model,\n        element\n      } = this.context;\n      model.preventUpdateNodeLikeHierarchy(() => {\n        model.updateData(dataToUpdate);\n      });\n      yield (_b = element.draw({\n        animation,\n        stage: 'visibility'\n      })) === null || _b === void 0 ? void 0 : _b.finished;\n    });\n  }\n  /**\n   * <zh/> 显示元素\n   *\n   * <en/> Show element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation\n   * @apiCategory element\n   */\n  showElement(id, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ids = Array.isArray(id) ? id : [id];\n      yield this.setElementVisibility(Object.fromEntries(ids.map(_id => [_id, 'visible'])), animation);\n    });\n  }\n  /**\n   * <zh/> 隐藏元素\n   *\n   * <en/> Hide element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation\n   * @apiCategory element\n   */\n  hideElement(id, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ids = Array.isArray(id) ? id : [id];\n      yield this.setElementVisibility(Object.fromEntries(ids.map(_id => [_id, 'hidden'])), animation);\n    });\n  }\n  /**\n   * <zh/> 获取元素可见性\n   *\n   * <en/> Get element visibility\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素可见性 | <en/> element visibility\n   * @apiCategory element\n   */\n  getElementVisibility(id) {\n    var _a, _b;\n    const element = this.context.element.getElement(id);\n    return (_b = (_a = element === null || element === void 0 ? void 0 : element.style) === null || _a === void 0 ? void 0 : _a.visibility) !== null && _b !== void 0 ? _b : 'visible';\n  }\n  setElementZIndex(args1, args2) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const dataToUpdate = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      const config = isObject(args1) ? args1 : {\n        [args1]: args2\n      };\n      Object.entries(config).forEach(([id, value]) => {\n        const elementType = this.getElementType(id);\n        dataToUpdate[`${elementType}s`].push({\n          id,\n          style: {\n            zIndex: value\n          }\n        });\n      });\n      const {\n        model,\n        element\n      } = this.context;\n      model.preventUpdateNodeLikeHierarchy(() => model.updateData(dataToUpdate));\n      yield (_a = element.draw({\n        animation: false,\n        stage: 'zIndex'\n      })) === null || _a === void 0 ? void 0 : _a.finished;\n    });\n  }\n  /**\n   * <zh/> 将元素置于最顶层\n   *\n   * <en/> Bring the element to the front\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @apiCategory element\n   */\n  frontElement(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ids = Array.isArray(id) ? id : [id];\n      const {\n        model\n      } = this.context;\n      const zIndexes = {};\n      ids.map(_id => {\n        const zIndex = model.getFrontZIndex(_id);\n        const elementType = model.getElementType(_id);\n        if (elementType === 'combo') {\n          const ancestor = model.getAncestorsData(_id, COMBO_KEY).at(-1) || this.getComboData(_id);\n          const descendants = [ancestor, ...model.getDescendantsData(idOf(ancestor))];\n          const delta = zIndex - getZIndexOf(ancestor);\n          descendants.forEach(combo => {\n            zIndexes[idOf(combo)] = this.getElementZIndex(idOf(combo)) + delta;\n          });\n          const {\n            internal\n          } = getSubgraphRelatedEdges(descendants.map(idOf), id => model.getRelatedEdgesData(id));\n          internal.forEach(edge => {\n            const edgeId = idOf(edge);\n            zIndexes[edgeId] = this.getElementZIndex(edgeId) + delta;\n          });\n        } else zIndexes[_id] = zIndex;\n      });\n      yield this.setElementZIndex(zIndexes);\n    });\n  }\n  /**\n   * <zh/> 获取元素层级\n   *\n   * <en/> Get element z-index\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素层级 | <en/> element z-index\n   * @apiCategory element\n   */\n  getElementZIndex(id) {\n    return getZIndexOf(this.context.model.getElementDataById(id));\n  }\n  setElementState(args1_1, args2_1) {\n    return __awaiter(this, arguments, void 0, function* (args1, args2, args3 = true) {\n      var _a, _b;\n      const [config, animation] = isObject(args1) ? [args1, (_a = args2) !== null && _a !== void 0 ? _a : true] : [{\n        [args1]: args2\n      }, args3];\n      const parseState = state => {\n        if (!state) return [];\n        return Array.isArray(state) ? state : [state];\n      };\n      const dataToUpdate = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      Object.entries(config).forEach(([id, value]) => {\n        const elementType = this.getElementType(id);\n        dataToUpdate[`${elementType}s`].push({\n          id,\n          states: parseState(value)\n        });\n      });\n      this.updateData(dataToUpdate);\n      yield (_b = this.context.element.draw({\n        animation,\n        stage: 'state'\n      })) === null || _b === void 0 ? void 0 : _b.finished;\n    });\n  }\n  /**\n   * <zh/> 获取元素状态\n   *\n   * <en/> Get element state\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素状态 | <en/> element state\n   * @apiCategory element\n   */\n  getElementState(id) {\n    return this.context.model.getElementState(id);\n  }\n  /**\n   * <zh/> 获取元素自身以及子节点在世界坐标系下的渲染包围盒\n   *\n   * <en/> Get the rendering bounding box of the element itself and its child nodes in the world coordinate system\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 渲染包围盒 | <en/> render bounding box\n   * @apiCategory element\n   */\n  getElementRenderBounds(id) {\n    return this.context.element.getElement(id).getRenderBounds();\n  }\n  /**\n   * <zh/> 收起元素\n   *\n   * <en/> Collapse element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param options - <zh/> 是否启用动画或者配置收起节点的配置项 | <en/> whether to enable animation or the options of collapsing node\n   * @apiCategory element\n   */\n  collapseElement(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, options = true) {\n      const {\n        model,\n        element\n      } = this.context;\n      if (isCollapsed(model.getNodeLikeData([id])[0])) return;\n      if (this.isCollapsingExpanding) return;\n      if (typeof options === 'boolean') options = {\n        animation: options,\n        align: true\n      };\n      const elementType = model.getElementType(id);\n      yield this.frontElement(id);\n      this.isCollapsingExpanding = true;\n      // 更新折叠状态 / Update collapse style\n      model.updateData(elementType === 'node' ? {\n        nodes: [{\n          id,\n          style: {\n            collapsed: true\n          }\n        }]\n      } : {\n        combos: [{\n          id,\n          style: {\n            collapsed: true\n          }\n        }]\n      });\n      if (elementType === 'node') yield element.collapseNode(id, options);else if (elementType === 'combo') yield element.collapseCombo(id, !!options.animation);\n      this.isCollapsingExpanding = false;\n    });\n  }\n  /**\n   * <zh/> 展开元素\n   *\n   * <en/> Expand Element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 是否启用动画或者配置收起节点的配置项 | <en/> whether to enable animation or the options of collapsing node\n   * @param options\n   * @apiCategory element\n   */\n  expandElement(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, options = true) {\n      const {\n        model,\n        element\n      } = this.context;\n      if (!isCollapsed(model.getNodeLikeData([id])[0])) return;\n      if (this.isCollapsingExpanding) return;\n      if (typeof options === 'boolean') options = {\n        animation: options,\n        align: true\n      };\n      const elementType = model.getElementType(id);\n      this.isCollapsingExpanding = true;\n      // 更新折叠状态 / Update collapse style\n      model.updateData(elementType === 'node' ? {\n        nodes: [{\n          id,\n          style: {\n            collapsed: false\n          }\n        }]\n      } : {\n        combos: [{\n          id,\n          style: {\n            collapsed: false\n          }\n        }]\n      });\n      if (elementType === 'node') yield element.expandNode(id, options);else if (elementType === 'combo') yield element.expandCombo(id, !!options.animation);\n      this.isCollapsingExpanding = false;\n    });\n  }\n  setElementCollapsibility(id, collapsed) {\n    const elementType = this.getElementType(id);\n    if (elementType === 'node') this.updateNodeData([{\n      id,\n      style: {\n        collapsed\n      }\n    }]);else if (elementType === 'combo') this.updateComboData([{\n      id,\n      style: {\n        collapsed\n      }\n    }]);\n  }\n  /**\n   * <zh/> 导出画布内容为 DataURL\n   *\n   * <en/> Export canvas content as DataURL\n   * @param options - <zh/> 导出配置 | <en/> export options\n   * @returns <zh/> DataURL | <en/> DataURL\n   * @apiCategory exportImage\n   */\n  toDataURL() {\n    return __awaiter(this, arguments, void 0, function* (options = {}) {\n      return this.context.canvas.toDataURL(options);\n    });\n  }\n  /**\n   * <zh/> 给定的视窗 DOM 坐标，转换为画布上的绘制坐标\n   *\n   * <en/> Convert the given viewport DOM coordinates to the drawing coordinates on the canvas\n   * @param point - <zh/> 视窗坐标 | <en/> viewport coordinates\n   * @returns <zh/> 画布上的绘制坐标 | <en/> drawing coordinates on the canvas\n   * @apiCategory viewport\n   */\n  getCanvasByViewport(point) {\n    return this.context.canvas.getCanvasByViewport(point);\n  }\n  /**\n   * <zh/> 给定画布上的绘制坐标，转换为视窗 DOM 的坐标\n   *\n   * <en/> Convert the given drawing coordinates on the canvas to the coordinates of the viewport DOM\n   * @param point - <zh/> 画布坐标 | <en/> canvas coordinates\n   * @returns <zh/> 视窗 DOM 的坐标 | <en/> coordinates of the viewport DOM\n   * @apiCategory viewport\n   */\n  getViewportByCanvas(point) {\n    return this.context.canvas.getViewportByCanvas(point);\n  }\n  /**\n   * <zh/> 给定画布上的绘制坐标，转换为浏览器坐标\n   *\n   * <en/> Convert the given drawing coordinates on the canvas to browser coordinates\n   * @param point - <zh/> 画布坐标 | <en/> canvas coordinates\n   * @returns <zh/> 浏览器坐标 | <en/> browser coordinates\n   * @apiCategory viewport\n   */\n  getClientByCanvas(point) {\n    return this.context.canvas.getClientByCanvas(point);\n  }\n  /**\n   * <zh/> 给定的浏览器坐标，转换为画布上的绘制坐标\n   *\n   * <en/> Convert the given browser coordinates to drawing coordinates on the canvas\n   * @param point - <zh/> 浏览器坐标 | <en/> browser coordinates\n   * @returns <zh/> 画布上的绘制坐标 | <en/> drawing coordinates on the canvas\n   * @apiCategory viewport\n   */\n  getCanvasByClient(point) {\n    return this.context.canvas.getCanvasByClient(point);\n  }\n  /**\n   * <zh/> 获取视口中心的画布坐标\n   *\n   * <en/> Get the canvas coordinates of the viewport center\n   * @returns <zh/> 视口中心的画布坐标 | <en/> Canvas coordinates of the viewport center\n   * @apiCategory viewport\n   */\n  getViewportCenter() {\n    return this.context.viewport.getViewportCenter();\n  }\n  /**\n   * <zh/> 获取视口中心的视口坐标\n   *\n   * <en/> Get the viewport coordinates of the viewport center\n   * @returns <zh/> 视口中心的视口坐标 | <en/> Viewport coordinates of the viewport center\n   * @apiCategory viewport\n   */\n  getCanvasCenter() {\n    return this.context.viewport.getCanvasCenter();\n  }\n  /**\n   * <zh/> 监听事件\n   *\n   * <en/> Listen to events\n   * @param eventName - <zh/> 事件名称 | <en/> event name\n   * @param callback - <zh/> 回调函数 | <en/> callback function\n   * @param once - <zh/> 是否只监听一次 | <en/> whether to listen only once\n   * @returns <zh/> Graph 实例 | <en/> Graph instance\n   * @apiCategory event\n   */\n  on(eventName, callback, once) {\n    return super.on(eventName, callback, once);\n  }\n  /**\n   * <zh/> 一次性监听事件\n   *\n   * <en/> Listen to events once\n   * @param eventName - <zh/> 事件名称 | <en/> event name\n   * @param callback - <zh/> 回调函数 | <en/> callback function\n   * @returns <zh/> Graph 实例 | <en/> Graph instance\n   * @apiCategory event\n   */\n  once(eventName, callback) {\n    return super.once(eventName, callback);\n  }\n  off(eventName, callback) {\n    return super.off(eventName, callback);\n  }\n}\n/**\n * @internal\n */\nGraph.defaultOptions = {\n  autoResize: false,\n  theme: 'light',\n  rotation: 0,\n  zoom: 1,\n  zoomRange: [0.01, 10]\n};","map":{"version":3,"names":["EventEmitter","debounce","isEqual","isFunction","isNumber","isObject","isString","omit","COMBO_KEY","GraphEvent","isCollapsed","sizeOf","getSubgraphRelatedEdges","GraphLifeCycleEvent","emit","idOf","isPreLayout","format","subtract","getZIndexOf","Animation","BatchController","BehaviorController","Canvas","DataController","ElementController","LayoutController","inferOptions","PluginController","TransformController","ViewportController","Graph","constructor","options","rendered","destroyed","context","model","isCollapsingExpanding","onResize","resize","_setOptions","Object","assign","defaultOptions","graph","autoResize","_a","globalThis","addEventListener","call","getOptions","setOptions","isInit","updateCanvas","data","addData","behaviors","combo","edge","layout","node","plugins","theme","transforms","setBehaviors","setData","setNode","setEdge","setCombo","setLayout","setTheme","setPlugins","setTransforms","getSize","canvas","width","height","setSize","setZoomRange","zoomRange","getZoomRange","refreshData","getTheme","getLayout","getBehaviors","behavior","updateBehavior","map","_behavior","key","getPlugins","plugin","updatePlugin","_plugin","getPluginInstance","getTransforms","transform","updateTransform","_transform","getData","getElementData","ids","Array","isArray","id","getElementDataById","getNodeData","undefined","getNodeLikeDatum","getEdgeData","getEdgeDatum","getComboData","addNodeData","addEdgeData","addComboData","addChildrenData","parentId","childrenData","updateData","updateNodeData","updateEdgeData","updateComboData","removeData","removeNodeData","removeEdgeData","removeComboData","getElementType","getRelatedEdgesData","direction","getNeighborNodesData","getAncestorsData","hierarchy","getParentData","getChildrenData","getDescendantsData","getElementDataByState","elementType","state","initCanvas","ready","container","renderer","cursor","background","canvasOptions","devicePixelRatio","setCursor","setRenderer","$container","document","getElementById","containerSize","BEFORE_CANVAS_INIT","AFTER_CANVAS_INIT","BEFORE_RENDERER_CHANGE","AFTER_RENDERER_CHANGE","_b","initRuntime","batch","viewport","element","animation","prepare","Promise","resolve","console","error","render","BEFORE_RENDER","draw","type","all","finished","autoFit","preLayoutDraw","postLayout","AFTER_RENDER","layoutOptions","stopLayout","clear","clearChanges","destroy","BEFORE_DESTROY","off","removeEventListener","AFTER_DESTROY","getCanvas","getContainer","specificSize","canvasSize","BEFORE_SIZE_CHANGE","size","AFTER_SIZE_CHANGE","fitView","fitCenter","focusElement","focusElements","zoomBy","ratio","origin","mode","scale","zoomTo","zoom","getZoom","rotateBy","angle","rotate","rotateTo","getRotation","translateBy","offset","translate","translateTo","position","getPosition","getCanvasByViewport","translateElementBy","args1_1","args2_1","args1","args2","args3","config","entries","forEach","translateNodeLikeBy","stage","translateElementTo","translateNodeLikeTo","getElementPosition","getElementRenderStyle","getElement","attributes","setElementVisibility","dataToUpdate","nodes","edges","combos","value","push","style","visibility","preventUpdateNodeLikeHierarchy","showElement","fromEntries","_id","hideElement","getElementVisibility","setElementZIndex","zIndex","frontElement","zIndexes","getFrontZIndex","ancestor","at","descendants","delta","getElementZIndex","internal","edgeId","setElementState","parseState","states","getElementState","getElementRenderBounds","getRenderBounds","collapseElement","id_1","getNodeLikeData","align","collapsed","collapseNode","collapseCombo","expandElement","expandNode","expandCombo","setElementCollapsibility","toDataURL","point","getViewportByCanvas","getClientByCanvas","getCanvasByClient","getViewportCenter","getCanvasCenter","on","eventName","callback","once","rotation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/runtime/graph.ts"],"sourcesContent":["import EventEmitter from '@antv/event-emitter';\nimport type { AABB, BaseStyleProps } from '@antv/g';\nimport { debounce, isEqual, isFunction, isNumber, isObject, isString, omit } from '@antv/util';\nimport { COMBO_KEY, GraphEvent } from '../constants';\nimport type { Plugin } from '../plugins/types';\nimport type {\n  BehaviorOptions,\n  ComboData,\n  ComboOptions,\n  EdgeData,\n  EdgeOptions,\n  GraphData,\n  GraphOptions,\n  LayoutOptions,\n  NodeData,\n  NodeOptions,\n  PluginOptions,\n  ThemeOptions,\n  TransformOptions,\n} from '../spec';\nimport type { UpdateBehaviorOption } from '../spec/behavior';\nimport type { UpdatePluginOption } from '../spec/plugin';\nimport type { UpdateTransformOption } from '../spec/transform';\nimport type {\n  DataID,\n  EdgeDirection,\n  ElementDatum,\n  ElementType,\n  FitViewOptions,\n  HierarchyKey,\n  ID,\n  IEvent,\n  NodeLikeData,\n  PartialEdgeData,\n  PartialGraphData,\n  PartialNodeLikeData,\n  Point,\n  State,\n  Vector2,\n  ViewportAnimationEffectTiming,\n} from '../types';\nimport { isCollapsed } from '../utils/collapsibility';\nimport { sizeOf } from '../utils/dom';\nimport { getSubgraphRelatedEdges } from '../utils/edge';\nimport { GraphLifeCycleEvent, emit } from '../utils/event';\nimport { idOf } from '../utils/id';\nimport { isPreLayout } from '../utils/layout';\nimport { format } from '../utils/print';\nimport { subtract } from '../utils/vector';\nimport { getZIndexOf } from '../utils/z-index';\nimport { Animation } from './animation';\nimport { BatchController } from './batch';\nimport { BehaviorController } from './behavior';\nimport type { DataURLOptions } from './canvas';\nimport { Canvas } from './canvas';\nimport { DataController } from './data';\nimport type { CollapseExpandNodeOptions } from './element';\nimport { ElementController } from './element';\nimport { LayoutController } from './layout';\nimport { inferOptions } from './options';\nimport { PluginController } from './plugin';\nimport { TransformController } from './transform';\nimport { RuntimeContext } from './types';\nimport { ViewportController } from './viewport';\n\nexport class Graph extends EventEmitter {\n  private options: GraphOptions = {};\n\n  /**\n   * @internal\n   */\n  static defaultOptions: GraphOptions = {\n    autoResize: false,\n    theme: 'light',\n    rotation: 0,\n    zoom: 1,\n    zoomRange: [0.01, 10],\n  };\n\n  /**\n   * <zh/> 当前图实例是否已经渲染\n   *\n   * <en/> Whether the current graph instance has been rendered\n   */\n  public rendered = false;\n\n  /**\n   * <zh/> 当前图实例是否已经被销毁\n   *\n   * <en/> Whether the current graph instance has been destroyed\n   */\n  public destroyed = false;\n\n  // @ts-expect-error will be initialized in createRuntime\n  private context: RuntimeContext = {\n    model: new DataController(),\n  };\n\n  constructor(options: GraphOptions) {\n    super();\n    this._setOptions(Object.assign({}, Graph.defaultOptions, options), true);\n    this.context.graph = this;\n\n    // Listening resize to autoResize.\n    this.options.autoResize && globalThis.addEventListener?.('resize', this.onResize);\n  }\n\n  /**\n   * <zh/> 获取配置项\n   *\n   * <en/> Get options\n   * @returns <zh/> 配置项 | <en/> options\n   * @apiCategory option\n   */\n  public getOptions(): GraphOptions {\n    return this.options;\n  }\n\n  /**\n   * <zh/> 设置配置项\n   *\n   * <en/> Set options\n   * @param options - <zh/> 配置项 | <en/> options\n   * @remarks\n   * <zh/> 要更新 devicePixelRatio、container 属性请销毁后重新创建实例\n   *\n   * <en/> To update devicePixelRatio and container properties, please destroy and recreate the instance\n   * @apiCategory option\n   */\n  public setOptions(options: GraphOptions): void {\n    this._setOptions(options, false);\n  }\n\n  private _setOptions(options: GraphOptions, isInit: boolean) {\n    this.updateCanvas(options);\n    Object.assign(this.options, inferOptions(options));\n\n    if (isInit) {\n      const { data } = options;\n      if (data) this.addData(data);\n      return;\n    }\n    const { behaviors, combo, data, edge, layout, node, plugins, theme, transforms } = options;\n    if (behaviors) this.setBehaviors(behaviors);\n    if (data) this.setData(data);\n    if (node) this.setNode(node);\n    if (edge) this.setEdge(edge);\n    if (combo) this.setCombo(combo);\n    if (layout) this.setLayout(layout);\n    if (theme) this.setTheme(theme);\n    if (plugins) this.setPlugins(plugins);\n    if (transforms) this.setTransforms(transforms);\n  }\n\n  /**\n   * <zh/> 获取当前画布容器的尺寸\n   *\n   * <en/> Get the size of the current canvas container\n   * @returns <zh/> 画布尺寸 | <en/> canvas size\n   * @apiCategory canvas\n   */\n  public getSize(): [number, number] {\n    if (this.context.canvas) return this.context.canvas.getSize();\n    return [this.options.width || 0, this.options.height || 0];\n  }\n\n  /**\n   * <zh/> 设置当前画布容器的尺寸\n   *\n   * <en/> Set the size of the current canvas container\n   * @param width - <zh/> 画布宽度 | <en/> canvas width\n   * @param height - <zh/> 画布高度 | <en/> canvas height\n   * @apiCategory canvas\n   */\n  public setSize(width: number, height: number): void {\n    if (width) this.options.width = width;\n    if (height) this.options.height = height;\n\n    this.resize(width, height);\n  }\n\n  /**\n   * <zh/> 设置当前图的缩放区间\n   *\n   * <en/> Get the zoom range of the current graph\n   * @param zoomRange - <zh/> 缩放区间 | <en/> zoom range\n   * @apiCategory viewport\n   */\n  public setZoomRange(zoomRange: GraphOptions['zoomRange']): void {\n    this.options.zoomRange = zoomRange;\n  }\n\n  /**\n   * <zh/> 获取当前图的缩放区间\n   *\n   * <en/> Get the zoom range of the current graph\n   * @returns <zh/> 缩放区间 | <en/> zoom range\n   * @apiCategory viewport\n   */\n  public getZoomRange(): GraphOptions['zoomRange'] {\n    return this.options.zoomRange;\n  }\n\n  /**\n   * <zh/> 设置节点样式映射\n   *\n   * <en/> Set node mapper\n   * @param node - <zh/> 节点配置 | <en/> node options\n   * @remarks\n   * <zh/> 即 `options.node` 的值\n   *\n   * <en/> The value of `options.node`\n   * @apiCategory element\n   */\n  public setNode(node: NodeOptions): void {\n    this.options.node = node;\n    this.context.model.refreshData();\n  }\n\n  /**\n   * <zh/> 设置边样式映射\n   *\n   * <en/> Set edge mapper\n   * @param edge - <zh/> 边配置 | <en/> edge options\n   * @remarks\n   * <zh/> 即 `options.edge` 的值\n   *\n   * <en/> The value of `options.edge`\n   * @apiCategory element\n   */\n  public setEdge(edge: EdgeOptions): void {\n    this.options.edge = edge;\n    this.context.model.refreshData();\n  }\n\n  /**\n   * <zh/> 设置组合样式映射\n   *\n   * <en/> Set combo mapper\n   * @param combo - <zh/> 组合配置 | <en/> combo options\n   * @remarks\n   * <zh/> 即 `options.combo` 的值\n   *\n   * <en/> The value of `options.combo`\n   * @apiCategory element\n   */\n  public setCombo(combo: ComboOptions): void {\n    this.options.combo = combo;\n    this.context.model.refreshData();\n  }\n\n  /**\n   * <zh/> 获取主题\n   *\n   * <en/> Get theme\n   * @returns <zh/> 当前主题 | <en/> current theme\n   * @apiCategory theme\n   */\n  public getTheme(): ThemeOptions {\n    return this.options.theme!;\n  }\n\n  /**\n   * <zh/> 设置主题\n   *\n   * <en/> Set theme\n   * @param theme - <zh/> 主题名 | <en/> theme name\n   * @example\n   * ```ts\n   * graph.setTheme('dark');\n   * ```\n   * @apiCategory theme\n   */\n  public setTheme(theme: ThemeOptions | ((prev: ThemeOptions) => ThemeOptions)): void {\n    this.options.theme = isFunction(theme) ? theme(this.getTheme()) : theme;\n  }\n\n  /**\n   * <zh/> 设置布局\n   *\n   * <en/> Set layout\n   * @param layout - <zh/> 布局配置 | <en/> layout options\n   * @example\n   * ```ts\n   * graph.setLayout({\n   *  type: 'dagre',\n   * })\n   * ```\n   * @apiCategory layout\n   */\n  public setLayout(layout: LayoutOptions | ((prev: LayoutOptions) => LayoutOptions)): void {\n    this.options.layout = isFunction(layout) ? layout(this.getLayout()) : layout;\n  }\n\n  /**\n   * <zh/> 获取布局配置\n   *\n   * <en/> Get layout options\n   * @returns <zh/> 布局配置 | <en/> layout options\n   * @apiCategory layout\n   */\n  public getLayout(): LayoutOptions {\n    return this.options.layout!;\n  }\n\n  /**\n   * <zh/> 设置交互\n   *\n   * <en/> Set behaviors\n   * @param behaviors - <zh/> 交互配置 | <en/> behavior options\n   * @remarks\n   * <zh/> 设置的交互会全量替换原有的交互，如果需要新增交互可以使用如下方式：\n   *\n   * <en/> The set behavior will completely replace the original behavior. If you need to add behavior, you can use the following method:\n   *\n   * ```ts\n   * graph.setBehaviors((behaviors) => [...behaviors, { type: 'zoom-canvas' }])\n   * ```\n   * @apiCategory behavior\n   */\n  public setBehaviors(behaviors: BehaviorOptions | ((prev: BehaviorOptions) => BehaviorOptions)): void {\n    this.options.behaviors = isFunction(behaviors) ? behaviors(this.getBehaviors()) : behaviors;\n    this.context.behavior?.setBehaviors(this.options.behaviors);\n  }\n\n  /**\n   * <zh/> 更新指定的交互配置\n   *\n   * <en/> Update specified behavior options\n   * @param behavior - <zh/> 交互配置 | <en/> behavior options\n   * @remarks\n   * <zh/> 如果要更新一个交互，那么必须在交互配置中指定 key 字段，例如：\n   *\n   * <en/> If you want to update a behavior, you must specify the key field in the behavior options, for example:\n   * ```ts\n   * {\n   *   behaviors: [{ type: 'zoom-canvas', key: 'zoom-canvas' }]\n   * }\n   *\n   * graph.updateBehavior({ key: 'zoom-canvas', enable: false })\n   * ```\n   * @apiCategory behavior\n   */\n  public updateBehavior(behavior: UpdateBehaviorOption): void {\n    this.setBehaviors((behaviors) =>\n      behaviors.map((_behavior) => {\n        if (typeof _behavior === 'object' && _behavior.key === behavior.key) {\n          return { ..._behavior, ...behavior };\n        }\n        return _behavior;\n      }),\n    );\n  }\n\n  /**\n   * <zh/> 获取交互配置\n   *\n   * <en/> Get behaviors options\n   * @returns <zh/> 交互配置 | <en/> behavior options\n   * @apiCategory behavior\n   */\n  public getBehaviors(): BehaviorOptions {\n    return this.options.behaviors || [];\n  }\n\n  /**\n   * <zh/> 设置插件配置\n   *\n   * <en/> Set plugins options\n   * @param plugins - <zh/> 插件配置 | <en/> plugin options\n   * @remarks\n   * <zh/> 设置的插件会全量替换原有的插件配置，如果需要新增插件可以使用如下方式：\n   *\n   * <en/> The set plugin will completely replace the original plugin configuration. If you need to add a plugin, you can use the following method:\n   * ```ts\n   * graph.setPlugins((plugins) => [...plugins, { key: 'grid-line' }])\n   * ```\n   * @apiCategory plugin\n   */\n  public setPlugins(plugins: PluginOptions | ((prev: PluginOptions) => PluginOptions)): void {\n    this.options.plugins = isFunction(plugins) ? plugins(this.getPlugins()) : plugins;\n    this.context.plugin?.setPlugins(this.options.plugins);\n  }\n\n  /**\n   * <zh/> 更新插件配置\n   *\n   * <en/> Update plugin options\n   * @param plugin - <zh/> 插件配置 | <en/> plugin options\n   * @remarks\n   * <zh/> 如果要更新一个插件，那么必须在插件配置中指定 key 字段，例如：\n   *\n   * <en/> If you want to update a plugin, you must specify the key field in the plugin options, for example:\n   * ```ts\n   * {\n   *   plugins: [{ key: 'grid-line' }]\n   * }\n   *\n   * graph.updatePlugin({ key: 'grid-line', follow: true })\n   * ```\n   * @apiCategory plugin\n   */\n  public updatePlugin(plugin: UpdatePluginOption): void {\n    this.setPlugins((plugins) =>\n      plugins.map((_plugin) => {\n        if (typeof _plugin === 'object' && _plugin.key === plugin.key) {\n          return { ..._plugin, ...plugin };\n        }\n        return _plugin;\n      }),\n    );\n  }\n\n  /**\n   * <zh/> 获取插件配置\n   *\n   * <en/> Get plugins options\n   * @returns <zh/> 插件配置 | <en/> plugin options\n   * @apiCategory plugin\n   */\n  public getPlugins(): PluginOptions {\n    return this.options.plugins || [];\n  }\n\n  /**\n   * <zh/> 获取插件实例\n   *\n   * <en/> Get plugin instance\n   * @param key - <zh/> 插件 key（在配置 plugin 时需要手动传入指定） | <en/> plugin key(need to be specified manually when configuring plugin)\n   * @returns <zh/> 插件实例 | <en/> plugin instance\n   * @remarks\n   * <zh/> 一些插件提供了 API 方法可供调用，例如全屏插件可以调用 `request` 和 `exit` 方法来请求和退出全屏\n   *\n   * <en/> Some plugins provide API methods for calling, such as the full-screen plugin can call the `request` and `exit` methods to request and exit full-screen\n   * ```ts\n   * const fullscreen = graph.getPluginInstance('fullscreen');\n   *\n   * fullscreen.request();\n   *\n   * fullscreen.exit();\n   * ```\n   * @apiCategory plugin\n   */\n  public getPluginInstance<T extends Plugin>(key: string) {\n    return this.context.plugin!.getPluginInstance(key) as unknown as T;\n  }\n\n  /**\n   * <zh/> 设置数据转换器\n   *\n   * <en/> Set data transforms\n   * @param transforms - <zh/> 数据转换配置 | <en/> data transform options\n   * @remarks\n   * <zh/> 数据转换器能够在图渲染过程中执行数据转换，目前支持在渲染前对绘制数据进行转化。\n   *\n   * <en/> Data transforms can perform data transformation during the rendering process of the graph. Currently, it supports transforming the drawing data before rendering.\n   * @apiCategory transform\n   */\n  public setTransforms(transforms: TransformOptions | ((prev: TransformOptions) => TransformOptions)): void {\n    this.options.transforms = isFunction(transforms) ? transforms(this.getTransforms()) : transforms;\n    this.context.transform?.setTransforms(this.options.transforms);\n  }\n\n  /**\n   * <zh/> 更新数据转换器\n   *\n   * <en/> Update data transform\n   * @param transform - <zh/> 数据转换器配置 | <en/> data transform options\n   * @apiCategory transform\n   */\n  public updateTransform(transform: UpdateTransformOption): void {\n    this.setTransforms((transforms) =>\n      transforms.map((_transform) => {\n        if (typeof _transform === 'object' && _transform.key === transform.key) {\n          return { ..._transform, ...transform };\n        }\n        return _transform;\n      }),\n    );\n    this.context.model.refreshData();\n  }\n\n  /**\n   * <zh/> 获取数据转换器配置\n   *\n   * <en/> Get data transforms options\n   * @returns <zh/> 数据转换配置 | <en/> data transform options\n   * @apiCategory transform\n   */\n  public getTransforms(): TransformOptions {\n    return this.options.transforms || [];\n  }\n\n  /**\n   * <zh/> 获取图数据\n   *\n   * <en/> Get graph data\n   * @returns <zh/> 图数据 | <en/> Graph data\n   * <zh/> 获取当前图的数据，包括节点、边、组合数据\n   *\n   * <en/> Get the data of the current graph, including node, edge, and combo data\n   * @apiCategory data\n   */\n  public getData(): Required<GraphData> {\n    return this.context.model.getData();\n  }\n\n  /**\n   * <zh/> 获取单个元素数据\n   *\n   * <en/> Get element data by ID\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素数据 | <en/> element data\n   * @remarks\n   * <zh/> 直接获取元素的数据而不必考虑元素类型\n   *\n   * <en/> Get element data directly without considering the element type\n   * @apiCategory data\n   */\n  public getElementData(id: ID): ElementDatum;\n  /**\n   * <zh/> 批量获取多个元素数据\n   *\n   * <en/> Get multiple element data in batch\n   * @param ids - <zh/> 元素 ID 数组 | <en/> element ID array\n   * @remarks\n   * <zh/> 直接获取元素的数据而不必考虑元素类型\n   *\n   * <en/> Get element data directly without considering the element type\n   * @apiCategory data\n   */\n  public getElementData(ids: ID[]): ElementDatum[];\n  public getElementData(ids: ID | ID[]): ElementDatum | ElementDatum[] {\n    if (Array.isArray(ids)) return ids.map((id) => this.context.model.getElementDataById(id));\n    return this.context.model.getElementDataById(ids);\n  }\n\n  /**\n   * <zh/> 获取所有节点数据\n   *\n   * <en/> Get all node data\n   * @returns <zh/> 节点数据 | <en/> node data\n   * @apiCategory data\n   */\n  public getNodeData(): NodeData[];\n  /**\n   * <zh/> 获取单个节点数据\n   *\n   * <en/> Get single node data\n   * @param id - <zh/> 节点 ID | <en/> node ID\n   * @returns <zh/> 节点数据 | <en/> node data\n   * @example\n   * ```ts\n   * const node1 = graph.getNodeData('node-1');\n   * ```\n   * @apiCategory data\n   * @remarks\n   * <zh/> 节点 id 必须存在，否则会抛出异常\n   *\n   * <en/> Node id must exist, otherwise an exception will be thrown\n   */\n  public getNodeData(id: ID): NodeData;\n  /**\n   * <zh/> 批量获取多个节点数据\n   *\n   * <en/> Get multiple node data in batch\n   * @param ids - <zh/> 节点 ID 数组 | <en/> node ID array\n   * @returns <zh/> 节点数据 | <en/> node data\n   * @example\n   * ```ts\n   * const [node1, node2] = graph.getNodeData(['node-1', 'node-2']);\n   * ```\n   * @apiCategory data\n   * @remarks\n   * <zh/> 数组中的每个节点 id 必须存在，否则将抛出异常\n   *\n   * <en/> Each node id in the array must exist, otherwise an exception will be thrown\n   */\n  public getNodeData(ids: ID[]): NodeData[];\n  public getNodeData(id?: ID | ID[]): NodeData | NodeData[] {\n    if (id === undefined) return this.context.model.getNodeData();\n    if (Array.isArray(id)) return this.context.model.getNodeData(id);\n    return this.context.model.getNodeLikeDatum(id);\n  }\n\n  /**\n   * <zh/> 获取所有边数据\n   *\n   * <en/> Get all edge data\n   * @returns <zh/> 边数据 | <en/> edge data\n   * @apiCategory data\n   */\n  public getEdgeData(): EdgeData[];\n  /**\n   * <zh/> 获取单条边数据\n   *\n   * <en/> Get single edge data\n   * @param id - <zh/> 边 ID | <en/> edge ID\n   * @returns <zh/> 边数据 | <en/> edge data\n   * @example\n   * ```ts\n   * const edge1 = graph.getEdgeData('edge-1');\n   * ```\n   * @apiCategory data\n   * @remarks\n   * <zh/> 边 id 必须存在，否则会抛出异常\n   *\n   * <en/> Edge id must exist, otherwise an exception will be thrown\n   */\n  public getEdgeData(id: ID): EdgeData;\n  /**\n   * <zh/> 批量获取多条边数据\n   *\n   * <en/> Get multiple edge data in batch\n   * @param ids - <zh/> 边 ID 数组 | <en/> edge ID array\n   * @returns <zh/> 边数据 | <en/> edge data\n   * @example\n   * ```ts\n   * const [edge1, edge2] = graph.getEdgeData(['edge-1', 'edge-2']);\n   * ```\n   * @apiCategory data\n   * @remarks\n   * <zh/> 数组中的每个边 id 必须存在，否则将抛出异常\n   *\n   * <en/> Each edge id in the array must exist, otherwise an exception will be thrown\n   */\n  public getEdgeData(ids: ID[]): EdgeData[];\n  public getEdgeData(id?: ID | ID[]): EdgeData | EdgeData[] {\n    if (id === undefined) return this.context.model.getEdgeData();\n    if (Array.isArray(id)) return this.context.model.getEdgeData(id);\n    return this.context.model.getEdgeDatum(id);\n  }\n\n  /**\n   * <zh/> 获取所有组合数据\n   *\n   * <en/> Get all combo data\n   * @returns <zh/> 组合数据 | <en/> combo data\n   * @apiCategory data\n   */\n  public getComboData(): ComboData[];\n  /**\n   * <zh/> 获取单个组合数据\n   *\n   * <en/> Get single combo data\n   * @param id - <zh/> 组合ID | <en/> combo ID\n   * @returns <zh/> 组合数据 | <en/> combo data\n   * @example\n   * ```ts\n   * const combo1 = graph.getComboData('combo-1');\n   * ```\n   * @apiCategory data\n   * @remarks\n   * <zh/> 组合 id 必须存在，否则会抛出异常\n   *\n   * <en/> Combo id must exist, otherwise an exception will be thrown\n   */\n  public getComboData(id: ID): ComboData;\n  /**\n   * <zh/> 批量获取多个组合数据\n   *\n   * <en/> Get multiple combo data in batch\n   * @param ids - <zh/> 组合ID 数组 | <en/> combo ID array\n   * @returns <zh/> 组合数据 | <en/> combo data\n   * @example\n   * ```ts\n   * const [combo1, combo2] = graph.getComboData(['combo-1', 'combo-2']);\n   * ```\n   * @apiCategory data\n   * @remarks\n   * <zh/> 数组中的每个组合 id 必须存在，否则将抛出异常\n   *\n   * <en/> Each combo id in the array must exist, otherwise an exception will be thrown\n   */\n  public getComboData(ids: ID[]): ComboData[];\n  public getComboData(id?: ID | ID[]): ComboData | ComboData[] {\n    if (id === undefined) return this.context.model.getComboData();\n    if (Array.isArray(id)) return this.context.model.getComboData(id);\n    return this.context.model.getNodeLikeDatum(id);\n  }\n\n  /**\n   * <zh/> 设置全量数据\n   *\n   * <en/> Set full data\n   * @param data - <zh/> 数据 | <en/> data\n   * @remarks\n   * <zh/> 设置全量数据会替换当前图中的所有数据，G6 会自动进行数据差异计算\n   *\n   * <en/> Setting full data will replace all data in the current graph, and G6 will automatically calculate the data difference\n   * @apiCategory data\n   */\n  public setData(data: GraphData | ((prev: GraphData) => GraphData)): void {\n    this.context.model.setData(isFunction(data) ? data(this.getData()) : data);\n  }\n\n  /**\n   * <zh/> 新增元素数据\n   *\n   * <en/> Add element data\n   * @param data - <zh/> 元素数据 | <en/> element data\n   * @example\n   * ```ts\n   * graph.addData({\n   *  nodes: [{ id: 'node-1' }, { id: 'node-2' }],\n   *  edges: [{ source: 'node-1', target: 'node-2' }],\n   * });\n   * ```\n   * @apiCategory data\n   */\n  public addData(data: GraphData | ((prev: GraphData) => GraphData)): void {\n    this.context.model.addData(isFunction(data) ? data(this.getData()) : data);\n  }\n\n  /**\n   * <zh/> 新增节点数据\n   *\n   * <en/> Add node data\n   * @param data - <zh/> 节点数据 | <en/> node data\n   * @example\n   * ```ts\n   * graph.addNodeData([{ id: 'node-1' }, { id: 'node-2' }]);\n   * ```\n   * @apiCategory data\n   */\n  public addNodeData(data: NodeData[] | ((prev: NodeData[]) => NodeData[])): void {\n    this.context.model.addNodeData(isFunction(data) ? data(this.getNodeData()) : data);\n  }\n\n  /**\n   * <zh/> 新增边数据\n   *\n   * <en/> Add edge data\n   * @param data - <zh/> 边数据 | <en/> edge data\n   * @example\n   * ```ts\n   * graph.addEdgeData([{ source: 'node-1', target: 'node-2' }]);\n   * ```\n   * @apiCategory data\n   */\n  public addEdgeData(data: EdgeData[] | ((prev: EdgeData[]) => EdgeData[])): void {\n    this.context.model.addEdgeData(isFunction(data) ? data(this.getEdgeData()) : data);\n  }\n\n  /**\n   * <zh/> 新增组合数据\n   *\n   * <en/> Add combo data\n   * @param data - <zh/> 组合数据 | <en/> combo data\n   * @example\n   * ```ts\n   * graph.addComboData([{ id: 'combo-1' }]);\n   * ```\n   * @apiCategory data\n   */\n  public addComboData(data: ComboData[] | ((prev: ComboData[]) => ComboData[])): void {\n    this.context.model.addComboData(isFunction(data) ? data(this.getComboData()) : data);\n  }\n\n  /**\n   * <zh/> 为树图节点添加子节点数据\n   *\n   * <en/> Add child node data to the tree node\n   * @param parentId - <zh/> 父节点 ID | <en/> parent node ID\n   * @param childrenData - <zh/> 子节点数据 | <en/> child node data\n   * @remarks\n   * <zh/> 为组合添加子节点使用 addNodeData / addComboData 方法\n   *\n   * <en/> Use addNodeData / addComboData method to add child nodes to the combo\n   * @apiCategory data\n   */\n  public addChildrenData(parentId: ID, childrenData: NodeData[]) {\n    this.context.model.addChildrenData(parentId, childrenData);\n  }\n\n  /**\n   * <zh/> 更新元素数据\n   *\n   * <en/> Update element data\n   * @param data - <zh/> 元素数据 | <en/> element data\n   * @remarks\n   * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据\n   *\n   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data\n   * @example\n   * ```ts\n   * graph.updateData({\n   *   nodes: [{ id: 'node-1', style: { x: 100, y: 100 } }],\n   *   edges: [{ id: 'edge-1', style: { lineWidth: 2 } }]\n   * });\n   * ```\n   * @apiCategory data\n   */\n  public updateData(data: PartialGraphData | ((prev: GraphData) => PartialGraphData)): void {\n    this.context.model.updateData(isFunction(data) ? data(this.getData()) : data);\n  }\n\n  /**\n   * <zh/> 更新节点数据\n   *\n   * <en/> Update node data\n   * @param data - <zh/> 节点数据 | <en/> node data\n   * @remarks\n   * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据\n   *\n   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data\n   * @example\n   * ```ts\n   * graph.updateNodeData([{ id: 'node-1', style: { x: 100, y: 100 } }]);\n   * ```\n   * @apiCategory data\n   */\n  public updateNodeData(\n    data: PartialNodeLikeData<NodeData>[] | ((prev: NodeData[]) => PartialNodeLikeData<NodeData>[]),\n  ): void {\n    this.context.model.updateNodeData(isFunction(data) ? data(this.getNodeData()) : data);\n  }\n\n  /**\n   * <zh/> 更新边数据\n   *\n   * <en/> Update edge data\n   * @param data - <zh/> 边数据 | <en/> edge data\n   * @remarks\n   * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据\n   *\n   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data\n   * @example\n   * ```ts\n   * graph.updateEdgeData([{ id: 'edge-1', style: { lineWidth: 2 } }]);\n   * ```\n   * @apiCategory data\n   */\n  public updateEdgeData(data: PartialEdgeData<EdgeData>[] | ((prev: EdgeData[]) => PartialEdgeData<EdgeData>[])): void {\n    this.context.model.updateEdgeData(isFunction(data) ? data(this.getEdgeData()) : data);\n  }\n\n  /**\n   * <zh/> 更新组合数据\n   *\n   * <en/> Update combo data\n   * @param data - <zh/> 组合数据 | <en/> combo data\n   * @remarks\n   * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据\n   *\n   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data\n   * @example\n   * ```ts\n   * graph.updateComboData([{ id: 'combo-1', style: { x: 100, y: 100 } }]);\n   * ```\n   * @apiCategory data\n   */\n  public updateComboData(\n    data: PartialNodeLikeData<ComboData>[] | ((prev: ComboData[]) => PartialNodeLikeData<ComboData>[]),\n  ): void {\n    this.context.model.updateComboData(isFunction(data) ? data(this.getComboData()) : data);\n  }\n\n  /**\n   * <zh/> 删除元素数据\n   *\n   * <en/> Remove element data\n   * @param ids - <zh/> 元素 ID 数组 | <en/> element ID array\n   * @example\n   * ```ts\n   * graph.removeData({\n   *   nodes: ['node-1', 'node-2'],\n   *   edges: ['edge-1'],\n   * });\n   * ```\n   * @apiCategory data\n   */\n  public removeData(ids: DataID | ((data: GraphData) => DataID)): void {\n    this.context.model.removeData(isFunction(ids) ? ids(this.getData()) : ids);\n  }\n\n  /**\n   * <zh/> 删除节点数据\n   *\n   * <en/> Remove node data\n   * @param ids - <zh/> 节点 ID 数组 | <en/> node ID array\n   * @example\n   * ```ts\n   * graph.removeNodeData(['node-1', 'node-2']);\n   * ```\n   * @apiCategory data\n   */\n  public removeNodeData(ids: ID[] | ((data: NodeData[]) => ID[])): void {\n    this.context.model.removeNodeData(isFunction(ids) ? ids(this.getNodeData()) : ids);\n  }\n\n  /**\n   * <zh/> 删除边数据\n   *\n   * <en/> Remove edge data\n   * @param ids - <zh/> 边 ID 数组 | <en/> edge ID array\n   * @remarks\n   * <zh/> 如果传入边数据时仅提供了 source 和 target，那么需要通过 `idOf` 方法获取边的实际 ID\n   *\n   * <en/> If only the source and target are provided when passing in the edge data, you need to get the actual ID of the edge through the `idOf` method\n   * @example\n   * ```ts\n   * graph.removeEdgeData(['edge-1']);\n   * ```\n   * @apiCategory data\n   */\n  public removeEdgeData(ids: ID[] | ((data: EdgeData[]) => ID[])): void {\n    this.context.model.removeEdgeData(isFunction(ids) ? ids(this.getEdgeData()) : ids);\n  }\n\n  /**\n   * <zh/> 删除组合数据\n   *\n   * <en/> Remove combo data\n   * @param ids - <zh/> 组合 ID 数组 | <en/> 组合 ID array\n   * @example\n   * ```ts\n   * graph.removeComboData(['combo-1']);\n   * ```\n   * @apiCategory data\n   */\n  public removeComboData(ids: ID[] | ((data: ComboData[]) => ID[])): void {\n    this.context.model.removeComboData(isFunction(ids) ? ids(this.getComboData()) : ids);\n  }\n\n  /**\n   * <zh/> 获取元素类型\n   *\n   * <en/> Get element type\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素类型 | <en/> element type\n   * @apiCategory element\n   */\n  public getElementType(id: ID): ElementType {\n    return this.context.model.getElementType(id);\n  }\n\n  /**\n   * <zh/> 获取节点或组合关联边的数据\n   *\n   * <en/> Get edge data related to the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @param direction - <zh/> 边的方向 | <en/> edge direction\n   * @returns <zh/> 边数据 | <en/> edge data\n   * @apiCategory data\n   */\n  public getRelatedEdgesData(id: ID, direction: EdgeDirection = 'both'): EdgeData[] {\n    return this.context.model.getRelatedEdgesData(id, direction);\n  }\n\n  /**\n   * <zh/> 获取节点或组合的一跳邻居节点数据\n   *\n   * <en/> Get the one-hop neighbor node data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @returns <zh/> 邻居节点数据 | <en/> neighbor node data\n   * @apiCategory data\n   */\n  public getNeighborNodesData(id: ID): NodeData[] {\n    return this.context.model.getNeighborNodesData(id);\n  }\n\n  /**\n   * <zh/> 获取节点或组合的祖先元素数据\n   *\n   * <en/> Get the ancestor element data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @param hierarchy - <zh/> 指定树图层级关系还是组合层级关系 | <en/> specify tree or combo hierarchy relationship\n   * @returns <zh/> 祖先元素数据 | <en/> ancestor element data\n   * @remarks\n   * <zh/> 数组中的顺序是从父节点到祖先节点\n   *\n   * <en/> The order in the array is from the parent node to the ancestor node\n   * @apiCategory data\n   */\n  public getAncestorsData(id: ID, hierarchy: HierarchyKey): NodeLikeData[] {\n    return this.context.model.getAncestorsData(id, hierarchy);\n  }\n\n  /**\n   * <zh/> 获取节点或组合的父元素数据\n   *\n   * <en/> Get the parent element data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @param hierarchy - <zh/> 指定树图层级关系还是组合层级关系 | <en/> specify tree or combo hierarchy relationship\n   * @returns <zh/> 父元素数据 | <en/> parent element data\n   * @apiCategory data\n   */\n  public getParentData(id: ID, hierarchy: HierarchyKey): NodeLikeData | undefined {\n    return this.context.model.getParentData(id, hierarchy);\n  }\n\n  /**\n   * <zh/> 获取节点或组合的子元素数据\n   *\n   * <en/> Get the child element data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @returns <zh/> 子元素数据 | <en/> child element data\n   * @apiCategory data\n   */\n  public getChildrenData(id: ID): NodeLikeData[] {\n    return this.context.model.getChildrenData(id);\n  }\n\n  /**\n   * <zh/> 获取节点或组合的后代元素数据\n   *\n   * <en/> Get the descendant element data of the node or combo\n   * @param id - <zh/> 节点或组合ID | <en/> node or combo ID\n   * @returns <zh/> 后代元素数据 | <en/> descendant element data\n   * @apiCategory data\n   */\n  public getDescendantsData(id: ID): NodeLikeData[] {\n    return this.context.model.getDescendantsData(id);\n  }\n\n  /**\n   * <zh/> 获取指定状态下的节点数据\n   *\n   * <en/> Get node data in a specific state\n   * @param state - <zh/> 状态 | <en/> state\n   * @returns <zh/> 节点数据 | <en/> node data\n   * @example\n   * ```ts\n   * const nodes = graph.getElementDataByState('node', 'selected');\n   * ```\n   * @apiCategory data\n   */\n  public getElementDataByState(elementType: 'node', state: State): NodeData[];\n  /**\n   * <zh/> 获取指定状态下的边数据\n   *\n   * <en/> Get edge data in a specific state\n   * @param state - <zh/> 状态 | <en/> state\n   * @returns <zh/> 边数据 | <en/> edge data\n   * @example\n   * ```ts\n   * const nodes = graph.getElementDataByState('edge', 'selected');\n   * ```\n   * @apiCategory data\n   */\n  public getElementDataByState(elementType: 'edge', state: State): EdgeData[];\n  /**\n   * <zh/> 获取指定状态下的组合数据\n   *\n   * <en/> Get combo data in a specific state\n   * @param state - <zh/> 状态 | <en/> state\n   * @returns <zh/> 组合数据 | <en/> combo data\n   * @example\n   * ```ts\n   * const nodes = graph.getElementDataByState('node', 'selected');\n   * ```\n   * @apiCategory data\n   */\n  public getElementDataByState(elementType: 'combo', state: State): ComboData[];\n  public getElementDataByState(elementType: ElementType, state: State): ElementDatum[] {\n    return this.context.model.getElementDataByState(elementType, state);\n  }\n\n  private async initCanvas() {\n    if (this.context.canvas) return await this.context.canvas.ready;\n\n    const {\n      container = 'container',\n      width,\n      height,\n      renderer,\n      cursor,\n      background,\n      canvas: canvasOptions,\n      devicePixelRatio = globalThis.devicePixelRatio ?? 1,\n    } = this.options;\n    if (container instanceof Canvas) {\n      this.context.canvas = container;\n      if (cursor) container.setCursor(cursor);\n      if (renderer) container.setRenderer(renderer);\n      await container.ready;\n    } else {\n      const $container = isString(container) ? document.getElementById(container!) : container;\n      const containerSize = sizeOf($container!);\n\n      this.emit(GraphEvent.BEFORE_CANVAS_INIT, { container: $container, width, height });\n      const options = {\n        ...canvasOptions,\n        container: $container!,\n        width: width || containerSize[0],\n        height: height || containerSize[1],\n        background,\n        renderer,\n        cursor,\n        devicePixelRatio,\n      };\n\n      const canvas = new Canvas(options);\n\n      this.context.canvas = canvas;\n      await canvas.ready;\n      this.emit(GraphEvent.AFTER_CANVAS_INIT, { canvas });\n    }\n  }\n\n  private updateCanvas(options: GraphOptions) {\n    const { renderer, cursor, height, width } = options;\n    const canvas = this.context.canvas;\n    if (!canvas) return;\n\n    if (renderer) {\n      this.emit(GraphEvent.BEFORE_RENDERER_CHANGE, { renderer: this.options.renderer });\n      canvas.setRenderer(renderer);\n      this.emit(GraphEvent.AFTER_RENDERER_CHANGE, { renderer });\n    }\n\n    if (cursor) canvas.setCursor(cursor);\n\n    if (isNumber(width) || isNumber(height))\n      this.setSize(width ?? this.options.width ?? 0, height ?? this.options.height ?? 0);\n  }\n\n  private initRuntime() {\n    this.context.options = this.options;\n    if (!this.context.batch) this.context.batch = new BatchController(this.context);\n    if (!this.context.plugin) this.context.plugin = new PluginController(this.context);\n    if (!this.context.viewport) this.context.viewport = new ViewportController(this.context);\n    if (!this.context.transform) this.context.transform = new TransformController(this.context);\n    if (!this.context.element) this.context.element = new ElementController(this.context);\n    if (!this.context.animation) this.context.animation = new Animation(this.context);\n    if (!this.context.layout) this.context.layout = new LayoutController(this.context);\n    if (!this.context.behavior) this.context.behavior = new BehaviorController(this.context);\n  }\n\n  private async prepare(): Promise<void> {\n    // 等待同步任务执行完成，避免 render 后立即调用 destroy 导致的问题\n    // Wait for synchronous tasks to complete, to avoid problems caused by calling destroy immediately after render\n    await Promise.resolve();\n\n    if (this.destroyed) {\n      // 如果图实例已经被销毁，则不再执行任何操作\n      // If the graph instance has been destroyed, no further operations will be performed\n      // eslint-disable-next-line no-console\n      console.error(format('The graph instance has been destroyed'));\n      return;\n    }\n\n    await this.initCanvas();\n    this.initRuntime();\n  }\n\n  /**\n   * <zh/> 执行渲染\n   *\n   * <en/> Render\n   * @remarks\n   * <zh/> 此过程会执行数据更新、绘制元素、执行布局\n   *\n   * > ⚠️ render 为异步方法，如果需要在 render 后执行一些操作，可以使用 `await graph.render()` 或者监听 GraphEvent.AFTER_RENDER 事件\n   *\n   * <en/> This process will execute data update, element rendering, and layout execution\n   *\n   * > ⚠️ render is an asynchronous method. If you need to perform some operations after render, you can use `await graph.render()` or listen to the GraphEvent.AFTER_RENDER event\n   * @apiCategory render\n   */\n  public async render(): Promise<void> {\n    await this.prepare();\n    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_RENDER));\n\n    if (!this.options.layout) {\n      const animation = this.context.element!.draw({ type: 'render' });\n      await Promise.all([animation?.finished, this.autoFit()]);\n    } else if (!this.rendered && isPreLayout(this.options.layout)) {\n      const animation = await this.context.element!.preLayoutDraw({ type: 'render' });\n      await Promise.all([animation?.finished, this.autoFit()]);\n    } else {\n      const animation = this.context.element!.draw({ type: 'render' });\n      await Promise.all([animation?.finished, this.context.layout!.postLayout()]);\n      await this.autoFit();\n    }\n\n    this.rendered = true;\n    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_RENDER));\n  }\n\n  /**\n   * <zh/> 绘制元素\n   *\n   * <en/> Draw elements\n   * @returns <zh/> 渲染结果 | <en/> draw result\n   * @remarks\n   * <zh/> 仅执行元素绘制，不会重新布局\n   *\n   * <zh/> ⚠️ draw 为异步方法，如果需要在 draw 后执行一些操作，可以使用 `await graph.draw()` 或者监听 GraphEvent.AFTER_DRAW 事件\n   *\n   * <en/> Only execute element drawing, no re-layout\n   *\n   * <en/> ⚠️ draw is an asynchronous method. If you need to perform some operations after draw, you can use `await graph.draw()` or listen to the GraphEvent.AFTER_DRAW event\n   * @apiCategory render\n   */\n  public async draw(): Promise<void> {\n    await this.prepare();\n    await this.context.element!.draw()?.finished;\n  }\n\n  /**\n   * <zh/> 执行布局\n   *\n   * <en/> Execute layout\n   * @param layoutOptions - <zh/> 布局配置项 | <en/> Layout options\n   * @apiCategory layout\n   */\n  public async layout(layoutOptions?: LayoutOptions) {\n    await this.context.layout!.postLayout(layoutOptions);\n  }\n\n  /**\n   * <zh/> 停止布局\n   *\n   * <en/> Stop layout\n   * @remarks\n   * <zh/> 适用于带有迭代动画的布局，目前有 `force` 属于此类布局，即停止力导布局的迭代，一般用于布局迭代时间过长情况下的手动停止迭代动画，例如在点击画布/节点的监听中调用\n   *\n   * <en/> Suitable for layouts with iterative animations. Currently, `force` belongs to this type of layout, that is, stop the iteration of the force-directed layout. It is generally used to manually stop the iteration animation when the layout iteration time is too long, such as calling in the click canvas/node listener\n   * @apiCategory layout\n   */\n  public stopLayout() {\n    this.context.layout!.stopLayout();\n  }\n\n  /**\n   * <zh/> 清空画布元素\n   *\n   * <en/> Clear canvas elements\n   * @apiCategory canvas\n   */\n  public async clear(): Promise<void> {\n    const { model, element } = this.context;\n    model.setData({});\n    model.clearChanges();\n    element?.clear();\n  }\n\n  /**\n   * <zh/> 销毁当前图实例\n   *\n   * <en/> Destroy the current graph instance\n   * @remarks\n   * <zh/> 销毁后无法进行任何操作，如果需要重新使用，需要重新创建一个新的图实例\n   *\n   * <en/> After destruction, no operations can be performed. If you need to reuse it, you need to create a new graph instance\n   * @apiCategory instance\n   */\n  public destroy(): void {\n    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_DESTROY));\n\n    const { layout, animation, element, model, canvas, behavior, plugin } = this.context;\n    plugin?.destroy();\n    behavior?.destroy();\n    layout?.destroy();\n    animation?.destroy();\n    element?.destroy();\n    model.destroy();\n    canvas?.destroy();\n    this.options = {};\n    // @ts-expect-error force delete\n    this.context = {};\n\n    this.off();\n    globalThis.removeEventListener?.('resize', this.onResize);\n\n    this.destroyed = true;\n\n    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_DESTROY));\n  }\n\n  /**\n   * <zh/> 获取画布实例\n   *\n   * <en/> Get canvas instance\n   * @returns - <zh/> 画布实例 | <en/> canvas instance\n   * @apiCategory canvas\n   */\n  public getCanvas(): Canvas {\n    return this.context.canvas;\n  }\n\n  /**\n   * <zh/> 调整画布大小为图容器大小\n   *\n   * <en/> Resize the canvas to the size of the graph container\n   * @apiCategory viewport\n   */\n  public resize(): void;\n  /**\n   * <zh/> 调整画布大小为指定宽高\n   *\n   * <en/> Resize the canvas to the specified width and height\n   * @param width - <zh/> 宽度 | <en/> width\n   * @param height - <zh/> 高度 | <en/> height\n   * @apiCategory viewport\n   */\n  public resize(width: number, height: number): void;\n  public resize(width?: number, height?: number): void {\n    const containerSize = sizeOf(this.context.canvas?.getContainer());\n    const specificSize: Vector2 = [width || containerSize[0], height || containerSize[1]];\n\n    if (!this.context.canvas) return;\n\n    const canvasSize = this.context.canvas!.getSize();\n    if (isEqual(specificSize, canvasSize)) return;\n\n    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_SIZE_CHANGE, { size: specificSize }));\n    this.context.canvas.resize(...specificSize);\n    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_SIZE_CHANGE, { size: specificSize }));\n  }\n\n  /**\n   * <zh/> 将图缩放至合适大小并平移至视口中心\n   *\n   * <en/> Zoom the graph to fit the viewport and move it to the center of the viewport\n   * @param options - <zh/> 适配配置 | <en/> fit options\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory viewport\n   */\n  public async fitView(options?: FitViewOptions, animation?: ViewportAnimationEffectTiming): Promise<void> {\n    await this.context.viewport?.fitView(options, animation);\n  }\n\n  /**\n   * <zh/> 将图平移至视口中心\n   *\n   * <en/> Move the graph to the center of the viewport\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory viewport\n   */\n  public async fitCenter(animation?: ViewportAnimationEffectTiming): Promise<void> {\n    await this.context.viewport?.fitCenter({ animation });\n  }\n\n  private async autoFit(): Promise<void> {\n    const { autoFit } = this.context.options;\n    if (!autoFit) return;\n\n    if (isString(autoFit)) {\n      if (autoFit === 'view') await this.fitView();\n      else if (autoFit === 'center') await this.fitCenter();\n    } else {\n      const { type, animation } = autoFit;\n      if (type === 'view') await this.fitView(autoFit.options, animation);\n      else if (type === 'center') await this.fitCenter(animation);\n    }\n  }\n\n  /**\n   * <zh/> 聚焦元素\n   *\n   * <en/> Focus on element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @remarks\n   * <zh/> 移动图，使得元素对齐到视口中心\n   *\n   * <en/> Move the graph so that the element is aligned to the center of the viewport\n   * @apiCategory viewport\n   */\n  public async focusElement(id: ID | ID[], animation?: ViewportAnimationEffectTiming): Promise<void> {\n    await this.context.viewport?.focusElements(Array.isArray(id) ? id : [id], { animation });\n  }\n\n  /**\n   * <zh/> 基于当前缩放比例进行缩放（相对缩放）\n   *\n   * <en/> Zoom based on the current zoom ratio (relative zoom)\n   * @param ratio - <zh/> 缩放比例 | <en/> zoom ratio\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @param origin - <zh/> 缩放中心(视口坐标) | <en/> zoom center(viewport coordinates)\n   * @remarks\n   * <zh/>\n   * - ratio > 1 放大\n   * - ratio < 1 缩小\n   *\n   * <en/>\n   * - ratio > 1 zoom in\n   * - ratio < 1 zoom out\n   * @apiCategory viewport\n   */\n  public async zoomBy(ratio: number, animation?: ViewportAnimationEffectTiming, origin?: Point): Promise<void> {\n    await this.context.viewport!.transform({ mode: 'relative', scale: ratio, origin }, animation);\n  }\n\n  /**\n   * <zh/> 缩放画布至指定比例（绝对缩放）\n   *\n   * <en/> Zoom the canvas to the specified ratio (absolute zoom)\n   * @param zoom - <zh/> 指定缩放比例 | <en/> specified zoom ratio\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @param origin - <zh/> 缩放中心(视口坐标) | <en/> zoom center(viewport coordinates)\n   * @remarks\n   * <zh/>\n   * - zoom = 1 默认大小\n   * - zoom > 1 放大\n   * - zoom < 1 缩小\n   *\n   * <en/>\n   * - zoom = 1 default size\n   * - zoom > 1 zoom in\n   * - zoom < 1 zoom out\n   * @apiCategory viewport\n   */\n  public async zoomTo(zoom: number, animation?: ViewportAnimationEffectTiming, origin?: Point): Promise<void> {\n    await this.context.viewport!.transform({ mode: 'absolute', scale: zoom, origin }, animation);\n  }\n\n  /**\n   * <zh/> 获取当前缩放比例\n   *\n   * <en/> Get the current zoom ratio\n   * @returns <zh/> 缩放比例 | <en/> zoom ratio\n   * @apiCategory viewport\n   */\n  public getZoom(): number {\n    return this.context.viewport!.getZoom();\n  }\n\n  /**\n   * <zh/> 基于当前旋转角度进行旋转（相对旋转）\n   *\n   * <en/> Rotate based on the current rotation angle (relative rotation)\n   * @param angle - <zh/> 旋转角度 | <en/> rotation angle\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @param origin - <zh/> 旋转中心(视口坐标) | <en/> rotation center(viewport coordinates)\n   * @apiCategory viewport\n   */\n  public async rotateBy(angle: number, animation?: ViewportAnimationEffectTiming, origin?: Point): Promise<void> {\n    await this.context.viewport!.transform({ mode: 'relative', rotate: angle, origin }, animation);\n  }\n\n  /**\n   * <zh/> 旋转画布至指定角度 (绝对旋转)\n   *\n   * <en/> Rotate the canvas to the specified angle (absolute rotation)\n   * @param angle - <zh/> 目标角度 | <en/> target angle\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @param origin - <zh/> 旋转中心(视口坐标) | <en/> rotation center(viewport coordinates)\n   * @apiCategory viewport\n   */\n  public async rotateTo(angle: number, animation?: ViewportAnimationEffectTiming, origin?: Point): Promise<void> {\n    await this.context.viewport!.transform({ mode: 'absolute', rotate: angle, origin }, animation);\n  }\n\n  /**\n   * <zh/> 获取当前旋转角度\n   *\n   * <en/> Get the current rotation angle\n   * @returns <zh/> 旋转角度 | <en/> rotation angle\n   * @apiCategory viewport\n   */\n  public getRotation(): number {\n    return this.context.viewport!.getRotation();\n  }\n\n  /**\n   * <zh/> 将图平移指定距离 (相对平移)\n   *\n   * <en/> Translate the graph by the specified distance (relative translation)\n   * @param offset - <zh/> 偏移量 | <en/> offset\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory viewport\n   */\n  public async translateBy(offset: Point, animation?: ViewportAnimationEffectTiming): Promise<void> {\n    await this.context.viewport!.transform({ mode: 'relative', translate: offset }, animation);\n  }\n\n  /**\n   * <zh/> 将图平移至指定位置 (绝对平移)\n   *\n   * <en/> Translate the graph to the specified position (absolute translation)\n   * @param position - <zh/> 指定位置 | <en/> specified position\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory viewport\n   */\n  public async translateTo(position: Point, animation?: ViewportAnimationEffectTiming): Promise<void> {\n    await this.context.viewport!.transform({ mode: 'absolute', translate: position }, animation);\n  }\n\n  /**\n   * <zh/> 获取图的位置\n   *\n   * <en/> Get the position of the graph\n   * @returns <zh/> 图的位置 | <en/> position of the graph\n   * @remarks\n   * <zh/> 即画布原点在视口坐标系下的位置。默认状态下，图的位置为 [0, 0]\n   *\n   * <en/> That is, the position of the canvas origin in the viewport coordinate system. By default, the position of the graph is [0, 0]\n   * @apiCategory viewport\n   */\n  public getPosition(): Point {\n    return subtract([0, 0], this.getCanvasByViewport([0, 0]));\n  }\n\n  /**\n   * <zh/> 将元素平移指定距离 (相对平移)\n   *\n   * <en/> Translate the element by the specified distance (relative translation)\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param offset - <zh/> 偏移量 | <en/> offset\n   * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation\n   * @apiCategory element\n   */\n  public async translateElementBy(id: ID, offset: Point, animation?: boolean): Promise<void>;\n  /**\n   * <zh/> 批量将元素平移指定距离 (相对平移)\n   *\n   * <en/> Batch translate elements by the specified distance (relative translation)\n   * @param offsets - <zh/> 偏移量配置 | <en/> offset options\n   * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation\n   * @apiCategory element\n   */\n  public async translateElementBy(offsets: Record<ID, Point>, animation?: boolean): Promise<void>;\n  public async translateElementBy(\n    args1: ID | Record<ID, Point>,\n    args2?: Point | boolean,\n    args3: boolean = true,\n  ): Promise<void> {\n    const [config, animation] = isObject(args1)\n      ? [args1, (args2 as boolean) ?? true]\n      : [{ [args1 as ID]: args2 as Point }, args3];\n\n    Object.entries(config).forEach(([id, offset]) => this.context.model.translateNodeLikeBy(id, offset));\n    await this.context.element!.draw({ animation, stage: 'translate' })?.finished;\n  }\n\n  /**\n   * <zh/> 将元素平移至指定位置 (绝对平移)\n   *\n   * <en/> Translate the element to the specified position (absolute translation)\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param position - <zh/> 指定位置 | <en/> specified position\n   * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation\n   * @apiCategory element\n   */\n  public async translateElementTo(id: ID, position: Point, animation?: boolean): Promise<void>;\n  /**\n   * <zh/> 批量将元素平移至指定位置 (绝对平移)\n   *\n   * <en/> Batch translate elements to the specified position (absolute translation)\n   * @param positions - <zh/> 位置配置 | <en/> position options\n   * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation\n   * @apiCategory element\n   */\n  public async translateElementTo(positions: Record<ID, Point>, animation?: boolean): Promise<void>;\n  public async translateElementTo(\n    args1: ID | Record<ID, Point>,\n    args2?: boolean | Point,\n    args3: boolean = true,\n  ): Promise<void> {\n    const [config, animation] = isObject(args1)\n      ? [args1, (args2 as boolean) ?? true]\n      : [{ [args1 as ID]: args2 as Point }, args3];\n\n    Object.entries(config).forEach(([id, position]) => this.context.model.translateNodeLikeTo(id, position));\n    await this.context.element!.draw({ animation, stage: 'translate' })?.finished;\n  }\n\n  /**\n   * <zh/> 获取元素位置\n   *\n   * <en/> Get element position\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素位置 | <en/> element position\n   * @apiCategory element\n   */\n  public getElementPosition(id: ID): Point {\n    return this.context.model.getElementPosition(id);\n  }\n\n  /**\n   * <zh/> 获取元素渲染样式\n   *\n   * <en/> Get element rendering style\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素渲染样式 | <en/> element rendering style\n   * @apiCategory element\n   */\n  public getElementRenderStyle(id: ID): Record<string, any> {\n    return omit(this.context.element!.getElement(id)!.attributes, ['context']);\n  }\n\n  /**\n   * <zh/> 设置元素可见性\n   *\n   * <en/> Set element visibility\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param visibility - <zh/> 可见性 | <en/> visibility\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @remarks\n   * <zh/> 可见性配置包括 `visible` 和 `hidden` 两种状态\n   *\n   * <en/> Visibility configuration includes two states: `visible` and `hidden`\n   * @apiCategory element\n   */\n  public async setElementVisibility(\n    id: ID,\n    visibility: BaseStyleProps['visibility'],\n    animation?: boolean,\n  ): Promise<void>;\n  /**\n   * <zh/> 批量设置元素可见性\n   *\n   * <en/> Batch set element visibility\n   * @param visibility - <zh/> 可见性配置 | <en/> visibility options\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory element\n   */\n  public async setElementVisibility(\n    visibility: Record<ID, BaseStyleProps['visibility']>,\n    animation?: boolean,\n  ): Promise<void>;\n  public async setElementVisibility(\n    args1: ID | Record<ID, BaseStyleProps['visibility']>,\n    args2?: boolean | BaseStyleProps['visibility'],\n    args3: boolean = true,\n  ): Promise<void> {\n    const [config, animation] = isObject(args1)\n      ? [args1, (args2 as boolean) ?? true]\n      : [{ [args1]: args2 as BaseStyleProps['visibility'] }, args3];\n\n    const dataToUpdate: Required<PartialGraphData> = { nodes: [], edges: [], combos: [] };\n    Object.entries(config).forEach(([id, value]) => {\n      const elementType = this.getElementType(id);\n      dataToUpdate[`${elementType}s`].push({ id, style: { visibility: value } });\n    });\n\n    const { model, element } = this.context;\n    model.preventUpdateNodeLikeHierarchy(() => {\n      model.updateData(dataToUpdate);\n    });\n    await element!.draw({ animation, stage: 'visibility' })?.finished;\n  }\n\n  /**\n   * <zh/> 显示元素\n   *\n   * <en/> Show element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation\n   * @apiCategory element\n   */\n  public async showElement(id: ID | ID[], animation?: boolean): Promise<void> {\n    const ids = Array.isArray(id) ? id : [id];\n    await this.setElementVisibility(\n      Object.fromEntries(ids.map((_id) => [_id, 'visible'] as [ID, BaseStyleProps['visibility']])),\n      animation,\n    );\n  }\n\n  /**\n   * <zh/> 隐藏元素\n   *\n   * <en/> Hide element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation\n   * @apiCategory element\n   */\n  public async hideElement(id: ID | ID[], animation?: boolean): Promise<void> {\n    const ids = Array.isArray(id) ? id : [id];\n    await this.setElementVisibility(\n      Object.fromEntries(ids.map((_id) => [_id, 'hidden'] as [ID, BaseStyleProps['visibility']])),\n      animation,\n    );\n  }\n\n  /**\n   * <zh/> 获取元素可见性\n   *\n   * <en/> Get element visibility\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素可见性 | <en/> element visibility\n   * @apiCategory element\n   */\n  public getElementVisibility(id: ID): BaseStyleProps['visibility'] {\n    const element = this.context.element!.getElement(id)!;\n    return element?.style?.visibility ?? 'visible';\n  }\n\n  /**\n   * <zh/> 设置元素层级\n   *\n   * <en/> Set element z-index\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param zIndex - <zh/> 层级 | <en/> z-index\n   * @apiCategory element\n   */\n  public async setElementZIndex(id: ID, zIndex: number): Promise<void>;\n  /**\n   * <zh/> 批量设置元素层级\n   *\n   * <en/> Batch set element z-index\n   * @param zIndex - <zh/> 层级配置 | <en/> z-index options\n   * @apiCategory element\n   */\n  public async setElementZIndex(zIndex: Record<ID, number>): Promise<void>;\n  public async setElementZIndex(args1: ID | Record<ID, number>, args2?: number): Promise<void> {\n    const dataToUpdate: Required<PartialGraphData> = { nodes: [], edges: [], combos: [] };\n    const config = isObject(args1) ? args1 : { [args1 as ID]: args2 as number };\n\n    Object.entries(config).forEach(([id, value]) => {\n      const elementType = this.getElementType(id);\n      dataToUpdate[`${elementType}s`].push({ id, style: { zIndex: value } });\n    });\n\n    const { model, element } = this.context;\n    model.preventUpdateNodeLikeHierarchy(() => model.updateData(dataToUpdate));\n    await element!.draw({ animation: false, stage: 'zIndex' })?.finished;\n  }\n\n  /**\n   * <zh/> 将元素置于最顶层\n   *\n   * <en/> Bring the element to the front\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @apiCategory element\n   */\n  public async frontElement(id: ID | ID[]): Promise<void> {\n    const ids = Array.isArray(id) ? id : [id];\n    const { model } = this.context;\n    const zIndexes: Record<ID, number> = {};\n\n    ids.map((_id) => {\n      const zIndex = model.getFrontZIndex(_id);\n      const elementType = model.getElementType(_id);\n      if (elementType === 'combo') {\n        const ancestor = model.getAncestorsData(_id, COMBO_KEY).at(-1) || this.getComboData(_id);\n        const descendants = [ancestor, ...model.getDescendantsData(idOf(ancestor))];\n        const delta = zIndex - getZIndexOf(ancestor);\n        descendants.forEach((combo) => {\n          zIndexes[idOf(combo)] = this.getElementZIndex(idOf(combo)) + delta;\n        });\n\n        const { internal } = getSubgraphRelatedEdges(descendants.map(idOf), (id) => model.getRelatedEdgesData(id));\n        internal.forEach((edge) => {\n          const edgeId = idOf(edge);\n          zIndexes[edgeId] = this.getElementZIndex(edgeId) + delta;\n        });\n      } else zIndexes[_id] = zIndex;\n    });\n\n    await this.setElementZIndex(zIndexes);\n  }\n\n  /**\n   * <zh/> 获取元素层级\n   *\n   * <en/> Get element z-index\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素层级 | <en/> element z-index\n   * @apiCategory element\n   */\n  public getElementZIndex(id: ID): number {\n    return getZIndexOf(this.context.model.getElementDataById(id));\n  }\n\n  /**\n   * <zh/> 设置元素状态\n   *\n   * <en/> Set element state\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param state - <zh/> 状态 | <en/> state\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory element\n   */\n  public async setElementState(id: ID, state: State | State[], animation?: boolean): Promise<void>;\n  /**\n   * <zh/> 批量设置元素状态\n   *\n   * <en/> Batch set element state\n   * @param state - <zh/> 状态配置 | <en/> state options\n   * @param animation - <zh/> 动画配置 | <en/> animation options\n   * @apiCategory element\n   */\n  public async setElementState(state: Record<ID, State | State[]>, animation?: boolean): Promise<void>;\n  public async setElementState(\n    args1: ID | Record<ID, State | State[]>,\n    args2?: boolean | State | State[],\n    args3: boolean = true,\n  ): Promise<void> {\n    const [config, animation] = isObject(args1)\n      ? [args1, (args2 as boolean) ?? true]\n      : [{ [args1]: args2 as State | State[] }, args3];\n\n    const parseState = (state: State | State[]) => {\n      if (!state) return [];\n      return Array.isArray(state) ? state : [state];\n    };\n\n    const dataToUpdate: Required<PartialGraphData> = { nodes: [], edges: [], combos: [] };\n    Object.entries(config).forEach(([id, value]) => {\n      const elementType = this.getElementType(id);\n      dataToUpdate[`${elementType}s`].push({ id, states: parseState(value) });\n    });\n    this.updateData(dataToUpdate);\n\n    await this.context.element!.draw({ animation, stage: 'state' })?.finished;\n  }\n\n  /**\n   * <zh/> 获取元素状态\n   *\n   * <en/> Get element state\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 元素状态 | <en/> element state\n   * @apiCategory element\n   */\n  public getElementState(id: ID): State[] {\n    return this.context.model.getElementState(id);\n  }\n\n  /**\n   * <zh/> 获取元素自身以及子节点在世界坐标系下的渲染包围盒\n   *\n   * <en/> Get the rendering bounding box of the element itself and its child nodes in the world coordinate system\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @returns <zh/> 渲染包围盒 | <en/> render bounding box\n   * @apiCategory element\n   */\n  public getElementRenderBounds(id: ID): AABB {\n    return this.context.element!.getElement(id)!.getRenderBounds();\n  }\n\n  private isCollapsingExpanding = false;\n\n  /**\n   * <zh/> 收起元素\n   *\n   * <en/> Collapse element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param options - <zh/> 是否启用动画或者配置收起节点的配置项 | <en/> whether to enable animation or the options of collapsing node\n   * @apiCategory element\n   */\n  public async collapseElement(id: ID, options: boolean | CollapseExpandNodeOptions = true): Promise<void> {\n    const { model, element } = this.context;\n    if (isCollapsed(model.getNodeLikeData([id])[0])) return;\n    if (this.isCollapsingExpanding) return;\n\n    if (typeof options === 'boolean') options = { animation: options, align: true };\n\n    const elementType = model.getElementType(id);\n\n    await this.frontElement(id);\n    this.isCollapsingExpanding = true;\n\n    // 更新折叠状态 / Update collapse style\n    model.updateData(\n      elementType === 'node'\n        ? {\n            nodes: [{ id, style: { collapsed: true } }],\n          }\n        : {\n            combos: [{ id, style: { collapsed: true } }],\n          },\n    );\n\n    if (elementType === 'node') await element!.collapseNode(id, options);\n    else if (elementType === 'combo') await element!.collapseCombo(id, !!options.animation);\n\n    this.isCollapsingExpanding = false;\n  }\n\n  /**\n   * <zh/> 展开元素\n   *\n   * <en/> Expand Element\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 是否启用动画或者配置收起节点的配置项 | <en/> whether to enable animation or the options of collapsing node\n   * @param options\n   * @apiCategory element\n   */\n  public async expandElement(id: ID, options: boolean | CollapseExpandNodeOptions = true): Promise<void> {\n    const { model, element } = this.context;\n    if (!isCollapsed(model.getNodeLikeData([id])[0])) return;\n    if (this.isCollapsingExpanding) return;\n\n    if (typeof options === 'boolean') options = { animation: options, align: true };\n\n    const elementType = model.getElementType(id);\n\n    this.isCollapsingExpanding = true;\n\n    // 更新折叠状态 / Update collapse style\n    model.updateData(\n      elementType === 'node'\n        ? {\n            nodes: [{ id, style: { collapsed: false } }],\n          }\n        : {\n            combos: [{ id, style: { collapsed: false } }],\n          },\n    );\n\n    if (elementType === 'node') await element!.expandNode(id, options);\n    else if (elementType === 'combo') await element!.expandCombo(id, !!options.animation);\n\n    this.isCollapsingExpanding = false;\n  }\n\n  private setElementCollapsibility(id: ID, collapsed: boolean) {\n    const elementType = this.getElementType(id);\n    if (elementType === 'node') this.updateNodeData([{ id, style: { collapsed } }]);\n    else if (elementType === 'combo') this.updateComboData([{ id, style: { collapsed } }]);\n  }\n\n  /**\n   * <zh/> 导出画布内容为 DataURL\n   *\n   * <en/> Export canvas content as DataURL\n   * @param options - <zh/> 导出配置 | <en/> export options\n   * @returns <zh/> DataURL | <en/> DataURL\n   * @apiCategory exportImage\n   */\n  public async toDataURL(options: Partial<DataURLOptions> = {}): Promise<string> {\n    return this.context.canvas!.toDataURL(options);\n  }\n\n  /**\n   * <zh/> 给定的视窗 DOM 坐标，转换为画布上的绘制坐标\n   *\n   * <en/> Convert the given viewport DOM coordinates to the drawing coordinates on the canvas\n   * @param point - <zh/> 视窗坐标 | <en/> viewport coordinates\n   * @returns <zh/> 画布上的绘制坐标 | <en/> drawing coordinates on the canvas\n   * @apiCategory viewport\n   */\n  public getCanvasByViewport(point: Point): Point {\n    return this.context.canvas.getCanvasByViewport(point);\n  }\n\n  /**\n   * <zh/> 给定画布上的绘制坐标，转换为视窗 DOM 的坐标\n   *\n   * <en/> Convert the given drawing coordinates on the canvas to the coordinates of the viewport DOM\n   * @param point - <zh/> 画布坐标 | <en/> canvas coordinates\n   * @returns <zh/> 视窗 DOM 的坐标 | <en/> coordinates of the viewport DOM\n   * @apiCategory viewport\n   */\n  public getViewportByCanvas(point: Point): Point {\n    return this.context.canvas.getViewportByCanvas(point);\n  }\n\n  /**\n   * <zh/> 给定画布上的绘制坐标，转换为浏览器坐标\n   *\n   * <en/> Convert the given drawing coordinates on the canvas to browser coordinates\n   * @param point - <zh/> 画布坐标 | <en/> canvas coordinates\n   * @returns <zh/> 浏览器坐标 | <en/> browser coordinates\n   * @apiCategory viewport\n   */\n  public getClientByCanvas(point: Point): Point {\n    return this.context.canvas.getClientByCanvas(point);\n  }\n\n  /**\n   * <zh/> 给定的浏览器坐标，转换为画布上的绘制坐标\n   *\n   * <en/> Convert the given browser coordinates to drawing coordinates on the canvas\n   * @param point - <zh/> 浏览器坐标 | <en/> browser coordinates\n   * @returns <zh/> 画布上的绘制坐标 | <en/> drawing coordinates on the canvas\n   * @apiCategory viewport\n   */\n  public getCanvasByClient(point: Point): Point {\n    return this.context.canvas.getCanvasByClient(point);\n  }\n\n  /**\n   * <zh/> 获取视口中心的画布坐标\n   *\n   * <en/> Get the canvas coordinates of the viewport center\n   * @returns <zh/> 视口中心的画布坐标 | <en/> Canvas coordinates of the viewport center\n   * @apiCategory viewport\n   */\n  public getViewportCenter(): Point {\n    return this.context.viewport!.getViewportCenter();\n  }\n\n  /**\n   * <zh/> 获取视口中心的视口坐标\n   *\n   * <en/> Get the viewport coordinates of the viewport center\n   * @returns <zh/> 视口中心的视口坐标 | <en/> Viewport coordinates of the viewport center\n   * @apiCategory viewport\n   */\n  public getCanvasCenter(): Point {\n    return this.context.viewport!.getCanvasCenter();\n  }\n\n  private onResize = debounce(() => {\n    this.resize();\n  }, 300);\n\n  /**\n   * <zh/> 监听事件\n   *\n   * <en/> Listen to events\n   * @param eventName - <zh/> 事件名称 | <en/> event name\n   * @param callback - <zh/> 回调函数 | <en/> callback function\n   * @param once - <zh/> 是否只监听一次 | <en/> whether to listen only once\n   * @returns <zh/> Graph 实例 | <en/> Graph instance\n   * @apiCategory event\n   */\n  public on<T extends IEvent = IEvent>(eventName: string, callback: (event: T) => void, once?: boolean): this {\n    return super.on(eventName, callback, once);\n  }\n\n  /**\n   * <zh/> 一次性监听事件\n   *\n   * <en/> Listen to events once\n   * @param eventName - <zh/> 事件名称 | <en/> event name\n   * @param callback - <zh/> 回调函数 | <en/> callback function\n   * @returns <zh/> Graph 实例 | <en/> Graph instance\n   * @apiCategory event\n   */\n  public once<T extends IEvent = IEvent>(eventName: string, callback: (event: T) => void): this {\n    return super.once(eventName, callback);\n  }\n\n  /**\n   * <zh/> 移除全部事件监听\n   *\n   * <en/> Remove all event listeners\n   * @returns <zh/> Graph 实例 | <en/> Graph instance\n   * @apiCategory event\n   */\n  public off(): this;\n  /**\n   * <zh/> 移除指定事件的全部监听\n   *\n   * <en/> Remove all listeners for the specified event\n   * @param eventName - <zh/> 事件名称 | <en/> event name\n   * @returns <zh/> Graph 实例 | <en/> Graph instance\n   * @apiCategory event\n   */\n  public off(eventName: string): this;\n  /**\n   * <zh/> 移除事件监听\n   *\n   * <en/> Remove event listener\n   * @param eventName - <zh/> 事件名称 | <en/> event name\n   * @param callback - <zh/> 回调函数 | <en/> callback function\n   * @returns <zh/> Graph 实例 | <en/> Graph instance\n   * @apiCategory event\n   */\n  public off(eventName: string, callback: (...args: any[]) => void): this;\n  public off(eventName?: string, callback?: (...args: any[]) => void) {\n    return super.off(eventName, callback);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}