{"ast":null,"code":"import { __assign, __extends, __read } from \"tslib\";\nimport { CustomEvent } from '@antv/g';\nimport { clamp } from '@antv/util';\nimport { transition } from '../../animation';\nimport { Component } from '../../core';\nimport { Text } from '../../shapes';\nimport { getEventPos, ifShow, parseSeriesAttr, select, subStyleProps, superStyleProps, toPrecision } from '../../util';\nimport { Sparkline } from '../sparkline';\nimport { CLASS_NAMES, HANDLE_DEFAULT_CFG, HANDLE_ICON_DEFAULT_CFG, HANDLE_LABEL_DEFAULT_CFG } from './constant';\nimport { Handle } from './handle';\nvar Slider = /** @class */function (_super) {\n  __extends(Slider, _super);\n  function Slider(options) {\n    var _this = _super.call(this, options, __assign(__assign(__assign({\n      x: 0,\n      y: 0,\n      animate: {\n        duration: 100,\n        fill: 'both'\n      },\n      brushable: true,\n      formatter: function (val) {\n        return val.toString();\n      },\n      handleSpacing: 2,\n      orientation: 'horizontal',\n      padding: 0,\n      autoFitLabel: true,\n      scrollable: true,\n      selectionFill: '#5B8FF9',\n      selectionFillOpacity: 0.45,\n      selectionZIndex: 2,\n      showHandle: true,\n      showLabel: true,\n      slidable: true,\n      trackFill: '#416180',\n      trackLength: 200,\n      trackOpacity: 0.05,\n      trackSize: 20,\n      trackZIndex: -1,\n      values: [0, 1],\n      type: 'range',\n      selectionType: 'select',\n      handleIconOffset: 0\n    }, superStyleProps(HANDLE_DEFAULT_CFG, 'handle')), superStyleProps(HANDLE_ICON_DEFAULT_CFG, 'handleIcon')), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, 'handleLabel'))) || this;\n    _this.range = [0, 1];\n    _this.onDragStart = function (target) {\n      return function (e) {\n        e.stopPropagation();\n        _this.target = target;\n        _this.prevPos = _this.getOrientVal(getEventPos(e));\n        var _a = _this.availableSpace,\n          x = _a.x,\n          y = _a.y;\n        var _b = _this.getBBox(),\n          X = _b.x,\n          Y = _b.y;\n        _this.selectionStartPos = _this.getRatio(_this.prevPos - _this.getOrientVal([x, y]) - _this.getOrientVal([+X, +Y]));\n        _this.selectionWidth = 0;\n        document.addEventListener('pointermove', _this.onDragging);\n        document.addEventListener('pointerup', _this.onDragEnd);\n      };\n    };\n    _this.onDragging = function (e) {\n      var _a = _this.attributes,\n        slidable = _a.slidable,\n        brushable = _a.brushable,\n        type = _a.type;\n      e.stopPropagation();\n      var currPos = _this.getOrientVal(getEventPos(e));\n      var diffPos = currPos - _this.prevPos;\n      if (!diffPos) return;\n      var deltaVal = _this.getRatio(diffPos);\n      switch (_this.target) {\n        case 'start':\n          if (slidable) _this.setValuesOffset(deltaVal);\n          break;\n        case 'end':\n          if (slidable) _this.setValuesOffset(0, deltaVal);\n          break;\n        case 'selection':\n          if (slidable) _this.setValuesOffset(deltaVal, deltaVal);\n          break;\n        case 'track':\n          if (!brushable) return;\n          // 绘制蒙板\n          _this.selectionWidth += deltaVal;\n          if (type === 'range') {\n            _this.innerSetValues([_this.selectionStartPos, _this.selectionStartPos + _this.selectionWidth].sort(), true);\n          } else _this.innerSetValues([0, _this.selectionStartPos + _this.selectionWidth], true);\n          break;\n        default:\n          break;\n      }\n      _this.prevPos = currPos;\n    };\n    _this.onDragEnd = function () {\n      document.removeEventListener('pointermove', _this.onDragging);\n      document.removeEventListener('pointermove', _this.onDragging);\n      document.removeEventListener('pointerup', _this.onDragEnd);\n      _this.target = '';\n      // 更新 handle 状态\n      _this.updateHandlesPosition(false);\n    };\n    _this.onValueChange = function (oldValue) {\n      var _a = _this.attributes,\n        onChange = _a.onChange,\n        type = _a.type;\n      var internalOldValue = type === 'range' ? oldValue : oldValue[1];\n      var value = type === 'range' ? _this.getValues() : _this.getValues()[1];\n      var evt = new CustomEvent('valuechange', {\n        detail: {\n          oldValue: internalOldValue,\n          value: value\n        }\n      });\n      _this.dispatchEvent(evt);\n      onChange === null || onChange === void 0 ? void 0 : onChange(value);\n    };\n    _this.selectionStartPos = 0;\n    _this.selectionWidth = 0;\n    _this.prevPos = 0;\n    _this.target = '';\n    return _this;\n  }\n  Object.defineProperty(Slider.prototype, \"values\", {\n    get: function () {\n      return this.attributes.values;\n    },\n    set: function (values) {\n      this.attributes.values = this.clampValues(values);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"sparklineStyle\", {\n    get: function () {\n      var orientation = this.attributes.orientation;\n      if (orientation !== 'horizontal') return null;\n      var attr = subStyleProps(this.attributes, 'sparkline');\n      return __assign(__assign({\n        zIndex: 0\n      }, this.availableSpace), attr);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"shape\", {\n    get: function () {\n      var _a = this.attributes,\n        trackLength = _a.trackLength,\n        trackSize = _a.trackSize;\n      var _b = __read(this.getOrientVal([[trackLength, trackSize], [trackSize, trackLength]]), 2),\n        width = _b[0],\n        height = _b[1];\n      return {\n        width: width,\n        height: height\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"availableSpace\", {\n    get: function () {\n      var _a = this.attributes,\n        x = _a.x,\n        y = _a.y,\n        padding = _a.padding;\n      var _b = __read(parseSeriesAttr(padding), 4),\n        top = _b[0],\n        right = _b[1],\n        bottom = _b[2],\n        left = _b[3];\n      var _c = this.shape,\n        width = _c.width,\n        height = _c.height;\n      return {\n        x: left,\n        y: top,\n        width: width - (left + right),\n        height: height - (top + bottom)\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Slider.prototype.getValues = function () {\n    return this.values;\n  };\n  /** 不触发重绘 */\n  Slider.prototype.setValues = function (values, animate) {\n    if (values === void 0) {\n      values = [0, 0];\n    }\n    if (animate === void 0) {\n      animate = false;\n    }\n    this.attributes.values = values;\n    var animation = animate === false ? false : this.attributes.animate;\n    this.updateSelectionArea(animation);\n    this.updateHandlesPosition(animation);\n  };\n  Slider.prototype.updateSelectionArea = function (animation) {\n    var newSelectionArea = this.calcSelectionArea();\n    this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).each(function (datum, index) {\n      transition(this, newSelectionArea[index], animation);\n    });\n  };\n  Slider.prototype.updateHandlesPosition = function (animation) {\n    if (!this.attributes.showHandle) return;\n    this.startHandle && transition(this.startHandle, this.getHandleStyle('start'), animation);\n    this.endHandle && transition(this.endHandle, this.getHandleStyle('end'), animation);\n  };\n  Slider.prototype.innerSetValues = function (values, trigger) {\n    if (values === void 0) {\n      values = [0, 0];\n    }\n    if (trigger === void 0) {\n      trigger = false;\n    }\n    var oldValues = this.values;\n    var newValues = this.clampValues(values);\n    this.attributes.values = newValues;\n    this.setValues(newValues);\n    if (trigger) {\n      this.onValueChange(oldValues);\n    }\n  };\n  Slider.prototype.renderTrack = function (container) {\n    var _a = this.attributes,\n      x = _a.x,\n      y = _a.y;\n    var style = subStyleProps(this.attributes, 'track');\n    this.trackShape = select(container).maybeAppendByClassName(CLASS_NAMES.track, 'rect').styles(__assign(__assign({\n      x: x,\n      y: y\n    }, this.shape), style));\n  };\n  Slider.prototype.renderBrushArea = function (container) {\n    var _a = this.attributes,\n      x = _a.x,\n      y = _a.y,\n      brushable = _a.brushable;\n    this.brushArea = select(container).maybeAppendByClassName(CLASS_NAMES.brushArea, 'rect').styles(__assign({\n      x: x,\n      y: y,\n      fill: 'transparent',\n      cursor: brushable ? 'crosshair' : 'default'\n    }, this.shape));\n  };\n  Slider.prototype.renderSparkline = function (container) {\n    var _this = this;\n    var _a = this.attributes,\n      x = _a.x,\n      y = _a.y,\n      orientation = _a.orientation;\n    var sparklineGroup = select(container).maybeAppendByClassName(CLASS_NAMES.sparklineGroup, 'g');\n    ifShow(orientation === 'horizontal', sparklineGroup, function (group) {\n      var style = __assign(__assign({}, _this.sparklineStyle), {\n        x: x,\n        y: y\n      });\n      group.maybeAppendByClassName(CLASS_NAMES.sparkline, function () {\n        return new Sparkline({\n          style: style\n        });\n      }).update(style);\n    });\n  };\n  Slider.prototype.renderHandles = function () {\n    var _this = this;\n    var _a;\n    var _b = this.attributes,\n      showHandle = _b.showHandle,\n      type = _b.type;\n    var availableHandle = type === 'range' ? ['start', 'end'] : ['end'];\n    var data = showHandle ? availableHandle : [];\n    var that = this;\n    (_a = this.foregroundGroup) === null || _a === void 0 ? void 0 : _a.selectAll(CLASS_NAMES.handle.class).data(data.map(function (type) {\n      return {\n        type: type\n      };\n    }), function (d) {\n      return d.type;\n    }).join(function (enter) {\n      return enter.append(function (_a) {\n        var type = _a.type;\n        return new Handle({\n          style: _this.getHandleStyle(type)\n        });\n      }).each(function (_a) {\n        var type = _a.type;\n        this.attr('class', \"\".concat(CLASS_NAMES.handle.name, \" \").concat(type, \"-handle\"));\n        var name = \"\".concat(type, \"Handle\");\n        that[name] = this;\n        this.addEventListener('pointerdown', that.onDragStart(type));\n      });\n    }, function (update) {\n      return update.each(function (_a) {\n        var type = _a.type;\n        this.update(that.getHandleStyle(type));\n      });\n    }, function (exit) {\n      return exit.each(function (_a) {\n        var type = _a.type;\n        var name = \"\".concat(type, \"Handle\");\n        that[name] = undefined;\n      }).remove();\n    });\n  };\n  Slider.prototype.renderSelection = function (container) {\n    var _a = this.attributes,\n      x = _a.x,\n      y = _a.y,\n      type = _a.type,\n      selectionType = _a.selectionType;\n    this.foregroundGroup = select(container).maybeAppendByClassName(CLASS_NAMES.foreground, 'g');\n    // value 类型的 slider 不渲染选区\n    var selectionStyle = subStyleProps(this.attributes, 'selection');\n    var applyStyle = function (selection) {\n      return selection.style('visibility', function (d) {\n        return d.show ? 'visible' : 'hidden';\n      }).style('cursor', function (d) {\n        if (selectionType === 'select') return 'grab';\n        if (selectionType === 'invert') return 'crosshair';\n        return 'default';\n      }).styles(__assign(__assign({}, selectionStyle), {\n        transform: \"translate(\".concat(x, \", \").concat(y, \")\")\n      }));\n    };\n    var that = this;\n    this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).data(type === 'value' ? [] : this.calcSelectionArea().map(function (area, index) {\n      return {\n        style: __assign({}, area),\n        index: index,\n        // 是否可见\n        show: selectionType === 'select' ? index === 1 : index !== 1\n      };\n    }), function (d) {\n      return d.index;\n    }).join(function (enter) {\n      return enter.append('rect').attr('className', CLASS_NAMES.selection.name).call(applyStyle).each(function (datum, index) {\n        var _this = this;\n        if (index === 1) {\n          that.selectionShape = select(this);\n          // 选区drag事件\n          this.on('pointerdown', function (e) {\n            _this.attr('cursor', 'grabbing');\n            that.onDragStart('selection')(e);\n          });\n          // 选区hover事件\n          that.dispatchCustomEvent(this, 'pointerenter', 'selectionMouseenter');\n          that.dispatchCustomEvent(this, 'pointerleave', 'selectionMouseleave');\n          that.dispatchCustomEvent(this, 'click', 'selectionClick');\n          // 拖拽交互\n          this.addEventListener('pointerdown', function () {\n            _this.attr('cursor', 'grabbing');\n          });\n          this.addEventListener('pointerup', function () {\n            _this.attr('cursor', 'pointer');\n          });\n          this.addEventListener('pointerover', function () {\n            _this.attr('cursor', 'pointer');\n          });\n        } else {\n          this.on('pointerdown', that.onDragStart('track'));\n        }\n      });\n    }, function (update) {\n      return update.call(applyStyle);\n    }, function (exit) {\n      return exit.remove();\n    });\n    this.updateSelectionArea(false);\n    this.renderHandles();\n  };\n  Slider.prototype.render = function (attributes, container) {\n    this.renderTrack(container);\n    this.renderSparkline(container);\n    this.renderBrushArea(container);\n    this.renderSelection(container);\n  };\n  Slider.prototype.clampValues = function (values, precision) {\n    var _a;\n    if (precision === void 0) {\n      precision = 4;\n    }\n    var _b = __read(this.range, 2),\n      min = _b[0],\n      max = _b[1];\n    var _c = __read(this.getValues().map(function (num) {\n        return toPrecision(num, precision);\n      }), 2),\n      prevStart = _c[0],\n      prevEnd = _c[1];\n    var internalValues = Array.isArray(values) ? values : [prevStart, values !== null && values !== void 0 ? values : prevEnd];\n    var _d = __read((internalValues || [prevStart, prevEnd]).map(function (num) {\n        return toPrecision(num, precision);\n      }), 2),\n      startVal = _d[0],\n      endVal = _d[1];\n    if (this.attributes.type === 'value') return [0, clamp(endVal, min, max)];\n    // 交换startVal endVal\n    if (startVal > endVal) {\n      _a = __read([endVal, startVal], 2), startVal = _a[0], endVal = _a[1];\n    }\n    var range = endVal - startVal;\n    // 超出范围就全选\n    if (range > max - min) return [min, max];\n    if (startVal < min) {\n      if (prevStart === min && prevEnd === endVal) return [min, endVal];\n      return [min, range + min];\n    }\n    if (endVal > max) {\n      if (prevEnd === max && prevStart === startVal) return [startVal, max];\n      return [max - range, max];\n    }\n    // 保留小数\n    return [startVal, endVal];\n  };\n  /**\n   * 计算选区坐标和宽高\n   * 默认用来计算前景位置大小\n   */\n  Slider.prototype.calcSelectionArea = function (values) {\n    var _a = __read(this.clampValues(values), 2),\n      start = _a[0],\n      end = _a[1];\n    var _b = this.availableSpace,\n      x = _b.x,\n      y = _b.y,\n      width = _b.width,\n      height = _b.height;\n    // 中间为选区，两端为反选区\n    return this.getOrientVal([[{\n      y: y,\n      height: height,\n      x: x,\n      width: start * width\n    }, {\n      y: y,\n      height: height,\n      x: start * width + x,\n      width: (end - start) * width\n    }, {\n      y: y,\n      height: height,\n      x: end * width,\n      width: (1 - end) * width\n    }], [{\n      x: x,\n      width: width,\n      y: y,\n      height: start * height\n    }, {\n      x: x,\n      width: width,\n      y: start * height + y,\n      height: (end - start) * height\n    }, {\n      x: x,\n      width: width,\n      y: end * height,\n      height: (1 - end) * height\n    }]]);\n  };\n  /**\n   * 计算手柄的x y\n   */\n  Slider.prototype.calcHandlePosition = function (handleType) {\n    var handleIconOffset = this.attributes.handleIconOffset;\n    var _a = this.availableSpace,\n      x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height;\n    var _b = __read(this.clampValues(), 2),\n      stVal = _b[0],\n      endVal = _b[1];\n    var offset = handleType === 'start' ? -handleIconOffset : handleIconOffset;\n    var L = (handleType === 'start' ? stVal : endVal) * this.getOrientVal([width, height]) + offset;\n    return {\n      x: x + this.getOrientVal([L, width / 2]),\n      y: y + this.getOrientVal([height / 2, L])\n    };\n  };\n  Slider.prototype.inferTextStyle = function (handleType) {\n    var orientation = this.attributes.orientation;\n    if (orientation === 'horizontal') return {};\n    if (handleType === 'start') return {\n      transformOrigin: 'left center',\n      transform: 'rotate(90)',\n      textAlign: 'start'\n    };\n    if (handleType === 'end') return {\n      transformOrigin: 'right center',\n      transform: 'rotate(90)',\n      textAlign: 'end'\n    };\n    return {};\n  };\n  /**\n   * 计算手柄应当处于的位置\n   * @param handleType start手柄还是end手柄\n   * @returns\n   */\n  Slider.prototype.calcHandleText = function (handleType) {\n    var _a;\n    var _b = this.attributes,\n      type = _b.type,\n      orientation = _b.orientation,\n      formatter = _b.formatter,\n      autoFitLabel = _b.autoFitLabel;\n    var handleStyle = subStyleProps(this.attributes, 'handle');\n    var labelStyle = subStyleProps(handleStyle, 'label');\n    var spacing = handleStyle.spacing;\n    var size = this.getHandleSize();\n    var values = this.clampValues();\n    var value = handleType === 'start' ? values[0] : values[1];\n    var text = formatter(value);\n    var temp = new Text({\n      style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), {\n        text: text\n      })\n    });\n    // 文字包围盒的宽高\n    var _c = temp.getBBox(),\n      textWidth = _c.width,\n      textHeight = _c.height;\n    temp.destroy();\n    if (!autoFitLabel) {\n      if (type === 'value') return {\n        text: text,\n        x: 0,\n        y: -textHeight - spacing\n      };\n      var finaleWidth = spacing + size + (orientation === 'horizontal' ? textWidth / 2 : 0);\n      return _a = {\n        text: text\n      }, _a[orientation === 'horizontal' ? 'x' : 'y'] = handleType === 'start' ? -finaleWidth : finaleWidth, _a;\n    }\n    var x = 0;\n    var y = 0;\n    // 相对于获取两端可用空间\n    var _d = this.availableSpace,\n      iW = _d.width,\n      iH = _d.height;\n    var _e = this.calcSelectionArea()[1],\n      fX = _e.x,\n      fY = _e.y,\n      fW = _e.width,\n      fH = _e.height;\n    var totalSpacing = spacing + size;\n    if (orientation === 'horizontal') {\n      var finalWidth = totalSpacing + textWidth / 2;\n      if (handleType === 'start') {\n        var left = fX - totalSpacing - textWidth;\n        x = left > 0 ? -finalWidth : finalWidth;\n      } else {\n        var sign = iW - fX - fW - totalSpacing > textWidth;\n        x = sign ? finalWidth : -finalWidth;\n      }\n    } else {\n      var positiveSize = totalSpacing;\n      var negativeSize = textHeight + totalSpacing;\n      if (handleType === 'start') {\n        y = fY - size > textHeight ? -negativeSize : positiveSize;\n      } else {\n        y = iH - (fY + fH) - size > textHeight ? negativeSize : -positiveSize;\n      }\n    }\n    return {\n      x: x,\n      y: y,\n      text: text\n    };\n  };\n  Slider.prototype.getHandleLabelStyle = function (handleType) {\n    var style = subStyleProps(this.attributes, 'handleLabel');\n    return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));\n  };\n  Slider.prototype.getHandleIconStyle = function () {\n    var shape = this.attributes.handleIconShape;\n    var style = subStyleProps(this.attributes, 'handleIcon');\n    var cursor = this.getOrientVal(['ew-resize', 'ns-resize']);\n    var size = this.getHandleSize();\n    return __assign({\n      cursor: cursor,\n      shape: shape,\n      size: size\n    }, style);\n  };\n  Slider.prototype.getHandleStyle = function (handleType) {\n    var _a = this.attributes,\n      ox = _a.x,\n      oy = _a.y,\n      showLabel = _a.showLabel,\n      showLabelOnInteraction = _a.showLabelOnInteraction,\n      orientation = _a.orientation;\n    var _b = this.calcHandlePosition(handleType),\n      x = _b.x,\n      y = _b.y;\n    var textStyle = this.calcHandleText(handleType);\n    var internalShowLabel = showLabel;\n    if (!showLabel && showLabelOnInteraction) {\n      if (this.target) internalShowLabel = true;else internalShowLabel = false;\n    }\n    return __assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), 'icon')), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), 'label')), {\n      transform: \"translate(\".concat(x + ox, \", \").concat(y + oy, \")\"),\n      orientation: orientation,\n      showLabel: internalShowLabel,\n      type: handleType,\n      zIndex: 3\n    });\n  };\n  Slider.prototype.getHandleSize = function () {\n    var _a = this.attributes,\n      size = _a.handleIconSize,\n      width = _a.width,\n      height = _a.height;\n    if (size) return size;\n    // 没设置 size 的话，高度就取 height + 4 高度，手柄宽度是高度的 1/ 2.4\n    return Math.floor((this.getOrientVal([+height, +width]) + 4) / 2.4);\n  };\n  Slider.prototype.getOrientVal = function (_a) {\n    var _b = __read(_a, 2),\n      x = _b[0],\n      y = _b[1];\n    var orientation = this.attributes.orientation;\n    return orientation === 'horizontal' ? x : y;\n  };\n  Slider.prototype.setValuesOffset = function (stOffset, endOffset, animate) {\n    if (endOffset === void 0) {\n      endOffset = 0;\n    }\n    if (animate === void 0) {\n      animate = false;\n    }\n    var type = this.attributes.type;\n    var _a = __read(this.getValues(), 2),\n      oldStartVal = _a[0],\n      oldEndVal = _a[1];\n    var internalStartOffset = type === 'range' ? stOffset : 0;\n    var values = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();\n    if (animate) this.setValues(values);else this.innerSetValues(values, true);\n  };\n  Slider.prototype.getRatio = function (val) {\n    var _a = this.availableSpace,\n      width = _a.width,\n      height = _a.height;\n    return val / this.getOrientVal([width, height]);\n  };\n  Slider.prototype.dispatchCustomEvent = function (target, event, name) {\n    var _this = this;\n    target.on(event, function (e) {\n      e.stopPropagation();\n      _this.dispatchEvent(new CustomEvent(name, {\n        detail: e\n      }));\n    });\n  };\n  Slider.prototype.bindEvents = function () {\n    // scroll 事件\n    this.addEventListener('wheel', this.onScroll);\n    var brushArea = this.brushArea;\n    this.dispatchCustomEvent(brushArea, 'click', 'trackClick');\n    this.dispatchCustomEvent(brushArea, 'pointerenter', 'trackMouseenter');\n    this.dispatchCustomEvent(brushArea, 'pointerleave', 'trackMouseleave');\n    // Drag and brush\n    brushArea.on('pointerdown', this.onDragStart('track'));\n  };\n  Slider.prototype.onScroll = function (event) {\n    var scrollable = this.attributes.scrollable;\n    if (scrollable) {\n      var deltaX = event.deltaX,\n        deltaY = event.deltaY;\n      var offset = deltaY || deltaX;\n      var deltaVal = this.getRatio(offset);\n      this.setValuesOffset(deltaVal, deltaVal, true);\n    }\n  };\n  Slider.tag = 'slider';\n  return Slider;\n}(Component);\nexport { Slider };","map":{"version":3,"names":["CustomEvent","clamp","transition","Component","Text","getEventPos","ifShow","parseSeriesAttr","select","subStyleProps","superStyleProps","toPrecision","Sparkline","CLASS_NAMES","HANDLE_DEFAULT_CFG","HANDLE_ICON_DEFAULT_CFG","HANDLE_LABEL_DEFAULT_CFG","Handle","Slider","_super","__extends","options","_this","call","__assign","x","y","animate","duration","fill","brushable","formatter","val","toString","handleSpacing","orientation","padding","autoFitLabel","scrollable","selectionFill","selectionFillOpacity","selectionZIndex","showHandle","showLabel","slidable","trackFill","trackLength","trackOpacity","trackSize","trackZIndex","values","type","selectionType","handleIconOffset","range","onDragStart","target","e","stopPropagation","prevPos","getOrientVal","_a","availableSpace","_b","getBBox","X","Y","selectionStartPos","getRatio","selectionWidth","document","addEventListener","onDragging","onDragEnd","attributes","currPos","diffPos","deltaVal","setValuesOffset","innerSetValues","sort","removeEventListener","updateHandlesPosition","onValueChange","oldValue","onChange","internalOldValue","value","getValues","evt","detail","dispatchEvent","Object","defineProperty","prototype","get","set","clampValues","attr","zIndex","__read","width","height","top","right","bottom","left","_c","shape","setValues","animation","updateSelectionArea","newSelectionArea","calcSelectionArea","foregroundGroup","selectAll","selection","class","each","datum","index","startHandle","getHandleStyle","endHandle","trigger","oldValues","newValues","renderTrack","container","style","trackShape","maybeAppendByClassName","track","styles","renderBrushArea","brushArea","cursor","renderSparkline","sparklineGroup","group","sparklineStyle","sparkline","update","renderHandles","availableHandle","data","that","handle","map","d","join","enter","append","concat","name","exit","undefined","remove","renderSelection","foreground","selectionStyle","applyStyle","show","transform","area","selectionShape","on","dispatchCustomEvent","render","precision","min","max","num","prevStart","prevEnd","internalValues","Array","isArray","_d","startVal","endVal","start","end","calcHandlePosition","handleType","stVal","offset","L","inferTextStyle","transformOrigin","textAlign","calcHandleText","handleStyle","labelStyle","spacing","size","getHandleSize","text","temp","textWidth","textHeight","destroy","finaleWidth","iW","iH","_e","fX","fY","fW","fH","totalSpacing","finalWidth","sign","positiveSize","negativeSize","getHandleLabelStyle","getHandleIconStyle","handleIconShape","ox","oy","showLabelOnInteraction","textStyle","internalShowLabel","handleIconSize","Math","floor","stOffset","endOffset","oldStartVal","oldEndVal","internalStartOffset","event","bindEvents","onScroll","deltaX","deltaY","tag"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/component/src/ui/slider/index.ts"],"sourcesContent":["import type { Cursor } from '@antv/g';\nimport { CustomEvent } from '@antv/g';\nimport { clamp } from '@antv/util';\nimport type { GenericAnimation } from '../../animation';\nimport { transition } from '../../animation';\nimport { Component } from '../../core';\nimport { Group, Rect, Text } from '../../shapes';\nimport type { Selection } from '../../util';\nimport { getEventPos, ifShow, parseSeriesAttr, select, subStyleProps, superStyleProps, toPrecision } from '../../util';\nimport type { SparklineStyleProps } from '../sparkline';\nimport { Sparkline } from '../sparkline';\nimport { CLASS_NAMES, HANDLE_DEFAULT_CFG, HANDLE_ICON_DEFAULT_CFG, HANDLE_LABEL_DEFAULT_CFG } from './constant';\nimport type { HandleType, IconStyleProps, LabelStyleProps } from './handle';\nimport { Handle, HandleStyleProps } from './handle';\nimport type { SliderOptions, SliderStyleProps } from './types';\n\nexport type { SliderOptions, SliderStyleProps };\n\nexport class Slider extends Component<SliderStyleProps> {\n  public static tag = 'slider';\n\n  private range = [0, 1];\n\n  public get values(): [number, number] {\n    return this.attributes.values as [number, number];\n  }\n\n  public set values(values: Required<SliderStyleProps>['values']) {\n    this.attributes.values = this.clampValues(values);\n  }\n\n  /** 滑道、背景 */\n  private trackShape!: Selection<Rect>;\n\n  /** 刷选交互区域 */\n  private brushArea!: Selection<Rect>;\n\n  private foregroundGroup!: Selection<Group>;\n\n  /** 前景、选区 */\n  private selectionShape?: Selection<Rect>;\n\n  /** 开始滑块 */\n  private startHandle?: Handle;\n\n  /** 结束滑块 */\n  private endHandle?: Handle;\n\n  /**\n   * 选区开始的位置\n   */\n  private selectionStartPos: number;\n\n  /**\n   * 选区宽度\n   */\n  private selectionWidth: number;\n\n  /**\n   * 记录上一次鼠标事件所在坐标\n   */\n  private prevPos: number;\n\n  /**\n   * drag事件当前选中的对象\n   */\n  private target: string;\n\n  private get sparklineStyle() {\n    const { orientation } = this.attributes;\n    if (orientation !== 'horizontal') return null;\n    const attr = subStyleProps<SparklineStyleProps>(this.attributes, 'sparkline');\n    return { zIndex: 0, ...this.availableSpace, ...attr };\n  }\n\n  private get shape() {\n    const { trackLength, trackSize } = this.attributes;\n    const [width, height] = this.getOrientVal([\n      [trackLength, trackSize],\n      [trackSize, trackLength],\n    ]);\n    return { width, height };\n  }\n\n  private get availableSpace() {\n    const { x, y, padding } = this.attributes;\n    const [top, right, bottom, left] = parseSeriesAttr(padding!);\n    const { width, height } = this.shape;\n    return {\n      x: left,\n      y: top,\n      width: width! - (left + right),\n      height: height! - (top + bottom),\n    };\n  }\n\n  constructor(options: SliderOptions) {\n    super(options, {\n      x: 0,\n      y: 0,\n      animate: { duration: 100, fill: 'both' },\n      brushable: true,\n      formatter: (val: any) => val.toString(),\n      handleSpacing: 2,\n      orientation: 'horizontal',\n      padding: 0,\n      autoFitLabel: true,\n      scrollable: true,\n      selectionFill: '#5B8FF9',\n      selectionFillOpacity: 0.45,\n      selectionZIndex: 2,\n      showHandle: true,\n      showLabel: true,\n      slidable: true,\n      trackFill: '#416180',\n      trackLength: 200,\n      trackOpacity: 0.05,\n      trackSize: 20,\n      trackZIndex: -1,\n      values: [0, 1],\n      type: 'range',\n      selectionType: 'select',\n      handleIconOffset: 0,\n      ...superStyleProps(HANDLE_DEFAULT_CFG, 'handle'),\n      ...superStyleProps(HANDLE_ICON_DEFAULT_CFG, 'handleIcon'),\n      ...superStyleProps(HANDLE_LABEL_DEFAULT_CFG, 'handleLabel'),\n    });\n\n    this.selectionStartPos = 0;\n    this.selectionWidth = 0;\n    this.prevPos = 0;\n    this.target = '';\n  }\n\n  public getValues() {\n    return this.values as [number, number];\n  }\n\n  /** 不触发重绘 */\n  public setValues(values: Required<SliderStyleProps>['values'] = [0, 0], animate: boolean = false) {\n    this.attributes.values = values;\n    const animation = animate === false ? false : this.attributes.animate;\n\n    this.updateSelectionArea(animation);\n    this.updateHandlesPosition(animation);\n  }\n\n  private updateSelectionArea(animation: GenericAnimation) {\n    const newSelectionArea = this.calcSelectionArea();\n    this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).each(function (datum, index) {\n      transition(this, newSelectionArea[index], animation);\n    });\n  }\n\n  private updateHandlesPosition(animation: GenericAnimation) {\n    if (!this.attributes.showHandle) return;\n    this.startHandle && transition(this.startHandle, this.getHandleStyle('start'), animation);\n    this.endHandle && transition(this.endHandle, this.getHandleStyle('end'), animation);\n  }\n\n  private innerSetValues(values: Required<SliderStyleProps>['values'] = [0, 0], trigger: boolean = false) {\n    const oldValues = this.values;\n    const newValues = this.clampValues(values);\n    this.attributes.values = newValues;\n    this.setValues(newValues);\n    if (trigger) {\n      this.onValueChange(oldValues);\n    }\n  }\n\n  private renderTrack(container: Group) {\n    const { x, y } = this.attributes;\n    const style = subStyleProps(this.attributes, 'track');\n\n    this.trackShape = select(container)\n      .maybeAppendByClassName(CLASS_NAMES.track, 'rect')\n      .styles({ x, y, ...this.shape, ...style });\n  }\n\n  private renderBrushArea(container: Group) {\n    const { x, y, brushable } = this.attributes;\n    this.brushArea = select(container)\n      .maybeAppendByClassName(CLASS_NAMES.brushArea, 'rect')\n      .styles({\n        x,\n        y,\n        fill: 'transparent',\n        cursor: brushable ? 'crosshair' : 'default',\n        ...this.shape,\n      });\n  }\n\n  private renderSparkline(container: Group) {\n    const { x, y, orientation } = this.attributes;\n    const sparklineGroup = select(container).maybeAppendByClassName(CLASS_NAMES.sparklineGroup, 'g');\n\n    ifShow(orientation === 'horizontal', sparklineGroup, (group) => {\n      const style = { ...this.sparklineStyle!, x, y };\n      group.maybeAppendByClassName(CLASS_NAMES.sparkline, () => new Sparkline({ style })).update(style);\n    });\n  }\n\n  private renderHandles() {\n    const { showHandle, type } = this.attributes;\n    const availableHandle: HandleType[] = type === 'range' ? ['start', 'end'] : ['end'];\n    const data = showHandle ? availableHandle : [];\n    const that = this;\n\n    this.foregroundGroup\n      ?.selectAll(CLASS_NAMES.handle.class)\n      .data(\n        data.map((type) => ({ type })),\n        (d) => d.type\n      )\n      .join(\n        (enter) =>\n          enter\n            .append(({ type }) => new Handle({ style: this.getHandleStyle(type) }))\n            .each(function ({ type }) {\n              this.attr('class', `${CLASS_NAMES.handle.name} ${type}-handle`);\n              const name = `${type}Handle` as `${HandleType}Handle`;\n              that[name] = this;\n              this.addEventListener('pointerdown', that.onDragStart(type));\n            }),\n        (update) =>\n          update.each(function ({ type }) {\n            this.update(that.getHandleStyle(type));\n          }),\n        (exit) =>\n          exit\n            .each(({ type }) => {\n              const name = `${type}Handle` as `${HandleType}Handle`;\n              that[name] = undefined;\n            })\n            .remove()\n      );\n  }\n\n  private renderSelection(container: Group) {\n    const { x, y, type, selectionType } = this.attributes;\n    this.foregroundGroup = select(container).maybeAppendByClassName(CLASS_NAMES.foreground, 'g');\n\n    // value 类型的 slider 不渲染选区\n    const selectionStyle = subStyleProps(this.attributes, 'selection');\n    const applyStyle = (selection: Selection) => {\n      return selection\n        .style('visibility', (d: any) => (d.show ? 'visible' : 'hidden'))\n        .style('cursor', (d: any) => {\n          if (selectionType === 'select') return 'grab';\n          if (selectionType === 'invert') return 'crosshair';\n          return 'default';\n        })\n        .styles({\n          ...selectionStyle,\n          transform: `translate(${x}, ${y})`,\n        });\n    };\n\n    const that = this;\n    this.foregroundGroup\n      .selectAll(CLASS_NAMES.selection.class)\n      .data(\n        type === 'value'\n          ? []\n          : this.calcSelectionArea().map((area, index) => ({\n              style: {\n                ...area,\n              },\n              index,\n              // 是否可见\n              show: selectionType === 'select' ? index === 1 : index !== 1,\n            })),\n        (d) => d.index\n      )\n      .join(\n        (enter) =>\n          enter\n            .append('rect')\n            .attr('className', CLASS_NAMES.selection.name)\n            .call(applyStyle)\n            .each(function (datum, index) {\n              if (index === 1) {\n                that.selectionShape = select(this);\n                // 选区drag事件\n                this.on('pointerdown', (e: any) => {\n                  this.attr('cursor', 'grabbing');\n                  that.onDragStart('selection')(e);\n                });\n                // 选区hover事件\n                that.dispatchCustomEvent(this, 'pointerenter', 'selectionMouseenter');\n                that.dispatchCustomEvent(this, 'pointerleave', 'selectionMouseleave');\n                that.dispatchCustomEvent(this, 'click', 'selectionClick');\n\n                // 拖拽交互\n                this.addEventListener('pointerdown', () => {\n                  this.attr('cursor', 'grabbing');\n                });\n                this.addEventListener('pointerup', () => {\n                  this.attr('cursor', 'pointer');\n                });\n                this.addEventListener('pointerover', () => {\n                  this.attr('cursor', 'pointer');\n                });\n              } else {\n                this.on('pointerdown', that.onDragStart('track'));\n              }\n            }),\n        (update) => update.call(applyStyle),\n        (exit) => exit.remove()\n      );\n    this.updateSelectionArea(false);\n    this.renderHandles();\n  }\n\n  public render(attributes: SliderStyleProps, container: Group) {\n    this.renderTrack(container);\n    this.renderSparkline(container);\n    this.renderBrushArea(container);\n    this.renderSelection(container);\n  }\n\n  private clampValues(values?: Required<SliderStyleProps>['values'], precision = 4): [number, number] {\n    const [min, max] = this.range;\n    const [prevStart, prevEnd] = this.getValues().map((num) => toPrecision(num, precision));\n    const internalValues = Array.isArray(values) ? values : [prevStart, values ?? prevEnd];\n    let [startVal, endVal] = (internalValues || [prevStart, prevEnd]).map((num) => toPrecision(num, precision));\n\n    if (this.attributes.type === 'value') return [0, clamp(endVal, min, max)];\n\n    // 交换startVal endVal\n    if (startVal > endVal) {\n      [startVal, endVal] = [endVal, startVal];\n    }\n    const range = endVal - startVal;\n    // 超出范围就全选\n    if (range > max - min) return [min, max];\n\n    if (startVal < min) {\n      if (prevStart === min && prevEnd === endVal) return [min, endVal];\n      return [min, range + min];\n    }\n    if (endVal > max) {\n      if (prevEnd === max && prevStart === startVal) return [startVal, max];\n      return [max - range, max];\n    }\n\n    // 保留小数\n    return [startVal, endVal];\n  }\n\n  /**\n   * 计算选区坐标和宽高\n   * 默认用来计算前景位置大小\n   */\n  private calcSelectionArea(values?: [number, number]) {\n    const [start, end] = this.clampValues(values);\n    const { x, y, width, height } = this.availableSpace;\n\n    // 中间为选区，两端为反选区\n    return this.getOrientVal([\n      [\n        { y, height, x, width: start * width },\n        { y, height, x: start * width + x, width: (end - start) * width },\n        { y, height, x: end * width, width: (1 - end) * width },\n      ],\n      [\n        { x, width, y, height: start * height },\n        { x, width, y: start * height + y, height: (end - start) * height },\n        { x, width, y: end * height, height: (1 - end) * height },\n      ],\n    ]);\n  }\n\n  /**\n   * 计算手柄的x y\n   */\n  private calcHandlePosition(handleType: HandleType) {\n    const { handleIconOffset } = this.attributes;\n    const { x, y, width, height } = this.availableSpace;\n    const [stVal, endVal] = this.clampValues();\n    const offset = handleType === 'start' ? -handleIconOffset : handleIconOffset;\n    const L = (handleType === 'start' ? stVal : endVal) * this.getOrientVal([width, height]) + offset;\n    return {\n      x: x + this.getOrientVal([L, width / 2]),\n      y: y + this.getOrientVal([height / 2, L]),\n    };\n  }\n\n  private inferTextStyle(handleType: HandleType): Record<string, any> {\n    const { orientation } = this.attributes;\n    if (orientation === 'horizontal') return {};\n    if (handleType === 'start') return { transformOrigin: 'left center', transform: 'rotate(90)', textAlign: 'start' };\n    if (handleType === 'end') return { transformOrigin: 'right center', transform: 'rotate(90)', textAlign: 'end' };\n    return {};\n  }\n\n  /**\n   * 计算手柄应当处于的位置\n   * @param handleType start手柄还是end手柄\n   * @returns\n   */\n  private calcHandleText(handleType: HandleType) {\n    const { type, orientation, formatter, autoFitLabel } = this.attributes;\n    const handleStyle = subStyleProps(this.attributes, 'handle');\n    const labelStyle = subStyleProps(handleStyle, 'label');\n    const { spacing } = handleStyle;\n    const size = this.getHandleSize();\n    const values = this.clampValues();\n\n    const value = handleType === 'start' ? values[0] : values[1];\n    const text = formatter(value);\n\n    const temp = new Text({\n      style: {\n        ...labelStyle,\n        ...this.inferTextStyle(handleType),\n        text,\n      },\n    });\n    // 文字包围盒的宽高\n    const { width: textWidth, height: textHeight } = temp.getBBox();\n    temp.destroy();\n\n    if (!autoFitLabel) {\n      if (type === 'value') return { text, x: 0, y: -textHeight - spacing };\n      const finaleWidth = spacing + size + (orientation === 'horizontal' ? textWidth / 2 : 0);\n      return { text, [orientation === 'horizontal' ? 'x' : 'y']: handleType === 'start' ? -finaleWidth : finaleWidth };\n    }\n\n    let x = 0;\n    let y = 0;\n    // 相对于获取两端可用空间\n    const { width: iW, height: iH } = this.availableSpace;\n    const { x: fX, y: fY, width: fW, height: fH } = this.calcSelectionArea()[1];\n    const totalSpacing = spacing + size;\n    if (orientation === 'horizontal') {\n      const finalWidth = totalSpacing + textWidth / 2;\n      if (handleType === 'start') {\n        const left = fX - totalSpacing - textWidth;\n        x = left > 0 ? -finalWidth : finalWidth;\n      } else {\n        const sign = iW - fX - fW - totalSpacing > textWidth;\n        x = sign ? finalWidth : -finalWidth;\n      }\n    } else {\n      const positiveSize = totalSpacing;\n      const negativeSize = textHeight + totalSpacing;\n      if (handleType === 'start') {\n        y = fY - size > textHeight ? -negativeSize : positiveSize;\n      } else {\n        y = iH - (fY + fH) - size > textHeight ? negativeSize : -positiveSize;\n      }\n    }\n    return { x, y, text };\n  }\n\n  private getHandleLabelStyle(handleType: HandleType): LabelStyleProps {\n    const style = subStyleProps(this.attributes, 'handleLabel');\n    return {\n      ...style,\n      ...this.calcHandleText(handleType),\n      ...this.inferTextStyle(handleType),\n    };\n  }\n\n  private getHandleIconStyle(): IconStyleProps {\n    const { handleIconShape: shape } = this.attributes;\n    const style = subStyleProps(this.attributes, 'handleIcon');\n    const cursor = this.getOrientVal(['ew-resize', 'ns-resize']) as Cursor;\n    const size = this.getHandleSize();\n\n    return {\n      cursor,\n      shape,\n      size,\n      ...style,\n    };\n  }\n\n  private getHandleStyle(handleType: HandleType): HandleStyleProps {\n    const { x: ox, y: oy, showLabel, showLabelOnInteraction, orientation } = this.attributes;\n    const { x, y } = this.calcHandlePosition(handleType);\n    const textStyle = this.calcHandleText(handleType);\n\n    let internalShowLabel = showLabel;\n    if (!showLabel && showLabelOnInteraction) {\n      if (this.target) internalShowLabel = true;\n      else internalShowLabel = false;\n    }\n\n    return {\n      ...superStyleProps(this.getHandleIconStyle(), 'icon'),\n      ...superStyleProps({ ...this.getHandleLabelStyle(handleType), ...textStyle }, 'label'),\n      transform: `translate(${x + ox}, ${y + oy})`,\n      orientation,\n      showLabel: internalShowLabel,\n      type: handleType,\n      zIndex: 3,\n    } as const;\n  }\n\n  private getHandleSize() {\n    const { handleIconSize: size, width, height } = this.attributes;\n    if (size) return size;\n    // 没设置 size 的话，高度就取 height + 4 高度，手柄宽度是高度的 1/ 2.4\n    return Math.floor((this.getOrientVal([+height!, +width!]) + 4) / 2.4);\n  }\n\n  private getOrientVal<T>([x, y]: [T, T]): T {\n    const { orientation } = this.attributes;\n    return orientation === 'horizontal' ? x : y;\n  }\n\n  private setValuesOffset(stOffset: number, endOffset: number = 0, animate: boolean = false) {\n    const { type } = this.attributes;\n    const [oldStartVal, oldEndVal] = this.getValues();\n    const internalStartOffset = type === 'range' ? stOffset : 0;\n    const values = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort() as [number, number];\n    if (animate) this.setValues(values);\n    else this.innerSetValues(values, true);\n  }\n\n  private getRatio(val: number) {\n    const { width, height } = this.availableSpace;\n    return val / this.getOrientVal([width, height]);\n  }\n\n  private dispatchCustomEvent(target: Selection, event: string, name: string) {\n    target.on(event, (e: MouseEvent) => {\n      e.stopPropagation();\n      this.dispatchEvent(new CustomEvent(name, { detail: e }));\n    });\n  }\n\n  public bindEvents() {\n    // scroll 事件\n    this.addEventListener('wheel', this.onScroll);\n    const brushArea = this.brushArea;\n    this.dispatchCustomEvent(brushArea, 'click', 'trackClick');\n    this.dispatchCustomEvent(brushArea, 'pointerenter', 'trackMouseenter');\n    this.dispatchCustomEvent(brushArea, 'pointerleave', 'trackMouseleave');\n    // Drag and brush\n    brushArea.on('pointerdown', this.onDragStart('track'));\n  }\n\n  private onScroll(event: WheelEvent) {\n    const { scrollable } = this.attributes;\n    if (scrollable) {\n      const { deltaX, deltaY } = event;\n      const offset = deltaY || deltaX;\n      const deltaVal = this.getRatio(offset);\n\n      this.setValuesOffset(deltaVal, deltaVal, true);\n    }\n  }\n\n  private onDragStart = (target: string) => (e: any) => {\n    e.stopPropagation();\n    this.target = target;\n    this.prevPos = this.getOrientVal(getEventPos(e));\n    const { x, y } = this.availableSpace;\n    const { x: X, y: Y } = this.getBBox();\n    this.selectionStartPos = this.getRatio(this.prevPos - this.getOrientVal([x, y]) - this.getOrientVal([+X!, +Y!]));\n    this.selectionWidth = 0;\n    document.addEventListener('pointermove', this.onDragging);\n    document.addEventListener('pointerup', this.onDragEnd);\n  };\n\n  private onDragging = (e: any) => {\n    const { slidable, brushable, type } = this.attributes;\n    e.stopPropagation();\n\n    const currPos = this.getOrientVal(getEventPos(e));\n    const diffPos = currPos - this.prevPos;\n\n    if (!diffPos) return;\n    const deltaVal = this.getRatio(diffPos);\n\n    switch (this.target) {\n      case 'start':\n        if (slidable) this.setValuesOffset(deltaVal);\n        break;\n      case 'end':\n        if (slidable) this.setValuesOffset(0, deltaVal);\n        break;\n      case 'selection':\n        if (slidable) this.setValuesOffset(deltaVal, deltaVal);\n        break;\n      case 'track':\n        if (!brushable) return;\n        // 绘制蒙板\n        this.selectionWidth += deltaVal;\n        if (type === 'range') {\n          this.innerSetValues(\n            [this.selectionStartPos, this.selectionStartPos + this.selectionWidth].sort() as [number, number],\n            true\n          );\n        } else this.innerSetValues([0, this.selectionStartPos + this.selectionWidth], true);\n\n        break;\n      default:\n        break;\n    }\n\n    this.prevPos = currPos;\n  };\n\n  private onDragEnd = () => {\n    document.removeEventListener('pointermove', this.onDragging);\n    document.removeEventListener('pointermove', this.onDragging);\n    document.removeEventListener('pointerup', this.onDragEnd);\n    this.target = '';\n    // 更新 handle 状态\n    this.updateHandlesPosition(false);\n  };\n\n  private onValueChange = (oldValue: [number, number]) => {\n    const { onChange, type } = this.attributes;\n    const internalOldValue = type === 'range' ? oldValue : oldValue[1];\n    const value = type === 'range' ? this.getValues() : this.getValues()[1];\n    const evt = new CustomEvent('valuechange', {\n      detail: { oldValue: internalOldValue, value },\n    });\n    this.dispatchEvent(evt);\n    onChange?.(value);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}