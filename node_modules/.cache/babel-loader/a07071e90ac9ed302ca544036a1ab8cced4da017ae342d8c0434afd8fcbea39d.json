{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Line } from '@antv/g';\nimport { isEqual } from '@antv/util';\nimport { NodeEvent } from '../../constants';\nimport { isVisible } from '../../utils/element';\nimport { divide } from '../../utils/vector';\nimport { BasePlugin } from '../base-plugin';\nconst defaultLineStyle = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  visibility: 'hidden'\n};\n/**\n * <zh/> 对齐线插件\n *\n * <en/> Snapline plugin\n */\nexport class Snapline extends BasePlugin {\n  constructor(context, options) {\n    super(context, Object.assign({}, Snapline.defaultOptions, options));\n    this.initSnapline = () => {\n      const canvas = this.context.canvas.getLayer('transient');\n      if (!this.horizontalLine) {\n        this.horizontalLine = canvas.appendChild(new Line({\n          style: Object.assign(Object.assign({}, defaultLineStyle), this.options.horizontalLineStyle)\n        }));\n      }\n      if (!this.verticalLine) {\n        this.verticalLine = canvas.appendChild(new Line({\n          style: Object.assign(Object.assign({}, defaultLineStyle), this.options.verticalLineStyle)\n        }));\n      }\n    };\n    this.isHorizontalSticking = false;\n    this.isVerticalSticking = false;\n    this.enableStick = true;\n    this.autoSnapToLine = (nodeId, bbox, metadata) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        verticalX,\n        horizontalY\n      } = metadata;\n      const {\n        tolerance\n      } = this.options;\n      const {\n        min: [nodeMinX, nodeMinY],\n        max: [nodeMaxX, nodeMaxY],\n        center: [nodeCenterX, nodeCenterY]\n      } = bbox;\n      let dx = 0;\n      let dy = 0;\n      if (verticalX !== null) {\n        if (distance(nodeMaxX, verticalX) < tolerance) dx = verticalX - nodeMaxX;\n        if (distance(nodeMinX, verticalX) < tolerance) dx = verticalX - nodeMinX;\n        if (distance(nodeCenterX, verticalX) < tolerance) dx = verticalX - nodeCenterX;\n        if (dx !== 0) this.isVerticalSticking = true;\n      }\n      if (horizontalY !== null) {\n        if (distance(nodeMaxY, horizontalY) < tolerance) dy = horizontalY - nodeMaxY;\n        if (distance(nodeMinY, horizontalY) < tolerance) dy = horizontalY - nodeMinY;\n        if (distance(nodeCenterY, horizontalY) < tolerance) dy = horizontalY - nodeCenterY;\n        if (dy !== 0) this.isHorizontalSticking = true;\n      }\n      if (dx !== 0 || dy !== 0) {\n        // Stick to the line\n        yield this.context.graph.translateElementBy({\n          [nodeId]: [dx, dy]\n        }, false);\n      }\n    });\n    this.enableSnap = event => {\n      const {\n        target\n      } = event;\n      const threshold = 0.5;\n      if (this.isHorizontalSticking || this.isVerticalSticking) {\n        const [dx, dy] = this.getDelta(event);\n        if (this.isHorizontalSticking && this.isVerticalSticking && Math.abs(dx) <= threshold && Math.abs(dy) <= threshold) {\n          this.context.graph.translateElementBy({\n            [target.id]: [-dx, -dy]\n          }, false);\n          return false;\n        } else if (this.isHorizontalSticking && Math.abs(dy) <= threshold) {\n          this.context.graph.translateElementBy({\n            [target.id]: [0, -dy]\n          }, false);\n          return false;\n        } else if (this.isVerticalSticking && Math.abs(dx) <= threshold) {\n          this.context.graph.translateElementBy({\n            [target.id]: [-dx, 0]\n          }, false);\n          return false;\n        } else {\n          this.isHorizontalSticking = false;\n          this.isVerticalSticking = false;\n          this.enableStick = false;\n          setTimeout(() => {\n            this.enableStick = true;\n          }, 200);\n        }\n      }\n      return this.enableStick;\n    };\n    this.calcSnaplineMetadata = (target, nodeBBox) => {\n      const {\n        tolerance,\n        shape\n      } = this.options;\n      const {\n        min: [nodeMinX, nodeMinY],\n        max: [nodeMaxX, nodeMaxY],\n        center: [nodeCenterX, nodeCenterY]\n      } = nodeBBox;\n      let verticalX = null;\n      let verticalMinY = null;\n      let verticalMaxY = null;\n      let horizontalY = null;\n      let horizontalMinX = null;\n      let horizontalMaxX = null;\n      this.getNodes().some(snapNode => {\n        if (isEqual(target.id, snapNode.id)) return false;\n        const snapBBox = getShape(snapNode, shape).getRenderBounds();\n        const {\n          min: [snapMinX, snapMinY],\n          max: [snapMaxX, snapMaxY],\n          center: [snapCenterX, snapCenterY]\n        } = snapBBox;\n        if (verticalX === null) {\n          if (distance(snapCenterX, nodeCenterX) < tolerance) {\n            verticalX = snapCenterX;\n          } else if (distance(snapMinX, nodeMinX) < tolerance) {\n            verticalX = snapMinX;\n          } else if (distance(snapMinX, nodeMaxX) < tolerance) {\n            verticalX = snapMinX;\n          } else if (distance(snapMaxX, nodeMaxX) < tolerance) {\n            verticalX = snapMaxX;\n          } else if (distance(snapMaxX, nodeMinX) < tolerance) {\n            verticalX = snapMaxX;\n          }\n          if (verticalX !== null) {\n            verticalMinY = Math.min(snapMinY, nodeMinY);\n            verticalMaxY = Math.max(snapMaxY, nodeMaxY);\n          }\n        }\n        if (horizontalY === null) {\n          if (distance(snapCenterY, nodeCenterY) < tolerance) {\n            horizontalY = snapCenterY;\n          } else if (distance(snapMinY, nodeMinY) < tolerance) {\n            horizontalY = snapMinY;\n          } else if (distance(snapMinY, nodeMaxY) < tolerance) {\n            horizontalY = snapMinY;\n          } else if (distance(snapMaxY, nodeMaxY) < tolerance) {\n            horizontalY = snapMaxY;\n          } else if (distance(snapMaxY, nodeMinY) < tolerance) {\n            horizontalY = snapMaxY;\n          }\n          if (horizontalY !== null) {\n            horizontalMinX = Math.min(snapMinX, nodeMinX);\n            horizontalMaxX = Math.max(snapMaxX, nodeMaxX);\n          }\n        }\n        return verticalX !== null && horizontalY !== null;\n      });\n      return {\n        verticalX,\n        verticalMinY,\n        verticalMaxY,\n        horizontalY,\n        horizontalMinX,\n        horizontalMaxX\n      };\n    };\n    this.onDragStart = () => {\n      this.initSnapline();\n    };\n    this.onDrag = event => __awaiter(this, void 0, void 0, function* () {\n      const {\n        target\n      } = event;\n      if (this.options.autoSnap) {\n        const enable = this.enableSnap(event);\n        if (!enable) return;\n      }\n      const nodeBBox = getShape(target, this.options.shape).getRenderBounds();\n      const metadata = this.calcSnaplineMetadata(target, nodeBBox);\n      this.hideSnapline();\n      if (metadata.verticalX !== null || metadata.horizontalY !== null) {\n        this.updateSnapline(metadata);\n      }\n      if (this.options.autoSnap) {\n        yield this.autoSnapToLine(target.id, nodeBBox, metadata);\n      }\n    });\n    this.onDragEnd = () => {\n      this.hideSnapline();\n    };\n    this.bindEvents();\n  }\n  getNodes() {\n    var _a;\n    const {\n      filter\n    } = this.options;\n    const allNodes = ((_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getNodes()) || [];\n    // 不考虑超出画布视口范围、不可见的节点\n    // Nodes that are out of the canvas viewport range, invisible are not considered\n    const nodes = allNodes.filter(node => {\n      var _a;\n      return isVisible(node) && ((_a = this.context.viewport) === null || _a === void 0 ? void 0 : _a.isInViewport(node.getRenderBounds()));\n    });\n    if (!filter) return nodes;\n    return nodes.filter(node => filter(node));\n  }\n  hideSnapline() {\n    this.horizontalLine.style.visibility = 'hidden';\n    this.verticalLine.style.visibility = 'hidden';\n  }\n  getLineWidth(direction) {\n    const {\n      lineWidth\n    } = this.options[`${direction}LineStyle`];\n    return +(lineWidth || defaultLineStyle.lineWidth || 1) / this.context.graph.getZoom();\n  }\n  updateSnapline(metadata) {\n    const {\n      verticalX,\n      verticalMinY,\n      verticalMaxY,\n      horizontalY,\n      horizontalMinX,\n      horizontalMaxX\n    } = metadata;\n    const [canvasWidth, canvasHeight] = this.context.canvas.getSize();\n    const {\n      offset\n    } = this.options;\n    if (horizontalY !== null) {\n      Object.assign(this.horizontalLine.style, {\n        x1: offset === Infinity ? 0 : horizontalMinX - offset,\n        y1: horizontalY,\n        x2: offset === Infinity ? canvasWidth : horizontalMaxX + offset,\n        y2: horizontalY,\n        visibility: 'visible',\n        lineWidth: this.getLineWidth('horizontal')\n      });\n    } else {\n      this.horizontalLine.style.visibility = 'hidden';\n    }\n    if (verticalX !== null) {\n      Object.assign(this.verticalLine.style, {\n        x1: verticalX,\n        y1: offset === Infinity ? 0 : verticalMinY - offset,\n        x2: verticalX,\n        y2: offset === Infinity ? canvasHeight : verticalMaxY + offset,\n        visibility: 'visible',\n        lineWidth: this.getLineWidth('vertical')\n      });\n    } else {\n      this.verticalLine.style.visibility = 'hidden';\n    }\n  }\n  /**\n   * Get the delta of the drag\n   * @param event - drag event object\n   * @returns delta\n   * @internal\n   */\n  getDelta(event) {\n    const zoom = this.context.graph.getZoom();\n    return divide([event.dx, event.dy], zoom);\n  }\n  bindEvents() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        graph\n      } = this.context;\n      graph.on(NodeEvent.DRAG_START, this.onDragStart);\n      graph.on(NodeEvent.DRAG, this.onDrag);\n      graph.on(NodeEvent.DRAG_END, this.onDragEnd);\n    });\n  }\n  unbindEvents() {\n    const {\n      graph\n    } = this.context;\n    graph.off(NodeEvent.DRAG_START, this.onDragStart);\n    graph.off(NodeEvent.DRAG, this.onDrag);\n    graph.off(NodeEvent.DRAG_END, this.onDragEnd);\n  }\n  destroyElements() {\n    var _a, _b;\n    (_a = this.horizontalLine) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this.verticalLine) === null || _b === void 0 ? void 0 : _b.destroy();\n  }\n  destroy() {\n    this.destroyElements();\n    this.unbindEvents();\n    super.destroy();\n  }\n}\nSnapline.defaultOptions = {\n  tolerance: 5,\n  offset: 20,\n  autoSnap: true,\n  shape: 'key',\n  verticalLineStyle: {\n    stroke: '#1783FF'\n  },\n  horizontalLineStyle: {\n    stroke: '#1783FF'\n  },\n  filter: () => true\n};\nconst distance = (a, b) => Math.abs(a - b);\nconst getShape = (node, shapeFilter) => {\n  return typeof shapeFilter === 'function' ? shapeFilter(node) : node.getShape(shapeFilter);\n};","map":{"version":3,"names":["Line","isEqual","NodeEvent","isVisible","divide","BasePlugin","defaultLineStyle","x1","y1","x2","y2","visibility","Snapline","constructor","context","options","Object","assign","defaultOptions","initSnapline","canvas","getLayer","horizontalLine","appendChild","style","horizontalLineStyle","verticalLine","verticalLineStyle","isHorizontalSticking","isVerticalSticking","enableStick","autoSnapToLine","nodeId","bbox","metadata","__awaiter","verticalX","horizontalY","tolerance","min","nodeMinX","nodeMinY","max","nodeMaxX","nodeMaxY","center","nodeCenterX","nodeCenterY","dx","dy","distance","graph","translateElementBy","enableSnap","event","target","threshold","getDelta","Math","abs","id","setTimeout","calcSnaplineMetadata","nodeBBox","shape","verticalMinY","verticalMaxY","horizontalMinX","horizontalMaxX","getNodes","some","snapNode","snapBBox","getShape","getRenderBounds","snapMinX","snapMinY","snapMaxX","snapMaxY","snapCenterX","snapCenterY","onDragStart","onDrag","autoSnap","enable","hideSnapline","updateSnapline","onDragEnd","bindEvents","filter","allNodes","_a","element","nodes","node","viewport","isInViewport","getLineWidth","direction","lineWidth","getZoom","canvasWidth","canvasHeight","getSize","offset","Infinity","zoom","on","DRAG_START","DRAG","DRAG_END","unbindEvents","off","destroyElements","destroy","_b","stroke","a","b","shapeFilter"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/plugins/snapline/index.ts"],"sourcesContent":["import { AABB, BaseStyleProps, DisplayObject, Line, LineStyleProps } from '@antv/g';\nimport { isEqual } from '@antv/util';\nimport { NodeEvent } from '../../constants';\nimport type { RuntimeContext } from '../../runtime/types';\nimport type { ID, IDragEvent, Node } from '../../types';\nimport { isVisible } from '../../utils/element';\nimport { divide } from '../../utils/vector';\nimport type { BasePluginOptions } from '../base-plugin';\nimport { BasePlugin } from '../base-plugin';\n\n/**\n * <zh/> 对齐线插件配置项\n *\n * <en/> Snapline plugin options\n */\nexport interface SnaplineOptions extends BasePluginOptions {\n  /**\n   * <zh/> 对齐精度，即移动节点时与目标位置的距离小于 tolerance 时触发显示对齐线\n   *\n   * <en/> The alignment accuracy, that is, when the distance between the moved node and the target position is less than tolerance, the alignment line is displayed\n   * @defaultValue 5\n   */\n  tolerance?: number;\n  /**\n   * <zh/> 对齐线头尾的延伸距离。取值范围：[0, Infinity]\n   *\n   * <en/> The extension distance of the snapline. The value range is [0, Infinity]\n   * @defaultValue 20\n   */\n  offset?: number;\n  /**\n   * <zh/> 是否启用自动吸附\n   *\n   * <en/> Whether to enable automatic adsorption\n   * @defaultValue true\n   */\n  autoSnap?: boolean;\n  /**\n   * <zh/> 指定元素上的哪个图形作为参照图形\n   *\n   * <en/> Specifies which shape on the element to use as the reference shape\n   * @defaultValue `'key'`\n   * @remarks\n   * <zh/>\n   * - 'key' 使用元素的主图形作为参照图形\n   * - 也可以传入一个函数，接收元素对象，返回一个图形\n   *\n   * <en/>\n   * - `'key'` uses the key shape of the element as the reference shape\n   * - You can also pass in a function that receives the element and returns a shape\n   */\n  shape?: string | ((node: Node) => DisplayObject);\n  /**\n   * <zh/> 垂直对齐线样式\n   *\n   * <en/> Vertical snapline style\n   * @defaultValue `{ stroke: '#1783FF' }`\n   */\n  verticalLineStyle?: BaseStyleProps;\n  /**\n   * <zh/> 水平对齐线样式\n   *\n   * <en/> Horizontal snapline style\n   * @defaultValue `{ stroke: '#1783FF' }`\n   */\n  horizontalLineStyle?: BaseStyleProps;\n  /**\n   * <zh/> 过滤器，用于过滤不需要作为参考的节点\n   *\n   * <en/> Filter, used to filter nodes that do not need to be used as references\n   * @defaultValue `() => true`\n   */\n  filter?: (node: Node) => boolean;\n}\n\nconst defaultLineStyle: LineStyleProps = { x1: 0, y1: 0, x2: 0, y2: 0, visibility: 'hidden' };\n\ntype Metadata = {\n  verticalX: number | null;\n  verticalMinY: number | null;\n  verticalMaxY: number | null;\n  horizontalY: number | null;\n  horizontalMinX: number | null;\n  horizontalMaxX: number | null;\n};\n\n/**\n * <zh/> 对齐线插件\n *\n * <en/> Snapline plugin\n */\nexport class Snapline extends BasePlugin<SnaplineOptions> {\n  static defaultOptions: Partial<SnaplineOptions> = {\n    tolerance: 5,\n    offset: 20,\n    autoSnap: true,\n    shape: 'key',\n    verticalLineStyle: { stroke: '#1783FF' },\n    horizontalLineStyle: { stroke: '#1783FF' },\n    filter: () => true,\n  };\n\n  private horizontalLine!: Line;\n  private verticalLine!: Line;\n\n  constructor(context: RuntimeContext, options: SnaplineOptions) {\n    super(context, Object.assign({}, Snapline.defaultOptions, options));\n    this.bindEvents();\n  }\n\n  private initSnapline = () => {\n    const canvas = this.context.canvas.getLayer('transient');\n\n    if (!this.horizontalLine) {\n      this.horizontalLine = canvas.appendChild(\n        new Line({ style: { ...defaultLineStyle, ...this.options.horizontalLineStyle } }),\n      );\n    }\n\n    if (!this.verticalLine) {\n      this.verticalLine = canvas.appendChild(\n        new Line({ style: { ...defaultLineStyle, ...this.options.verticalLineStyle } }),\n      );\n    }\n  };\n\n  private getNodes(): Node[] {\n    const { filter } = this.options;\n    const allNodes = this.context.element?.getNodes() || [];\n\n    // 不考虑超出画布视口范围、不可见的节点\n    // Nodes that are out of the canvas viewport range, invisible are not considered\n    const nodes = allNodes.filter((node) => {\n      return isVisible(node) && this.context.viewport?.isInViewport(node.getRenderBounds());\n    });\n\n    if (!filter) return nodes;\n\n    return nodes.filter((node) => filter(node));\n  }\n\n  private hideSnapline() {\n    this.horizontalLine.style.visibility = 'hidden';\n    this.verticalLine.style.visibility = 'hidden';\n  }\n\n  private getLineWidth(direction: 'horizontal' | 'vertical') {\n    const { lineWidth } = this.options[`${direction}LineStyle`] as LineStyleProps;\n    return +(lineWidth || defaultLineStyle.lineWidth || 1) / this.context.graph.getZoom();\n  }\n\n  private updateSnapline(metadata: Metadata) {\n    const { verticalX, verticalMinY, verticalMaxY, horizontalY, horizontalMinX, horizontalMaxX } = metadata;\n    const [canvasWidth, canvasHeight] = this.context.canvas.getSize();\n    const { offset } = this.options;\n\n    if (horizontalY !== null) {\n      Object.assign(this.horizontalLine.style, {\n        x1: offset === Infinity ? 0 : horizontalMinX! - offset,\n        y1: horizontalY,\n        x2: offset === Infinity ? canvasWidth : horizontalMaxX! + offset,\n        y2: horizontalY,\n        visibility: 'visible',\n        lineWidth: this.getLineWidth('horizontal'),\n      });\n    } else {\n      this.horizontalLine.style.visibility = 'hidden';\n    }\n\n    if (verticalX !== null) {\n      Object.assign(this.verticalLine.style, {\n        x1: verticalX,\n        y1: offset === Infinity ? 0 : verticalMinY! - offset,\n        x2: verticalX,\n        y2: offset === Infinity ? canvasHeight : verticalMaxY! + offset,\n        visibility: 'visible',\n        lineWidth: this.getLineWidth('vertical'),\n      });\n    } else {\n      this.verticalLine.style.visibility = 'hidden';\n    }\n  }\n\n  private isHorizontalSticking = false;\n  private isVerticalSticking = false;\n  private enableStick = true;\n\n  private autoSnapToLine = async (nodeId: ID, bbox: AABB, metadata: Metadata) => {\n    const { verticalX, horizontalY } = metadata;\n    const { tolerance } = this.options;\n    const {\n      min: [nodeMinX, nodeMinY],\n      max: [nodeMaxX, nodeMaxY],\n      center: [nodeCenterX, nodeCenterY],\n    } = bbox;\n\n    let dx = 0;\n    let dy = 0;\n    if (verticalX !== null) {\n      if (distance(nodeMaxX, verticalX) < tolerance) dx = verticalX - nodeMaxX;\n      if (distance(nodeMinX, verticalX) < tolerance) dx = verticalX - nodeMinX;\n      if (distance(nodeCenterX, verticalX) < tolerance) dx = verticalX - nodeCenterX;\n\n      if (dx !== 0) this.isVerticalSticking = true;\n    }\n    if (horizontalY !== null) {\n      if (distance(nodeMaxY, horizontalY) < tolerance) dy = horizontalY - nodeMaxY;\n      if (distance(nodeMinY, horizontalY) < tolerance) dy = horizontalY - nodeMinY;\n      if (distance(nodeCenterY, horizontalY) < tolerance) dy = horizontalY - nodeCenterY;\n\n      if (dy !== 0) this.isHorizontalSticking = true;\n    }\n    if (dx !== 0 || dy !== 0) {\n      // Stick to the line\n      await this.context.graph.translateElementBy({ [nodeId]: [dx, dy] }, false);\n    }\n  };\n\n  /**\n   * Get the delta of the drag\n   * @param event - drag event object\n   * @returns delta\n   * @internal\n   */\n  protected getDelta(event: IDragEvent<Node>) {\n    const zoom = this.context.graph.getZoom();\n    return divide([event.dx, event.dy], zoom);\n  }\n\n  private enableSnap = (event: IDragEvent<Node>) => {\n    const { target } = event;\n\n    const threshold = 0.5;\n\n    if (this.isHorizontalSticking || this.isVerticalSticking) {\n      const [dx, dy] = this.getDelta(event);\n      if (\n        this.isHorizontalSticking &&\n        this.isVerticalSticking &&\n        Math.abs(dx) <= threshold &&\n        Math.abs(dy) <= threshold\n      ) {\n        this.context.graph.translateElementBy({ [target.id]: [-dx, -dy] }, false);\n        return false;\n      } else if (this.isHorizontalSticking && Math.abs(dy) <= threshold) {\n        this.context.graph.translateElementBy({ [target.id]: [0, -dy] }, false);\n        return false;\n      } else if (this.isVerticalSticking && Math.abs(dx) <= threshold) {\n        this.context.graph.translateElementBy({ [target.id]: [-dx, 0] }, false);\n        return false;\n      } else {\n        this.isHorizontalSticking = false;\n        this.isVerticalSticking = false;\n        this.enableStick = false;\n        setTimeout(() => {\n          this.enableStick = true;\n        }, 200);\n      }\n    }\n\n    return this.enableStick;\n  };\n\n  private calcSnaplineMetadata = (target: Node, nodeBBox: AABB): Metadata => {\n    const { tolerance, shape } = this.options;\n\n    const {\n      min: [nodeMinX, nodeMinY],\n      max: [nodeMaxX, nodeMaxY],\n      center: [nodeCenterX, nodeCenterY],\n    } = nodeBBox;\n\n    let verticalX: number | null = null;\n    let verticalMinY: number | null = null;\n    let verticalMaxY: number | null = null;\n    let horizontalY: number | null = null;\n    let horizontalMinX: number | null = null;\n    let horizontalMaxX: number | null = null;\n\n    this.getNodes().some((snapNode: Node) => {\n      if (isEqual(target.id, snapNode.id)) return false;\n\n      const snapBBox = getShape(snapNode, shape).getRenderBounds();\n      const {\n        min: [snapMinX, snapMinY],\n        max: [snapMaxX, snapMaxY],\n        center: [snapCenterX, snapCenterY],\n      } = snapBBox;\n\n      if (verticalX === null) {\n        if (distance(snapCenterX, nodeCenterX) < tolerance) {\n          verticalX = snapCenterX;\n        } else if (distance(snapMinX, nodeMinX) < tolerance) {\n          verticalX = snapMinX;\n        } else if (distance(snapMinX, nodeMaxX) < tolerance) {\n          verticalX = snapMinX;\n        } else if (distance(snapMaxX, nodeMaxX) < tolerance) {\n          verticalX = snapMaxX;\n        } else if (distance(snapMaxX, nodeMinX) < tolerance) {\n          verticalX = snapMaxX;\n        }\n\n        if (verticalX !== null) {\n          verticalMinY = Math.min(snapMinY, nodeMinY);\n          verticalMaxY = Math.max(snapMaxY, nodeMaxY);\n        }\n      }\n\n      if (horizontalY === null) {\n        if (distance(snapCenterY, nodeCenterY) < tolerance) {\n          horizontalY = snapCenterY;\n        } else if (distance(snapMinY, nodeMinY) < tolerance) {\n          horizontalY = snapMinY;\n        } else if (distance(snapMinY, nodeMaxY) < tolerance) {\n          horizontalY = snapMinY;\n        } else if (distance(snapMaxY, nodeMaxY) < tolerance) {\n          horizontalY = snapMaxY;\n        } else if (distance(snapMaxY, nodeMinY) < tolerance) {\n          horizontalY = snapMaxY;\n        }\n\n        if (horizontalY !== null) {\n          horizontalMinX = Math.min(snapMinX, nodeMinX);\n          horizontalMaxX = Math.max(snapMaxX, nodeMaxX);\n        }\n      }\n\n      return verticalX !== null && horizontalY !== null;\n    });\n    return { verticalX, verticalMinY, verticalMaxY, horizontalY, horizontalMinX, horizontalMaxX };\n  };\n\n  protected onDragStart = () => {\n    this.initSnapline();\n  };\n\n  protected onDrag = async (event: IDragEvent<Node>) => {\n    const { target } = event;\n\n    if (this.options.autoSnap) {\n      const enable = this.enableSnap(event);\n      if (!enable) return;\n    }\n\n    const nodeBBox = getShape(target, this.options.shape).getRenderBounds();\n    const metadata = this.calcSnaplineMetadata(target, nodeBBox);\n\n    this.hideSnapline();\n\n    if (metadata.verticalX !== null || metadata.horizontalY !== null) {\n      this.updateSnapline(metadata);\n    }\n\n    if (this.options.autoSnap) {\n      await this.autoSnapToLine(target.id, nodeBBox, metadata);\n    }\n  };\n\n  protected onDragEnd = () => {\n    this.hideSnapline();\n  };\n\n  private async bindEvents() {\n    const { graph } = this.context;\n    graph.on(NodeEvent.DRAG_START, this.onDragStart);\n    graph.on(NodeEvent.DRAG, this.onDrag);\n    graph.on(NodeEvent.DRAG_END, this.onDragEnd);\n  }\n\n  private unbindEvents() {\n    const { graph } = this.context;\n    graph.off(NodeEvent.DRAG_START, this.onDragStart);\n    graph.off(NodeEvent.DRAG, this.onDrag);\n    graph.off(NodeEvent.DRAG_END, this.onDragEnd);\n  }\n\n  private destroyElements() {\n    this.horizontalLine?.destroy();\n    this.verticalLine?.destroy();\n  }\n\n  public destroy() {\n    this.destroyElements();\n    this.unbindEvents();\n    super.destroy();\n  }\n}\n\nconst distance = (a: number, b: number) => Math.abs(a - b);\n\nconst getShape = (node: Node, shapeFilter: string | ((node: Node) => DisplayObject)) => {\n  return typeof shapeFilter === 'function' ? shapeFilter(node) : node.getShape(shapeFilter);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}