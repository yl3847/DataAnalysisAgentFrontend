{"ast":null,"code":"export class Grid {\n  constructor(points, cellSize) {\n    this._cells = [];\n    this._cellSize = cellSize;\n    this._reverseCellSize = 1 / cellSize;\n    for (const point of points) {\n      const x = this.coordToCellNum(point[0]);\n      const y = this.coordToCellNum(point[1]);\n      if (!this._cells[x]) {\n        this._cells[x] = [];\n      }\n      if (!this._cells[x][y]) {\n        this._cells[x][y] = [];\n      }\n      this._cells[x][y].push(point);\n    }\n  }\n  cellPoints(x, y) {\n    var _a;\n    return ((_a = this._cells[x]) === null || _a === void 0 ? void 0 : _a[y]) || [];\n  }\n  rangePoints(bbox) {\n    const tlCellX = this.coordToCellNum(bbox[0]);\n    const tlCellY = this.coordToCellNum(bbox[1]);\n    const brCellX = this.coordToCellNum(bbox[2]);\n    const brCellY = this.coordToCellNum(bbox[3]);\n    const points = [];\n    for (let x = tlCellX; x <= brCellX; x++) {\n      for (let y = tlCellY; y <= brCellY; y++) {\n        const cell = this.cellPoints(x, y);\n        for (const point of cell) {\n          points.push(point);\n        }\n      }\n    }\n    return points;\n  }\n  removePoint(point) {\n    const cellX = this.coordToCellNum(point[0]);\n    const cellY = this.coordToCellNum(point[1]);\n    const cell = this._cells[cellX][cellY];\n    const index = cell.findIndex(([px, py]) => px === point[0] && py === point[1]);\n    if (index > -1) {\n      cell.splice(index, 1);\n    }\n    return cell;\n  }\n  trunc(val) {\n    return Math.trunc(val);\n  }\n  coordToCellNum(x) {\n    return this.trunc(x * this._reverseCellSize);\n  }\n  extendBbox(bbox, scaleFactor) {\n    return [bbox[0] - scaleFactor * this._cellSize, bbox[1] - scaleFactor * this._cellSize, bbox[2] + scaleFactor * this._cellSize, bbox[3] + scaleFactor * this._cellSize];\n  }\n}\nexport function grid(points, cellSize) {\n  return new Grid(points, cellSize);\n}","map":{"version":3,"names":["Grid","constructor","points","cellSize","_cells","_cellSize","_reverseCellSize","point","x","coordToCellNum","y","push","cellPoints","_a","rangePoints","bbox","tlCellX","tlCellY","brCellX","brCellY","cell","removePoint","cellX","cellY","index","findIndex","px","py","splice","trunc","val","Math","extendBbox","scaleFactor","grid"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/plugins/hull/hull/grid_handle.ts"],"sourcesContent":["import type { Point } from '../../../types';\nimport type { BBox } from './format';\n\nexport class Grid {\n  private _cells: Point[][][] = [];\n  private _cellSize: number;\n  private _reverseCellSize: number;\n  constructor(points: Point[], cellSize: number) {\n    this._cellSize = cellSize;\n    this._reverseCellSize = 1 / cellSize;\n    for (const point of points) {\n      const x = this.coordToCellNum(point[0]);\n      const y = this.coordToCellNum(point[1]);\n\n      if (!this._cells[x]) {\n        this._cells[x] = [];\n      }\n\n      if (!this._cells[x][y]) {\n        this._cells[x][y] = [];\n      }\n\n      this._cells[x][y].push(point);\n    }\n  }\n  cellPoints(x: number, y: number): Point[] {\n    return this._cells[x]?.[y] || [];\n  }\n  rangePoints(bbox: BBox): Point[] {\n    const tlCellX = this.coordToCellNum(bbox[0]);\n    const tlCellY = this.coordToCellNum(bbox[1]);\n    const brCellX = this.coordToCellNum(bbox[2]);\n    const brCellY = this.coordToCellNum(bbox[3]);\n    const points: Point[] = [];\n    for (let x = tlCellX; x <= brCellX; x++) {\n      for (let y = tlCellY; y <= brCellY; y++) {\n        const cell = this.cellPoints(x, y);\n        for (const point of cell) {\n          points.push(point);\n        }\n      }\n    }\n    return points;\n  }\n  removePoint(point: Point): Point[] {\n    const cellX = this.coordToCellNum(point[0]);\n    const cellY = this.coordToCellNum(point[1]);\n    const cell = this._cells[cellX][cellY];\n    const index = cell.findIndex(([px, py]) => px === point[0] && py === point[1]);\n    if (index > -1) {\n      cell.splice(index, 1);\n    }\n    return cell;\n  }\n  private trunc(val: number): number {\n    return Math.trunc(val);\n  }\n  coordToCellNum(x: number): number {\n    return this.trunc(x * this._reverseCellSize);\n  }\n  extendBbox(bbox: BBox, scaleFactor: number): BBox {\n    return [\n      bbox[0] - scaleFactor * this._cellSize,\n      bbox[1] - scaleFactor * this._cellSize,\n      bbox[2] + scaleFactor * this._cellSize,\n      bbox[3] + scaleFactor * this._cellSize,\n    ];\n  }\n}\n\nexport function grid(points: Point[], cellSize: number): Grid {\n  return new Grid(points, cellSize);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}