{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Line, Text } from '@antv/g';\nimport { deepMix, throttle } from '@antv/util';\nimport { max, min, rollup, sort, bisectCenter, bisector, group } from '@antv/vendor/d3-array';\nimport { subObject } from '../utils/helper';\nimport { ELEMENT_CLASS_NAME, LABEL_CLASS_NAME } from '../runtime';\nimport { selectPlotArea, mousePosition } from './utils';\nfunction maybeTransform(options) {\n  const {\n    transform = []\n  } = options;\n  const normalizeY = transform.find(d => d.type === 'normalizeY');\n  if (normalizeY) return normalizeY;\n  const newNormalizeY = {\n    type: 'normalizeY'\n  };\n  transform.push(newNormalizeY);\n  options.transform = transform;\n  return newNormalizeY;\n}\nfunction markValue(markState, markName, channels) {\n  const [value] = Array.from(markState.entries()).filter(([mark]) => mark.type === markName).map(([mark]) => {\n    const {\n      encode\n    } = mark;\n    const channel = name => {\n      const channel = encode[name];\n      return [name, channel ? channel.value : undefined];\n    };\n    return Object.fromEntries(channels.map(channel));\n  });\n  return value;\n}\n/**\n * @todo Perf\n */\nexport function ChartIndex(_a) {\n  var {\n      wait = 20,\n      leading,\n      trailing = false,\n      labelFormatter = date => `${date}`\n    } = _a,\n    style = __rest(_a, [\"wait\", \"leading\", \"trailing\", \"labelFormatter\"]);\n  return context => {\n    const {\n      view,\n      container,\n      update,\n      setState\n    } = context;\n    const {\n      markState,\n      scale,\n      coordinate\n    } = view;\n    // Get line mark value, exit if it is not existed.\n    const value = markValue(markState, 'line', ['x', 'y', 'series']);\n    if (!value) return;\n    // Prepare channel value.\n    const {\n      y: Y,\n      x: X,\n      series: S = []\n    } = value;\n    const I = Y.map((_, i) => i);\n    const sortedX = sort(I.map(i => X[i]));\n    // Prepare shapes.\n    const plotArea = selectPlotArea(container);\n    const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);\n    const labels = container.getElementsByClassName(LABEL_CLASS_NAME);\n    // The format of label key: `${elementKey}-index`,\n    // group labels by elementKey.\n    const keyofLabel = d => d.__data__.key.split('-')[0];\n    const keyLabels = group(labels, keyofLabel);\n    const rule = new Line({\n      style: Object.assign({\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: plotArea.getAttribute('height'),\n        stroke: 'black',\n        lineWidth: 1\n      }, subObject(style, 'rule'))\n    });\n    const text = new Text({\n      style: Object.assign({\n        x: 0,\n        y: plotArea.getAttribute('height'),\n        text: '',\n        fontSize: 10\n      }, subObject(style, 'label'))\n    });\n    rule.append(text);\n    plotArea.appendChild(rule);\n    // Get the closet date to the rule.\n    const dateByFocus = (coordinate, scaleX, focus) => {\n      const [normalizedX] = coordinate.invert(focus);\n      const date = scaleX.invert(normalizedX);\n      return sortedX[bisectCenter(sortedX, date)];\n    };\n    // Update rule and label content.\n    const updateRule = (focus, date) => {\n      rule.setAttribute('x1', focus[0]);\n      rule.setAttribute('x2', focus[0]);\n      text.setAttribute('text', labelFormatter(date));\n    };\n    // Store the new inner state alter rerender the view.\n    let newView;\n    // Rerender the view to update basis for each line.\n    const updateBasisByRerender = focus => __awaiter(this, void 0, void 0, function* () {\n      // Find the closetDate to the rule.\n      const {\n        x: scaleX\n      } = scale;\n      const date = dateByFocus(coordinate, scaleX, focus);\n      updateRule(focus, date);\n      setState('chartIndex', options => {\n        // Clone options and get line mark.\n        const clonedOptions = deepMix({}, options);\n        const lineMark = clonedOptions.marks.find(d => d.type === 'line');\n        // Update domain of y scale for the line mark.\n        const r = I => max(I, i => +Y[i]) / min(I, i => +Y[i]);\n        const k = max(rollup(I, r, i => S[i]).values());\n        const domainY = [1 / k, k];\n        deepMix(lineMark, {\n          scale: {\n            y: {\n              domain: domainY\n            }\n          }\n        });\n        // Update normalize options.\n        const normalizeY = maybeTransform(lineMark);\n        normalizeY.groupBy = 'color';\n        normalizeY.basis = (I, Y) => {\n          const i = I[bisector(i => X[+i]).center(I, date)];\n          return Y[i];\n        };\n        // Disable animation.\n        for (const mark of clonedOptions.marks) mark.animate = false;\n        return clonedOptions;\n      });\n      const newState = yield update('chartIndex');\n      newView = newState.view;\n    });\n    // Only apply translate to update basis for each line.\n    // If performance is ok, there is no need to use this\n    // strategy to update basis.\n    const updateBasisByTranslate = focus => {\n      // Find the closetDate to the rule.\n      const {\n        scale,\n        coordinate\n      } = newView;\n      const {\n        x: scaleX,\n        y: scaleY\n      } = scale;\n      const date = dateByFocus(coordinate, scaleX, focus);\n      updateRule(focus, date);\n      // Translate mark and label for better performance.\n      for (const line of lines) {\n        // Compute transform in y direction.\n        const {\n          seriesIndex: SI,\n          key\n        } = line.__data__;\n        const i = SI[bisector(i => X[+i]).center(SI, date)];\n        const p0 = [0, scaleY.map(1)]; // basis point\n        const p1 = [0, scaleY.map(Y[i] / Y[SI[0]])];\n        const [, y0] = coordinate.map(p0);\n        const [, y1] = coordinate.map(p1);\n        const dy = y0 - y1;\n        line.setAttribute('transform', `translate(0, ${dy})`);\n        // Update line and related label.\n        const labels = keyLabels.get(key) || [];\n        for (const label of labels) {\n          // @todo Replace with style.transform.\n          // It now has unexpected behavior.\n          label.setAttribute('dy', dy);\n        }\n      }\n    };\n    const updateBasis = throttle(event => {\n      const focus = mousePosition(plotArea, event);\n      if (!focus) return;\n      updateBasisByTranslate(focus);\n    }, wait, {\n      leading,\n      trailing\n    });\n    updateBasisByRerender([0, 0]);\n    plotArea.addEventListener('pointerenter', updateBasis);\n    plotArea.addEventListener('pointermove', updateBasis);\n    plotArea.addEventListener('pointerleave', updateBasis);\n    return () => {\n      rule.remove();\n      plotArea.removeEventListener('pointerenter', updateBasis);\n      plotArea.removeEventListener('pointermove', updateBasis);\n      plotArea.removeEventListener('pointerleave', updateBasis);\n    };\n  };\n}\nChartIndex.props = {\n  reapplyWhenUpdate: true\n};","map":{"version":3,"names":["Line","Text","deepMix","throttle","max","min","rollup","sort","bisectCenter","bisector","group","subObject","ELEMENT_CLASS_NAME","LABEL_CLASS_NAME","selectPlotArea","mousePosition","maybeTransform","options","transform","normalizeY","find","d","type","newNormalizeY","push","markValue","markState","markName","channels","value","Array","from","entries","filter","mark","map","encode","channel","name","undefined","Object","fromEntries","ChartIndex","_a","wait","leading","trailing","labelFormatter","date","style","__rest","context","view","container","update","setState","scale","coordinate","y","Y","x","X","series","S","I","_","i","sortedX","plotArea","lines","getElementsByClassName","labels","keyofLabel","__data__","key","split","keyLabels","rule","assign","x1","y1","x2","y2","getAttribute","stroke","lineWidth","text","fontSize","append","appendChild","dateByFocus","scaleX","focus","normalizedX","invert","updateRule","setAttribute","newView","updateBasisByRerender","__awaiter","clonedOptions","lineMark","marks","r","k","values","domainY","domain","groupBy","basis","center","animate","newState","updateBasisByTranslate","scaleY","line","seriesIndex","SI","p0","p1","y0","dy","get","label","updateBasis","event","addEventListener","remove","removeEventListener","props","reapplyWhenUpdate"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/chartIndex.ts"],"sourcesContent":["import { Line, Text } from '@antv/g';\nimport { deepMix, throttle } from '@antv/util';\nimport {\n  max,\n  min,\n  rollup,\n  sort,\n  bisectCenter,\n  bisector,\n  group,\n} from '@antv/vendor/d3-array';\nimport { G2Element } from 'utils/selection';\nimport { subObject } from '../utils/helper';\nimport {\n  ELEMENT_CLASS_NAME,\n  G2Mark,\n  G2MarkState,\n  LABEL_CLASS_NAME,\n} from '../runtime';\nimport { selectPlotArea, mousePosition } from './utils';\n\nfunction maybeTransform(options) {\n  const { transform = [] } = options;\n  const normalizeY = transform.find((d) => d.type === 'normalizeY');\n  if (normalizeY) return normalizeY;\n  const newNormalizeY = { type: 'normalizeY' };\n  transform.push(newNormalizeY);\n  options.transform = transform;\n  return newNormalizeY;\n}\n\nfunction markValue(\n  markState: Map<G2Mark, G2MarkState>,\n  markName: string,\n  channels: string[],\n) {\n  const [value] = Array.from(markState.entries())\n    .filter(([mark]) => mark.type === markName)\n    .map(([mark]) => {\n      const { encode } = mark;\n      const channel = (name) => {\n        const channel = encode[name];\n        return [name, channel ? channel.value : undefined];\n      };\n      return Object.fromEntries(channels.map(channel));\n    });\n  return value;\n}\n\n/**\n * @todo Perf\n */\nexport function ChartIndex({\n  wait = 20,\n  leading,\n  trailing = false,\n  labelFormatter = (date) => `${date}`,\n  ...style\n}: Record<string, any>) {\n  return (context) => {\n    const { view, container, update, setState } = context;\n    const { markState, scale, coordinate } = view;\n\n    // Get line mark value, exit if it is not existed.\n    const value = markValue(markState, 'line', ['x', 'y', 'series']);\n    if (!value) return;\n\n    // Prepare channel value.\n    const { y: Y, x: X, series: S = [] } = value;\n    const I = Y.map((_, i) => i);\n    const sortedX: number[] = sort(I.map((i) => X[i]));\n\n    // Prepare shapes.\n    const plotArea = selectPlotArea(container);\n    const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);\n    const labels = container.getElementsByClassName(\n      LABEL_CLASS_NAME,\n    ) as G2Element[];\n\n    // The format of label key: `${elementKey}-index`,\n    // group labels by elementKey.\n    const keyofLabel = (d) => d.__data__.key.split('-')[0];\n    const keyLabels = group(labels, keyofLabel);\n\n    const rule = new Line({\n      style: {\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: plotArea.getAttribute('height'),\n        stroke: 'black',\n        lineWidth: 1,\n        ...subObject(style, 'rule'),\n      },\n    });\n    const text = new Text({\n      style: {\n        x: 0,\n        y: plotArea.getAttribute('height'),\n        text: '',\n        fontSize: 10,\n        ...subObject(style, 'label'),\n      },\n    });\n    rule.append(text);\n    plotArea.appendChild(rule);\n\n    // Get the closet date to the rule.\n    const dateByFocus = (coordinate, scaleX, focus) => {\n      const [normalizedX] = coordinate.invert(focus);\n      const date = scaleX.invert(normalizedX);\n      return sortedX[bisectCenter(sortedX, date)];\n    };\n\n    // Update rule and label content.\n    const updateRule = (focus, date) => {\n      rule.setAttribute('x1', focus[0]);\n      rule.setAttribute('x2', focus[0]);\n      text.setAttribute('text', labelFormatter(date));\n    };\n\n    // Store the new inner state alter rerender the view.\n    let newView;\n\n    // Rerender the view to update basis for each line.\n    const updateBasisByRerender = async (focus) => {\n      // Find the closetDate to the rule.\n      const { x: scaleX } = scale;\n      const date = dateByFocus(coordinate, scaleX, focus);\n\n      updateRule(focus, date);\n\n      setState('chartIndex', (options) => {\n        // Clone options and get line mark.\n        const clonedOptions = deepMix({}, options);\n        const lineMark = clonedOptions.marks.find((d) => d.type === 'line');\n\n        // Update domain of y scale for the line mark.\n        const r = (I: number[]) => max(I, (i) => +Y[i]) / min(I, (i) => +Y[i]);\n        const k = max(rollup(I, r, (i) => S[i]).values());\n        const domainY = [1 / k, k];\n        deepMix(lineMark, {\n          scale: { y: { domain: domainY } },\n        });\n        // Update normalize options.\n        const normalizeY = maybeTransform(lineMark);\n        normalizeY.groupBy = 'color';\n        normalizeY.basis = (I, Y) => {\n          const i = I[bisector((i) => X[+i]).center(I, date)];\n          return Y[i];\n        };\n        // Disable animation.\n        for (const mark of clonedOptions.marks) mark.animate = false;\n        return clonedOptions;\n      });\n\n      const newState = await update('chartIndex');\n      newView = newState.view;\n    };\n\n    // Only apply translate to update basis for each line.\n    // If performance is ok, there is no need to use this\n    // strategy to update basis.\n    const updateBasisByTranslate = (focus) => {\n      // Find the closetDate to the rule.\n      const { scale, coordinate } = newView;\n      const { x: scaleX, y: scaleY } = scale;\n      const date = dateByFocus(coordinate, scaleX, focus);\n\n      updateRule(focus, date);\n\n      // Translate mark and label for better performance.\n      for (const line of lines) {\n        // Compute transform in y direction.\n        const { seriesIndex: SI, key } = line.__data__;\n        const i = SI[bisector((i) => X[+i]).center(SI, date)];\n        const p0 = [0, scaleY.map(1)]; // basis point\n        const p1 = [0, scaleY.map(Y[i] / Y[SI[0]])];\n        const [, y0] = coordinate.map(p0);\n        const [, y1] = coordinate.map(p1);\n        const dy = y0 - y1;\n        line.setAttribute('transform', `translate(0, ${dy})`);\n\n        // Update line and related label.\n        const labels = keyLabels.get(key) || [];\n        for (const label of labels) {\n          // @todo Replace with style.transform.\n          // It now has unexpected behavior.\n          label.setAttribute('dy', dy);\n        }\n      }\n    };\n\n    const updateBasis = throttle(\n      (event) => {\n        const focus = mousePosition(plotArea, event);\n        if (!focus) return;\n        updateBasisByTranslate(focus);\n      },\n      wait,\n      { leading, trailing },\n    ) as (...args: any[]) => void;\n\n    updateBasisByRerender([0, 0]);\n\n    plotArea.addEventListener('pointerenter', updateBasis);\n    plotArea.addEventListener('pointermove', updateBasis);\n    plotArea.addEventListener('pointerleave', updateBasis);\n\n    return () => {\n      rule.remove();\n      plotArea.removeEventListener('pointerenter', updateBasis);\n      plotArea.removeEventListener('pointermove', updateBasis);\n      plotArea.removeEventListener('pointerleave', updateBasis);\n    };\n  };\n}\n\nChartIndex.props = {\n  reapplyWhenUpdate: true,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}