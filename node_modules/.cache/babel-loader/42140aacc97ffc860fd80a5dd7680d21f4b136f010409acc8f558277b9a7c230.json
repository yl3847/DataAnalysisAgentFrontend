{"ast":null,"code":"import { isNumber } from '@antv/util';\nimport { getBBoxSegments, getBBoxSize, getExpandedBBox, isPointInBBox, isPointOnBBoxBoundary } from '../bbox';\nimport { getLinesIntersection } from '../line';\nimport { add, manhattanDistance, toVector2 } from '../vector';\nconst defaultCfg = {\n  enableObstacleAvoidance: false,\n  offset: 10,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 3000,\n  gridSize: 5,\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  directionMap: {\n    right: {\n      stepX: 1,\n      stepY: 0\n    },\n    left: {\n      stepX: -1,\n      stepY: 0\n    },\n    bottom: {\n      stepX: 0,\n      stepY: 1\n    },\n    top: {\n      stepX: 0,\n      stepY: -1\n    }\n  },\n  penalties: {\n    0: 0,\n    90: 0\n  },\n  distFunc: manhattanDistance\n};\nconst keyOf = point => `${Math.round(point[0])}|||${Math.round(point[1])}`;\n/**\n * <zh/> 将坐标对齐到网格\n *\n * <en/> Align to the grid\n * @param p - <zh/> 坐标 | <en/> point\n * @param gridSize - <zh/> 网格大小 | <en/> grid size\n * @returns <zh/> 对齐后的坐标 | <en/> aligned point\n */\nfunction alignToGrid(p, gridSize) {\n  const align = value => Math.round(value / gridSize);\n  if (isNumber(p)) return align(p);\n  return p.map(align);\n}\n/**\n * <zh/> 获取两个角度的变化方向，并确保小于 180 度\n *\n * <en/ >Get changed direction angle and make sure less than 180 degrees\n * @param angle1 - <zh/> 第一个角度 | <en/> the first angle\n * @param angle2 - <zh/> 第二个角度 | <en/> the second angle\n * @returns <zh/> 两个角度的变化方向 | <en/> changed direction angle\n */\nfunction getAngleDiff(angle1, angle2) {\n  const directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;\n}\n/**\n * <zh/> 获取从 p1 指向 p2 的向量与 x 轴正方向之间的夹角，单位为弧度\n *\n * <en/> Get the angle between the vector from p1 to p2 and the positive direction of the x-axis, in radians\n * @param p1 - <zh/> 点 p1 | <en/> point p1\n * @param p2 - <zh/> 点 p2 | <en/> point p2\n * @returns <zh/> 夹角 | <en/> angle\n */\nfunction getDirectionAngle(p1, p2) {\n  const deltaX = p2[0] - p1[0];\n  const deltaY = p2[1] - p1[1];\n  if (!deltaX && !deltaY) return 0;\n  return Math.atan2(deltaY, deltaX);\n}\n/**\n * <zh/> 获取两个点之间的方向变化\n *\n * <en/> Get direction change between two points\n * @param current - <zh/> 当前点 | <en/> current point\n * @param neighbor - <zh/> 邻居点 | <en/> neighbor point\n * @param cameFrom - <zh/> 来源点 | <en/> source point\n * @param scaleStartPoint - <zh/> 缩放后的起点 | <en/> scaled start point\n * @returns <zh/> 方向变化 | <en/> direction change\n */\nfunction getDirectionChange(current, neighbor, cameFrom, scaleStartPoint) {\n  const directionAngle = getDirectionAngle(current, neighbor);\n  const currentCameFrom = cameFrom[keyOf(current)];\n  const prev = !currentCameFrom ? scaleStartPoint : currentCameFrom;\n  const prevDirectionAngle = getDirectionAngle(prev, current);\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n}\n/**\n * <zh/> 获取障碍物地图\n *\n * <en/> Get obstacle map\n * @param nodes - <zh/> 图上所有节点 | <en/> all nodes on the graph\n * @param options - <zh/> 路由配置 | <en/> router options\n * @returns <zh/> 障碍物地图 | <en/> obstacle map\n */\nconst getObstacleMap = (nodes, options) => {\n  const {\n    offset,\n    gridSize\n  } = options;\n  const obstacleMap = {};\n  nodes.forEach(item => {\n    if (!item || item.destroyed || !item.isVisible()) return;\n    const bbox = getExpandedBBox(item.getRenderBounds(), offset);\n    for (let x = alignToGrid(bbox.min[0], gridSize); x <= alignToGrid(bbox.max[0], gridSize); x += 1) {\n      for (let y = alignToGrid(bbox.min[1], gridSize); y <= alignToGrid(bbox.max[1], gridSize); y += 1) {\n        obstacleMap[`${x}|||${y}`] = true;\n      }\n    }\n  });\n  return obstacleMap;\n};\n/**\n * <zh/> 估算从起点到多个锚点的最小代价\n *\n * <en/> Estimate minimum cost from the starting point to multiple anchor points\n * @param from - <zh/> 起点 | <en/> source point\n * @param anchors - <zh/> 锚点 | <en/> anchor points\n * @param distFunc - <zh/> 距离函数 | <en/> distance function\n * @returns <zh/> 最小成本 | <en/> minimum cost\n */\nexport function estimateCost(from, anchors, distFunc) {\n  return Math.min(...anchors.map(anchor => distFunc(from, anchor)));\n}\n/**\n * <zh/> 已知一个点集与一个参考点，从点集中找到距离参考点最近的点\n *\n * <en/> Given a set of points and a reference point, find the point closest to the reference point from the set of points\n * @param points - <zh/> 点集 | <en/> set of points\n * @param refPoint - <zh/> 参考点 | <en/> reference point\n * @param distFunc - <zh/> 距离函数 | <en/> distance function\n * @returns <zh/> 最近的点 | <en/> nearest point\n */\nexport function getNearestPoint(points, refPoint, distFunc) {\n  let nearestPoint = points[0];\n  let minDistance = distFunc(points[0], refPoint);\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    const dis = distFunc(point, refPoint);\n    if (dis < minDistance) {\n      nearestPoint = point;\n      minDistance = dis;\n    }\n  }\n  return nearestPoint;\n}\n/**\n * Calculate the connection points on the expanded BBox\n * @param point\n * @param node\n * @param directions\n * @param options\n */\nconst getBoxPoints = (point, node, directions, options) => {\n  // create-edge 生成边的过程中，endNode 为 null\n  if (!node) return [point];\n  const {\n    directionMap,\n    offset\n  } = options;\n  const expandedBBox = getExpandedBBox(node.getRenderBounds(), offset);\n  const points = Object.keys(directionMap).reduce((res, directionKey) => {\n    if (directions.includes(directionKey)) {\n      const direction = directionMap[directionKey];\n      const [width, height] = getBBoxSize(expandedBBox);\n      const otherPoint = [point[0] + direction.stepX * width, point[1] + direction.stepY * height];\n      const segments = getBBoxSegments(expandedBBox);\n      for (let i = 0; i < segments.length; i++) {\n        const intersectP = getLinesIntersection([point, otherPoint], segments[i]);\n        if (intersectP && isPointOnBBoxBoundary(intersectP, expandedBBox)) {\n          res.push(intersectP);\n        }\n      }\n    }\n    return res;\n  }, []);\n  if (!isPointInBBox(point, expandedBBox)) {\n    points.push(point);\n  }\n  return points.map(point => alignToGrid(point, options.gridSize));\n};\nconst getControlPoints = (current, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize) => {\n  const controlPoints = [];\n  // append endPoint\n  let pointZero = [scaleEndPoint[0] === endPoint[0] ? endPoint[0] : current[0] * gridSize, scaleEndPoint[1] === endPoint[1] ? endPoint[1] : current[1] * gridSize];\n  controlPoints.unshift(pointZero);\n  let _current = current;\n  let _currentCameFrom = cameFrom[keyOf(_current)];\n  while (_currentCameFrom) {\n    const prePoint = _currentCameFrom;\n    const point = _current;\n    const directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n    if (directionChange) {\n      pointZero = [prePoint[0] === point[0] ? pointZero[0] : prePoint[0] * gridSize, prePoint[1] === point[1] ? pointZero[1] : prePoint[1] * gridSize];\n      controlPoints.unshift(pointZero);\n    }\n    _currentCameFrom = cameFrom[keyOf(prePoint)];\n    _current = prePoint;\n  }\n  // append startPoint\n  const realStartPoints = startPoints.map(point => [point[0] * gridSize, point[1] * gridSize]);\n  const startPoint = getNearestPoint(realStartPoints, pointZero, manhattanDistance);\n  controlPoints.unshift(startPoint);\n  return controlPoints;\n};\n/**\n * Find the shortest path between a given source node to a destination node according to A* Search Algorithm：https://www.geeksforgeeks.org/a-search-algorithm/\n * @param sourceNode - <zh/> 源节点 | <en/> source node\n * @param targetNode - <zh/> 目标节点 | <en/> target node\n * @param nodes - <zh/> 图上所有节点 | <en/> all nodes on the graph\n * @param config - <zh/> 路由配置 | <en/> router options\n * @returns <zh/> 控制点数组 | <en/> control point array\n */\nexport function aStarSearch(sourceNode, targetNode, nodes, config) {\n  const startPoint = toVector2(sourceNode.getCenter());\n  const endPoint = toVector2(targetNode.getCenter());\n  const options = Object.assign(defaultCfg, config);\n  const {\n    gridSize\n  } = options;\n  const obstacles = options.enableObstacleAvoidance ? nodes : [sourceNode, targetNode];\n  const obstacleMap = getObstacleMap(obstacles, options);\n  const scaleStartPoint = alignToGrid(startPoint, gridSize);\n  const scaleEndPoint = alignToGrid(endPoint, gridSize);\n  const startPoints = getBoxPoints(startPoint, sourceNode, options.startDirections, options);\n  const endPoints = getBoxPoints(endPoint, targetNode, options.endDirections, options);\n  startPoints.forEach(point => delete obstacleMap[keyOf(point)]);\n  endPoints.forEach(point => delete obstacleMap[keyOf(point)]);\n  const openList = {};\n  const closedList = {};\n  const cameFrom = {};\n  // The movement cost to move from the starting point to the current point on the grid.\n  const gScore = {};\n  // The estimated movement cost to move from the starting point to the end point after passing through the current point.\n  // f = g + h\n  const fScore = {};\n  const sortedOpenSet = new SortedArray();\n  for (let i = 0; i < startPoints.length; i++) {\n    const firstStep = startPoints[i];\n    const key = keyOf(firstStep);\n    openList[key] = firstStep;\n    gScore[key] = 0;\n    fScore[key] = estimateCost(firstStep, endPoints, options.distFunc);\n    // Push start point to sortedOpenSet\n    sortedOpenSet.add({\n      id: key,\n      value: fScore[key]\n    });\n  }\n  const endPointsKeys = endPoints.map(point => keyOf(point));\n  let remainLoops = options.maximumLoops;\n  let current;\n  let curCost = Infinity;\n  for (const [id, value] of Object.entries(openList)) {\n    if (fScore[id] <= curCost) {\n      curCost = fScore[id];\n      current = value;\n    }\n  }\n  while (Object.keys(openList).length > 0 && remainLoops > 0) {\n    const minId = sortedOpenSet.minId(false);\n    if (minId) {\n      current = openList[minId];\n    } else {\n      break;\n    }\n    const key = keyOf(current);\n    // If currentNode is final, return the successful path\n    if (endPointsKeys.includes(key)) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize);\n    }\n    // Set currentNode as closed\n    delete openList[key];\n    sortedOpenSet.remove(key);\n    closedList[key] = true;\n    // Get the neighbor points of the next step\n    for (const dir of Object.values(options.directionMap)) {\n      const neighbor = add(current, [dir.stepX, dir.stepY]);\n      const neighborId = keyOf(neighbor);\n      if (closedList[neighborId]) continue;\n      const directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > options.maxAllowedDirectionChange) continue;\n      if (obstacleMap[neighborId]) continue; // skip if intersects\n      // Add neighbor points to openList, and calculate the cost of each neighbor point\n      if (!openList[neighborId]) {\n        openList[neighborId] = neighbor;\n      }\n      const directionPenalties = options.penalties[directionChange];\n      const neighborCost = options.distFunc(current, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);\n      const costFromStart = gScore[key] + neighborCost;\n      const neighborGScore = gScore[neighborId];\n      if (neighborGScore && costFromStart >= neighborGScore) continue;\n      cameFrom[neighborId] = current;\n      gScore[neighborId] = costFromStart;\n      fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, options.distFunc);\n      sortedOpenSet.add({\n        id: neighborId,\n        value: fScore[neighborId]\n      });\n    }\n    remainLoops -= 1;\n  }\n  return [];\n}\n/**\n * <zh/> 有序数组，按升序排列\n *\n * <en/> Sorted array, sorted in ascending order\n */\nexport class SortedArray {\n  constructor() {\n    this.arr = [];\n    this.map = {};\n    this.arr = [];\n    this.map = {};\n  }\n  _innerAdd(item, length) {\n    let low = 0,\n      high = length - 1;\n    while (high - low > 1) {\n      const mid = Math.floor((low + high) / 2);\n      if (this.arr[mid].value > item.value) {\n        high = mid;\n      } else if (this.arr[mid].value < item.value) {\n        low = mid;\n      } else {\n        this.arr.splice(mid, 0, item);\n        this.map[item.id] = true;\n        return;\n      }\n    }\n    this.arr.splice(high, 0, item);\n    this.map[item.id] = true;\n  }\n  /**\n   * <zh/> 将新项添加到适当的索引位置\n   *\n   * <en/> Add the new item to the appropriate index\n   * @param item - <zh/> 新项 | <en/> new item\n   */\n  add(item) {\n    // 已经存在，先移除\n    // If exists, remove it\n    delete this.map[item.id];\n    const length = this.arr.length;\n    // 如果为空或者最后一个元素小于当前元素，直接添加到最后\n    // If empty or the last element is less than the current element, add to the end\n    if (!length || this.arr[length - 1].value < item.value) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    // 按照升序排列，找到合适的位置插入\n    // Find the appropriate position to insert in ascending order\n    this._innerAdd(item, length);\n  }\n  remove(id) {\n    if (!this.map[id]) return;\n    delete this.map[id];\n  }\n  _clearAndGetMinId() {\n    let res;\n    for (let i = this.arr.length - 1; i >= 0; i--) {\n      if (this.map[this.arr[i].id]) res = this.arr[i].id;else this.arr.splice(i, 1);\n    }\n    return res;\n  }\n  _findFirstId() {\n    while (this.arr.length) {\n      const first = this.arr.shift();\n      if (this.map[first.id]) return first.id;\n    }\n  }\n  minId(clear) {\n    if (clear) {\n      return this._clearAndGetMinId();\n    } else {\n      return this._findFirstId();\n    }\n  }\n}","map":{"version":3,"names":["isNumber","getBBoxSegments","getBBoxSize","getExpandedBBox","isPointInBBox","isPointOnBBoxBoundary","getLinesIntersection","add","manhattanDistance","toVector2","defaultCfg","enableObstacleAvoidance","offset","maxAllowedDirectionChange","Math","PI","maximumLoops","gridSize","startDirections","endDirections","directionMap","right","stepX","stepY","left","bottom","top","penalties","distFunc","keyOf","point","round","alignToGrid","p","align","value","map","getAngleDiff","angle1","angle2","directionChange","abs","getDirectionAngle","p1","p2","deltaX","deltaY","atan2","getDirectionChange","current","neighbor","cameFrom","scaleStartPoint","directionAngle","currentCameFrom","prev","prevDirectionAngle","getObstacleMap","nodes","options","obstacleMap","forEach","item","destroyed","isVisible","bbox","getRenderBounds","x","min","max","y","estimateCost","from","anchors","anchor","getNearestPoint","points","refPoint","nearestPoint","minDistance","i","length","dis","getBoxPoints","node","directions","expandedBBox","Object","keys","reduce","res","directionKey","includes","direction","width","height","otherPoint","segments","intersectP","push","getControlPoints","endPoint","startPoints","scaleEndPoint","controlPoints","pointZero","unshift","_current","_currentCameFrom","prePoint","realStartPoints","startPoint","aStarSearch","sourceNode","targetNode","config","getCenter","assign","obstacles","endPoints","openList","closedList","gScore","fScore","sortedOpenSet","SortedArray","firstStep","key","id","endPointsKeys","remainLoops","curCost","Infinity","entries","minId","remove","dir","values","neighborId","directionPenalties","neighborCost","isNaN","costFromStart","neighborGScore","constructor","arr","_innerAdd","low","high","mid","floor","splice","_clearAndGetMinId","_findFirstId","first","shift","clear"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/router/shortest-path.ts"],"sourcesContent":["import { isNumber } from '@antv/util';\nimport type { Direction, ID, Node, Point, ShortestPathRouterOptions } from '../../types';\nimport { getBBoxSegments, getBBoxSize, getExpandedBBox, isPointInBBox, isPointOnBBoxBoundary } from '../bbox';\nimport { getLinesIntersection } from '../line';\nimport { add, manhattanDistance, toVector2 } from '../vector';\n\nconst defaultCfg: ShortestPathRouterOptions = {\n  enableObstacleAvoidance: false,\n  offset: 10,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 3000,\n  gridSize: 5,\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  directionMap: {\n    right: { stepX: 1, stepY: 0 },\n    left: { stepX: -1, stepY: 0 },\n    bottom: { stepX: 0, stepY: 1 },\n    top: { stepX: 0, stepY: -1 },\n  },\n  penalties: { 0: 0, 90: 0 },\n  distFunc: manhattanDistance,\n};\n\nconst keyOf = (point: Point) => `${Math.round(point[0])}|||${Math.round(point[1])}`;\n\nfunction alignToGrid(p: Point, gridSize: number): Point;\nfunction alignToGrid(p: number, gridSize: number): number;\n/**\n * <zh/> 将坐标对齐到网格\n *\n * <en/> Align to the grid\n * @param p - <zh/> 坐标 | <en/> point\n * @param gridSize - <zh/> 网格大小 | <en/> grid size\n * @returns <zh/> 对齐后的坐标 | <en/> aligned point\n */\nfunction alignToGrid(p: number | Point, gridSize: number): number | Point {\n  const align = (value: number) => Math.round(value / gridSize);\n  if (isNumber(p)) return align(p);\n  return p.map(align) as Point;\n}\n\n/**\n * <zh/> 获取两个角度的变化方向，并确保小于 180 度\n *\n * <en/ >Get changed direction angle and make sure less than 180 degrees\n * @param angle1 - <zh/> 第一个角度 | <en/> the first angle\n * @param angle2 - <zh/> 第二个角度 | <en/> the second angle\n * @returns <zh/> 两个角度的变化方向 | <en/> changed direction angle\n */\nfunction getAngleDiff(angle1: number, angle2: number) {\n  const directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;\n}\n\n/**\n * <zh/> 获取从 p1 指向 p2 的向量与 x 轴正方向之间的夹角，单位为弧度\n *\n * <en/> Get the angle between the vector from p1 to p2 and the positive direction of the x-axis, in radians\n * @param p1 - <zh/> 点 p1 | <en/> point p1\n * @param p2 - <zh/> 点 p2 | <en/> point p2\n * @returns <zh/> 夹角 | <en/> angle\n */\nfunction getDirectionAngle(p1: Point, p2: Point) {\n  const deltaX = p2[0] - p1[0];\n  const deltaY = p2[1] - p1[1];\n\n  if (!deltaX && !deltaY) return 0;\n\n  return Math.atan2(deltaY, deltaX);\n}\n\n/**\n * <zh/> 获取两个点之间的方向变化\n *\n * <en/> Get direction change between two points\n * @param current - <zh/> 当前点 | <en/> current point\n * @param neighbor - <zh/> 邻居点 | <en/> neighbor point\n * @param cameFrom - <zh/> 来源点 | <en/> source point\n * @param scaleStartPoint - <zh/> 缩放后的起点 | <en/> scaled start point\n * @returns <zh/> 方向变化 | <en/> direction change\n */\nfunction getDirectionChange(\n  current: Point,\n  neighbor: Point,\n  cameFrom: Record<string, Point>,\n  scaleStartPoint: Point,\n): number {\n  const directionAngle = getDirectionAngle(current, neighbor);\n\n  const currentCameFrom = cameFrom[keyOf(current)];\n  const prev = !currentCameFrom ? scaleStartPoint : currentCameFrom;\n  const prevDirectionAngle = getDirectionAngle(prev, current);\n\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n}\n\n/**\n * <zh/> 获取障碍物地图\n *\n * <en/> Get obstacle map\n * @param nodes - <zh/> 图上所有节点 | <en/> all nodes on the graph\n * @param options - <zh/> 路由配置 | <en/> router options\n * @returns <zh/> 障碍物地图 | <en/> obstacle map\n */\nconst getObstacleMap = (nodes: Node[], options: Required<ShortestPathRouterOptions>) => {\n  const { offset, gridSize } = options;\n  const obstacleMap: Record<string, boolean> = {};\n\n  nodes.forEach((item: Node) => {\n    if (!item || item.destroyed || !item.isVisible()) return;\n    const bbox = getExpandedBBox(item.getRenderBounds(), offset);\n    for (let x = alignToGrid(bbox.min[0], gridSize); x <= alignToGrid(bbox.max[0], gridSize); x += 1) {\n      for (let y = alignToGrid(bbox.min[1], gridSize); y <= alignToGrid(bbox.max[1], gridSize); y += 1) {\n        obstacleMap[`${x}|||${y}`] = true;\n      }\n    }\n  });\n  return obstacleMap;\n};\n\n/**\n * <zh/> 估算从起点到多个锚点的最小代价\n *\n * <en/> Estimate minimum cost from the starting point to multiple anchor points\n * @param from - <zh/> 起点 | <en/> source point\n * @param anchors - <zh/> 锚点 | <en/> anchor points\n * @param distFunc - <zh/> 距离函数 | <en/> distance function\n * @returns <zh/> 最小成本 | <en/> minimum cost\n */\nexport function estimateCost(from: Point, anchors: Point[], distFunc: (p1: Point, p2: Point) => number) {\n  return Math.min(...anchors.map((anchor) => distFunc(from, anchor)));\n}\n\n/**\n * <zh/> 已知一个点集与一个参考点，从点集中找到距离参考点最近的点\n *\n * <en/> Given a set of points and a reference point, find the point closest to the reference point from the set of points\n * @param points - <zh/> 点集 | <en/> set of points\n * @param refPoint - <zh/> 参考点 | <en/> reference point\n * @param distFunc - <zh/> 距离函数 | <en/> distance function\n * @returns <zh/> 最近的点 | <en/> nearest point\n */\nexport function getNearestPoint(points: Point[], refPoint: Point, distFunc: (p1: Point, p2: Point) => number): Point {\n  let nearestPoint = points[0];\n  let minDistance = distFunc(points[0], refPoint);\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    const dis = distFunc(point, refPoint);\n    if (dis < minDistance) {\n      nearestPoint = point;\n      minDistance = dis;\n    }\n  }\n  return nearestPoint;\n}\n\n/**\n * Calculate the connection points on the expanded BBox\n * @param point\n * @param node\n * @param directions\n * @param options\n */\nconst getBoxPoints = (\n  point: Point,\n  node: Node,\n  directions: Direction[],\n  options: Required<ShortestPathRouterOptions>,\n): Point[] => {\n  // create-edge 生成边的过程中，endNode 为 null\n  if (!node) return [point];\n\n  const { directionMap, offset } = options;\n  const expandedBBox = getExpandedBBox(node.getRenderBounds(), offset);\n\n  const points = (Object.keys(directionMap) as Direction[]).reduce<Point[]>((res, directionKey) => {\n    if (directions.includes(directionKey)) {\n      const direction = directionMap[directionKey];\n      const [width, height] = getBBoxSize(expandedBBox);\n      const otherPoint: Point = [point[0] + direction.stepX * width, point[1] + direction.stepY * height];\n      const segments = getBBoxSegments(expandedBBox);\n      for (let i = 0; i < segments.length; i++) {\n        const intersectP = getLinesIntersection([point, otherPoint], segments[i]);\n        if (intersectP && isPointOnBBoxBoundary(intersectP, expandedBBox)) {\n          res.push(intersectP);\n        }\n      }\n    }\n\n    return res;\n  }, []);\n\n  if (!isPointInBBox(point, expandedBBox)) {\n    points.push(point);\n  }\n\n  return points.map((point) => alignToGrid(point, options.gridSize));\n};\n\nconst getControlPoints = (\n  current: Point,\n  cameFrom: Record<ID, Point>,\n  scaleStartPoint: Point,\n  endPoint: Point,\n  startPoints: Point[],\n  scaleEndPoint: Point,\n  gridSize: number,\n) => {\n  const controlPoints: Point[] = [];\n\n  // append endPoint\n  let pointZero: Point = [\n    scaleEndPoint[0] === endPoint[0] ? endPoint[0] : current[0] * gridSize,\n    scaleEndPoint[1] === endPoint[1] ? endPoint[1] : current[1] * gridSize,\n  ];\n  controlPoints.unshift(pointZero);\n\n  let _current = current;\n  let _currentCameFrom = cameFrom[keyOf(_current)];\n\n  while (_currentCameFrom) {\n    const prePoint = _currentCameFrom;\n    const point = _current;\n    const directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n\n    if (directionChange) {\n      pointZero = [\n        prePoint[0] === point[0] ? pointZero[0] : prePoint[0] * gridSize,\n        prePoint[1] === point[1] ? pointZero[1] : prePoint[1] * gridSize,\n      ];\n      controlPoints.unshift(pointZero);\n    }\n    _currentCameFrom = cameFrom[keyOf(prePoint)];\n    _current = prePoint;\n  }\n\n  // append startPoint\n  const realStartPoints = startPoints.map((point) => [point[0] * gridSize, point[1] * gridSize] as Point);\n  const startPoint = getNearestPoint(realStartPoints, pointZero, manhattanDistance);\n\n  controlPoints.unshift(startPoint);\n\n  return controlPoints;\n};\n\n/**\n * Find the shortest path between a given source node to a destination node according to A* Search Algorithm：https://www.geeksforgeeks.org/a-search-algorithm/\n * @param sourceNode - <zh/> 源节点 | <en/> source node\n * @param targetNode - <zh/> 目标节点 | <en/> target node\n * @param nodes - <zh/> 图上所有节点 | <en/> all nodes on the graph\n * @param config - <zh/> 路由配置 | <en/> router options\n * @returns <zh/> 控制点数组 | <en/> control point array\n */\nexport function aStarSearch(\n  sourceNode: Node,\n  targetNode: Node,\n  nodes: Node[],\n  config: ShortestPathRouterOptions,\n): Point[] {\n  const startPoint = toVector2(sourceNode.getCenter());\n  const endPoint = toVector2(targetNode.getCenter());\n\n  const options = Object.assign(defaultCfg, config) as Required<ShortestPathRouterOptions>;\n\n  const { gridSize } = options;\n\n  const obstacles = options.enableObstacleAvoidance ? nodes : [sourceNode, targetNode];\n  const obstacleMap = getObstacleMap(obstacles, options);\n\n  const scaleStartPoint = alignToGrid(startPoint, gridSize);\n  const scaleEndPoint = alignToGrid(endPoint, gridSize);\n\n  const startPoints = getBoxPoints(startPoint, sourceNode, options.startDirections, options);\n  const endPoints = getBoxPoints(endPoint, targetNode, options.endDirections, options);\n\n  startPoints.forEach((point) => delete obstacleMap[keyOf(point)]);\n  endPoints.forEach((point) => delete obstacleMap[keyOf(point)]);\n\n  const openList: Record<string, Point> = {};\n  const closedList: Record<string, boolean> = {};\n  const cameFrom: Record<string, Point> = {};\n\n  // The movement cost to move from the starting point to the current point on the grid.\n  const gScore: Record<string, number> = {};\n\n  // The estimated movement cost to move from the starting point to the end point after passing through the current point.\n  // f = g + h\n  const fScore: Record<string, number> = {};\n\n  const sortedOpenSet = new SortedArray();\n\n  for (let i = 0; i < startPoints.length; i++) {\n    const firstStep = startPoints[i];\n    const key = keyOf(firstStep);\n    openList[key] = firstStep;\n    gScore[key] = 0;\n    fScore[key] = estimateCost(firstStep, endPoints, options.distFunc);\n\n    // Push start point to sortedOpenSet\n    sortedOpenSet.add({\n      id: key,\n      value: fScore[key],\n    });\n  }\n\n  const endPointsKeys = endPoints.map((point) => keyOf(point));\n\n  let remainLoops = options.maximumLoops;\n  let current: Point;\n  let curCost = Infinity;\n\n  for (const [id, value] of Object.entries(openList)) {\n    if (fScore[id] <= curCost) {\n      curCost = fScore[id];\n      current = value;\n    }\n  }\n\n  while (Object.keys(openList).length > 0 && remainLoops > 0) {\n    const minId = sortedOpenSet.minId(false);\n    if (minId) {\n      current = openList[minId];\n    } else {\n      break;\n    }\n    const key = keyOf(current);\n\n    // If currentNode is final, return the successful path\n    if (endPointsKeys.includes(key)) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize);\n    }\n\n    // Set currentNode as closed\n    delete openList[key];\n    sortedOpenSet.remove(key);\n    closedList[key] = true;\n\n    // Get the neighbor points of the next step\n    for (const dir of Object.values(options.directionMap)) {\n      const neighbor = add(current, [dir.stepX, dir.stepY]);\n      const neighborId = keyOf(neighbor);\n      if (closedList[neighborId]) continue;\n\n      const directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > options.maxAllowedDirectionChange) continue;\n\n      if (obstacleMap[neighborId]) continue; // skip if intersects\n\n      // Add neighbor points to openList, and calculate the cost of each neighbor point\n      if (!openList[neighborId]) {\n        openList[neighborId] = neighbor;\n      }\n\n      const directionPenalties = options.penalties[directionChange];\n      const neighborCost =\n        options.distFunc(current, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);\n      const costFromStart = gScore[key] + neighborCost;\n      const neighborGScore = gScore[neighborId];\n\n      if (neighborGScore && costFromStart >= neighborGScore) continue;\n\n      cameFrom[neighborId] = current;\n      gScore[neighborId] = costFromStart;\n      fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, options.distFunc);\n\n      sortedOpenSet.add({\n        id: neighborId,\n        value: fScore[neighborId],\n      });\n    }\n    remainLoops -= 1;\n  }\n\n  return [];\n}\n\ntype Item = {\n  id: string;\n  value: number;\n};\n\n/**\n * <zh/> 有序数组，按升序排列\n *\n * <en/> Sorted array, sorted in ascending order\n */\nexport class SortedArray {\n  public arr: Item[] = [];\n\n  private map: Record<string, boolean> = {};\n\n  constructor() {\n    this.arr = [];\n    this.map = {};\n  }\n\n  private _innerAdd(item: Item, length: number) {\n    let low = 0,\n      high = length - 1;\n    while (high - low > 1) {\n      const mid = Math.floor((low + high) / 2);\n      if (this.arr[mid].value > item.value) {\n        high = mid;\n      } else if (this.arr[mid].value < item.value) {\n        low = mid;\n      } else {\n        this.arr.splice(mid, 0, item);\n        this.map[item.id] = true;\n        return;\n      }\n    }\n    this.arr.splice(high, 0, item);\n    this.map[item.id] = true;\n  }\n\n  /**\n   * <zh/> 将新项添加到适当的索引位置\n   *\n   * <en/> Add the new item to the appropriate index\n   * @param item - <zh/> 新项 | <en/> new item\n   */\n  public add(item: Item) {\n    // 已经存在，先移除\n    // If exists, remove it\n    delete this.map[item.id];\n\n    const length = this.arr.length;\n    // 如果为空或者最后一个元素小于当前元素，直接添加到最后\n    // If empty or the last element is less than the current element, add to the end\n    if (!length || this.arr[length - 1].value < item.value) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n\n    // 按照升序排列，找到合适的位置插入\n    // Find the appropriate position to insert in ascending order\n    this._innerAdd(item, length);\n  }\n\n  public remove(id: string) {\n    if (!this.map[id]) return;\n    delete this.map[id];\n  }\n\n  private _clearAndGetMinId() {\n    let res;\n    for (let i = this.arr.length - 1; i >= 0; i--) {\n      if (this.map[this.arr[i].id]) res = this.arr[i].id;\n      else this.arr.splice(i, 1);\n    }\n    return res;\n  }\n\n  private _findFirstId() {\n    while (this.arr.length) {\n      const first = this.arr.shift()!;\n      if (this.map[first.id]) return first.id;\n    }\n  }\n\n  public minId(clear: boolean) {\n    if (clear) {\n      return this._clearAndGetMinId();\n    } else {\n      return this._findFirstId();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}