{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar feasibleTree = require(\"./feasible-tree\");\nvar slack = require(\"./util\").slack;\nvar initRank = require(\"./util\").longestPath;\nvar preorder = require(\"../graphlib\").alg.preorder;\nvar postorder = require(\"../graphlib\").alg.postorder;\nvar simplify = require(\"../util\").simplify;\nmodule.exports = networkSimplex;\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  initRank(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n  var e, f;\n  while (e = leaveEdge(t)) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function (v) {\n    assignCutValue(t, g, v);\n  });\n}\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n  cutValue = graphEdge.weight;\n  _.forEach(g.nodeEdges(child), function (e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n  return cutValue;\n}\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function (w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n  return nextLim;\n}\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n  var candidates = _.filter(g.edges(), function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n  return _.minBy(candidates, function (edge) {\n    return slack(g, edge);\n  });\n}\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function (v) {\n    return !g.node(v).parent;\n  });\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function (v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}","map":{"version":3,"names":["_","require","feasibleTree","slack","initRank","longestPath","preorder","alg","postorder","simplify","module","exports","networkSimplex","initLowLimValues","initCutValues","calcCutValue","leaveEdge","enterEdge","exchangeEdges","g","t","e","f","vs","nodes","slice","length","forEach","v","assignCutValue","child","childLab","node","parent","edge","cutvalue","childIsTail","graphEdge","cutValue","weight","nodeEdges","isOutEdge","other","w","pointsToHead","otherWeight","isTreeEdge","otherCutValue","tree","root","arguments","dfsAssignLowLim","visited","nextLim","low","label","neighbors","has","lim","find","edges","hasEdge","vLabel","wLabel","tailLabel","flip","candidates","filter","isDescendant","minBy","removeEdge","setEdge","updateRanks","flipped","rank","minlen","u","rootLabel"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/dagre/lib/rank/network-simplex.js"],"sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar feasibleTree = require(\"./feasible-tree\");\nvar slack = require(\"./util\").slack;\nvar initRank = require(\"./util\").longestPath;\nvar preorder = require(\"../graphlib\").alg.preorder;\nvar postorder = require(\"../graphlib\").alg.postorder;\nvar simplify = require(\"../util\").simplify;\n\nmodule.exports = networkSimplex;\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  initRank(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function(v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function(e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function(w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function(e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function(edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return _.minBy(candidates, function(edge) { return slack(g, edge); });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function(v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}