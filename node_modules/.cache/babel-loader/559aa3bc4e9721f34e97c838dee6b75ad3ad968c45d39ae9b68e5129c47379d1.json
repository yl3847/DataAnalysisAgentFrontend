{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Text, Group, Circle, Path } from '@antv/g';\nimport { deepMix, isUndefined, find, get } from '@antv/util';\nimport { subObject } from '../utils/helper';\nimport { selectPlotArea, getPointsR, getPointsPath, getElements, getThetaPath } from './utils';\nconst DEFAULT_STYLE = {\n  pointR: 6,\n  pointStrokeWidth: 1,\n  pointStroke: '#888',\n  pointActiveStroke: '#f5f5f5',\n  pathStroke: '#888',\n  pathLineDash: [3, 4],\n  labelFontSize: 12,\n  labelFill: '#888',\n  labelStroke: '#fff',\n  labelLineWidth: 1,\n  labelY: -6,\n  labelX: 2\n};\n// point shape name.\nconst MOVE_POINT_NAME = 'movePoint';\n// Element mouseenter change style.\nconst elementMouseenter = e => {\n  const element = e.target;\n  const {\n    markType\n  } = element;\n  // Mark line.\n  if (markType === 'line') {\n    element.attr('_lineWidth', element.attr('lineWidth') || 1);\n    element.attr('lineWidth', element.attr('_lineWidth') + 3);\n  }\n  // Mark interval.\n  if (markType === 'interval') {\n    element.attr('_opacity', element.attr('opacity') || 1);\n    element.attr('opacity', 0.7 * element.attr('_opacity'));\n  }\n};\n// Element mouseleave change style.\nconst elementMouseleave = e => {\n  const element = e.target;\n  const {\n    markType\n  } = element;\n  // Mark line.\n  if (markType === 'line') {\n    element.attr('lineWidth', element.attr('_lineWidth'));\n  }\n  // Mark interval.\n  if (markType === 'interval') {\n    element.attr('opacity', element.attr('_opacity'));\n  }\n};\n// Get the latest overall data based on the individual data changes.\nconst getNewData = (newChangeData, data, encode) => {\n  return data.map(d => {\n    const isUpdate = ['x', 'color'].reduce((v, key) => {\n      const field = encode[key];\n      if (!field) return v;\n      if (d[field] !== newChangeData[field]) return false;\n      return v;\n    }, true);\n    return isUpdate ? Object.assign(Object.assign({}, d), newChangeData) : d;\n  });\n};\n// Find mark interval origin element data.\nconst getIntervalDataRatioTransformFn = element => {\n  const y = get(element, ['__data__', 'y']);\n  const y1 = get(element, ['__data__', 'y1']);\n  const v = y1 - y;\n  const {\n    __data__: {\n      data,\n      encode,\n      transform\n    },\n    childNodes\n  } = element.parentNode;\n  const isNormalizeY = find(transform, ({\n    type\n  }) => type === 'normalizeY');\n  const yField = get(encode, ['y', 'field']);\n  const value = data[childNodes.indexOf(element)][yField];\n  return (newValue, isTheta = false) => {\n    if (isNormalizeY || isTheta) {\n      return newValue / (1 - newValue) / (v / (1 - v)) * value;\n    }\n    return newValue;\n  };\n};\n// Find origin path data.\nconst getPathDataRatioTransformFn = (element, index) => {\n  const v = get(element, ['__data__', 'seriesItems', index, '0', 'value']);\n  const i = get(element, ['__data__', 'seriesIndex', index]);\n  const {\n    __data__: {\n      data,\n      encode,\n      transform\n    }\n  } = element.parentNode;\n  const isNormalizeY = find(transform, ({\n    type\n  }) => type === 'normalizeY');\n  const yField = get(encode, ['y', 'field']);\n  const value = data[i][yField];\n  return newValue => {\n    if (isNormalizeY) {\n      if (v === 1) {\n        return newValue;\n      }\n      return newValue / (1 - newValue) / (v / (1 - v)) * value;\n    }\n    return newValue;\n  };\n};\n// Point shape select change style.\nconst selectedPointsStyle = (pointsShape, selection, defaultStyle) => {\n  pointsShape.forEach((shape, index) => {\n    shape.attr('stroke', selection[1] === index ? defaultStyle['activeStroke'] : defaultStyle['stroke']);\n  });\n};\n// Create help show message shape.\nconst createHelpShape = (group, circle, pathStyle, labelStyle) => {\n  const pathShape = new Path({\n    style: pathStyle\n  });\n  const labelShape = new Text({\n    style: labelStyle\n  });\n  circle.appendChild(labelShape);\n  group.appendChild(pathShape);\n  return [pathShape, labelShape];\n};\n// Get color scale type.\nconst getColorType = (scaleColor, color) => {\n  const indexOf = get(scaleColor, ['options', 'range', 'indexOf']);\n  if (!indexOf) return;\n  const i = scaleColor.options.range.indexOf(color);\n  return scaleColor.sortedDomain[i];\n};\n// Get the same direction new point.\nconst getSamePointPosition = (center, point, target) => {\n  const oldR = getPointsR(center, point);\n  const newR = getPointsR(center, target);\n  const ratio = newR / oldR;\n  const newX = center[0] + (point[0] - center[0]) * ratio;\n  const newY = center[1] + (point[1] - center[1]) * ratio;\n  return [newX, newY];\n};\n/**\n * ElementPointMove interaction.\n */\nexport function ElementPointMove(elementPointMoveOptions = {}) {\n  const {\n      selection = [],\n      precision = 2\n    } = elementPointMoveOptions,\n    style = __rest(elementPointMoveOptions, [\"selection\", \"precision\"]);\n  const defaultStyle = Object.assign(Object.assign({}, DEFAULT_STYLE), style || {});\n  // Shape default style.\n  const pathDefaultStyle = subObject(defaultStyle, 'path');\n  const labelDefaultStyle = subObject(defaultStyle, 'label');\n  const pointDefaultStyle = subObject(defaultStyle, 'point');\n  return (context, _, emitter) => {\n    const {\n      update,\n      setState,\n      container,\n      view,\n      options: {\n        marks,\n        coordinate: coordinateOptions\n      }\n    } = context;\n    const plotArea = selectPlotArea(container);\n    let elements = getElements(plotArea);\n    let newState;\n    let newSelection = selection;\n    const {\n      transform = [],\n      type: coordinateType\n    } = coordinateOptions;\n    const isTranspose = !!find(transform, ({\n      type\n    }) => type === 'transpose');\n    const isPolar = coordinateType === 'polar';\n    const isTheta = coordinateType === 'theta';\n    const isArea = !!find(elements, ({\n      markType\n    }) => markType === 'area');\n    if (isArea) {\n      elements = elements.filter(({\n        markType\n      }) => markType === 'area');\n    }\n    // Create points\n    const pointsGroup = new Group({\n      style: {\n        // Tooltip point need down.\n        zIndex: 2\n      }\n    });\n    plotArea.appendChild(pointsGroup);\n    const selectedChange = () => {\n      emitter.emit('element-point:select', {\n        nativeEvent: true,\n        data: {\n          selection: newSelection\n        }\n      });\n    };\n    const dataChange = (changeData, data) => {\n      emitter.emit('element-point:moved', {\n        nativeEvent: true,\n        data: {\n          changeData,\n          data\n        }\n      });\n    };\n    // Element click change style.\n    const elementClick = e => {\n      const element = e.target;\n      newSelection = [element.parentNode.childNodes.indexOf(element)];\n      selectedChange();\n      createPoints(element);\n    };\n    const elementSelect = d => {\n      const {\n        data: {\n          selection\n        },\n        nativeEvent\n      } = d;\n      if (nativeEvent) return;\n      newSelection = selection;\n      const element = get(elements, [newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]]);\n      if (element) {\n        createPoints(element);\n      }\n    };\n    // Create select element points.\n    const createPoints = element => {\n      const {\n        attributes,\n        markType,\n        __data__: data\n      } = element;\n      const {\n        stroke: fill\n      } = attributes;\n      const {\n        points,\n        seriesTitle,\n        color,\n        title,\n        seriesX,\n        y1\n      } = data;\n      // Transpose Currently only do mark interval;\n      if (isTranspose && markType !== 'interval') return;\n      const {\n        scale,\n        coordinate\n      } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;\n      const {\n        color: scaleColor,\n        y: scaleY,\n        x: scaleX\n      } = scale;\n      const center = coordinate.getCenter();\n      pointsGroup.removeChildren();\n      let downPoint;\n      const updateView = (x, y, color, markTypes) => __awaiter(this, void 0, void 0, function* () {\n        setState('elementPointMove', viewOptions => {\n          var _a;\n          // Update marks.\n          const newMarks = (((_a = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a === void 0 ? void 0 : _a.marks) || marks).map(mark => {\n            if (!markTypes.includes(mark.type)) return mark;\n            const {\n              data,\n              encode\n            } = mark;\n            const encodeKeys = Object.keys(encode);\n            // Get change new one element data.\n            const newChangeData = encodeKeys.reduce((value, key) => {\n              const dataKey = encode[key];\n              if (key === 'x') {\n                value[dataKey] = x;\n              }\n              if (key === 'y') {\n                value[dataKey] = y;\n              }\n              if (key === 'color') {\n                value[dataKey] = color;\n              }\n              return value;\n            }, {});\n            // Get change new all data.\n            const newData = getNewData(newChangeData, data, encode);\n            dataChange(newChangeData, newData);\n            return deepMix({}, mark, {\n              data: newData,\n              // No need animate\n              animate: false\n            });\n          });\n          return Object.assign(Object.assign({}, viewOptions), {\n            marks: newMarks\n          });\n        });\n        return yield update('elementPointMove');\n      });\n      if (['line', 'area'].includes(markType)) {\n        points.forEach((p, index) => {\n          const title = scaleX.invert(seriesX[index]);\n          // Area points have bottom point.\n          if (!title) return;\n          const circle = new Circle({\n            name: MOVE_POINT_NAME,\n            style: Object.assign({\n              cx: p[0],\n              cy: p[1],\n              fill\n            }, pointDefaultStyle)\n          });\n          const ratioTransform = getPathDataRatioTransformFn(element, index);\n          circle.addEventListener('mousedown', e => {\n            const oldPoint = coordinate.output([seriesX[index], 0]);\n            const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;\n            container.attr('cursor', 'move');\n            if (newSelection[1] !== index) {\n              newSelection[1] = index;\n              selectedChange();\n            }\n            selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);\n            const [pathShape, labelShape] = createHelpShape(pointsGroup, circle, pathDefaultStyle, labelDefaultStyle);\n            // Point move change text\n            const pointMousemove = e => {\n              const newCy = p[1] + e.clientY - downPoint[1];\n              // Area/Radar chart.\n              if (isArea) {\n                // Radar chart.\n                if (isPolar) {\n                  const newCx = p[0] + e.clientX - downPoint[0];\n                  const [newX, newY] = getSamePointPosition(center, oldPoint, [newCx, newCy]);\n                  const [, initY] = coordinate.output([1, scaleY.output(0)]);\n                  const [, y] = coordinate.invert([newX, initY - (points[index + pathLength][1] - newY)]);\n                  const nextIndex = (index + 1) % pathLength;\n                  const lastIndex = (index - 1 + pathLength) % pathLength;\n                  const newPath = getPointsPath([points[lastIndex], [newX, newY], seriesTitle[nextIndex] && points[nextIndex]]);\n                  labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));\n                  pathShape.attr('d', newPath);\n                  circle.attr('cx', newX);\n                  circle.attr('cy', newY);\n                } else {\n                  // Area chart.\n                  const [, initY] = coordinate.output([1, scaleY.output(0)]);\n                  const [, y] = coordinate.invert([p[0], initY - (points[index + pathLength][1] - newCy)]);\n                  const newPath = getPointsPath([points[index - 1], [p[0], newCy], seriesTitle[index + 1] && points[index + 1]]);\n                  labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));\n                  pathShape.attr('d', newPath);\n                  circle.attr('cy', newCy);\n                }\n              } else {\n                // Line chart.\n                const [, y] = coordinate.invert([p[0], newCy]);\n                const newPath = getPointsPath([points[index - 1], [p[0], newCy], points[index + 1]]);\n                labelShape.attr('text', scaleY.invert(y).toFixed(precision));\n                pathShape.attr('d', newPath);\n                circle.attr('cy', newCy);\n              }\n            };\n            downPoint = [e.clientX, e.clientY];\n            window.addEventListener('mousemove', pointMousemove);\n            const mouseupFn = () => __awaiter(this, void 0, void 0, function* () {\n              container.attr('cursor', 'default');\n              window.removeEventListener('mousemove', pointMousemove);\n              container.removeEventListener('mouseup', mouseupFn);\n              if (isUndefined(labelShape.attr('text'))) return;\n              const y = Number(labelShape.attr('text'));\n              const colorType = getColorType(scaleColor, color);\n              newState = yield updateView(title, y, colorType, ['line', 'area']);\n              labelShape.remove();\n              pathShape.remove();\n              createPoints(element);\n            });\n            container.addEventListener('mouseup', mouseupFn);\n          });\n          pointsGroup.appendChild(circle);\n        });\n        selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);\n      } else if (markType === 'interval') {\n        // Column chart point.\n        let circlePoint = [(points[0][0] + points[1][0]) / 2, points[0][1]];\n        // Bar chart point.\n        if (isTranspose) {\n          circlePoint = [points[0][0], (points[0][1] + points[1][1]) / 2];\n        } else if (isTheta) {\n          // Pie chart point.\n          circlePoint = points[0];\n        }\n        const ratioTransform = getIntervalDataRatioTransformFn(element);\n        const circle = new Circle({\n          name: MOVE_POINT_NAME,\n          style: Object.assign(Object.assign({\n            cx: circlePoint[0],\n            cy: circlePoint[1],\n            fill\n          }, pointDefaultStyle), {\n            stroke: pointDefaultStyle['activeStroke']\n          })\n        });\n        circle.addEventListener('mousedown', e => {\n          container.attr('cursor', 'move');\n          const colorType = getColorType(scaleColor, color);\n          const [pathShape, labelShape] = createHelpShape(pointsGroup, circle, pathDefaultStyle, labelDefaultStyle);\n          // Point move change text\n          const pointMousemove = e => {\n            if (isTranspose) {\n              // Bar chart.\n              const newCx = circlePoint[0] + e.clientX - downPoint[0];\n              const [initX] = coordinate.output([scaleY.output(0), scaleY.output(0)]);\n              const [, x] = coordinate.invert([initX + (newCx - points[2][0]), circlePoint[1]]);\n              const newPath = getPointsPath([[newCx, points[0][1]], [newCx, points[1][1]], points[2], points[3]], true);\n              labelShape.attr('text', ratioTransform(scaleY.invert(x)).toFixed(precision));\n              pathShape.attr('d', newPath);\n              circle.attr('cx', newCx);\n            } else if (isTheta) {\n              // Pie chart.\n              const newCy = circlePoint[1] + e.clientY - downPoint[1];\n              const newCx = circlePoint[0] + e.clientX - downPoint[0];\n              const [newXOut, newYOut] = getSamePointPosition(center, [newCx, newCy], circlePoint);\n              const [newXIn, newYIn] = getSamePointPosition(center, [newCx, newCy], points[1]);\n              const lastPercent = coordinate.invert([newXOut, newYOut])[1];\n              const percent = y1 - lastPercent;\n              if (percent < 0) return;\n              const newPath = getThetaPath(center, [[newXOut, newYOut], [newXIn, newYIn], points[2], points[3]], percent > 0.5 ? 1 : 0);\n              labelShape.attr('text', ratioTransform(percent, true).toFixed(precision));\n              pathShape.attr('d', newPath);\n              circle.attr('cx', newXOut);\n              circle.attr('cy', newYOut);\n            } else {\n              // Column chart.\n              const newCy = circlePoint[1] + e.clientY - downPoint[1];\n              const [, initY] = coordinate.output([1, scaleY.output(0)]);\n              const [, y] = coordinate.invert([circlePoint[0], initY - (points[2][1] - newCy)]);\n              const newPath = getPointsPath([[points[0][0], newCy], [points[1][0], newCy], points[2], points[3]], true);\n              labelShape.attr('text', ratioTransform(scaleY.invert(y)).toFixed(precision));\n              pathShape.attr('d', newPath);\n              circle.attr('cy', newCy);\n            }\n          };\n          downPoint = [e.clientX, e.clientY];\n          window.addEventListener('mousemove', pointMousemove);\n          // Change mosueup change data and update 、clear shape.\n          const mouseupFn = () => __awaiter(this, void 0, void 0, function* () {\n            container.attr('cursor', 'default');\n            container.removeEventListener('mouseup', mouseupFn);\n            window.removeEventListener('mousemove', pointMousemove);\n            if (isUndefined(labelShape.attr('text'))) return;\n            const y = Number(labelShape.attr('text'));\n            newState = yield updateView(title, y, colorType, [markType]);\n            labelShape.remove();\n            pathShape.remove();\n            createPoints(element);\n          });\n          container.addEventListener('mouseup', mouseupFn);\n        });\n        pointsGroup.appendChild(circle);\n      }\n    };\n    // Add EventListener.\n    elements.forEach((element, index) => {\n      if (newSelection[0] === index) {\n        createPoints(element);\n      }\n      element.addEventListener('click', elementClick);\n      element.addEventListener('mouseenter', elementMouseenter);\n      element.addEventListener('mouseleave', elementMouseleave);\n    });\n    const rootClick = e => {\n      const element = e === null || e === void 0 ? void 0 : e.target;\n      if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {\n        newSelection = [];\n        selectedChange();\n        pointsGroup.removeChildren();\n      }\n    };\n    emitter.on('element-point:select', elementSelect);\n    emitter.on('element-point:unselect', rootClick);\n    container.addEventListener('mousedown', rootClick);\n    // Remove EventListener.\n    return () => {\n      pointsGroup.remove();\n      emitter.off('element-point:select', elementSelect);\n      emitter.off('element-point:unselect', rootClick);\n      container.removeEventListener('mousedown', rootClick);\n      elements.forEach(element => {\n        element.removeEventListener('click', elementClick);\n        element.removeEventListener('mouseenter', elementMouseenter);\n        element.removeEventListener('mouseleave', elementMouseleave);\n      });\n    };\n  };\n}","map":{"version":3,"names":["Text","Group","Circle","Path","deepMix","isUndefined","find","get","subObject","selectPlotArea","getPointsR","getPointsPath","getElements","getThetaPath","DEFAULT_STYLE","pointR","pointStrokeWidth","pointStroke","pointActiveStroke","pathStroke","pathLineDash","labelFontSize","labelFill","labelStroke","labelLineWidth","labelY","labelX","MOVE_POINT_NAME","elementMouseenter","e","element","target","markType","attr","elementMouseleave","getNewData","newChangeData","data","encode","map","d","isUpdate","reduce","v","key","field","Object","assign","getIntervalDataRatioTransformFn","y","y1","__data__","transform","childNodes","parentNode","isNormalizeY","type","yField","value","indexOf","newValue","isTheta","getPathDataRatioTransformFn","index","i","selectedPointsStyle","pointsShape","selection","defaultStyle","forEach","shape","createHelpShape","group","circle","pathStyle","labelStyle","pathShape","style","labelShape","appendChild","getColorType","scaleColor","color","options","range","sortedDomain","getSamePointPosition","center","point","oldR","newR","ratio","newX","newY","ElementPointMove","elementPointMoveOptions","precision","__rest","pathDefaultStyle","labelDefaultStyle","pointDefaultStyle","context","_","emitter","update","setState","container","view","marks","coordinate","coordinateOptions","plotArea","elements","newState","newSelection","coordinateType","isTranspose","isPolar","isArea","filter","pointsGroup","zIndex","selectedChange","emit","nativeEvent","dataChange","changeData","elementClick","createPoints","elementSelect","attributes","stroke","fill","points","seriesTitle","title","seriesX","scale","scaleY","x","scaleX","getCenter","removeChildren","downPoint","updateView","markTypes","__awaiter","viewOptions","newMarks","_a","mark","includes","encodeKeys","keys","dataKey","newData","animate","p","invert","name","cx","cy","ratioTransform","addEventListener","oldPoint","output","pathLength","length","pointMousemove","newCy","clientY","newCx","clientX","initY","nextIndex","lastIndex","newPath","toFixed","window","mouseupFn","removeEventListener","Number","colorType","remove","circlePoint","initX","newXOut","newYOut","newXIn","newYIn","lastPercent","percent","rootClick","on","off"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/elementPointMove.ts"],"sourcesContent":["import { Text, Group, Circle, Path } from '@antv/g';\nimport { deepMix, isUndefined, find, get } from '@antv/util';\nimport type { CircleStyleProps, TextStyleProps, PathStyleProps } from '@antv/g';\nimport { subObject } from '../utils/helper';\n\nimport {\n  selectPlotArea,\n  getPointsR,\n  getPointsPath,\n  getElements,\n  getThetaPath,\n} from './utils';\n\nexport type ElementPointMoveOptions = {\n  selection?: number[];\n  precision?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_STYLE = {\n  pointR: 6,\n  pointStrokeWidth: 1,\n  pointStroke: '#888',\n  pointActiveStroke: '#f5f5f5',\n  pathStroke: '#888',\n  pathLineDash: [3, 4],\n  labelFontSize: 12,\n  labelFill: '#888',\n  labelStroke: '#fff',\n  labelLineWidth: 1,\n  labelY: -6,\n  labelX: 2,\n};\n\n// point shape name.\nconst MOVE_POINT_NAME = 'movePoint';\n\n// Element mouseenter change style.\nconst elementMouseenter = (e) => {\n  const element = e.target;\n  const { markType } = element;\n  // Mark line.\n  if (markType === 'line') {\n    element.attr('_lineWidth', element.attr('lineWidth') || 1);\n    element.attr('lineWidth', element.attr('_lineWidth') + 3);\n  }\n  // Mark interval.\n  if (markType === 'interval') {\n    element.attr('_opacity', element.attr('opacity') || 1);\n    element.attr('opacity', 0.7 * element.attr('_opacity'));\n  }\n};\n\n// Element mouseleave change style.\nconst elementMouseleave = (e) => {\n  const element = e.target;\n  const { markType } = element;\n  // Mark line.\n  if (markType === 'line') {\n    element.attr('lineWidth', element.attr('_lineWidth'));\n  }\n  // Mark interval.\n  if (markType === 'interval') {\n    element.attr('opacity', element.attr('_opacity'));\n  }\n};\n\n// Get the latest overall data based on the individual data changes.\nconst getNewData = (newChangeData, data, encode) => {\n  return data.map((d) => {\n    const isUpdate = ['x', 'color'].reduce((v, key) => {\n      const field = encode[key];\n      if (!field) return v;\n\n      if (d[field] !== newChangeData[field]) return false;\n\n      return v;\n    }, true);\n\n    return isUpdate ? { ...d, ...newChangeData } : d;\n  });\n};\n\n// Find mark interval origin element data.\nconst getIntervalDataRatioTransformFn = (element) => {\n  const y = get(element, ['__data__', 'y']);\n  const y1 = get(element, ['__data__', 'y1']);\n  const v = y1 - y;\n\n  const {\n    __data__: { data, encode, transform },\n    childNodes,\n  } = element.parentNode;\n  const isNormalizeY = find(transform, ({ type }) => type === 'normalizeY');\n  const yField = get(encode, ['y', 'field']);\n  const value = data[childNodes.indexOf(element)][yField];\n\n  return (newValue, isTheta = false) => {\n    if (isNormalizeY || isTheta) {\n      return (newValue / (1 - newValue) / (v / (1 - v))) * value;\n    }\n\n    return newValue;\n  };\n};\n\n// Find origin path data.\nconst getPathDataRatioTransformFn = (element, index) => {\n  const v = get(element, ['__data__', 'seriesItems', index, '0', 'value']);\n  const i = get(element, ['__data__', 'seriesIndex', index]);\n\n  const {\n    __data__: { data, encode, transform },\n  } = element.parentNode;\n  const isNormalizeY = find(transform, ({ type }) => type === 'normalizeY');\n  const yField = get(encode, ['y', 'field']);\n  const value = data[i][yField];\n\n  return (newValue) => {\n    if (isNormalizeY) {\n      if (v === 1) {\n        return newValue;\n      }\n      return (newValue / (1 - newValue) / (v / (1 - v))) * value;\n    }\n\n    return newValue;\n  };\n};\n\n// Point shape select change style.\nconst selectedPointsStyle = (pointsShape, selection, defaultStyle) => {\n  pointsShape.forEach((shape, index) => {\n    shape.attr(\n      'stroke',\n      selection[1] === index\n        ? defaultStyle['activeStroke']\n        : defaultStyle['stroke'],\n    );\n  });\n};\n\n// Create help show message shape.\nconst createHelpShape = (\n  group,\n  circle,\n  pathStyle,\n  labelStyle,\n): [Path, Text] => {\n  const pathShape = new Path({\n    style: pathStyle,\n  });\n\n  const labelShape = new Text({\n    style: labelStyle,\n  });\n\n  circle.appendChild(labelShape);\n  group.appendChild(pathShape);\n  return [pathShape, labelShape];\n};\n\n// Get color scale type.\nconst getColorType = (scaleColor, color) => {\n  const indexOf = get(scaleColor, ['options', 'range', 'indexOf']);\n  if (!indexOf) return;\n  const i = scaleColor.options.range.indexOf(color);\n  return scaleColor.sortedDomain[i];\n};\n\n// Get the same direction new point.\nconst getSamePointPosition = (center, point, target) => {\n  const oldR = getPointsR(center, point);\n  const newR = getPointsR(center, target);\n  const ratio = newR / oldR;\n  const newX = center[0] + (point[0] - center[0]) * ratio;\n  const newY = center[1] + (point[1] - center[1]) * ratio;\n  return [newX, newY];\n};\n\n/**\n * ElementPointMove interaction.\n */\nexport function ElementPointMove(\n  elementPointMoveOptions: ElementPointMoveOptions = {},\n) {\n  const { selection = [], precision = 2, ...style } = elementPointMoveOptions;\n\n  const defaultStyle = { ...DEFAULT_STYLE, ...(style || {}) };\n\n  // Shape default style.\n  const pathDefaultStyle = subObject(defaultStyle, 'path') as PathStyleProps;\n  const labelDefaultStyle = subObject(defaultStyle, 'label') as TextStyleProps;\n  const pointDefaultStyle = subObject(\n    defaultStyle,\n    'point',\n  ) as CircleStyleProps;\n\n  return (context, _, emitter) => {\n    const {\n      update,\n      setState,\n      container,\n      view,\n      options: { marks, coordinate: coordinateOptions },\n    } = context;\n    const plotArea = selectPlotArea(container);\n    let elements = getElements(plotArea);\n    let newState;\n    let newSelection = selection;\n\n    const { transform = [], type: coordinateType } = coordinateOptions;\n    const isTranspose = !!find(transform, ({ type }) => type === 'transpose');\n    const isPolar = coordinateType === 'polar';\n    const isTheta = coordinateType === 'theta';\n    const isArea = !!find(elements, ({ markType }) => markType === 'area');\n\n    if (isArea) {\n      elements = elements.filter(({ markType }) => markType === 'area');\n    }\n\n    // Create points\n    const pointsGroup = new Group({\n      style: {\n        // Tooltip point need down.\n        zIndex: 2,\n      },\n    });\n    plotArea.appendChild(pointsGroup);\n\n    const selectedChange = () => {\n      emitter.emit('element-point:select', {\n        nativeEvent: true,\n        data: {\n          selection: newSelection,\n        },\n      });\n    };\n\n    const dataChange = (changeData, data) => {\n      emitter.emit('element-point:moved', {\n        nativeEvent: true,\n        data: {\n          changeData,\n          data,\n        },\n      });\n    };\n\n    // Element click change style.\n    const elementClick = (e) => {\n      const element = e.target;\n      newSelection = [element.parentNode.childNodes.indexOf(element)];\n      selectedChange();\n      createPoints(element);\n    };\n\n    const elementSelect = (d) => {\n      const {\n        data: { selection },\n        nativeEvent,\n      } = d;\n      if (nativeEvent) return;\n      newSelection = selection;\n      const element = get(elements, [newSelection?.[0]]);\n      if (element) {\n        createPoints(element);\n      }\n    };\n\n    // Create select element points.\n    const createPoints = (element) => {\n      const { attributes, markType, __data__: data } = element;\n      const { stroke: fill } = attributes;\n      const { points, seriesTitle, color, title, seriesX, y1 } = data;\n      // Transpose Currently only do mark interval;\n      if (isTranspose && markType !== 'interval') return;\n\n      const { scale, coordinate } = newState?.view || view;\n      const { color: scaleColor, y: scaleY, x: scaleX } = scale;\n      const center = coordinate.getCenter();\n\n      pointsGroup.removeChildren();\n      let downPoint;\n\n      const updateView = async (x, y, color, markTypes) => {\n        setState('elementPointMove', (viewOptions) => {\n          // Update marks.\n          const newMarks = (newState?.options?.marks || marks).map((mark) => {\n            if (!markTypes.includes(mark.type)) return mark;\n            const { data, encode } = mark;\n            const encodeKeys = Object.keys(encode);\n\n            // Get change new one element data.\n            const newChangeData = encodeKeys.reduce((value, key) => {\n              const dataKey = encode[key];\n              if (key === 'x') {\n                value[dataKey] = x;\n              }\n              if (key === 'y') {\n                value[dataKey] = y;\n              }\n              if (key === 'color') {\n                value[dataKey] = color;\n              }\n              return value;\n            }, {} as any);\n            // Get change new all data.\n            const newData = getNewData(newChangeData, data, encode);\n            dataChange(newChangeData, newData);\n\n            return deepMix({}, mark, {\n              data: newData,\n              // No need animate\n              animate: false,\n            });\n          });\n\n          return { ...viewOptions, marks: newMarks };\n        });\n\n        return await update('elementPointMove');\n      };\n\n      if (['line', 'area'].includes(markType)) {\n        points.forEach((p, index) => {\n          const title = scaleX.invert(seriesX[index]);\n\n          // Area points have bottom point.\n          if (!title) return;\n\n          const circle = new Circle({\n            name: MOVE_POINT_NAME,\n            style: {\n              cx: p[0],\n              cy: p[1],\n              fill,\n              ...pointDefaultStyle,\n            },\n          });\n\n          const ratioTransform = getPathDataRatioTransformFn(element, index);\n\n          circle.addEventListener('mousedown', (e) => {\n            const oldPoint = coordinate.output([seriesX[index], 0]);\n            const pathLength = seriesTitle?.length;\n\n            container.attr('cursor', 'move');\n\n            if (newSelection[1] !== index) {\n              newSelection[1] = index;\n              selectedChange();\n            }\n            selectedPointsStyle(\n              pointsGroup.childNodes,\n              newSelection,\n              pointDefaultStyle,\n            );\n\n            const [pathShape, labelShape] = createHelpShape(\n              pointsGroup,\n              circle,\n              pathDefaultStyle,\n              labelDefaultStyle,\n            );\n\n            // Point move change text\n            const pointMousemove = (e) => {\n              const newCy = p[1] + e.clientY - downPoint[1];\n              // Area/Radar chart.\n              if (isArea) {\n                // Radar chart.\n                if (isPolar) {\n                  const newCx = p[0] + e.clientX - downPoint[0];\n\n                  const [newX, newY] = getSamePointPosition(center, oldPoint, [\n                    newCx,\n                    newCy,\n                  ]);\n\n                  const [, initY] = coordinate.output([1, scaleY.output(0)]);\n                  const [, y] = coordinate.invert([\n                    newX,\n                    initY - (points[index + pathLength][1] - newY),\n                  ]);\n\n                  const nextIndex = (index + 1) % pathLength;\n                  const lastIndex = (index - 1 + pathLength) % pathLength;\n                  const newPath = getPointsPath([\n                    points[lastIndex],\n                    [newX, newY],\n                    seriesTitle[nextIndex] && points[nextIndex],\n                  ]);\n                  labelShape.attr(\n                    'text',\n                    ratioTransform(scaleY.invert(y)).toFixed(precision),\n                  );\n                  pathShape.attr('d', newPath);\n                  circle.attr('cx', newX);\n                  circle.attr('cy', newY);\n                } else {\n                  // Area chart.\n                  const [, initY] = coordinate.output([1, scaleY.output(0)]);\n                  const [, y] = coordinate.invert([\n                    p[0],\n                    initY - (points[index + pathLength][1] - newCy),\n                  ]);\n                  const newPath = getPointsPath([\n                    points[index - 1],\n                    [p[0], newCy],\n                    seriesTitle[index + 1] && points[index + 1],\n                  ]);\n                  labelShape.attr(\n                    'text',\n                    ratioTransform(scaleY.invert(y)).toFixed(precision),\n                  );\n                  pathShape.attr('d', newPath);\n                  circle.attr('cy', newCy);\n                }\n              } else {\n                // Line chart.\n                const [, y] = coordinate.invert([p[0], newCy]);\n                const newPath = getPointsPath([\n                  points[index - 1],\n                  [p[0], newCy],\n                  points[index + 1],\n                ]);\n                labelShape.attr('text', scaleY.invert(y).toFixed(precision));\n                pathShape.attr('d', newPath);\n                circle.attr('cy', newCy);\n              }\n            };\n\n            downPoint = [e.clientX, e.clientY];\n            window.addEventListener('mousemove', pointMousemove);\n\n            const mouseupFn = async () => {\n              container.attr('cursor', 'default');\n              window.removeEventListener('mousemove', pointMousemove);\n              container.removeEventListener('mouseup', mouseupFn);\n\n              if (isUndefined(labelShape.attr('text'))) return;\n\n              const y = Number(labelShape.attr('text'));\n              const colorType = getColorType(scaleColor, color);\n              newState = await updateView(title, y, colorType, [\n                'line',\n                'area',\n              ]);\n\n              labelShape.remove();\n              pathShape.remove();\n              createPoints(element);\n            };\n\n            container.addEventListener('mouseup', mouseupFn);\n          });\n\n          pointsGroup.appendChild(circle);\n        });\n\n        selectedPointsStyle(\n          pointsGroup.childNodes,\n          newSelection,\n          pointDefaultStyle,\n        );\n      } else if (markType === 'interval') {\n        // Column chart point.\n        let circlePoint = [(points[0][0] + points[1][0]) / 2, points[0][1]];\n        // Bar chart point.\n        if (isTranspose) {\n          circlePoint = [points[0][0], (points[0][1] + points[1][1]) / 2];\n        } else if (isTheta) {\n          // Pie chart point.\n          circlePoint = points[0];\n        }\n\n        const ratioTransform = getIntervalDataRatioTransformFn(element);\n\n        const circle = new Circle({\n          name: MOVE_POINT_NAME,\n          style: {\n            cx: circlePoint[0],\n            cy: circlePoint[1],\n            fill,\n            ...pointDefaultStyle,\n            stroke: pointDefaultStyle['activeStroke'],\n          },\n        });\n\n        circle.addEventListener('mousedown', (e) => {\n          container.attr('cursor', 'move');\n\n          const colorType = getColorType(scaleColor, color);\n\n          const [pathShape, labelShape] = createHelpShape(\n            pointsGroup,\n            circle,\n            pathDefaultStyle,\n            labelDefaultStyle,\n          );\n\n          // Point move change text\n          const pointMousemove = (e) => {\n            if (isTranspose) {\n              // Bar chart.\n              const newCx = circlePoint[0] + e.clientX - downPoint[0];\n              const [initX] = coordinate.output([\n                scaleY.output(0),\n                scaleY.output(0),\n              ]);\n\n              const [, x] = coordinate.invert([\n                initX + (newCx - points[2][0]),\n                circlePoint[1],\n              ]);\n              const newPath = getPointsPath(\n                [\n                  [newCx, points[0][1]],\n                  [newCx, points[1][1]],\n                  points[2],\n                  points[3],\n                ],\n                true,\n              );\n\n              labelShape.attr(\n                'text',\n                ratioTransform(scaleY.invert(x)).toFixed(precision),\n              );\n              pathShape.attr('d', newPath);\n              circle.attr('cx', newCx);\n            } else if (isTheta) {\n              // Pie chart.\n              const newCy = circlePoint[1] + e.clientY - downPoint[1];\n              const newCx = circlePoint[0] + e.clientX - downPoint[0];\n\n              const [newXOut, newYOut] = getSamePointPosition(\n                center,\n                [newCx, newCy],\n                circlePoint,\n              );\n              const [newXIn, newYIn] = getSamePointPosition(\n                center,\n                [newCx, newCy],\n                points[1],\n              );\n              const lastPercent = coordinate.invert([newXOut, newYOut])[1];\n              const percent = y1 - lastPercent;\n\n              if (percent < 0) return;\n              const newPath = getThetaPath(\n                center,\n                [[newXOut, newYOut], [newXIn, newYIn], points[2], points[3]],\n                percent > 0.5 ? 1 : 0,\n              );\n\n              labelShape.attr(\n                'text',\n                ratioTransform(percent, true).toFixed(precision),\n              );\n              pathShape.attr('d', newPath);\n              circle.attr('cx', newXOut);\n              circle.attr('cy', newYOut);\n            } else {\n              // Column chart.\n              const newCy = circlePoint[1] + e.clientY - downPoint[1];\n              const [, initY] = coordinate.output([1, scaleY.output(0)]);\n\n              const [, y] = coordinate.invert([\n                circlePoint[0],\n                initY - (points[2][1] - newCy),\n              ]);\n              const newPath = getPointsPath(\n                [\n                  [points[0][0], newCy],\n                  [points[1][0], newCy],\n                  points[2],\n                  points[3],\n                ],\n                true,\n              );\n\n              labelShape.attr(\n                'text',\n                ratioTransform(scaleY.invert(y)).toFixed(precision),\n              );\n              pathShape.attr('d', newPath);\n              circle.attr('cy', newCy);\n            }\n          };\n\n          downPoint = [e.clientX, e.clientY];\n          window.addEventListener('mousemove', pointMousemove);\n\n          // Change mosueup change data and update 、clear shape.\n          const mouseupFn = async () => {\n            container.attr('cursor', 'default');\n            container.removeEventListener('mouseup', mouseupFn);\n            window.removeEventListener('mousemove', pointMousemove);\n\n            if (isUndefined(labelShape.attr('text'))) return;\n\n            const y = Number(labelShape.attr('text'));\n\n            newState = await updateView(title, y, colorType, [markType]);\n\n            labelShape.remove();\n            pathShape.remove();\n            createPoints(element);\n          };\n\n          container.addEventListener('mouseup', mouseupFn);\n        });\n\n        pointsGroup.appendChild(circle);\n      }\n    };\n\n    // Add EventListener.\n    elements.forEach((element, index) => {\n      if (newSelection[0] === index) {\n        createPoints(element);\n      }\n      element.addEventListener('click', elementClick);\n      element.addEventListener('mouseenter', elementMouseenter);\n      element.addEventListener('mouseleave', elementMouseleave);\n    });\n\n    const rootClick = (e) => {\n      const element = e?.target;\n      if (\n        !element ||\n        (element.name !== MOVE_POINT_NAME && !elements.includes(element))\n      ) {\n        newSelection = [];\n        selectedChange();\n        pointsGroup.removeChildren();\n      }\n    };\n\n    emitter.on('element-point:select', elementSelect);\n    emitter.on('element-point:unselect', rootClick);\n    container.addEventListener('mousedown', rootClick);\n\n    // Remove EventListener.\n    return () => {\n      pointsGroup.remove();\n      emitter.off('element-point:select', elementSelect);\n      emitter.off('element-point:unselect', rootClick);\n      container.removeEventListener('mousedown', rootClick);\n      elements.forEach((element) => {\n        element.removeEventListener('click', elementClick);\n        element.removeEventListener('mouseenter', elementMouseenter);\n        element.removeEventListener('mouseleave', elementMouseleave);\n      });\n    };\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}