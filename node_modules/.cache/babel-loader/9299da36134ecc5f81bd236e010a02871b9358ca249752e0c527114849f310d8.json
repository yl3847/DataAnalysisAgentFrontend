{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Coordinate, Coordinate3D } from '@antv/coord';\nimport { useLibrary } from './library';\nexport function createCoordinate(layout, partialOptions, library) {\n  const [useCoordinate] = useLibrary('coordinate', library);\n  const {\n    innerHeight,\n    innerWidth,\n    insetLeft,\n    insetTop,\n    insetRight,\n    insetBottom\n  } = layout;\n  const {\n    coordinates: partialTransform = []\n  } = partialOptions;\n  const transform = inferCoordinate(partialTransform);\n  const isCartesian3D = transform[0].type === 'cartesian3D';\n  const options = Object.assign(Object.assign({}, layout), {\n    x: insetLeft,\n    y: insetTop,\n    width: innerWidth - insetLeft - insetRight,\n    height: innerHeight - insetBottom - insetTop,\n    transformations: transform.flatMap(useCoordinate)\n  });\n  const coordinate = isCartesian3D ?\n  // @ts-ignore\n  new Coordinate3D(options) : new Coordinate(options);\n  return coordinate;\n}\nexport function coordinate2Transform(node, library) {\n  // @ts-ignore\n  const {\n      coordinate = {},\n      coordinates\n    } = node,\n    rest = __rest(node, [\"coordinate\", \"coordinates\"]);\n  // If coordinates are already set, it means that the coordinate has been processed\n  // during the initialization. There is not need to process it during update.\n  if (coordinates) return node;\n  const {\n      type,\n      transform = []\n    } = coordinate,\n    options = __rest(coordinate, [\"type\", \"transform\"]);\n  if (!type) return Object.assign(Object.assign({}, rest), {\n    coordinates: transform\n  });\n  const [, createCoordinate] = useLibrary('coordinate', library);\n  const {\n    transform: isTransform = false\n  } = createCoordinate(type).props || {};\n  if (isTransform) {\n    throw new Error(`Unknown coordinate: ${type}.`);\n  }\n  return Object.assign(Object.assign({}, rest), {\n    coordinates: [Object.assign({\n      type\n    }, options), ...transform]\n  });\n}\nexport function coordOf(coordinates, type) {\n  return coordinates.filter(d => d.type === type);\n}\n/**\n * todo Duplication is not considered\n */\nexport function isPolar(coordinates) {\n  return coordOf(coordinates, 'polar').length > 0;\n}\nexport function isHelix(coordinates) {\n  return coordOf(coordinates, 'helix').length > 0;\n}\n/**\n * todo The number of transposes matters\n */\nexport function isTranspose(coordinates) {\n  return coordOf(coordinates, 'transpose').length % 2 === 1;\n}\nexport function isParallel(coordinates) {\n  return coordOf(coordinates, 'parallel').length > 0;\n}\nexport function isTheta(coordinates) {\n  return coordOf(coordinates, 'theta').length > 0;\n}\nexport function isReflect(coordinates) {\n  return coordOf(coordinates, 'reflect').length > 0;\n}\nexport function isRadial(coordinates) {\n  return coordOf(coordinates, 'radial').length > 0;\n}\nexport function isRadar(coordinates) {\n  return coordOf(coordinates, 'radar').length > 0;\n}\n/**\n * todo The axis corresponding to the Y reversal is not reversed\n */\nexport function isReflectY(coordinates) {\n  return coordOf(coordinates, 'reflectY').length > 0;\n}\nfunction inferCoordinate(coordinates) {\n  if (coordinates.find(d => d.type === 'cartesian' || d.type === 'cartesian3D')) return coordinates;\n  return [...coordinates, {\n    type: 'cartesian'\n  }];\n}","map":{"version":3,"names":["Coordinate","Coordinate3D","useLibrary","createCoordinate","layout","partialOptions","library","useCoordinate","innerHeight","innerWidth","insetLeft","insetTop","insetRight","insetBottom","coordinates","partialTransform","transform","inferCoordinate","isCartesian3D","type","options","Object","assign","x","y","width","height","transformations","flatMap","coordinate","coordinate2Transform","node","rest","__rest","isTransform","props","Error","coordOf","filter","d","isPolar","length","isHelix","isTranspose","isParallel","isTheta","isReflect","isRadial","isRadar","isReflectY","find"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/runtime/coordinate.ts"],"sourcesContent":["import { Coordinate, Coordinate3D } from '@antv/coord';\nimport { G2View, G2CoordinateOptions, G2Library } from './types/options';\nimport { CoordinateComponent, CoordinateTransform } from './types/component';\nimport { useLibrary } from './library';\nimport { Layout } from './types/common';\n\nexport function createCoordinate(\n  layout: Layout,\n  partialOptions: G2View,\n  library: G2Library,\n): Coordinate {\n  const [useCoordinate] = useLibrary<\n    G2CoordinateOptions,\n    CoordinateComponent,\n    CoordinateTransform\n  >('coordinate', library);\n  const {\n    innerHeight,\n    innerWidth,\n    insetLeft,\n    insetTop,\n    insetRight,\n    insetBottom,\n  } = layout;\n  const { coordinates: partialTransform = [] } = partialOptions;\n  const transform = inferCoordinate(partialTransform);\n\n  const isCartesian3D = transform[0].type === 'cartesian3D';\n  const options = {\n    // @todo Find a better solution.\n    // Store more layout information for component.\n    ...layout,\n    x: insetLeft,\n    y: insetTop,\n    width: innerWidth - insetLeft - insetRight,\n    height: innerHeight - insetBottom - insetTop,\n    transformations: transform.flatMap(useCoordinate),\n  };\n\n  const coordinate = isCartesian3D\n    ? // @ts-ignore\n      new Coordinate3D(options)\n    : new Coordinate(options);\n  return coordinate as Coordinate;\n}\n\nexport function coordinate2Transform(node: G2View, library: G2Library): G2View {\n  // @ts-ignore\n  const { coordinate = {}, coordinates, ...rest } = node;\n\n  // If coordinates are already set, it means that the coordinate has been processed\n  // during the initialization. There is not need to process it during update.\n  if (coordinates) return node;\n\n  const { type, transform = [], ...options } = coordinate;\n  if (!type) return { ...rest, coordinates: transform };\n  const [, createCoordinate] = useLibrary<\n    G2CoordinateOptions,\n    CoordinateComponent,\n    CoordinateTransform\n  >('coordinate', library);\n  const { transform: isTransform = false } = createCoordinate(type).props || {};\n  if (isTransform) {\n    throw new Error(`Unknown coordinate: ${type}.`);\n  }\n  return { ...rest, coordinates: [{ type, ...options }, ...transform] };\n}\n\nexport function coordOf(\n  coordinates: G2CoordinateOptions[],\n  type: string,\n): G2CoordinateOptions[] {\n  return coordinates.filter((d) => d.type === type);\n}\n\n/**\n * todo Duplication is not considered\n */\n\nexport function isPolar(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'polar').length > 0;\n}\n\nexport function isHelix(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'helix').length > 0;\n}\n\n/**\n * todo The number of transposes matters\n */\nexport function isTranspose(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'transpose').length % 2 === 1;\n}\n\nexport function isParallel(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'parallel').length > 0;\n}\n\nexport function isTheta(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'theta').length > 0;\n}\n\nexport function isReflect(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'reflect').length > 0;\n}\n\nexport function isRadial(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'radial').length > 0;\n}\n\nexport function isRadar(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'radar').length > 0;\n}\n\n/**\n * todo The axis corresponding to the Y reversal is not reversed\n */\nexport function isReflectY(coordinates: G2CoordinateOptions[]) {\n  return coordOf(coordinates, 'reflectY').length > 0;\n}\n\nfunction inferCoordinate(\n  coordinates: G2CoordinateOptions[],\n): G2CoordinateOptions[] {\n  if (\n    coordinates.find((d) => d.type === 'cartesian' || d.type === 'cartesian3D')\n  )\n    return coordinates;\n  return [...coordinates, { type: 'cartesian' }];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}