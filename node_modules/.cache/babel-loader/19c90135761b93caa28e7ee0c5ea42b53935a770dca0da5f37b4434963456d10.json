{"ast":null,"code":"import { Group, Rect, Circle, Path, Text, Ellipse, Image, Line, Polygon, Polyline, HTML } from '@antv/g';\nimport { group } from '@antv/vendor/d3-array';\nimport { error } from './helper';\nexport function select(node) {\n  return new Selection([node], null, node, node.ownerDocument);\n}\n/**\n * A simple implementation of d3-selection for @antv/g.\n * It has the core features of d3-selection and extended ability.\n * Every methods of selection returns new selection if elements\n * are mutated(e.g. append, remove), otherwise return the selection itself(e.g. attr, style).\n * @see https://github.com/d3/d3-selection\n * @see https://github.com/antvis/g\n * @todo Nested selections.\n * @todo More useful functor.\n */\nexport class Selection {\n  constructor(elements = null, data = null, parent = null, document = null, selections = [null, null, null, null, null], transitions = [], updateElements = []) {\n    this._elements = Array.from(elements);\n    this._data = data;\n    this._parent = parent;\n    this._document = document;\n    this._enter = selections[0];\n    this._update = selections[1];\n    this._exit = selections[2];\n    this._merge = selections[3];\n    this._split = selections[4];\n    this._transitions = transitions;\n    this._facetElements = updateElements;\n  }\n  selectAll(selector) {\n    const elements = typeof selector === 'string' ? this._parent.querySelectorAll(selector) : selector;\n    return new Selection(elements, null, this._elements[0], this._document);\n  }\n  selectFacetAll(selector) {\n    const elements = typeof selector === 'string' ? this._parent.querySelectorAll(selector) : selector;\n    return new Selection(this._elements, null, this._parent, this._document, undefined, undefined, elements);\n  }\n  /**\n   * @todo Replace with querySelector which has bug now.\n   */\n  select(selector) {\n    const element = typeof selector === 'string' ? this._parent.querySelectorAll(selector)[0] || null : selector;\n    return new Selection([element], null, element, this._document);\n  }\n  append(node) {\n    const callback = typeof node === 'function' ? node : () => this.createElement(node);\n    const elements = [];\n    if (this._data !== null) {\n      // For empty selection, append new element to parent.\n      // Each element is bind with datum.\n      for (let i = 0; i < this._data.length; i++) {\n        const d = this._data[i];\n        const [datum, from] = Array.isArray(d) ? d : [d, null];\n        const newElement = callback(datum, i);\n        newElement.__data__ = datum;\n        if (from !== null) newElement.__fromElements__ = from;\n        this._parent.appendChild(newElement);\n        elements.push(newElement);\n      }\n      return new Selection(elements, null, this._parent, this._document);\n    } else {\n      // For non-empty selection, append new element to\n      // selected element and return new selection.\n      for (let i = 0; i < this._elements.length; i++) {\n        const element = this._elements[i];\n        const datum = element.__data__;\n        const newElement = callback(datum, i);\n        element.appendChild(newElement);\n        elements.push(newElement);\n      }\n      return new Selection(elements, null, elements[0], this._document);\n    }\n  }\n  maybeAppend(id, node, className) {\n    const element = this._elements[0];\n    const child = element.getElementById(id);\n    if (child) {\n      return new Selection([child], null, this._parent, this._document);\n    }\n    const newChild = typeof node === 'string' ? this.createElement(node) : node();\n    newChild.id = id;\n    if (className) newChild.className = className;\n    element.appendChild(newChild);\n    return new Selection([newChild], null, this._parent, this._document);\n  }\n  /**\n   * Bind data to elements, and produce three selection:\n   * Enter: Selection with empty elements and data to be bind to elements.\n   * Update: Selection with elements to be updated.\n   * Exit: Selection with elements to be removed.\n   */\n  data(data, id = d => d, groupId = () => null) {\n    // An Array of new data.\n    const enter = [];\n    // An Array of elements to be updated.\n    const update = [];\n    // A Set of elements to be removed.\n    const exit = new Set(this._elements);\n    // An Array of data to be merged into one element.\n    const merge = [];\n    // A Set of elements to be split into multiple datum.\n    const split = new Set();\n    // A Map from key to each element.\n    const keyElement = new Map(this._elements.map((d, i) => [id(d.__data__, i), d]));\n    // A Map from key to exist element. The Update Selection\n    // can get element from this map, this is for diff among\n    // facets.\n    const keyUpdateElement = new Map(this._facetElements.map((d, i) => [id(d.__data__, i), d]));\n    // A Map from groupKey to a group of elements.\n    const groupKeyElements = group(this._elements, d => groupId(d.__data__));\n    // Diff data with selection(elements with data).\n    // !!! Note\n    // The switch is strictly ordered, not not change the order of them.\n    for (let i = 0; i < data.length; i++) {\n      const datum = data[i];\n      const key = id(datum, i);\n      const groupKey = groupId(datum, i);\n      // Append element to update selection if incoming data has\n      // exactly the same key with elements.\n      if (keyElement.has(key)) {\n        const element = keyElement.get(key);\n        element.__data__ = datum;\n        element.__facet__ = false;\n        update.push(element);\n        exit.delete(element);\n        keyElement.delete(key);\n        // Append element to update selection if incoming data has\n        // exactly the same key with updateElements.\n      } else if (keyUpdateElement.has(key)) {\n        const element = keyUpdateElement.get(key);\n        element.__data__ = datum;\n        // Flag this element should update its parentNode.\n        element.__facet__ = true;\n        update.push(element);\n        keyUpdateElement.delete(key);\n        // Append datum to merge selection if existed elements has\n        // its key as groupKey.\n      } else if (groupKeyElements.has(key)) {\n        const group = groupKeyElements.get(key);\n        merge.push([datum, group]);\n        for (const element of group) exit.delete(element);\n        groupKeyElements.delete(key);\n        // Append element to split selection if incoming data has\n        // groupKey as its key, and bind to datum for it.\n      } else if (keyElement.has(groupKey)) {\n        const element = keyElement.get(groupKey);\n        if (element.__toData__) element.__toData__.push(datum);else element.__toData__ = [datum];\n        split.add(element);\n        exit.delete(element);\n      } else {\n        // @todo Data with non-unique key.\n        enter.push(datum);\n      }\n    }\n    // Create new selection with enter, update and exit.\n    const S = [new Selection([], enter, this._parent, this._document), new Selection(update, null, this._parent, this._document), new Selection(exit, null, this._parent, this._document), new Selection([], merge, this._parent, this._document), new Selection(split, null, this._parent, this._document)];\n    return new Selection(this._elements, null, this._parent, this._document, S);\n  }\n  merge(other) {\n    const elements = [...this._elements, ...other._elements];\n    const transitions = [...this._transitions, ...other._transitions];\n    return new Selection(elements, null, this._parent, this._document, undefined, transitions);\n  }\n  createElement(type) {\n    if (this._document) {\n      return this._document.createElement(type, {});\n    }\n    const Ctor = Selection.registry[type];\n    if (Ctor) return new Ctor();\n    return error(`Unknown node type: ${type}`);\n  }\n  /**\n   * Apply callback for each selection(enter, update, exit)\n   * and merge them into one selection.\n   */\n  join(enter = d => d, update = d => d, exit = d => d.remove(), merge = d => d, split = d => d.remove()) {\n    const newEnter = enter(this._enter);\n    const newUpdate = update(this._update);\n    const newExit = exit(this._exit);\n    const newMerge = merge(this._merge);\n    const newSplit = split(this._split);\n    return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);\n  }\n  remove() {\n    // Remove node immediately if there is no transition,\n    // otherwise wait until transition finished.\n    for (let i = 0; i < this._elements.length; i++) {\n      const transition = this._transitions[i];\n      if (transition) {\n        const T = Array.isArray(transition) ? transition : [transition];\n        Promise.all(T.map(d => d.finished)).then(() => {\n          const element = this._elements[i];\n          element.remove();\n        });\n      } else {\n        const element = this._elements[i];\n        element.remove();\n      }\n    }\n    return new Selection([], null, this._parent, this._document, undefined, this._transitions);\n  }\n  each(callback) {\n    for (let i = 0; i < this._elements.length; i++) {\n      const element = this._elements[i];\n      const datum = element.__data__;\n      callback(datum, i, element);\n    }\n    return this;\n  }\n  attr(key, value) {\n    const callback = typeof value !== 'function' ? () => value : value;\n    return this.each(function (d, i, element) {\n      if (value !== undefined) element[key] = callback(d, i, element);\n    });\n  }\n  style(key, value) {\n    const callback = typeof value !== 'function' ? () => value : value;\n    return this.each(function (d, i, element) {\n      if (value !== undefined) element.style[key] = callback(d, i, element);\n    });\n  }\n  transition(value) {\n    const callback = typeof value !== 'function' ? () => value : value;\n    const {\n      _transitions: T\n    } = this;\n    return this.each(function (d, i, element) {\n      T[i] = callback(d, i, element);\n    });\n  }\n  on(event, handler) {\n    this.each(function (d, i, element) {\n      element.addEventListener(event, handler);\n    });\n    return this;\n  }\n  call(callback, ...args) {\n    callback(this, ...args);\n    return this;\n  }\n  node() {\n    return this._elements[0];\n  }\n  nodes() {\n    return this._elements;\n  }\n  transitions() {\n    return this._transitions;\n  }\n  parent() {\n    return this._parent;\n  }\n}\nSelection.registry = {\n  g: Group,\n  rect: Rect,\n  circle: Circle,\n  path: Path,\n  text: Text,\n  ellipse: Ellipse,\n  image: Image,\n  line: Line,\n  polygon: Polygon,\n  polyline: Polyline,\n  html: HTML\n};","map":{"version":3,"names":["Group","Rect","Circle","Path","Text","Ellipse","Image","Line","Polygon","Polyline","HTML","group","error","select","node","Selection","ownerDocument","constructor","elements","data","parent","document","selections","transitions","updateElements","_elements","Array","from","_data","_parent","_document","_enter","_update","_exit","_merge","_split","_transitions","_facetElements","selectAll","selector","querySelectorAll","selectFacetAll","undefined","element","append","callback","createElement","i","length","d","datum","isArray","newElement","__data__","__fromElements__","appendChild","push","maybeAppend","id","className","child","getElementById","newChild","groupId","enter","update","exit","Set","merge","split","keyElement","Map","map","keyUpdateElement","groupKeyElements","key","groupKey","has","get","__facet__","delete","__toData__","add","S","other","type","Ctor","registry","join","remove","newEnter","newUpdate","newExit","newMerge","newSplit","transition","T","Promise","all","finished","then","each","attr","value","style","on","event","handler","addEventListener","call","args","nodes","g","rect","circle","path","text","ellipse","image","line","polygon","polyline","html"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/utils/selection.ts"],"sourcesContent":["import {\n  Group,\n  Rect,\n  DisplayObject,\n  IDocument,\n  BaseStyleProps as BP,\n  Circle,\n  Path,\n  Text,\n  Ellipse,\n  Image,\n  Line,\n  Polygon,\n  Polyline,\n  HTML,\n  IAnimation as GAnimation,\n} from '@antv/g';\nimport { group } from '@antv/vendor/d3-array';\nimport { error } from './helper';\n\nexport type G2Element = DisplayObject & {\n  // Data for this element.\n  __data__?: any;\n  // An Array of data to be splitted to.\n  __toData__?: any[];\n  // An Array of elements to be merged from.\n  __fromElements__?: DisplayObject[];\n  // Whether to update parent if it in update selection.\n  __facet__?: boolean;\n  // Whether is removed in G2, but also exist in G dom.\n  __removed__?: boolean;\n};\n\nexport function select<T = any>(node: DisplayObject) {\n  return new Selection<T>([node], null, node, node.ownerDocument);\n}\n\n/**\n * A simple implementation of d3-selection for @antv/g.\n * It has the core features of d3-selection and extended ability.\n * Every methods of selection returns new selection if elements\n * are mutated(e.g. append, remove), otherwise return the selection itself(e.g. attr, style).\n * @see https://github.com/d3/d3-selection\n * @see https://github.com/antvis/g\n * @todo Nested selections.\n * @todo More useful functor.\n */\nexport class Selection<T = any> {\n  static registry: Record<string, new () => G2Element> = {\n    g: Group,\n    rect: Rect,\n    circle: Circle,\n    path: Path,\n    text: Text,\n    ellipse: Ellipse,\n    image: Image,\n    line: Line,\n    polygon: Polygon,\n    polyline: Polyline,\n    html: HTML,\n  };\n  private _elements: G2Element[];\n  private _parent: G2Element;\n  private _data: T[] | [T, G2Element[]][];\n  private _enter: Selection;\n  private _exit: Selection;\n  private _update: Selection;\n  private _merge: Selection;\n  private _split: Selection;\n  private _document: IDocument;\n  private _transitions: (GAnimation | GAnimation[])[];\n  private _facetElements: G2Element[];\n\n  constructor(\n    elements: Iterable<G2Element> = null,\n    data: T[] | [T, G2Element[]][] = null,\n    parent: G2Element = null,\n    document: IDocument | null = null,\n    selections: [Selection, Selection, Selection, Selection, Selection] = [\n      null,\n      null,\n      null,\n      null,\n      null,\n    ],\n    transitions: (GAnimation | GAnimation[])[] = [],\n    updateElements: G2Element[] = [],\n  ) {\n    this._elements = Array.from(elements);\n    this._data = data;\n    this._parent = parent;\n    this._document = document;\n    this._enter = selections[0];\n    this._update = selections[1];\n    this._exit = selections[2];\n    this._merge = selections[3];\n    this._split = selections[4];\n    this._transitions = transitions;\n    this._facetElements = updateElements;\n  }\n\n  selectAll(selector: string | G2Element[]): Selection<T> {\n    const elements =\n      typeof selector === 'string'\n        ? this._parent.querySelectorAll<G2Element>(selector)\n        : selector;\n    return new Selection<T>(elements, null, this._elements[0], this._document);\n  }\n\n  selectFacetAll(selector: string | G2Element[]): Selection<T> {\n    const elements =\n      typeof selector === 'string'\n        ? this._parent.querySelectorAll<G2Element>(selector)\n        : selector;\n    return new Selection<T>(\n      this._elements,\n      null,\n      this._parent,\n      this._document,\n      undefined,\n      undefined,\n      elements,\n    );\n  }\n\n  /**\n   * @todo Replace with querySelector which has bug now.\n   */\n  select(selector: string | G2Element): Selection<T> {\n    const element =\n      typeof selector === 'string'\n        ? this._parent.querySelectorAll<G2Element>(selector)[0] || null\n        : selector;\n    return new Selection<T>([element], null, element, this._document);\n  }\n\n  append(node: string | ((data: T, i: number) => G2Element)): Selection<T> {\n    const callback =\n      typeof node === 'function' ? node : () => this.createElement(node);\n\n    const elements = [];\n    if (this._data !== null) {\n      // For empty selection, append new element to parent.\n      // Each element is bind with datum.\n      for (let i = 0; i < this._data.length; i++) {\n        const d = this._data[i];\n        const [datum, from] = Array.isArray(d) ? d : [d, null];\n        const newElement = callback(datum, i);\n        newElement.__data__ = datum;\n        if (from !== null) newElement.__fromElements__ = from;\n        this._parent.appendChild(newElement);\n        elements.push(newElement);\n      }\n      return new Selection(elements, null, this._parent, this._document);\n    } else {\n      // For non-empty selection, append new element to\n      // selected element and return new selection.\n      for (let i = 0; i < this._elements.length; i++) {\n        const element = this._elements[i];\n        const datum = element.__data__;\n        const newElement = callback(datum, i);\n        element.appendChild(newElement);\n        elements.push(newElement);\n      }\n      return new Selection(elements, null, elements[0], this._document);\n    }\n  }\n\n  maybeAppend(\n    id: string,\n    node: string | (() => G2Element),\n    className?: string,\n  ) {\n    const element = this._elements[0];\n    const child = element.getElementById(id) as G2Element;\n    if (child) {\n      return new Selection([child], null, this._parent, this._document);\n    }\n    const newChild =\n      typeof node === 'string' ? this.createElement(node) : node();\n    newChild.id = id;\n    if (className) newChild.className = className;\n    element.appendChild(newChild);\n    return new Selection([newChild], null, this._parent, this._document);\n  }\n\n  /**\n   * Bind data to elements, and produce three selection:\n   * Enter: Selection with empty elements and data to be bind to elements.\n   * Update: Selection with elements to be updated.\n   * Exit: Selection with elements to be removed.\n   */\n  data<T = any>(\n    data: T[],\n    id: (d: T, index?: number) => any = (d) => d,\n    groupId: (d: T, index?: number) => any = () => null,\n  ): Selection<T> {\n    // An Array of new data.\n    const enter: T[] = [];\n\n    // An Array of elements to be updated.\n    const update: G2Element[] = [];\n\n    // A Set of elements to be removed.\n    const exit = new Set<G2Element>(this._elements);\n\n    // An Array of data to be merged into one element.\n    const merge: [T, G2Element[]][] = [];\n\n    // A Set of elements to be split into multiple datum.\n    const split = new Set<G2Element>();\n\n    // A Map from key to each element.\n    const keyElement = new Map<string, G2Element>(\n      this._elements.map((d, i) => [id(d.__data__, i), d]),\n    );\n\n    // A Map from key to exist element. The Update Selection\n    // can get element from this map, this is for diff among\n    // facets.\n    const keyUpdateElement = new Map<string, G2Element>(\n      this._facetElements.map((d, i) => [id(d.__data__, i), d]),\n    );\n\n    // A Map from groupKey to a group of elements.\n    const groupKeyElements = group(this._elements, (d) => groupId(d.__data__));\n\n    // Diff data with selection(elements with data).\n    // !!! Note\n    // The switch is strictly ordered, not not change the order of them.\n    for (let i = 0; i < data.length; i++) {\n      const datum = data[i];\n      const key = id(datum, i);\n      const groupKey = groupId(datum, i);\n      // Append element to update selection if incoming data has\n      // exactly the same key with elements.\n      if (keyElement.has(key)) {\n        const element = keyElement.get(key);\n        element.__data__ = datum;\n        element.__facet__ = false;\n        update.push(element);\n        exit.delete(element);\n        keyElement.delete(key);\n        // Append element to update selection if incoming data has\n        // exactly the same key with updateElements.\n      } else if (keyUpdateElement.has(key)) {\n        const element = keyUpdateElement.get(key);\n        element.__data__ = datum;\n        // Flag this element should update its parentNode.\n        element.__facet__ = true;\n        update.push(element);\n        keyUpdateElement.delete(key);\n        // Append datum to merge selection if existed elements has\n        // its key as groupKey.\n      } else if (groupKeyElements.has(key)) {\n        const group = groupKeyElements.get(key);\n        merge.push([datum, group]);\n        for (const element of group) exit.delete(element);\n        groupKeyElements.delete(key);\n        // Append element to split selection if incoming data has\n        // groupKey as its key, and bind to datum for it.\n      } else if (keyElement.has(groupKey)) {\n        const element = keyElement.get(groupKey);\n        if (element.__toData__) element.__toData__.push(datum);\n        else element.__toData__ = [datum];\n        split.add(element);\n        exit.delete(element);\n      } else {\n        // @todo Data with non-unique key.\n        enter.push(datum);\n      }\n    }\n\n    // Create new selection with enter, update and exit.\n    const S: [\n      Selection<T>,\n      Selection<T>,\n      Selection<T>,\n      Selection<T>,\n      Selection<T>,\n    ] = [\n      new Selection<T>([], enter, this._parent, this._document),\n      new Selection<T>(update, null, this._parent, this._document),\n      new Selection<T>(exit, null, this._parent, this._document),\n      new Selection<T>([], merge, this._parent, this._document),\n      new Selection<T>(split, null, this._parent, this._document),\n    ];\n\n    return new Selection<T>(\n      this._elements,\n      null,\n      this._parent,\n      this._document,\n      S,\n    );\n  }\n\n  merge(other: Selection<T>): Selection<T> {\n    const elements = [...this._elements, ...other._elements];\n    const transitions = [...this._transitions, ...other._transitions];\n    return new Selection<T>(\n      elements,\n      null,\n      this._parent,\n      this._document,\n      undefined,\n      transitions,\n    );\n  }\n\n  createElement(type: string): G2Element {\n    if (this._document) {\n      return this._document.createElement<G2Element, BP>(type, {});\n    }\n    const Ctor = Selection.registry[type];\n    if (Ctor) return new Ctor();\n    return error(`Unknown node type: ${type}`);\n  }\n  /**\n   * Apply callback for each selection(enter, update, exit)\n   * and merge them into one selection.\n   */\n  join(\n    enter: (selection: Selection<T>) => any = (d) => d,\n    update: (selection: Selection<T>) => any = (d) => d,\n    exit: (selection: Selection<T>) => any = (d) => d.remove(),\n    merge: (selection: Selection<T>) => any = (d) => d,\n    split: (selection: Selection<T>) => any = (d) => d.remove(),\n  ): Selection<T> {\n    const newEnter = enter(this._enter);\n    const newUpdate = update(this._update);\n    const newExit = exit(this._exit);\n    const newMerge = merge(this._merge);\n    const newSplit = split(this._split);\n    return newUpdate\n      .merge(newEnter)\n      .merge(newExit)\n      .merge(newMerge)\n      .merge(newSplit);\n  }\n\n  remove(): Selection<T> {\n    // Remove node immediately if there is no transition,\n    // otherwise wait until transition finished.\n    for (let i = 0; i < this._elements.length; i++) {\n      const transition = this._transitions[i];\n      if (transition) {\n        const T = Array.isArray(transition) ? transition : [transition];\n        Promise.all(T.map((d) => d.finished)).then(() => {\n          const element = this._elements[i];\n          element.remove();\n        });\n      } else {\n        const element = this._elements[i];\n        element.remove();\n      }\n    }\n    return new Selection<T>(\n      [],\n      null,\n      this._parent,\n      this._document,\n      undefined,\n      this._transitions,\n    );\n  }\n\n  each(callback: (datum: T, index: number, element) => any): Selection<T> {\n    for (let i = 0; i < this._elements.length; i++) {\n      const element = this._elements[i];\n      const datum = element.__data__;\n      callback(datum, i, element);\n    }\n    return this;\n  }\n\n  attr(key: string, value: any): Selection<T> {\n    const callback = typeof value !== 'function' ? () => value : value;\n    return this.each(function (d, i, element) {\n      if (value !== undefined) element[key] = callback(d, i, element);\n    });\n  }\n\n  style(key: string, value: any): Selection<T> {\n    const callback = typeof value !== 'function' ? () => value : value;\n    return this.each(function (d, i, element) {\n      if (value !== undefined) element.style[key] = callback(d, i, element);\n    });\n  }\n\n  transition(value: any): Selection<T> {\n    const callback = typeof value !== 'function' ? () => value : value;\n    const { _transitions: T } = this;\n    return this.each(function (d, i, element) {\n      T[i] = callback(d, i, element);\n    });\n  }\n\n  on(event: string, handler: any) {\n    this.each(function (d, i, element) {\n      element.addEventListener(event, handler);\n    });\n    return this;\n  }\n\n  call(\n    callback: (selection: Selection<T>, ...args: any[]) => any,\n    ...args: any[]\n  ): Selection<T> {\n    callback(this, ...args);\n    return this;\n  }\n\n  node(): G2Element {\n    return this._elements[0];\n  }\n\n  nodes(): G2Element[] {\n    return this._elements;\n  }\n\n  transitions(): (GAnimation | GAnimation[])[] {\n    return this._transitions;\n  }\n\n  parent(): DisplayObject {\n    return this._parent;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}