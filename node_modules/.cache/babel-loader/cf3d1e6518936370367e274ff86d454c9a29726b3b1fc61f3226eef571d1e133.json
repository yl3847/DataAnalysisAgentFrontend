{"ast":null,"code":"import { BaseTransform, idOf } from '@antv/g6';\nimport { linear, log, pow, sqrt } from '../utils/scale';\nexport class MapEdgeLineWidth extends BaseTransform {\n  static defaultOptions = {\n    minValue: (edge, edges) => Math.min(...Object.values(edges)),\n    maxValue: (edge, edges) => Math.max(...Object.values(edges)),\n    minLineWidth: 1,\n    maxLineWidth: 10,\n    scale: 'linear'\n  };\n  constructor(context, options) {\n    super(context, Object.assign({}, MapEdgeLineWidth.defaultOptions, options));\n  }\n  beforeDraw(input) {\n    const {\n      maxValue,\n      minValue,\n      maxLineWidth,\n      minLineWidth,\n      scale,\n      value\n    } = this.options;\n    const edges = this.context.model.getEdgeData();\n    const valueFunc = typeof value === 'function' ? value : () => value;\n    const values = Object.fromEntries(edges.map(edge => [idOf(edge), valueFunc(edge)]));\n    const {\n      add: {\n        edges: edgesToAdd\n      },\n      update: {\n        edges: edgesToUpdate\n      }\n    } = input;\n    [...edgesToAdd.values(), ...edgesToUpdate.values()].forEach(edge => {\n      const lineWidth = this.assignLineWidthByValue(values[idOf(edge)] || 0, typeof minValue === 'function' ? minValue(edge, values) : minValue, typeof maxValue === 'function' ? maxValue(edge, values) : maxValue, typeof minLineWidth === 'function' ? minLineWidth(edge) : minLineWidth, typeof maxLineWidth === 'function' ? maxLineWidth(edge) : maxLineWidth, scale);\n      edge.style ||= {};\n      edge.style.lineWidth = lineWidth;\n    });\n    return input;\n  }\n  assignLineWidthByValue = (value, minValue, maxValue, minLineWidth, maxLineWidth, scale) => {\n    const domain = [minValue, maxValue];\n    const range = [minLineWidth, maxLineWidth];\n    if (value < minValue || value > maxValue || minValue === maxValue) return range[0];\n    if (typeof scale === 'function') return scale(value, domain, range);\n    switch (scale) {\n      case 'linear':\n        return linear(value, domain, range);\n      case 'log':\n        return log(value, domain, range);\n      case 'pow':\n        return pow(value, domain, range, 2);\n      case 'sqrt':\n        return sqrt(value, domain, range);\n      default:\n        return range[0];\n    }\n  };\n}","map":{"version":3,"names":["BaseTransform","idOf","linear","log","pow","sqrt","MapEdgeLineWidth","defaultOptions","minValue","edge","edges","Math","min","Object","values","maxValue","max","minLineWidth","maxLineWidth","scale","constructor","context","options","assign","beforeDraw","input","value","model","getEdgeData","valueFunc","fromEntries","map","add","edgesToAdd","update","edgesToUpdate","forEach","lineWidth","assignLineWidthByValue","style","domain","range"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@ant-design/graphs/es/core/transform/map-edge-line-width.js"],"sourcesContent":["import { BaseTransform, idOf } from '@antv/g6';\nimport { linear, log, pow, sqrt } from '../utils/scale';\nexport class MapEdgeLineWidth extends BaseTransform {\n    static defaultOptions = {\n        minValue: (edge, edges) => Math.min(...Object.values(edges)),\n        maxValue: (edge, edges) => Math.max(...Object.values(edges)),\n        minLineWidth: 1,\n        maxLineWidth: 10,\n        scale: 'linear',\n    };\n    constructor(context, options) {\n        super(context, Object.assign({}, MapEdgeLineWidth.defaultOptions, options));\n    }\n    beforeDraw(input) {\n        const { maxValue, minValue, maxLineWidth, minLineWidth, scale, value } = this.options;\n        const edges = this.context.model.getEdgeData();\n        const valueFunc = typeof value === 'function' ? value : () => value;\n        const values = Object.fromEntries(edges.map((edge) => [idOf(edge), valueFunc(edge)]));\n        const { add: { edges: edgesToAdd }, update: { edges: edgesToUpdate }, } = input;\n        [...edgesToAdd.values(), ...edgesToUpdate.values()].forEach((edge) => {\n            const lineWidth = this.assignLineWidthByValue(values[idOf(edge)] || 0, typeof minValue === 'function' ? minValue(edge, values) : minValue, typeof maxValue === 'function' ? maxValue(edge, values) : maxValue, typeof minLineWidth === 'function' ? minLineWidth(edge) : minLineWidth, typeof maxLineWidth === 'function' ? maxLineWidth(edge) : maxLineWidth, scale);\n            edge.style ||= {};\n            edge.style.lineWidth = lineWidth;\n        });\n        return input;\n    }\n    assignLineWidthByValue = (value, minValue, maxValue, minLineWidth, maxLineWidth, scale) => {\n        const domain = [minValue, maxValue];\n        const range = [minLineWidth, maxLineWidth];\n        if (value < minValue || value > maxValue || minValue === maxValue)\n            return range[0];\n        if (typeof scale === 'function')\n            return scale(value, domain, range);\n        switch (scale) {\n            case 'linear':\n                return linear(value, domain, range);\n            case 'log':\n                return log(value, domain, range);\n            case 'pow':\n                return pow(value, domain, range, 2);\n            case 'sqrt':\n                return sqrt(value, domain, range);\n            default:\n                return range[0];\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}