{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { arc } from '@antv/vendor/d3-shape';\nimport { isPolar, isHelix, isTranspose } from '../../utils/coordinate';\nimport { select } from '../../utils/selection';\nimport { sub } from '../../utils/vector';\nimport { clamp } from '../../utils/number';\nimport { applyStyle, getArcObject, reorder, toOpacityKey } from '../utils';\n// Render rect in different coordinate.\nexport function rect(document, points, value, coordinate, style = {}) {\n  const {\n      inset = 0,\n      radius = 0,\n      insetLeft = inset,\n      insetTop = inset,\n      insetRight = inset,\n      insetBottom = inset,\n      radiusBottomLeft = radius,\n      radiusBottomRight = radius,\n      radiusTopLeft = radius,\n      radiusTopRight = radius,\n      minWidth = -Infinity,\n      maxWidth = Infinity,\n      minHeight = -Infinity\n    } = style,\n    rest = __rest(style, [\"inset\", \"radius\", \"insetLeft\", \"insetTop\", \"insetRight\", \"insetBottom\", \"radiusBottomLeft\", \"radiusBottomRight\", \"radiusTopLeft\", \"radiusTopRight\", \"minWidth\", \"maxWidth\", \"minHeight\"]);\n  if (!isPolar(coordinate) && !isHelix(coordinate)) {\n    const tpShape = !!isTranspose(coordinate);\n    const [p0,, p2] = tpShape ? reorder(points) : points;\n    const [x, y] = p0;\n    const [width, height] = sub(p2, p0);\n    // Deal with width or height is negative.\n    const absX = width > 0 ? x : x + width;\n    const absY = height > 0 ? y : y + height;\n    const absWidth = Math.abs(width);\n    const absHeight = Math.abs(height);\n    const finalX = absX + insetLeft;\n    const finalY = absY + insetTop;\n    const finalWidth = absWidth - (insetLeft + insetRight);\n    const finalHeight = absHeight - (insetTop + insetBottom);\n    const clampWidth = tpShape ? clamp(finalWidth, minHeight, Infinity) : clamp(finalWidth, minWidth, maxWidth);\n    const clampHeight = tpShape ? clamp(finalHeight, minWidth, maxWidth) : clamp(finalHeight, minHeight, Infinity);\n    const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;\n    const clampY = tpShape ? finalY - (clampHeight - finalHeight) / 2 : finalY - (clampHeight - finalHeight);\n    return select(document.createElement('rect', {})).style('x', clampX).style('y', clampY).style('width', clampWidth).style('height', clampHeight).style('radius', [radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft]).call(applyStyle, rest).node();\n  }\n  // Render path in polar coordinate.\n  const {\n    y,\n    y1\n  } = value;\n  const center = coordinate.getCenter();\n  const arcObject = getArcObject(coordinate, points, [y, y1]);\n  const path = arc().cornerRadius(radius).padAngle(inset * Math.PI / 180);\n  return select(document.createElement('path', {})).style('d', path(arcObject)).style('transform', `translate(${center[0]}, ${center[1]})`).style('radius', radius).style('inset', inset).call(applyStyle, rest).node();\n}\n/**\n * Render rect in different coordinate.\n * Calc arc path based on control points directly rather startAngle, endAngle, innerRadius,\n * outerRadius. This is not accurate and will cause bug when the range of y scale is [1, 0]\n * for cell geometry.\n */\nexport const Color = (options, context) => {\n  // Render border only when colorAttribute is stroke.\n  const {\n      colorAttribute,\n      opacityAttribute = 'fill',\n      first = true,\n      last = true\n    } = options,\n    style = __rest(options, [\"colorAttribute\", \"opacityAttribute\", \"first\", \"last\"]);\n  const {\n    coordinate,\n    document\n  } = context;\n  return (points, value, defaults) => {\n    const {\n        color: defaultColor,\n        radius: defaultRadius = 0\n      } = defaults,\n      restDefaults = __rest(defaults, [\"color\", \"radius\"]);\n    const defaultLineWidth = restDefaults.lineWidth || 1;\n    const {\n        stroke,\n        radius = defaultRadius,\n        radiusTopLeft = radius,\n        radiusTopRight = radius,\n        radiusBottomRight = radius,\n        radiusBottomLeft = radius,\n        innerRadius = 0,\n        innerRadiusTopLeft = innerRadius,\n        innerRadiusTopRight = innerRadius,\n        innerRadiusBottomRight = innerRadius,\n        innerRadiusBottomLeft = innerRadius,\n        lineWidth = colorAttribute === 'stroke' || stroke ? defaultLineWidth : 0,\n        inset = 0,\n        insetLeft = inset,\n        insetRight = inset,\n        insetBottom = inset,\n        insetTop = inset,\n        minWidth,\n        maxWidth,\n        minHeight\n      } = style,\n      rest = __rest(style, [\"stroke\", \"radius\", \"radiusTopLeft\", \"radiusTopRight\", \"radiusBottomRight\", \"radiusBottomLeft\", \"innerRadius\", \"innerRadiusTopLeft\", \"innerRadiusTopRight\", \"innerRadiusBottomRight\", \"innerRadiusBottomLeft\", \"lineWidth\", \"inset\", \"insetLeft\", \"insetRight\", \"insetBottom\", \"insetTop\", \"minWidth\", \"maxWidth\", \"minHeight\"]);\n    const {\n      color = defaultColor,\n      opacity\n    } = value;\n    // Extended style, which is not supported by native g shape,\n    // should apply at first.\n    const standardDirRadius = [first ? radiusTopLeft : innerRadiusTopLeft, first ? radiusTopRight : innerRadiusTopRight, last ? radiusBottomRight : innerRadiusBottomRight, last ? radiusBottomLeft : innerRadiusBottomLeft];\n    const standardDir = ['radiusTopLeft', 'radiusTopRight', 'radiusBottomRight', 'radiusBottomLeft'];\n    // Transpose: rotate it clockwise by 90.\n    if (isTranspose(coordinate)) {\n      standardDir.push(standardDir.shift());\n    }\n    const extendedStyle = Object.assign(Object.assign({\n      radius\n    }, Object.fromEntries(standardDir.map((d, i) => [d, standardDirRadius[i]]))), {\n      inset,\n      insetLeft,\n      insetRight,\n      insetBottom,\n      insetTop,\n      minWidth,\n      maxWidth,\n      minHeight\n    });\n    return select(rect(document, points, value, coordinate, extendedStyle)).call(applyStyle, restDefaults).style('fill', 'transparent').style(colorAttribute, color).style(toOpacityKey(options), opacity).style('lineWidth', lineWidth).style('stroke', stroke === undefined ? color : stroke)\n    // shape.style has higher priority.\n    .call(applyStyle, rest).node();\n  };\n};\n// @todo Should Shape have default animations using for ordinal scale?\nColor.props = {\n  defaultEnterAnimation: 'scaleInY',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut'\n};","map":{"version":3,"names":["arc","isPolar","isHelix","isTranspose","select","sub","clamp","applyStyle","getArcObject","reorder","toOpacityKey","rect","document","points","value","coordinate","style","inset","radius","insetLeft","insetTop","insetRight","insetBottom","radiusBottomLeft","radiusBottomRight","radiusTopLeft","radiusTopRight","minWidth","Infinity","maxWidth","minHeight","rest","__rest","tpShape","p0","p2","x","y","width","height","absX","absY","absWidth","Math","abs","absHeight","finalX","finalY","finalWidth","finalHeight","clampWidth","clampHeight","clampX","clampY","createElement","call","node","y1","center","getCenter","arcObject","path","cornerRadius","padAngle","PI","Color","options","context","colorAttribute","opacityAttribute","first","last","defaults","color","defaultColor","defaultRadius","restDefaults","defaultLineWidth","lineWidth","stroke","innerRadius","innerRadiusTopLeft","innerRadiusTopRight","innerRadiusBottomRight","innerRadiusBottomLeft","opacity","standardDirRadius","standardDir","push","shift","extendedStyle","Object","assign","fromEntries","map","d","i","undefined","props","defaultEnterAnimation","defaultUpdateAnimation","defaultExitAnimation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/interval/color.ts"],"sourcesContent":["import { arc } from '@antv/vendor/d3-shape';\nimport { Vector2, ShapeComponent as SC } from '../../runtime';\nimport { isPolar, isHelix, isTranspose } from '../../utils/coordinate';\nimport { select } from '../../utils/selection';\nimport { sub } from '../../utils/vector';\nimport { clamp } from '../../utils/number';\nimport { applyStyle, getArcObject, reorder, toOpacityKey } from '../utils';\n\nexport type ColorOptions = {\n  colorAttribute: 'fill' | 'stroke';\n  /**\n   * Minimum width of each interval.\n   */\n  minWidth?: number;\n  /**\n   * Maximum width of each interval.\n   */\n  maxWidth?: number;\n\n  /**\n   * Minimum height of each interval.\n   */\n  minHeight?: number;\n\n  [key: string]: any;\n};\n\n// Render rect in different coordinate.\nexport function rect(\n  document,\n  points,\n  value,\n  coordinate,\n  style: Record<string, any> = {},\n) {\n  const {\n    inset = 0,\n    radius = 0,\n    insetLeft = inset,\n    insetTop = inset,\n    insetRight = inset,\n    insetBottom = inset,\n    radiusBottomLeft = radius,\n    radiusBottomRight = radius,\n    radiusTopLeft = radius,\n    radiusTopRight = radius,\n    minWidth = -Infinity,\n    maxWidth = Infinity,\n    minHeight = -Infinity,\n    ...rest\n  } = style;\n  if (!isPolar(coordinate) && !isHelix(coordinate)) {\n    const tpShape = !!isTranspose(coordinate);\n\n    const [p0, , p2] = tpShape ? reorder(points) : points;\n    const [x, y] = p0;\n    const [width, height] = sub(p2, p0);\n    // Deal with width or height is negative.\n    const absX = width > 0 ? x : x + width;\n    const absY = height > 0 ? y : y + height;\n\n    const absWidth = Math.abs(width);\n    const absHeight = Math.abs(height);\n    const finalX = absX + insetLeft;\n    const finalY = absY + insetTop;\n    const finalWidth = absWidth - (insetLeft + insetRight);\n    const finalHeight = absHeight - (insetTop + insetBottom);\n\n    const clampWidth = tpShape\n      ? clamp(finalWidth, minHeight, Infinity)\n      : clamp(finalWidth, minWidth, maxWidth);\n    const clampHeight = tpShape\n      ? clamp(finalHeight, minWidth, maxWidth)\n      : clamp(finalHeight, minHeight, Infinity);\n    const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;\n    const clampY = tpShape\n      ? finalY - (clampHeight - finalHeight) / 2\n      : finalY - (clampHeight - finalHeight);\n\n    return select(document.createElement('rect', {}))\n      .style('x', clampX)\n      .style('y', clampY)\n      .style('width', clampWidth)\n      .style('height', clampHeight)\n      .style('radius', [\n        radiusTopLeft,\n        radiusTopRight,\n        radiusBottomRight,\n        radiusBottomLeft,\n      ])\n      .call(applyStyle, rest)\n      .node();\n  }\n\n  // Render path in polar coordinate.\n  const { y, y1 } = value;\n  const center = coordinate.getCenter() as Vector2;\n  const arcObject = getArcObject(coordinate, points, [y, y1]);\n  const path = arc()\n    .cornerRadius(radius as number)\n    .padAngle((inset * Math.PI) / 180);\n\n  return select(document.createElement('path', {}))\n    .style('d', path(arcObject))\n    .style('transform', `translate(${center[0]}, ${center[1]})`)\n    .style('radius', radius)\n    .style('inset', inset)\n    .call(applyStyle, rest)\n    .node();\n}\n\n/**\n * Render rect in different coordinate.\n * Calc arc path based on control points directly rather startAngle, endAngle, innerRadius,\n * outerRadius. This is not accurate and will cause bug when the range of y scale is [1, 0]\n * for cell geometry.\n */\nexport const Color: SC<ColorOptions> = (options, context) => {\n  // Render border only when colorAttribute is stroke.\n  const {\n    colorAttribute,\n    opacityAttribute = 'fill',\n    first = true,\n    last = true,\n    ...style\n  } = options;\n\n  const { coordinate, document } = context;\n\n  return (points, value, defaults) => {\n    const {\n      color: defaultColor,\n      radius: defaultRadius = 0,\n      ...restDefaults\n    } = defaults;\n\n    const defaultLineWidth = restDefaults.lineWidth || 1;\n    const {\n      stroke,\n      radius = defaultRadius,\n      radiusTopLeft = radius,\n      radiusTopRight = radius,\n      radiusBottomRight = radius,\n      radiusBottomLeft = radius,\n      innerRadius = 0,\n      innerRadiusTopLeft = innerRadius,\n      innerRadiusTopRight = innerRadius,\n      innerRadiusBottomRight = innerRadius,\n      innerRadiusBottomLeft = innerRadius,\n      lineWidth = colorAttribute === 'stroke' || stroke ? defaultLineWidth : 0,\n      inset = 0,\n      insetLeft = inset,\n      insetRight = inset,\n      insetBottom = inset,\n      insetTop = inset,\n      minWidth,\n      maxWidth,\n      minHeight,\n      ...rest\n    } = style;\n    const { color = defaultColor, opacity } = value;\n\n    // Extended style, which is not supported by native g shape,\n    // should apply at first.\n    const standardDirRadius = [\n      first ? radiusTopLeft : innerRadiusTopLeft,\n      first ? radiusTopRight : innerRadiusTopRight,\n      last ? radiusBottomRight : innerRadiusBottomRight,\n      last ? radiusBottomLeft : innerRadiusBottomLeft,\n    ];\n    const standardDir = [\n      'radiusTopLeft',\n      'radiusTopRight',\n      'radiusBottomRight',\n      'radiusBottomLeft',\n    ];\n    // Transpose: rotate it clockwise by 90.\n    if (isTranspose(coordinate)) {\n      standardDir.push(standardDir.shift());\n    }\n    const extendedStyle = {\n      radius,\n      ...Object.fromEntries(\n        standardDir.map((d, i) => [d, standardDirRadius[i]]),\n      ),\n      inset,\n      insetLeft,\n      insetRight,\n      insetBottom,\n      insetTop,\n      minWidth,\n      maxWidth,\n      minHeight,\n    };\n\n    return (\n      select(rect(document, points, value, coordinate, extendedStyle))\n        .call(applyStyle, restDefaults)\n        .style('fill', 'transparent')\n        .style(colorAttribute, color)\n        .style(toOpacityKey(options), opacity)\n        .style('lineWidth', lineWidth)\n        .style('stroke', stroke === undefined ? color : stroke)\n        // shape.style has higher priority.\n        .call(applyStyle, rest)\n        .node()\n    );\n  };\n};\n\n// @todo Should Shape have default animations using for ordinal scale?\nColor.props = {\n  defaultEnterAnimation: 'scaleInY',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut',\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}