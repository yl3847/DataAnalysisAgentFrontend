{"ast":null,"code":"import { treeToGraphData } from '@antv/g6';\n/**\n * 获取邻居节点\n * @param nodeId - 节点 ID\n * @param edges - 边数据\n * @param direction - 边的方向\n * @returns 邻居节点 ID\n */\nexport const getNeighborNodeIds = (nodeId, edges, direction) => {\n  const getSuccessorNodeIds = (reverse = false) => {\n    const [source, target] = reverse ? ['target', 'source'] : ['source', 'target'];\n    return edges.filter(edge => edge[source] === nodeId).map(edge => edge[target]);\n  };\n  if (direction === 'out') return getSuccessorNodeIds();\n  if (direction === 'in') return getSuccessorNodeIds(true);\n  return getSuccessorNodeIds().concat(getSuccessorNodeIds(true));\n};\nconst EMPTY_GRAPH_DATA = {\n  nodes: [],\n  edges: []\n};\n/**\n * 检查给定的数据是否是有效的树图结构\n * @param data - 数据\n * @returns 如果数据是有效的树图结构，则返回 true；否则返回 false\n */\nexport function isTreeData(data) {\n  if (typeof data !== 'object' || data === null) return false;\n  if (!('id' in data)) return false;\n  if ('children' in data) {\n    if (!Array.isArray(data.children)) return false;\n    for (const child of data.children) {\n      if (!isTreeData(child)) return false;\n    }\n  }\n  return true;\n}\n/**\n * 检查给定的数据是否是有效的图结构\n * @param data - 数据\n * @returns 如果数据是有效的图结构，则返回 true；否则返回 false\n */\nexport function isGraphData(data) {\n  if (typeof data !== 'object' || data === null) return false;\n  if (!Object.keys(data).every(key => ['nodes', 'edges', 'combos'].includes(key))) {\n    return false;\n  }\n  const {\n    nodes = [],\n    edges = [],\n    combos = []\n  } = data;\n  if (!Array.isArray(nodes) || !Array.isArray(edges) || !Array.isArray(combos)) {\n    return false;\n  }\n  const nodeIds = new Set(nodes.map(node => node.id));\n  if (!nodes.every(node => typeof node === 'object' && node !== null && 'id' in node)) {\n    return false;\n  }\n  if (!edges.every(edge => nodeIds.has(edge.source) && nodeIds.has(edge.target))) {\n    return false;\n  }\n  return true;\n}\n/**\n * 将图数据转换为树图数据\n * @param data - 图数据\n * @returns 树图数据\n */\nexport function graphData2TreeData(data) {\n  if (!isGraphData(data)) {\n    return;\n  }\n  const {\n    nodes = [],\n    edges = []\n  } = data;\n  const nodeMap = Object.fromEntries(nodes.map(node => [node.id, node]));\n  const indegree = Object.fromEntries(nodes.map(node => [node.id, 0]));\n  const adjList = Object.fromEntries(nodes.map(node => [node.id, []]));\n  for (const {\n    source,\n    target\n  } of edges) {\n    adjList[source].push(target);\n    indegree[target] = (indegree[target] || 0) + 1;\n  }\n  const roots = Object.entries(indegree).filter(([_, deg]) => deg === 0).map(([id]) => id);\n  if (roots.length !== 1) {\n    return;\n  }\n  const buildTree = nodeId => {\n    const node = nodeMap[nodeId];\n    return {\n      ...node,\n      children: adjList[nodeId].map(buildTree)\n    };\n  };\n  return buildTree(roots[0]);\n}\n/**\n * 将树图数据转换为图数据\n * @param data - 树图数据\n * @param defaultExpandLevel - 默认展开层级。若不传入，则所有节点均展开\n * @returns 图数据\n */\nexport function treeData2GraphData(data, defaultExpandLevel) {\n  if (!isTreeData(data)) return EMPTY_GRAPH_DATA;\n  return treeToGraphData(data, {\n    getNodeData: (datum, depth) => {\n      datum.depth = depth;\n      datum.style ||= {};\n      if (defaultExpandLevel) {\n        datum.style.collapsed = depth >= defaultExpandLevel;\n      }\n      if (!datum.children) return datum;\n      const {\n        children,\n        ...restDatum\n      } = datum;\n      return {\n        ...restDatum,\n        children: children.map(child => child.id)\n      };\n    }\n  });\n}\n/**\n * Used in TreeGraph scene, accepts tree data or graph data that meets certain conditions\n *\n * Conditions are as follows:\n * 1. There is only one root node\n * 2. Node ID is unique\n * 3. The source and target of the edge are in the node ID\n * 4. No cycle\n * 5. The indegree of the child node is 1\n */\nexport function formatTreeData(data, defaultExpandLevel) {\n  if (!data) return EMPTY_GRAPH_DATA;\n  const treeData = isGraphData(data) ? graphData2TreeData(data) : data;\n  if (!treeData) return EMPTY_GRAPH_DATA;\n  return treeData2GraphData(treeData, defaultExpandLevel);\n}","map":{"version":3,"names":["treeToGraphData","getNeighborNodeIds","nodeId","edges","direction","getSuccessorNodeIds","reverse","source","target","filter","edge","map","concat","EMPTY_GRAPH_DATA","nodes","isTreeData","data","Array","isArray","children","child","isGraphData","Object","keys","every","key","includes","combos","nodeIds","Set","node","id","has","graphData2TreeData","nodeMap","fromEntries","indegree","adjList","push","roots","entries","_","deg","length","buildTree","treeData2GraphData","defaultExpandLevel","getNodeData","datum","depth","style","collapsed","restDatum","formatTreeData","treeData"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@ant-design/graphs/es/core/utils/data.js"],"sourcesContent":["import { treeToGraphData } from '@antv/g6';\n/**\n * 获取邻居节点\n * @param nodeId - 节点 ID\n * @param edges - 边数据\n * @param direction - 边的方向\n * @returns 邻居节点 ID\n */\nexport const getNeighborNodeIds = (nodeId, edges, direction) => {\n    const getSuccessorNodeIds = (reverse = false) => {\n        const [source, target] = reverse ? ['target', 'source'] : ['source', 'target'];\n        return edges.filter((edge) => edge[source] === nodeId).map((edge) => edge[target]);\n    };\n    if (direction === 'out')\n        return getSuccessorNodeIds();\n    if (direction === 'in')\n        return getSuccessorNodeIds(true);\n    return getSuccessorNodeIds().concat(getSuccessorNodeIds(true));\n};\nconst EMPTY_GRAPH_DATA = { nodes: [], edges: [] };\n/**\n * 检查给定的数据是否是有效的树图结构\n * @param data - 数据\n * @returns 如果数据是有效的树图结构，则返回 true；否则返回 false\n */\nexport function isTreeData(data) {\n    if (typeof data !== 'object' || data === null)\n        return false;\n    if (!('id' in data))\n        return false;\n    if ('children' in data) {\n        if (!Array.isArray(data.children))\n            return false;\n        for (const child of data.children) {\n            if (!isTreeData(child))\n                return false;\n        }\n    }\n    return true;\n}\n/**\n * 检查给定的数据是否是有效的图结构\n * @param data - 数据\n * @returns 如果数据是有效的图结构，则返回 true；否则返回 false\n */\nexport function isGraphData(data) {\n    if (typeof data !== 'object' || data === null)\n        return false;\n    if (!Object.keys(data).every((key) => ['nodes', 'edges', 'combos'].includes(key))) {\n        return false;\n    }\n    const { nodes = [], edges = [], combos = [] } = data;\n    if (!Array.isArray(nodes) || !Array.isArray(edges) || !Array.isArray(combos)) {\n        return false;\n    }\n    const nodeIds = new Set(nodes.map((node) => node.id));\n    if (!nodes.every((node) => typeof node === 'object' && node !== null && 'id' in node)) {\n        return false;\n    }\n    if (!edges.every((edge) => nodeIds.has(edge.source) && nodeIds.has(edge.target))) {\n        return false;\n    }\n    return true;\n}\n/**\n * 将图数据转换为树图数据\n * @param data - 图数据\n * @returns 树图数据\n */\nexport function graphData2TreeData(data) {\n    if (!isGraphData(data)) {\n        return;\n    }\n    const { nodes = [], edges = [] } = data;\n    const nodeMap = Object.fromEntries(nodes.map((node) => [node.id, node]));\n    const indegree = Object.fromEntries(nodes.map((node) => [node.id, 0]));\n    const adjList = Object.fromEntries(nodes.map((node) => [node.id, []]));\n    for (const { source, target } of edges) {\n        adjList[source].push(target);\n        indegree[target] = (indegree[target] || 0) + 1;\n    }\n    const roots = Object.entries(indegree)\n        .filter(([_, deg]) => deg === 0)\n        .map(([id]) => id);\n    if (roots.length !== 1) {\n        return;\n    }\n    const buildTree = (nodeId) => {\n        const node = nodeMap[nodeId];\n        return {\n            ...node,\n            children: adjList[nodeId].map(buildTree),\n        };\n    };\n    return buildTree(roots[0]);\n}\n/**\n * 将树图数据转换为图数据\n * @param data - 树图数据\n * @param defaultExpandLevel - 默认展开层级。若不传入，则所有节点均展开\n * @returns 图数据\n */\nexport function treeData2GraphData(data, defaultExpandLevel) {\n    if (!isTreeData(data))\n        return EMPTY_GRAPH_DATA;\n    return treeToGraphData(data, {\n        getNodeData: (datum, depth) => {\n            datum.depth = depth;\n            datum.style ||= {};\n            if (defaultExpandLevel) {\n                datum.style.collapsed = depth >= defaultExpandLevel;\n            }\n            if (!datum.children)\n                return datum;\n            const { children, ...restDatum } = datum;\n            return { ...restDatum, children: children.map((child) => child.id) };\n        },\n    });\n}\n/**\n * Used in TreeGraph scene, accepts tree data or graph data that meets certain conditions\n *\n * Conditions are as follows:\n * 1. There is only one root node\n * 2. Node ID is unique\n * 3. The source and target of the edge are in the node ID\n * 4. No cycle\n * 5. The indegree of the child node is 1\n */\nexport function formatTreeData(data, defaultExpandLevel) {\n    if (!data)\n        return EMPTY_GRAPH_DATA;\n    const treeData = isGraphData(data) ? graphData2TreeData(data) : data;\n    if (!treeData)\n        return EMPTY_GRAPH_DATA;\n    return treeData2GraphData(treeData, defaultExpandLevel);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}