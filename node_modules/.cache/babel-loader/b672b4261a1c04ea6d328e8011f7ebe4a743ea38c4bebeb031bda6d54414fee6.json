{"ast":null,"code":"import orient from './robust-orientation';\nfunction checkCollinear(a0, a1, b0, b1) {\n  for (let d = 0; d < 2; ++d) {\n    const x0 = a0[d];\n    const y0 = a1[d];\n    const [l0, h0] = [Math.min(x0, y0), Math.max(x0, y0)];\n    const x1 = b0[d];\n    const y1 = b1[d];\n    const [l1, h1] = [Math.min(x1, y1), Math.max(x1, y1)];\n    if (h1 < l0 || h0 < l1) return false;\n  }\n  return true;\n}\nexport function segmentsIntersect(a0, a1, b0, b1) {\n  const x0 = orient(a0, b0, b1);\n  const y0 = orient(a1, b0, b1);\n  if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0) return false;\n  const x1 = orient(b0, a0, a1);\n  const y1 = orient(b1, a0, a1);\n  if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0) return false;\n  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {\n    return checkCollinear(a0, a1, b0, b1);\n  }\n  return true;\n}","map":{"version":3,"names":["orient","checkCollinear","a0","a1","b0","b1","d","x0","y0","l0","h0","Math","min","max","x1","y1","l1","h1","segmentsIntersect"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/plugins/hull/hull/robust-segment-intersect.ts"],"sourcesContent":["import type { Point } from '../../../types';\nimport orient from './robust-orientation';\n\nfunction checkCollinear(a0: Point, a1: Point, b0: Point, b1: Point): boolean {\n  for (let d = 0; d < 2; ++d) {\n    const x0 = a0[d];\n    const y0 = a1[d];\n    const [l0, h0] = [Math.min(x0, y0), Math.max(x0, y0)];\n\n    const x1 = b0[d];\n    const y1 = b1[d];\n    const [l1, h1] = [Math.min(x1, y1), Math.max(x1, y1)];\n    if (h1 < l0 || h0 < l1) return false;\n  }\n  return true;\n}\n\nexport function segmentsIntersect(a0: Point, a1: Point, b0: Point, b1: Point): boolean {\n  const x0 = orient(a0, b0, b1);\n  const y0 = orient(a1, b0, b1);\n  if ((x0 > 0 && y0 > 0) || (x0 < 0 && y0 < 0)) return false;\n  const x1 = orient(b0, a0, a1);\n  const y1 = orient(b1, a0, a1);\n  if ((x1 > 0 && y1 > 0) || (x1 < 0 && y1 < 0)) return false;\n  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {\n    return checkCollinear(a0, a1, b0, b1);\n  }\n  return true;\n}\n"],"mappings":"AACA,OAAOA,MAAM,MAAM,sBAAsB;AAEzC,SAASC,cAAcA,CAACC,EAAS,EAAEC,EAAS,EAAEC,EAAS,EAAEC,EAAS;EAChE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;IAC1B,MAAMC,EAAE,GAAGL,EAAE,CAACI,CAAC,CAAC;IAChB,MAAME,EAAE,GAAGL,EAAE,CAACG,CAAC,CAAC;IAChB,MAAM,CAACG,EAAE,EAAEC,EAAE,CAAC,GAAG,CAACC,IAAI,CAACC,GAAG,CAACL,EAAE,EAAEC,EAAE,CAAC,EAAEG,IAAI,CAACE,GAAG,CAACN,EAAE,EAAEC,EAAE,CAAC,CAAC;IAErD,MAAMM,EAAE,GAAGV,EAAE,CAACE,CAAC,CAAC;IAChB,MAAMS,EAAE,GAAGV,EAAE,CAACC,CAAC,CAAC;IAChB,MAAM,CAACU,EAAE,EAAEC,EAAE,CAAC,GAAG,CAACN,IAAI,CAACC,GAAG,CAACE,EAAE,EAAEC,EAAE,CAAC,EAAEJ,IAAI,CAACE,GAAG,CAACC,EAAE,EAAEC,EAAE,CAAC,CAAC;IACrD,IAAIE,EAAE,GAAGR,EAAE,IAAIC,EAAE,GAAGM,EAAE,EAAE,OAAO,KAAK;EACtC;EACA,OAAO,IAAI;AACb;AAEA,OAAM,SAAUE,iBAAiBA,CAAChB,EAAS,EAAEC,EAAS,EAAEC,EAAS,EAAEC,EAAS;EAC1E,MAAME,EAAE,GAAGP,MAAM,CAACE,EAAE,EAAEE,EAAE,EAAEC,EAAE,CAAC;EAC7B,MAAMG,EAAE,GAAGR,MAAM,CAACG,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;EAC7B,IAAKE,EAAE,GAAG,CAAC,IAAIC,EAAE,GAAG,CAAC,IAAMD,EAAE,GAAG,CAAC,IAAIC,EAAE,GAAG,CAAE,EAAE,OAAO,KAAK;EAC1D,MAAMM,EAAE,GAAGd,MAAM,CAACI,EAAE,EAAEF,EAAE,EAAEC,EAAE,CAAC;EAC7B,MAAMY,EAAE,GAAGf,MAAM,CAACK,EAAE,EAAEH,EAAE,EAAEC,EAAE,CAAC;EAC7B,IAAKW,EAAE,GAAG,CAAC,IAAIC,EAAE,GAAG,CAAC,IAAMD,EAAE,GAAG,CAAC,IAAIC,EAAE,GAAG,CAAE,EAAE,OAAO,KAAK;EAC1D,IAAIR,EAAE,KAAK,CAAC,IAAIC,EAAE,KAAK,CAAC,IAAIM,EAAE,KAAK,CAAC,IAAIC,EAAE,KAAK,CAAC,EAAE;IAChD,OAAOd,cAAc,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;EACvC;EACA,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}