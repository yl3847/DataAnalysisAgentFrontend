{"ast":null,"code":"import { formatUtil } from './format';\nimport { grid } from './grid_handle';\nimport { monotoneConvexHull2D as convexHull } from './monotone-convex-hull-2d';\nimport { segmentsIntersect as intersect } from './robust-segment-intersect';\nfunction _filterDuplicates(pointset) {\n  const unique = [pointset[0]];\n  let lastPoint = pointset[0];\n  for (let i = 1; i < pointset.length; i++) {\n    const currentPoint = pointset[i];\n    if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {\n      unique.push(currentPoint);\n    }\n    lastPoint = currentPoint;\n  }\n  return unique;\n}\nfunction _sortByX(pointset) {\n  return pointset.sort(function (a, b) {\n    return a[0] - b[0] || a[1] - b[1];\n  });\n}\nfunction _sqLength(a, b) {\n  return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n}\nfunction _cos(o, a, b) {\n  const aShifted = [a[0] - o[0], a[1] - o[1]],\n    bShifted = [b[0] - o[0], b[1] - o[1]],\n    sqALen = _sqLength(o, a),\n    sqBLen = _sqLength(o, b),\n    dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n  return dot / Math.sqrt(sqALen * sqBLen);\n}\nfunction _intersect(segment, pointset) {\n  for (let i = 0; i < pointset.length - 1; i++) {\n    const seg = [pointset[i], pointset[i + 1]];\n    if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] || segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {\n      continue;\n    }\n    if (intersect(segment[0], segment[1], seg[0], seg[1])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction _occupiedArea(pointset) {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  for (let i = pointset.length - 1; i >= 0; i--) {\n    if (pointset[i][0] < minX) {\n      minX = pointset[i][0];\n    }\n    if (pointset[i][1] < minY) {\n      minY = pointset[i][1];\n    }\n    if (pointset[i][0] > maxX) {\n      maxX = pointset[i][0];\n    }\n    if (pointset[i][1] > maxY) {\n      maxY = pointset[i][1];\n    }\n  }\n  return [maxX - minX,\n  // width\n  maxY - minY // height\n  ];\n}\nfunction _bBoxAround(edge) {\n  return [Math.min(edge[0][0], edge[1][0]),\n  // left\n  Math.min(edge[0][1], edge[1][1]),\n  // top\n  Math.max(edge[0][0], edge[1][0]),\n  // right\n  Math.max(edge[0][1], edge[1][1]) // bottom\n  ];\n}\nfunction _midPoint(edge, innerPoints, convex) {\n  let point = null,\n    angle1Cos = MAX_CONCAVE_ANGLE_COS,\n    angle2Cos = MAX_CONCAVE_ANGLE_COS,\n    a1Cos,\n    a2Cos;\n  for (let i = 0; i < innerPoints.length; i++) {\n    a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n    a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n    if (a1Cos > angle1Cos && a2Cos > angle2Cos && !_intersect([edge[0], innerPoints[i]], convex) && !_intersect([edge[1], innerPoints[i]], convex)) {\n      angle1Cos = a1Cos;\n      angle2Cos = a2Cos;\n      point = innerPoints[i];\n    }\n  }\n  return point;\n}\nfunction _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {\n  let midPointInserted = false;\n  for (let i = 0; i < convex.length - 1; i++) {\n    const edge = [convex[i], convex[i + 1]];\n    // generate a key in the format X0,Y0,X1,Y1\n    const keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];\n    if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen || edgeSkipList.has(keyInSkipList)) {\n      continue;\n    }\n    let scaleFactor = 0;\n    let bBoxAround = _bBoxAround(edge);\n    let bBoxWidth;\n    let bBoxHeight;\n    let midPoint;\n    do {\n      bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n      bBoxWidth = bBoxAround[2] - bBoxAround[0];\n      bBoxHeight = bBoxAround[3] - bBoxAround[1];\n      midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);\n      scaleFactor++;\n    } while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n    if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {\n      edgeSkipList.add(keyInSkipList);\n    }\n    if (midPoint !== null) {\n      convex.splice(i + 1, 0, midPoint);\n      grid.removePoint(midPoint);\n      midPointInserted = true;\n    }\n  }\n  if (midPointInserted) {\n    return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n  }\n  return convex;\n}\nexport function hull(pointset, concavity, format) {\n  const maxEdgeLen = concavity || 20;\n  const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));\n  if (points.length < 4) {\n    const concave = points.concat([points[0]]);\n    return format ? formatUtil.fromXy(concave, format) : concave;\n  }\n  const occupiedArea = _occupiedArea(points);\n  const maxSearchArea = [occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT, occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT];\n  const convex = convexHull(points).reverse().map(idx => points[idx]); // ccw -> cw, indices -> points\n  convex.push(convex[0]);\n  const innerPoints = points.filter(function (pt) {\n    return convex.indexOf(pt) < 0;\n  });\n  const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n  const concave = _concave(convex, Math.pow(maxEdgeLen, 2), maxSearchArea, grid(innerPoints, cellSize), new Set());\n  return format ? formatUtil.fromXy(concave, format) : concave;\n}\nconst MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\nconst MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;","map":{"version":3,"names":["formatUtil","grid","monotoneConvexHull2D","convexHull","segmentsIntersect","intersect","_filterDuplicates","pointset","unique","lastPoint","i","length","currentPoint","push","_sortByX","sort","a","b","_sqLength","Math","pow","_cos","o","aShifted","bShifted","sqALen","sqBLen","dot","sqrt","_intersect","segment","seg","_occupiedArea","minX","Infinity","minY","maxX","maxY","_bBoxAround","edge","min","max","_midPoint","innerPoints","convex","point","angle1Cos","MAX_CONCAVE_ANGLE_COS","angle2Cos","a1Cos","a2Cos","_concave","maxSqEdgeLen","maxSearchArea","edgeSkipList","midPointInserted","keyInSkipList","has","scaleFactor","bBoxAround","bBoxWidth","bBoxHeight","midPoint","extendBbox","rangePoints","add","splice","removePoint","hull","concavity","format","maxEdgeLen","points","toXy","concave","concat","fromXy","occupiedArea","MAX_SEARCH_BBOX_SIZE_PERCENT","reverse","map","idx","filter","pt","indexOf","cellSize","ceil","Set","cos","PI"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/plugins/hull/hull/index.ts"],"sourcesContent":["import type { Point } from '../../../types';\nimport type { BBox, FormatTuple } from './format';\nimport { formatUtil } from './format';\nimport type { Grid } from './grid_handle';\nimport { grid } from './grid_handle';\nimport { monotoneConvexHull2D as convexHull } from './monotone-convex-hull-2d';\nimport { segmentsIntersect as intersect } from './robust-segment-intersect';\n\nfunction _filterDuplicates(pointset: Point[]) {\n  const unique = [pointset[0]];\n  let lastPoint = pointset[0];\n  for (let i = 1; i < pointset.length; i++) {\n    const currentPoint = pointset[i];\n    if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {\n      unique.push(currentPoint);\n    }\n    lastPoint = currentPoint;\n  }\n  return unique;\n}\n\nfunction _sortByX(pointset: Point[]) {\n  return pointset.sort(function (a, b) {\n    return a[0] - b[0] || a[1] - b[1];\n  });\n}\n\nfunction _sqLength(a: Point, b: Point) {\n  return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n}\n\nfunction _cos(o: Point, a: Point, b: Point) {\n  const aShifted = [a[0] - o[0], a[1] - o[1]],\n    bShifted = [b[0] - o[0], b[1] - o[1]],\n    sqALen = _sqLength(o, a),\n    sqBLen = _sqLength(o, b),\n    dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n\n  return dot / Math.sqrt(sqALen * sqBLen);\n}\n\nfunction _intersect(segment: [Point, Point], pointset: Point[]) {\n  for (let i = 0; i < pointset.length - 1; i++) {\n    const seg = [pointset[i], pointset[i + 1]];\n    if (\n      (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1]) ||\n      (segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1])\n    ) {\n      continue;\n    }\n    if (intersect(segment[0], segment[1], seg[0], seg[1])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction _occupiedArea(pointset: Point[]) {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (let i = pointset.length - 1; i >= 0; i--) {\n    if (pointset[i][0] < minX) {\n      minX = pointset[i][0];\n    }\n    if (pointset[i][1] < minY) {\n      minY = pointset[i][1];\n    }\n    if (pointset[i][0] > maxX) {\n      maxX = pointset[i][0];\n    }\n    if (pointset[i][1] > maxY) {\n      maxY = pointset[i][1];\n    }\n  }\n\n  return [\n    maxX - minX, // width\n    maxY - minY, // height\n  ];\n}\n\nfunction _bBoxAround(edge: [Point, Point]): BBox {\n  return [\n    Math.min(edge[0][0], edge[1][0]), // left\n    Math.min(edge[0][1], edge[1][1]), // top\n    Math.max(edge[0][0], edge[1][0]), // right\n    Math.max(edge[0][1], edge[1][1]), // bottom\n  ];\n}\n\nfunction _midPoint(edge: [Point, Point], innerPoints: Point[], convex: Point[]) {\n  let point = null,\n    angle1Cos = MAX_CONCAVE_ANGLE_COS,\n    angle2Cos = MAX_CONCAVE_ANGLE_COS,\n    a1Cos,\n    a2Cos;\n\n  for (let i = 0; i < innerPoints.length; i++) {\n    a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n    a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n\n    if (\n      a1Cos > angle1Cos &&\n      a2Cos > angle2Cos &&\n      !_intersect([edge[0], innerPoints[i]], convex) &&\n      !_intersect([edge[1], innerPoints[i]], convex)\n    ) {\n      angle1Cos = a1Cos;\n      angle2Cos = a2Cos;\n      point = innerPoints[i];\n    }\n  }\n\n  return point;\n}\n\nfunction _concave(\n  convex: Point[],\n  maxSqEdgeLen: number,\n  maxSearchArea: [number, number],\n  grid: Grid,\n  edgeSkipList: Set<string>,\n) {\n  let midPointInserted = false;\n\n  for (let i = 0; i < convex.length - 1; i++) {\n    const edge: [Point, Point] = [convex[i], convex[i + 1]];\n    // generate a key in the format X0,Y0,X1,Y1\n    const keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];\n\n    if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen || edgeSkipList.has(keyInSkipList)) {\n      continue;\n    }\n\n    let scaleFactor = 0;\n    let bBoxAround = _bBoxAround(edge);\n    let bBoxWidth;\n    let bBoxHeight;\n    let midPoint;\n    do {\n      bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n      bBoxWidth = bBoxAround[2] - bBoxAround[0];\n      bBoxHeight = bBoxAround[3] - bBoxAround[1];\n\n      midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);\n      scaleFactor++;\n    } while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n\n    if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {\n      edgeSkipList.add(keyInSkipList);\n    }\n\n    if (midPoint !== null) {\n      convex.splice(i + 1, 0, midPoint);\n      grid.removePoint(midPoint);\n      midPointInserted = true;\n    }\n  }\n\n  if (midPointInserted) {\n    return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n  }\n\n  return convex;\n}\n\nexport function hull(pointset: Point[], concavity: number, format?: FormatTuple): Point[] {\n  const maxEdgeLen = concavity || 20;\n\n  const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format) as Point[]));\n\n  if (points.length < 4) {\n    const concave = points.concat([points[0]]);\n    return (format ? formatUtil.fromXy(concave, format) : concave) as Point[];\n  }\n\n  const occupiedArea = _occupiedArea(points);\n  const maxSearchArea: [number, number] = [\n    occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n    occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n  ];\n\n  const convex = convexHull(points)\n    .reverse()\n    .map((idx: number) => points[idx]); // ccw -> cw, indices -> points\n  convex.push(convex[0]);\n\n  const innerPoints = points.filter(function (pt) {\n    return convex.indexOf(pt) < 0;\n  });\n\n  const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n\n  const concave = _concave(convex, Math.pow(maxEdgeLen, 2), maxSearchArea, grid(innerPoints, cellSize), new Set());\n\n  return (format ? formatUtil.fromXy(concave, format) : concave) as Point[];\n}\n\nconst MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\nconst MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}