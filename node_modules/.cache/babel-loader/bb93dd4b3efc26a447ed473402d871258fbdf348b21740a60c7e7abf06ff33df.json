{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { lowerFirst, upperFirst, isPlainObject } from '@antv/util';\nimport { Band, Constant } from '@antv/scale';\n/**\n * @description Get element's ancestor view node.\n * @param elemenet G2 element.\n * @returns Element's ancestor view node.\n */\nexport function getViewFromElement(element) {\n  var _a;\n  let current = element;\n  while (current) {\n    if (((_a = current.attributes) === null || _a === void 0 ? void 0 : _a.class) === 'view') return current;\n    current = current.parentNode;\n  }\n  return null;\n}\n/**\n * @description Check if the element is a heatmap.\n * @param element G2 element.\n * @returns True if the element is a heatmap, otherwise false.\n */\nexport function isHeatmap(element) {\n  const {\n    markType,\n    nodeName\n  } = element;\n  return markType === 'heatmap' && nodeName === 'image';\n}\n/**\n * @description Get element's original data.\n * @param elemenet G2 element.\n * @param elemenet View data, if not provided, will get from element's ancestor view.\n * @returns The original data of the element.\n */\nexport function dataOf(element, viewData) {\n  const view = viewData !== null && viewData !== void 0 ? viewData : getViewFromElement(element).__data__;\n  const datum = element.__data__;\n  const {\n    markKey,\n    index,\n    seriesIndex,\n    normalized = {\n      x: 0\n    }\n  } = datum;\n  const {\n    markState\n  } = view;\n  const selectedMark = Array.from(markState.keys()).find(mark => mark.key === markKey);\n  if (!selectedMark) return;\n  if (seriesIndex) {\n    return seriesIndex.map(i => selectedMark.data[i]);\n  }\n  return isHeatmap(element) ? selectedMark.data[Math.round(selectedMark.data.length * normalized.x)] : selectedMark.data[index];\n}\n/**\n * @description Get element's series name.\n * @param elemenet G2 element.\n * @returns The series name of the element.\n */\nexport function seriesOf(elemenet) {\n  const viewData = getViewFromElement(elemenet).__data__;\n  const {\n    scale\n  } = viewData;\n  return groupNameOf(scale, elemenet.__data__);\n}\n/**\n * Get group name with view's scale and element's datum.\n */\nexport function groupNameOf(scale, datum) {\n  const {\n    color: scaleColor,\n    series: scaleSeries,\n    facet = false\n  } = scale;\n  const {\n    color,\n    series\n  } = datum;\n  const invertAble = scale => {\n    return scale && scale.invert && !(scale instanceof Band) && !(scale instanceof Constant);\n  };\n  // For non constant color channel.\n  if (invertAble(scaleSeries)) {\n    const cloned = scaleSeries.clone();\n    return cloned.invert(series);\n  }\n  if (series && scaleSeries instanceof Band && scaleSeries.invert(series) !== color && !facet) {\n    return scaleSeries.invert(series);\n  }\n  if (invertAble(scaleColor)) {\n    const name = scaleColor.invert(color);\n    // For threshold scale.\n    if (Array.isArray(name)) return null;\n    return name;\n  }\n  return null;\n}\nexport function identity(x) {\n  return x;\n}\n/**\n * Composes functions from left to right.\n */\nexport function compose(fns) {\n  return fns.reduce((composed, fn) => (x, ...args) => fn(composed(x, ...args), ...args), identity);\n}\n/**\n * Composes single-argument async functions from left to right.\n */\nexport function composeAsync(fns) {\n  return fns.reduce((composed, fn) => x => __awaiter(this, void 0, void 0, function* () {\n    const value = yield composed(x);\n    return fn(value);\n  }), identity);\n}\nexport function capitalizeFirst(str) {\n  return str.replace(/( |^)[a-z]/g, L => L.toUpperCase());\n}\nexport function error(message = '') {\n  throw new Error(message);\n}\nexport function copyAttributes(target, source) {\n  const {\n    attributes\n  } = source;\n  const exclude = new Set(['id', 'className']);\n  for (const [key, value] of Object.entries(attributes)) {\n    if (!exclude.has(key)) {\n      target.attr(key, value);\n    }\n  }\n}\nexport function defined(x) {\n  return x !== undefined && x !== null && !Number.isNaN(x);\n}\nexport function random(a, b) {\n  return a + (b - a) * Math.random();\n}\nexport function useMemo(compute) {\n  const map = new Map();\n  return key => {\n    if (map.has(key)) return map.get(key);\n    const value = compute(key);\n    map.set(key, value);\n    return value;\n  };\n}\nexport function appendTransform(node, transform) {\n  const {\n    transform: preTransform\n  } = node.style;\n  const unset = d => d === 'none' || d === undefined;\n  const prefix = unset(preTransform) ? '' : preTransform;\n  node.style.transform = `${prefix} ${transform}`.trimStart();\n}\nexport function subObject(obj, prefix) {\n  return maybeSubObject(obj, prefix) || {};\n}\nexport function maybeSubObject(obj, prefix) {\n  const entries = Object.entries(obj || {}).filter(([key]) => key.startsWith(prefix)).map(([key, value]) => [lowerFirst(key.replace(prefix, '').trim()), value]).filter(([key]) => !!key);\n  return entries.length === 0 ? null : Object.fromEntries(entries);\n}\nexport function prefixObject(obj, prefix) {\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => {\n    return [`${prefix}${upperFirst(key)}`, value];\n  }));\n}\nexport function filterPrefixObject(obj, prefix) {\n  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find(p => key.startsWith(p))));\n}\nexport function omitPrefixObject(obj, ...prefixes) {\n  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes.every(prefix => !key.startsWith(prefix))));\n}\nexport function maybePercentage(x, size) {\n  if (x === undefined) return null;\n  if (typeof x === 'number') return x;\n  const px = +x.replace('%', '');\n  return Number.isNaN(px) ? null : px / 100 * size;\n}\nexport function isStrictObject(d) {\n  return typeof d === 'object' && !(d instanceof Date) && d !== null && !Array.isArray(d);\n}\nexport function isUnset(value) {\n  return value === null || value === false;\n}\nexport function deepAssign(dist, src, maxLevel = 5, level = 0) {\n  if (level >= maxLevel) return;\n  for (const key of Object.keys(src)) {\n    const value = src[key];\n    if (!isPlainObject(value) || !isPlainObject(dist[key])) {\n      dist[key] = value;\n    } else {\n      deepAssign(dist[key], value, maxLevel, level + 1);\n    }\n  }\n  return dist;\n}","map":{"version":3,"names":["lowerFirst","upperFirst","isPlainObject","Band","Constant","getViewFromElement","element","current","_a","attributes","class","parentNode","isHeatmap","markType","nodeName","dataOf","viewData","view","__data__","datum","markKey","index","seriesIndex","normalized","x","markState","selectedMark","Array","from","keys","find","mark","key","map","i","data","Math","round","length","seriesOf","elemenet","scale","groupNameOf","color","scaleColor","series","scaleSeries","facet","invertAble","invert","cloned","clone","name","isArray","identity","compose","fns","reduce","composed","fn","args","composeAsync","__awaiter","value","capitalizeFirst","str","replace","L","toUpperCase","error","message","Error","copyAttributes","target","source","exclude","Set","Object","entries","has","attr","defined","undefined","Number","isNaN","random","a","b","useMemo","compute","Map","get","set","appendTransform","node","transform","preTransform","style","unset","d","prefix","trimStart","subObject","obj","maybeSubObject","filter","startsWith","trim","fromEntries","prefixObject","filterPrefixObject","p","omitPrefixObject","prefixes","every","maybePercentage","size","px","isStrictObject","Date","isUnset","deepAssign","dist","src","maxLevel","level"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/utils/helper.ts"],"sourcesContent":["import { DisplayObject } from '@antv/g';\nimport { lowerFirst, upperFirst, isPlainObject } from '@antv/util';\nimport { Band, Base, Constant } from '@antv/scale';\nimport { G2Element } from './selection';\n\n/**\n * @description Get element's ancestor view node.\n * @param elemenet G2 element.\n * @returns Element's ancestor view node.\n */\nexport function getViewFromElement(element: G2Element) {\n  let current = element as G2Element;\n  while (current) {\n    if (current.attributes?.class === 'view') return current;\n    current = current.parentNode as G2Element;\n  }\n  return null;\n}\n\n/**\n * @description Check if the element is a heatmap.\n * @param element G2 element.\n * @returns True if the element is a heatmap, otherwise false.\n */\nexport function isHeatmap(element) {\n  const { markType, nodeName } = element;\n  return markType === 'heatmap' && nodeName === 'image';\n}\n\n/**\n * @description Get element's original data.\n * @param elemenet G2 element.\n * @param elemenet View data, if not provided, will get from element's ancestor view.\n * @returns The original data of the element.\n */\nexport function dataOf(element: G2Element, viewData?: any) {\n  const view = viewData ?? getViewFromElement(element).__data__;\n  const datum = element.__data__;\n  const { markKey, index, seriesIndex, normalized = { x: 0 } } = datum;\n  const { markState } = view;\n  const selectedMark: any = Array.from(markState.keys()).find(\n    (mark) => (mark as any).key === markKey,\n  );\n  if (!selectedMark) return;\n  if (seriesIndex) {\n    return seriesIndex.map((i) => selectedMark.data[i]);\n  }\n  return isHeatmap(element)\n    ? selectedMark.data[Math.round(selectedMark.data.length * normalized.x)]\n    : selectedMark.data[index];\n}\n\n/**\n * @description Get element's series name.\n * @param elemenet G2 element.\n * @returns The series name of the element.\n */\nexport function seriesOf(elemenet: G2Element): string {\n  const viewData = getViewFromElement(elemenet).__data__;\n  const { scale } = viewData;\n  return groupNameOf(scale, elemenet.__data__);\n}\n\n/**\n * Get group name with view's scale and element's datum.\n */\nexport function groupNameOf(scale: Record<string, Base<any>>, datum) {\n  const { color: scaleColor, series: scaleSeries, facet = false } = scale;\n  const { color, series } = datum;\n  const invertAble = (scale) => {\n    return (\n      scale &&\n      scale.invert &&\n      !(scale instanceof Band) &&\n      !(scale instanceof Constant)\n    );\n  };\n  // For non constant color channel.\n  if (invertAble(scaleSeries)) {\n    const cloned = scaleSeries.clone();\n    return cloned.invert(series);\n  }\n  if (\n    series &&\n    scaleSeries instanceof Band &&\n    scaleSeries.invert(series) !== color &&\n    !facet\n  ) {\n    return scaleSeries.invert(series);\n  }\n  if (invertAble(scaleColor)) {\n    const name = scaleColor.invert(color);\n    // For threshold scale.\n    if (Array.isArray(name)) return null;\n    return name;\n  }\n  return null;\n}\n\nexport function identity<T>(x: T): T {\n  return x;\n}\n\ntype Func<R> = (x: R, ...args: any[]) => R;\n/**\n * Composes functions from left to right.\n */\nexport function compose<R>(fns: Func<R>[]): Func<R> {\n  return fns.reduce(\n    (composed, fn) =>\n      (x, ...args) =>\n        fn(composed(x, ...args), ...args),\n    identity,\n  );\n}\n\n/**\n * Composes single-argument async functions from left to right.\n */\nexport function composeAsync<R>(\n  fns: ((x: R) => Promise<R> | R)[],\n): (x: R) => Promise<R> | R {\n  return fns.reduce(\n    (composed, fn) => async (x) => {\n      const value = await composed(x);\n      return fn(value);\n    },\n    identity,\n  );\n}\n\nexport function capitalizeFirst(str: string): string {\n  return str.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());\n}\n\nexport function error(message = ''): never {\n  throw new Error(message);\n}\n\nexport function copyAttributes(target: DisplayObject, source: DisplayObject) {\n  const { attributes } = source;\n  const exclude = new Set(['id', 'className']);\n  for (const [key, value] of Object.entries(attributes)) {\n    if (!exclude.has(key)) {\n      target.attr(key, value);\n    }\n  }\n}\n\nexport function defined(x: any) {\n  return x !== undefined && x !== null && !Number.isNaN(x);\n}\n\nexport function random(a: number, b: number): number {\n  return a + (b - a) * Math.random();\n}\n\nexport function useMemo<T = unknown, U = unknown>(\n  compute: (key: T) => U,\n): (key: T) => U {\n  const map = new Map<T, U>();\n  return (key) => {\n    if (map.has(key)) return map.get(key);\n    const value = compute(key);\n    map.set(key, value);\n    return value;\n  };\n}\n\nexport function appendTransform(node: DisplayObject, transform: any) {\n  const { transform: preTransform } = node.style;\n  const unset = (d) => d === 'none' || d === undefined;\n  const prefix = unset(preTransform) ? '' : preTransform;\n  node.style.transform = `${prefix} ${transform}`.trimStart();\n}\n\nexport function subObject(\n  obj: Record<string, any>,\n  prefix: string,\n): Record<string, any> {\n  return maybeSubObject(obj, prefix) || {};\n}\n\nexport function maybeSubObject(\n  obj: Record<string, any>,\n  prefix: string,\n): Record<string, any> {\n  const entries = Object.entries(obj || {})\n    .filter(([key]) => key.startsWith(prefix))\n    .map(([key, value]) => [lowerFirst(key.replace(prefix, '').trim()), value])\n    .filter(([key]) => !!key);\n  return entries.length === 0 ? null : Object.fromEntries(entries);\n}\n\nexport function prefixObject(\n  obj: Record<string, any>,\n  prefix: string,\n): Record<string, any> {\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => {\n      return [`${prefix}${upperFirst(key)}`, value];\n    }),\n  );\n}\n\nexport function filterPrefixObject(\n  obj: Record<string, any>,\n  prefix: string[],\n): Record<string, any> {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([key]) =>\n      prefix.find((p) => key.startsWith(p)),\n    ),\n  );\n}\n\nexport function omitPrefixObject(\n  obj: Record<string, any>,\n  ...prefixes: string[]\n) {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([key]) =>\n      prefixes.every((prefix) => !key.startsWith(prefix)),\n    ),\n  );\n}\n\nexport function maybePercentage(x: number | string, size: number) {\n  if (x === undefined) return null;\n  if (typeof x === 'number') return x;\n  const px = +x.replace('%', '');\n  return Number.isNaN(px) ? null : (px / 100) * size;\n}\n\nexport function isStrictObject(d: any): boolean {\n  return (\n    typeof d === 'object' &&\n    !(d instanceof Date) &&\n    d !== null &&\n    !Array.isArray(d)\n  );\n}\n\nexport function isUnset(value) {\n  return value === null || value === false;\n}\n\nexport function deepAssign(\n  dist: Record<string, unknown>,\n  src: Record<string, unknown>,\n  maxLevel = 5,\n  level = 0,\n): Record<string, unknown> {\n  if (level >= maxLevel) return;\n  for (const key of Object.keys(src)) {\n    const value = src[key];\n    if (!isPlainObject(value) || !isPlainObject(dist[key])) {\n      dist[key] = value;\n    } else {\n      deepAssign(\n        dist[key] as Record<string, unknown>,\n        value as Record<string, unknown>,\n        maxLevel,\n        level + 1,\n      );\n    }\n  }\n  return dist;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}