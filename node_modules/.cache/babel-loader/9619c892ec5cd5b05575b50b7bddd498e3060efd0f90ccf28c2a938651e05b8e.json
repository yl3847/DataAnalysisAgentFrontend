{"ast":null,"code":"import { parseToRGB } from '../utils/color';\nimport { isOverflow, parseAABB } from '../utils/bounds';\nimport { bboxOf } from '../interaction/utils';\nimport { mostContrast } from './utils';\n/**\n * Get bounds of element considering animation state.\n * If element has animations, get the final state bounds.\n */\nfunction getBoundsWithAnimation(element) {\n  var _a;\n  const animations = element.getAnimations();\n  // If no animations, use regular bboxOf.\n  if (!animations || animations.length === 0) {\n    return bboxOf(element);\n  }\n  // Clone element and apply final animation state.\n  const cloneElement = element.cloneNode(true);\n  cloneElement.style.visibility = 'hidden';\n  animations.forEach(animation => {\n    const keyframes = animation.effect.getKeyframes();\n    if (keyframes && keyframes.length > 0) {\n      cloneElement.attr(keyframes[keyframes.length - 1]);\n    }\n  });\n  (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(cloneElement);\n  const bounds = bboxOf(cloneElement);\n  cloneElement.destroy();\n  return bounds;\n}\n/**\n * Reverse label stroke against label color.\n * More about contract, see https://webaim.org/resources/contrastchecker/\n */\nexport const OverflowStroke = options => {\n  const {\n    palette = ['#000', '#fff'],\n    threshold = 2\n  } = options;\n  return labels => {\n    labels.forEach(l => {\n      var _a, _b;\n      const dependentElement = l.attr('dependentElement');\n      const labelFill = (_b = (_a = l.attributes.fill) !== null && _a !== void 0 ? _a : l.parsedStyle.fill) !== null && _b !== void 0 ? _b : '#fff';\n      const textBounds = parseAABB(getBoundsWithAnimation(l));\n      const elementBounds = parseAABB(getBoundsWithAnimation(dependentElement));\n      if (isOverflow(textBounds, elementBounds, threshold)) {\n        // Add stroke to make overflowing text more visible.\n        // Use the opposite color from palette for stroke.\n        const strokeColor = mostContrast(parseToRGB(labelFill), palette);\n        l.attr('stroke', strokeColor);\n      } else {\n        // Undefined can't set to attrs, have to remove.\n        l.removeAttribute('stroke');\n      }\n    });\n    return labels;\n  };\n};","map":{"version":3,"names":["parseToRGB","isOverflow","parseAABB","bboxOf","mostContrast","getBoundsWithAnimation","element","animations","getAnimations","length","cloneElement","cloneNode","style","visibility","forEach","animation","keyframes","effect","getKeyframes","attr","_a","parentNode","appendChild","bounds","destroy","OverflowStroke","options","palette","threshold","labels","l","dependentElement","labelFill","_b","attributes","fill","parsedStyle","textBounds","elementBounds","strokeColor","removeAttribute"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/label-transform/overflowStroke.ts"],"sourcesContent":["import { DisplayObject } from '@antv/g';\nimport { OverflowStrokeTransform } from '../spec';\nimport { LabelTransformComponent as LLC } from '../runtime';\nimport { parseToRGB } from '../utils/color';\nimport { isOverflow, parseAABB } from '../utils/bounds';\nimport { bboxOf } from '../interaction/utils';\nimport { mostContrast } from './utils';\n\nexport type OverflowStrokeOptions = Omit<OverflowStrokeTransform, 'type'>;\n\n/**\n * Get bounds of element considering animation state.\n * If element has animations, get the final state bounds.\n */\nfunction getBoundsWithAnimation(element: DisplayObject) {\n  const animations = element.getAnimations();\n\n  // If no animations, use regular bboxOf.\n  if (!animations || animations.length === 0) {\n    return bboxOf(element);\n  }\n\n  // Clone element and apply final animation state.\n  const cloneElement = element.cloneNode(true) as DisplayObject;\n  cloneElement.style.visibility = 'hidden';\n\n  animations.forEach((animation) => {\n    const keyframes = animation.effect.getKeyframes();\n    if (keyframes && keyframes.length > 0) {\n      cloneElement.attr(keyframes[keyframes.length - 1]);\n    }\n  });\n\n  element.parentNode?.appendChild(cloneElement);\n  const bounds = bboxOf(cloneElement);\n  cloneElement.destroy();\n\n  return bounds;\n}\n\n/**\n * Reverse label stroke against label color.\n * More about contract, see https://webaim.org/resources/contrastchecker/\n */\nexport const OverflowStroke: LLC<OverflowStrokeOptions> = (options) => {\n  const { palette = ['#000', '#fff'], threshold = 2 } = options;\n\n  return (labels: DisplayObject[]) => {\n    labels.forEach((l) => {\n      const dependentElement = l.attr('dependentElement');\n      const labelFill = l.attributes.fill ?? l.parsedStyle.fill ?? '#fff';\n\n      const textBounds = parseAABB(getBoundsWithAnimation(l));\n      const elementBounds = parseAABB(getBoundsWithAnimation(dependentElement));\n\n      if (isOverflow(textBounds, elementBounds, threshold)) {\n        // Add stroke to make overflowing text more visible.\n        // Use the opposite color from palette for stroke.\n        const strokeColor = mostContrast(parseToRGB(labelFill), palette);\n\n        l.attr('stroke', strokeColor);\n      } else {\n        // Undefined can't set to attrs, have to remove.\n        l.removeAttribute('stroke');\n      }\n    });\n    return labels;\n  };\n};\n"],"mappings":"AAGA,SAASA,UAAU,QAAQ,gBAAgB;AAC3C,SAASC,UAAU,EAAEC,SAAS,QAAQ,iBAAiB;AACvD,SAASC,MAAM,QAAQ,sBAAsB;AAC7C,SAASC,YAAY,QAAQ,SAAS;AAItC;;;;AAIA,SAASC,sBAAsBA,CAACC,OAAsB;;EACpD,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAa,EAAE;EAE1C;EACA,IAAI,CAACD,UAAU,IAAIA,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;IAC1C,OAAON,MAAM,CAACG,OAAO,CAAC;;EAGxB;EACA,MAAMI,YAAY,GAAGJ,OAAO,CAACK,SAAS,CAAC,IAAI,CAAkB;EAC7DD,YAAY,CAACE,KAAK,CAACC,UAAU,GAAG,QAAQ;EAExCN,UAAU,CAACO,OAAO,CAAEC,SAAS,IAAI;IAC/B,MAAMC,SAAS,GAAGD,SAAS,CAACE,MAAM,CAACC,YAAY,EAAE;IACjD,IAAIF,SAAS,IAAIA,SAAS,CAACP,MAAM,GAAG,CAAC,EAAE;MACrCC,YAAY,CAACS,IAAI,CAACH,SAAS,CAACA,SAAS,CAACP,MAAM,GAAG,CAAC,CAAC,CAAC;;EAEtD,CAAC,CAAC;EAEF,CAAAW,EAAA,GAAAd,OAAO,CAACe,UAAU,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,WAAW,CAACZ,YAAY,CAAC;EAC7C,MAAMa,MAAM,GAAGpB,MAAM,CAACO,YAAY,CAAC;EACnCA,YAAY,CAACc,OAAO,EAAE;EAEtB,OAAOD,MAAM;AACf;AAEA;;;;AAIA,OAAO,MAAME,cAAc,GAAgCC,OAAO,IAAI;EACpE,MAAM;IAAEC,OAAO,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC;IAAEC,SAAS,GAAG;EAAC,CAAE,GAAGF,OAAO;EAE7D,OAAQG,MAAuB,IAAI;IACjCA,MAAM,CAACf,OAAO,CAAEgB,CAAC,IAAI;;MACnB,MAAMC,gBAAgB,GAAGD,CAAC,CAACX,IAAI,CAAC,kBAAkB,CAAC;MACnD,MAAMa,SAAS,GAAG,CAAAC,EAAA,IAAAb,EAAA,GAAAU,CAAC,CAACI,UAAU,CAACC,IAAI,cAAAf,EAAA,cAAAA,EAAA,GAAIU,CAAC,CAACM,WAAW,CAACD,IAAI,cAAAF,EAAA,cAAAA,EAAA,GAAI,MAAM;MAEnE,MAAMI,UAAU,GAAGnC,SAAS,CAACG,sBAAsB,CAACyB,CAAC,CAAC,CAAC;MACvD,MAAMQ,aAAa,GAAGpC,SAAS,CAACG,sBAAsB,CAAC0B,gBAAgB,CAAC,CAAC;MAEzE,IAAI9B,UAAU,CAACoC,UAAU,EAAEC,aAAa,EAAEV,SAAS,CAAC,EAAE;QACpD;QACA;QACA,MAAMW,WAAW,GAAGnC,YAAY,CAACJ,UAAU,CAACgC,SAAS,CAAC,EAAEL,OAAO,CAAC;QAEhEG,CAAC,CAACX,IAAI,CAAC,QAAQ,EAAEoB,WAAW,CAAC;OAC9B,MAAM;QACL;QACAT,CAAC,CAACU,eAAe,CAAC,QAAQ,CAAC;;IAE/B,CAAC,CAAC;IACF,OAAOX,MAAM;EACf,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}