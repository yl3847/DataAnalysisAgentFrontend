{"ast":null,"code":"/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nconst longestPath = g => {\n  const visited = {};\n  const dfs = v => {\n    var _a;\n    const label = g.getNode(v);\n    if (!label) return 0;\n    if (visited[v]) {\n      return label.data.rank;\n    }\n    visited[v] = true;\n    let rank;\n    (_a = g.getRelatedEdges(v, 'out')) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      const wRank = dfs(e.target);\n      const minLen = e.data.minlen;\n      const r = wRank - minLen;\n      if (r) {\n        if (rank === undefined || r < rank) {\n          rank = r;\n        }\n      }\n    });\n    if (!rank) {\n      rank = 0;\n    }\n    label.data.rank = rank;\n    return rank;\n  };\n  g.getAllNodes().filter(n => g.getRelatedEdges(n.id, 'in').length === 0).forEach(source => dfs(source.id));\n};\nconst longestPathWithLayer = g => {\n  // 用longest path，找出最深的点\n  const visited = {};\n  let minRank;\n  const dfs = v => {\n    var _a;\n    const label = g.getNode(v);\n    if (!label) return 0;\n    if (visited[v]) {\n      return label.data.rank;\n    }\n    visited[v] = true;\n    let rank;\n    (_a = g.getRelatedEdges(v, 'out')) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      const wRank = dfs(e.target);\n      const minLen = e.data.minlen;\n      const r = wRank - minLen;\n      if (r) {\n        if (rank === undefined || r < rank) {\n          rank = r;\n        }\n      }\n    });\n    if (!rank) {\n      rank = 0;\n    }\n    if (minRank === undefined || rank < minRank) {\n      minRank = rank;\n    }\n    label.data.rank = rank;\n    return rank;\n  };\n  g.getAllNodes().filter(n => g.getRelatedEdges(n.id, 'in').length === 0).forEach(source => {\n    if (source) dfs(source.id);\n  });\n  if (minRank === undefined) {\n    minRank = 0;\n  }\n  // minRank += 1; // NOTE: 最小的层级是dummy root，+1\n  // forward一遍，赋值层级\n  const forwardVisited = {};\n  const dfsForward = (v, nextRank) => {\n    var _a;\n    const label = g.getNode(v);\n    const currRank = !isNaN(label.data.layer) ? label.data.layer : nextRank;\n    // 没有指定，取最大值\n    if (label.data.rank === undefined || label.data.rank < currRank) {\n      label.data.rank = currRank;\n    }\n    if (forwardVisited[v]) return;\n    forwardVisited[v] = true;\n    // DFS遍历子节点\n    (_a = g.getRelatedEdges(v, 'out')) === null || _a === void 0 ? void 0 : _a.forEach(e => {\n      dfsForward(e.target, currRank + e.data.minlen);\n    });\n  };\n  // 指定层级的，更新下游\n  g.getAllNodes().forEach(n => {\n    const label = n.data;\n    if (!label) return;\n    if (!isNaN(label.layer)) {\n      dfsForward(n.id, label.layer); // 默认的dummy root所在层的rank是-1\n    } else {\n      label.rank -= minRank;\n    }\n  });\n};\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nconst slack = (g, e) => {\n  return g.getNode(e.target).data.rank - g.getNode(e.source).data.rank - e.data.minlen;\n};\nexport { longestPath, longestPathWithLayer, slack };","map":{"version":3,"names":["longestPath","g","visited","dfs","v","label","getNode","data","rank","_a","getRelatedEdges","forEach","e","wRank","target","minLen","minlen","r","undefined","getAllNodes","filter","n","id","length","source","longestPathWithLayer","minRank","forwardVisited","dfsForward","nextRank","currRank","isNaN","layer","slack"],"sources":["../../../src/antv-dagre/rank/util.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}