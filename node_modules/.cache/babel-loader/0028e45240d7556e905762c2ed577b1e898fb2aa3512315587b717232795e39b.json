{"ast":null,"code":"import EventEmitter from '@antv/event-emitter';\nimport { GraphView } from './graphView';\nimport { doBFS, doDFS } from './utils/traverse';\nexport class Graph extends EventEmitter {\n  nodeMap = new Map();\n  edgeMap = new Map();\n  inEdgesMap = new Map();\n  outEdgesMap = new Map();\n  bothEdgesMap = new Map();\n  treeIndices = new Map();\n  changes = [];\n  batchCount = 0;\n  /**\n   * This function is called with a {@link GraphChangedEvent} each time a graph change happened.\n   *\n   * `event.changes` contains all the graph changes in order since last `onChanged`.\n   */\n  onChanged = () => {\n    // Do nothing.\n  };\n  /**\n   * Create a new Graph instance.\n   * @param options - The options to initialize a graph. See {@link GraphOptions}.\n   *\n   * ```ts\n   * const graph = new Graph({\n   *   // Optional, initial nodes.\n   *   nodes: [\n   *     // Each node has a unique ID.\n   *     { id: 'A', foo: 1 },\n   *     { id: 'B', foo: 1 },\n   *   ],\n   *   // Optional, initial edges.\n   *   edges: [\n   *     { id: 'C', source: 'B', target: 'B', weight: 1 },\n   *   ],\n   *   // Optional, called with a GraphChangedEvent.\n   *   onChanged: (event) => {\n   *     console.log(event);\n   *   }\n   * });\n   * ```\n   */\n  constructor(options) {\n    super();\n    if (!options) return;\n    if (options.nodes) this.addNodes(options.nodes);\n    if (options.edges) this.addEdges(options.edges);\n    if (options.tree) this.addTree(options.tree);\n    if (options.onChanged) this.onChanged = options.onChanged;\n  }\n  /**\n   * Batch several graph changes into one.\n   *\n   * Make several changes, but dispatch only one ChangedEvent at the end of batch:\n   * ```ts\n   * graph.batch(() => {\n   *   graph.addNodes([]);\n   *   graph.addEdges([]);\n   * });\n   * ```\n   *\n   * Batches can be nested. Only the outermost batch will dispatch a ChangedEvent:\n   * ```ts\n   * graph.batch(() => {\n   *   graph.addNodes([]);\n   *   graph.batch(() => {\n   *     graph.addEdges([]);\n   *   });\n   * });\n   * ```\n   */\n  batch = fn => {\n    this.batchCount += 1;\n    fn();\n    this.batchCount -= 1;\n    if (!this.batchCount) {\n      this.commit();\n    }\n  };\n  /**\n   * Reset changes and dispatch a ChangedEvent.\n   */\n  commit() {\n    const changes = this.changes;\n    this.changes = [];\n    const event = {\n      graph: this,\n      changes\n    };\n    this.emit('changed', event);\n    this.onChanged(event);\n  }\n  /**\n   * Reduce the number of ordered graph changes by dropping or merging unnecessary changes.\n   *\n   * For example, if we update a node and remove it in a batch:\n   *\n   * ```ts\n   * graph.batch(() => {\n   *   graph.updateNodeData('A', 'foo', 2);\n   *   graph.removeNode('A');\n   * });\n   * ```\n   *\n   * We get 2 atomic graph changes like\n   *\n   * ```ts\n   * [\n   *   { type: 'NodeDataUpdated', id: 'A', propertyName: 'foo', oldValue: 1, newValue: 2 },\n   *   { type: 'NodeRemoved', value: { id: 'A', data: { foo: 2 } },\n   * ]\n   * ```\n   *\n   * Since node 'A' has been removed, we actually have no need to handle with NodeDataUpdated change.\n   *\n   * `reduceChanges()` here helps us remove such changes.\n   */\n  reduceChanges(changes) {\n    let mergedChanges = [];\n    changes.forEach(change => {\n      switch (change.type) {\n        case 'NodeRemoved':\n          {\n            // NodeAdded: A added.\n            // NodeDataUpdated: A changed.\n            // TreeStructureChanged: A's parent changed.\n            // NodeRemoved: A removed. 👈🏻 Since A was removed, above three changes may be ignored.\n            let isNewlyAdded = false;\n            mergedChanges = mergedChanges.filter(pastChange => {\n              if (pastChange.type === 'NodeAdded') {\n                const sameId = pastChange.value.id === change.value.id;\n                if (sameId) {\n                  isNewlyAdded = true;\n                }\n                return !sameId;\n              } else if (pastChange.type === 'NodeDataUpdated') {\n                return pastChange.id !== change.value.id;\n              } else if (pastChange.type === 'TreeStructureChanged') {\n                return pastChange.nodeId !== change.value.id;\n              }\n              return true;\n            });\n            if (!isNewlyAdded) {\n              mergedChanges.push(change);\n            }\n            break;\n          }\n        case 'EdgeRemoved':\n          {\n            // EdgeAdded: A added.\n            // EdgeDataUpdated: A changed.\n            // EdgeDataUpdated: A's source/target changed.\n            // EdgeRemoved: A removed. 👈🏻 Since A was removed, above three changes may be ignored.\n            let isNewlyAdded = false;\n            mergedChanges = mergedChanges.filter(pastChange => {\n              if (pastChange.type === 'EdgeAdded') {\n                const sameId = pastChange.value.id === change.value.id;\n                if (sameId) {\n                  isNewlyAdded = true;\n                }\n                return !sameId;\n              } else if (pastChange.type === 'EdgeDataUpdated' || pastChange.type === 'EdgeUpdated') {\n                return pastChange.id !== change.value.id;\n              }\n              return true;\n            });\n            if (!isNewlyAdded) {\n              mergedChanges.push(change);\n            }\n            break;\n          }\n        case 'NodeDataUpdated':\n        case 'EdgeDataUpdated':\n        case 'EdgeUpdated':\n          {\n            // NodeDataUpdated: { id: A, propertyName: 'foo', oldValue: 1, newValue: 2 }.\n            // NodeDataUpdated: { id: A, propertyName: 'foo', oldValue: 2, newValue: 3 }.\n            // 👆 Could be merged as { id: A, propertyName: 'foo', oldValue: 1, newValue: 3 }.\n            const index = mergedChanges.findIndex(pastChange => {\n              return pastChange.type === change.type && pastChange.id === change.id && (change.propertyName === undefined || pastChange.propertyName === change.propertyName);\n            });\n            const existingChange = mergedChanges[index];\n            if (existingChange) {\n              if (change.propertyName !== undefined) {\n                // The incoming change is of the same property of existing change.\n                existingChange.newValue = change.newValue;\n              } else {\n                // The incoming change is a whole data override.\n                mergedChanges.splice(index, 1);\n                mergedChanges.push(change);\n              }\n            } else {\n              mergedChanges.push(change);\n            }\n            break;\n          }\n        case 'TreeStructureDetached':\n          {\n            // TreeStructureAttached\n            // TreeStructureChanged\n            // TreeStructureDetached 👈🏻 Since the tree struct was detached, above 2 changes may be ignored.\n            mergedChanges = mergedChanges.filter(pastChange => {\n              if (pastChange.type === 'TreeStructureAttached') {\n                return pastChange.treeKey !== change.treeKey;\n              } else if (pastChange.type === 'TreeStructureChanged') {\n                return pastChange.treeKey !== change.treeKey;\n              }\n              return true;\n            });\n            mergedChanges.push(change);\n            break;\n          }\n        case 'TreeStructureChanged':\n          {\n            const existingChange = mergedChanges.find(pastChange => {\n              return pastChange.type === 'TreeStructureChanged' && pastChange.treeKey === change.treeKey && pastChange.nodeId === change.nodeId;\n            });\n            if (existingChange) {\n              existingChange.newParentId = change.newParentId;\n            } else {\n              mergedChanges.push(change);\n            }\n            break;\n          }\n        default:\n          mergedChanges.push(change);\n          break;\n      }\n    });\n    return mergedChanges;\n  }\n  // ================= Node =================\n  checkNodeExistence(id) {\n    this.getNode(id);\n  }\n  /**\n   * Check if a node exists in the graph.\n   * @group NodeMethods\n   */\n  hasNode(id) {\n    return this.nodeMap.has(id);\n  }\n  /**\n   * Tell if two nodes are neighbors.\n   * @group NodeMethods\n   */\n  areNeighbors(firstNodeId, secondNodeId) {\n    return this.getNeighbors(secondNodeId).some(neighbor => neighbor.id === firstNodeId);\n  }\n  /**\n   * Get the node data with given ID.\n   * @group NodeMethods\n   */\n  getNode(id) {\n    const node = this.nodeMap.get(id);\n    if (!node) {\n      throw new Error('Node not found for id: ' + id);\n    }\n    return node;\n  }\n  /**\n   * Given a node ID, find all edges of the node.\n   * @param id - ID of the node\n   * @param direction - Edge direction, defaults to 'both'.\n   * @group NodeMethods\n   */\n  getRelatedEdges(id, direction) {\n    this.checkNodeExistence(id);\n    if (direction === 'in') {\n      const inEdges = this.inEdgesMap.get(id);\n      return Array.from(inEdges);\n    } else if (direction === 'out') {\n      const outEdges = this.outEdgesMap.get(id);\n      return Array.from(outEdges);\n    } else {\n      const bothEdges = this.bothEdgesMap.get(id);\n      return Array.from(bothEdges);\n    }\n  }\n  /**\n   * Get the degree of the given node.\n   * @group NodeMethods\n   */\n  getDegree(id, direction) {\n    return this.getRelatedEdges(id, direction).length;\n  }\n  /**\n   * Get all successors of the given node.\n   */\n  getSuccessors(id) {\n    const outEdges = this.getRelatedEdges(id, 'out');\n    const targets = outEdges.map(edge => this.getNode(edge.target));\n    return Array.from(new Set(targets));\n  }\n  /**\n   * Get all predecessors of the given node.\n   */\n  getPredecessors(id) {\n    const inEdges = this.getRelatedEdges(id, 'in');\n    const sources = inEdges.map(edge => this.getNode(edge.source));\n    return Array.from(new Set(sources));\n  }\n  /**\n   * Given a node ID, find its neighbors.\n   * @param id - ID of the node\n   * @group NodeMethods\n   */\n  getNeighbors(id) {\n    const predecessors = this.getPredecessors(id);\n    const successors = this.getSuccessors(id);\n    return Array.from(new Set([...predecessors, ...successors]));\n  }\n  doAddNode(node) {\n    if (this.hasNode(node.id)) {\n      throw new Error('Node already exists: ' + node.id);\n    }\n    this.nodeMap.set(node.id, node);\n    this.inEdgesMap.set(node.id, new Set());\n    this.outEdgesMap.set(node.id, new Set());\n    this.bothEdgesMap.set(node.id, new Set());\n    this.treeIndices.forEach(tree => {\n      tree.childrenMap.set(node.id, new Set());\n    });\n    this.changes.push({\n      type: 'NodeAdded',\n      value: node\n    });\n  }\n  /**\n   * Add all nodes of the given array, or iterable, into the graph.\n   * @group NodeMethods\n   */\n  addNodes(nodes) {\n    this.batch(() => {\n      for (const node of nodes) {\n        this.doAddNode(node);\n      }\n    });\n  }\n  /**\n   * Add a single node into the graph.\n   * @group NodeMethods\n   */\n  addNode(node) {\n    this.addNodes([node]);\n  }\n  doRemoveNode(id) {\n    const node = this.getNode(id);\n    const bothEdges = this.bothEdgesMap.get(id);\n    bothEdges?.forEach(edge => this.doRemoveEdge(edge.id));\n    this.nodeMap.delete(id);\n    this.treeIndices.forEach(tree => {\n      tree.childrenMap.get(id)?.forEach(child => {\n        tree.parentMap.delete(child.id);\n      });\n      const parent = tree.parentMap.get(id);\n      if (parent) tree.childrenMap.get(parent.id)?.delete(node);\n      tree.parentMap.delete(id);\n      tree.childrenMap.delete(id);\n    });\n    this.bothEdgesMap.delete(id);\n    this.inEdgesMap.delete(id);\n    this.outEdgesMap.delete(id);\n    this.changes.push({\n      type: 'NodeRemoved',\n      value: node\n    });\n  }\n  /**\n   * Remove nodes and their attached edges from the graph.\n   * @group NodeMethods\n   */\n  removeNodes(idList) {\n    this.batch(() => {\n      idList.forEach(id => this.doRemoveNode(id));\n    });\n  }\n  /**\n   * Remove a single node and its attached edges from the graph.\n   * @group NodeMethods\n   */\n  removeNode(id) {\n    this.removeNodes([id]);\n  }\n  updateNodeDataProperty(id, propertyName, value) {\n    const node = this.getNode(id);\n    this.batch(() => {\n      const oldValue = node.data[propertyName];\n      const newValue = value;\n      node.data[propertyName] = newValue;\n      this.changes.push({\n        type: 'NodeDataUpdated',\n        id,\n        propertyName,\n        oldValue,\n        newValue\n      });\n    });\n  }\n  /**\n   * Like Object.assign, merge all properties of `path` to the node data.\n   * @param id Node ID.\n   * @param patch A data object to merge.\n   */\n  mergeNodeData(id, patch) {\n    this.batch(() => {\n      Object.entries(patch).forEach(([propertyName, value]) => {\n        this.updateNodeDataProperty(id, propertyName, value);\n      });\n    });\n  }\n  updateNodeData(...args) {\n    const id = args[0];\n    const node = this.getNode(id);\n    if (typeof args[1] === 'string') {\n      // id, propertyName, value\n      this.updateNodeDataProperty(id, args[1], args[2]);\n      return;\n    }\n    let data;\n    if (typeof args[1] === 'function') {\n      // id, update\n      const update = args[1];\n      data = update(node.data);\n    } else if (typeof args[1] === 'object') {\n      // id, data\n      data = args[1];\n    }\n    this.batch(() => {\n      const oldValue = node.data;\n      const newValue = data;\n      node.data = data;\n      this.changes.push({\n        type: 'NodeDataUpdated',\n        id,\n        oldValue,\n        newValue\n      });\n    });\n  }\n  // ================= Edge =================\n  checkEdgeExistence(id) {\n    if (!this.hasEdge(id)) {\n      throw new Error('Edge not found for id: ' + id);\n    }\n  }\n  /**\n   * Check if an edge exists in the graph.\n   * @group NodeMethods\n   */\n  hasEdge(id) {\n    return this.edgeMap.has(id);\n  }\n  /**\n   * Get the edge data with given ID.\n   * @group EdgeMethods\n   */\n  getEdge(id) {\n    this.checkEdgeExistence(id);\n    return this.edgeMap.get(id);\n  }\n  /**\n   * Get the edge, the source node, and the target node by an edge ID.\n   * @group EdgeMethods\n   */\n  getEdgeDetail(id) {\n    const edge = this.getEdge(id);\n    return {\n      edge,\n      source: this.getNode(edge.source),\n      target: this.getNode(edge.target)\n    };\n  }\n  doAddEdge(edge) {\n    if (this.hasEdge(edge.id)) {\n      throw new Error('Edge already exists: ' + edge.id);\n    }\n    this.checkNodeExistence(edge.source);\n    this.checkNodeExistence(edge.target);\n    this.edgeMap.set(edge.id, edge);\n    const inEdges = this.inEdgesMap.get(edge.target);\n    const outEdges = this.outEdgesMap.get(edge.source);\n    const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);\n    const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);\n    inEdges.add(edge);\n    outEdges.add(edge);\n    bothEdgesOfSource.add(edge);\n    bothEdgesOfTarget.add(edge);\n    this.changes.push({\n      type: 'EdgeAdded',\n      value: edge\n    });\n  }\n  /**\n   * Add all edges of the given iterable(an array, a set, etc.) into the graph.\n   * @group EdgeMethods\n   */\n  addEdges(edges) {\n    this.batch(() => {\n      for (const edge of edges) {\n        this.doAddEdge(edge);\n      }\n    });\n  }\n  /**\n   * Add a single edge pointing from `source` to `target` into the graph.\n   *\n   * ```ts\n   * graph.addNode({ id: 'NodeA' });\n   * graph.addNode({ id: 'NodeB' });\n   * graph.addEdge({ id: 'EdgeA', source: 'NodeA', target: 'NodeB' });\n   * ```\n   *\n   * If `source` or `target` were not found in the current graph, it throws an Error.\n   * @group EdgeMethods\n   */\n  addEdge(edge) {\n    this.addEdges([edge]);\n  }\n  doRemoveEdge(id) {\n    const edge = this.getEdge(id);\n    const outEdges = this.outEdgesMap.get(edge.source);\n    const inEdges = this.inEdgesMap.get(edge.target);\n    const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);\n    const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);\n    outEdges.delete(edge);\n    inEdges.delete(edge);\n    bothEdgesOfSource.delete(edge);\n    bothEdgesOfTarget.delete(edge);\n    this.edgeMap.delete(id);\n    this.changes.push({\n      type: 'EdgeRemoved',\n      value: edge\n    });\n  }\n  /**\n   * Remove edges whose id was included in the given id list.\n   * @group EdgeMethods\n   */\n  removeEdges(idList) {\n    this.batch(() => {\n      idList.forEach(id => this.doRemoveEdge(id));\n    });\n  }\n  /**\n   * Remove a single edge of the given id.\n   * @group EdgeMethods\n   */\n  removeEdge(id) {\n    this.removeEdges([id]);\n  }\n  /**\n   * Change the source of an edge. The source must be found in current graph.\n   * @group EdgeMethods\n   */\n  updateEdgeSource(id, source) {\n    const edge = this.getEdge(id);\n    this.checkNodeExistence(source);\n    const oldSource = edge.source;\n    const newSource = source;\n    this.outEdgesMap.get(oldSource).delete(edge);\n    this.bothEdgesMap.get(oldSource).delete(edge);\n    this.outEdgesMap.get(newSource).add(edge);\n    this.bothEdgesMap.get(newSource).add(edge);\n    edge.source = source;\n    this.batch(() => {\n      this.changes.push({\n        type: 'EdgeUpdated',\n        id,\n        propertyName: 'source',\n        oldValue: oldSource,\n        newValue: newSource\n      });\n    });\n  }\n  /**\n   * Change the target of an edge. The target must be found in current graph.\n   * @group EdgeMethods\n   */\n  updateEdgeTarget(id, target) {\n    const edge = this.getEdge(id);\n    this.checkNodeExistence(target);\n    const oldTarget = edge.target;\n    const newTarget = target;\n    this.inEdgesMap.get(oldTarget).delete(edge);\n    this.bothEdgesMap.get(oldTarget).delete(edge);\n    this.inEdgesMap.get(newTarget).add(edge);\n    this.bothEdgesMap.get(newTarget).add(edge);\n    edge.target = target;\n    this.batch(() => {\n      this.changes.push({\n        type: 'EdgeUpdated',\n        id,\n        propertyName: 'target',\n        oldValue: oldTarget,\n        newValue: newTarget\n      });\n    });\n  }\n  updateEdgeDataProperty(id, propertyName, value) {\n    const edge = this.getEdge(id);\n    this.batch(() => {\n      const oldValue = edge.data[propertyName];\n      const newValue = value;\n      edge.data[propertyName] = newValue;\n      this.changes.push({\n        type: 'EdgeDataUpdated',\n        id,\n        propertyName,\n        oldValue,\n        newValue\n      });\n    });\n  }\n  updateEdgeData(...args) {\n    const id = args[0];\n    const edge = this.getEdge(id);\n    if (typeof args[1] === 'string') {\n      // id, propertyName, value\n      this.updateEdgeDataProperty(id, args[1], args[2]);\n      return;\n    }\n    let data;\n    if (typeof args[1] === 'function') {\n      // id, update\n      const update = args[1];\n      data = update(edge.data);\n    } else if (typeof args[1] === 'object') {\n      // id, data\n      data = args[1];\n    }\n    this.batch(() => {\n      const oldValue = edge.data;\n      const newValue = data;\n      edge.data = data;\n      this.changes.push({\n        type: 'EdgeDataUpdated',\n        id,\n        oldValue,\n        newValue\n      });\n    });\n  }\n  /**\n   * @group EdgeMethods\n   */\n  mergeEdgeData(id, patch) {\n    this.batch(() => {\n      Object.entries(patch).forEach(([propertyName, value]) => {\n        this.updateEdgeDataProperty(id, propertyName, value);\n      });\n    });\n  }\n  // ================= Tree =================\n  checkTreeExistence(treeKey) {\n    if (!this.hasTreeStructure(treeKey)) {\n      throw new Error('Tree structure not found for treeKey: ' + treeKey);\n    }\n  }\n  hasTreeStructure(treeKey) {\n    return this.treeIndices.has(treeKey);\n  }\n  /**\n   * Attach a new tree structure representing the hierarchy of all nodes in the graph.\n   * @param treeKey A unique key of the tree structure. You can attach multiple tree structures with different keys.\n   *\n   * ```ts\n   * const graph = new Graph({\n   *   nodes: [{ id: 1 }, { id: 2 }, { id: 3 }],\n   * });\n   * graph.attachTreeStructure('Inheritance');\n   * graph.setParent(2, 1, 'Inheritance');\n   * graph.setParent(3, 1, 'Inheritance');\n   * graph.getRoots('Inheritance'); // [1]\n   * graph.getChildren(1, 'Inheritance'); // [2,3]\n   * ```\n   * @group TreeMethods\n   */\n  attachTreeStructure(treeKey) {\n    if (this.treeIndices.has(treeKey)) {\n      // Already attached.\n      return;\n    }\n    this.treeIndices.set(treeKey, {\n      parentMap: new Map(),\n      childrenMap: new Map()\n    });\n    this.batch(() => {\n      this.changes.push({\n        type: 'TreeStructureAttached',\n        treeKey\n      });\n    });\n  }\n  /**\n   * Detach the tree structure of the given tree key from the graph.\n   *\n   * ```ts\n   * graph.detachTreeStructure('Inheritance');\n   * graph.getRoots('Inheritance'); // Error!\n   * ```\n   * @group TreeMethods\n   */\n  detachTreeStructure(treeKey) {\n    this.checkTreeExistence(treeKey);\n    this.treeIndices.delete(treeKey);\n    this.batch(() => {\n      this.changes.push({\n        type: 'TreeStructureDetached',\n        treeKey\n      });\n    });\n  }\n  /**\n   * Traverse the given tree data, add each node into the graph, then attach the tree structure.\n   *\n   * ```ts\n   * graph.addTree({\n   *   id: 1,\n   *   children: [\n   *     { id: 2 },\n   *     { id: 3 },\n   *   ],\n   * }, 'Inheritance');\n   * graph.getRoots('Inheritance'); // [1]\n   * graph.getChildren(1, 'Inheritance'); // [2, 3]\n   * graph.getAllNodes(); // [1, 2, 3]\n   * graph.getAllEdges(); // []\n   * ```\n   * @group TreeMethods\n   */\n  addTree(tree, treeKey) {\n    this.batch(() => {\n      this.attachTreeStructure(treeKey);\n      // Add Nodes\n      const nodes = [];\n      const stack = Array.isArray(tree) ? tree : [tree];\n      while (stack.length) {\n        const node = stack.shift();\n        nodes.push(node);\n        if (node.children) {\n          stack.push(...node.children);\n        }\n      }\n      this.addNodes(nodes);\n      // Set parent for each child node.\n      nodes.forEach(parent => {\n        parent.children?.forEach(child => {\n          this.setParent(child.id, parent.id, treeKey);\n        });\n      });\n    });\n  }\n  /**\n   * Get the root nodes of an attached tree structure.\n   *\n   * Consider a graph with the following tree structure attached:\n   * ```\n   * Tree structure:\n   *    O     3\n   *   / \\    |\n   *  1   2   4\n   * ```\n   * `graph.getRoots()` takes all nodes without a parent, therefore [0, 3] was returned.\n   *\n   * Newly added nodes are also unparented. So they are counted as roots.\n   * ```ts\n   * graph.addNode({ id: 5 });\n   * graph.getRoots(); // [0, 3, 5]\n   * ```\n   *\n   * Here is how the tree structure looks like:\n   * ```\n   * Tree structure:\n   *    O     3  5\n   *   / \\    |\n   *  1   2   4\n   * ```\n   *\n   * By setting a parent, a root node no more be a root.\n   * ```ts\n   * graph.setParent(5, 2);\n   * graph.getRoots(); // [0, 3]\n   * ```\n   *\n   * The tree structure now becomes:\n   * ```\n   * Tree structure:\n   *    O     3\n   *   / \\    |\n   *  1   2   4\n   *      |\n   *      5\n   * ```\n   *\n   * Removing a node forces its children to be unparented, or roots.\n   * ```ts\n   * graph.removeNode(0);\n   * graph.getRoots(); // [1, 2, 3]\n   * ```\n   *\n   * You might draw the the structure as follow:\n   * ```\n   * Tree structure:\n   *  1   2  3\n   *      |  |\n   *      5  4\n   * ```\n   * @group TreeMethods\n   */\n  getRoots(treeKey) {\n    this.checkTreeExistence(treeKey);\n    return this.getAllNodes().filter(node => !this.getParent(node.id, treeKey));\n  }\n  /**\n   * Given a node ID and an optional tree key, get the children of the node in the specified tree structure.\n   * @group TreeMethods\n   */\n  getChildren(id, treeKey) {\n    this.checkNodeExistence(id);\n    this.checkTreeExistence(treeKey);\n    const tree = this.treeIndices.get(treeKey);\n    const children = tree.childrenMap.get(id);\n    return Array.from(children || []);\n  }\n  /**\n   * Given a node ID and an optional tree key, get the parent of the node in the specified tree structure.\n   * If the given node is one of the tree roots, this returns null.\n   * @group TreeMethods\n   */\n  getParent(id, treeKey) {\n    this.checkNodeExistence(id);\n    this.checkTreeExistence(treeKey);\n    const tree = this.treeIndices.get(treeKey);\n    return tree.parentMap.get(id) || null;\n  }\n  /**\n   * Returns an array of all the ancestor nodes, staring from the parent to the root.\n   */\n  getAncestors(id, treeKey) {\n    const ancestors = [];\n    let current = this.getNode(id);\n    let parent;\n    // eslint-disable-next-line no-cond-assign\n    while (parent = this.getParent(current.id, treeKey)) {\n      ancestors.push(parent);\n      current = parent;\n    }\n    return ancestors;\n  }\n  /**\n   * Set node parent. If this operation causes a circle, it fails with an error.\n   * @param id - ID of the child node.\n   * @param parent - ID of the parent node. If it is undefined or null, means unset parent for node with id.\n   * @param treeKey - Which tree structure the relation is applied to.\n   * @group TreeMethods\n   */\n  setParent(id, parent, treeKey) {\n    this.checkTreeExistence(treeKey);\n    const tree = this.treeIndices.get(treeKey);\n    if (!tree) return;\n    const node = this.getNode(id);\n    const oldParent = tree.parentMap.get(id);\n    // Same parent id as old one, skip\n    if (oldParent?.id === parent) return;\n    // New parent is undefined or null, unset parent for the node\n    if (parent === undefined || parent === null) {\n      if (oldParent) {\n        tree.childrenMap.get(oldParent.id)?.delete(node);\n      }\n      tree.parentMap.delete(id);\n      return;\n    }\n    const newParent = this.getNode(parent);\n    // Set parent\n    tree.parentMap.set(id, newParent);\n    // Set children\n    if (oldParent) {\n      tree.childrenMap.get(oldParent.id)?.delete(node);\n    }\n    let children = tree.childrenMap.get(newParent.id);\n    if (!children) {\n      children = new Set();\n      tree.childrenMap.set(newParent.id, children);\n    }\n    children.add(node);\n    this.batch(() => {\n      this.changes.push({\n        type: 'TreeStructureChanged',\n        treeKey,\n        nodeId: id,\n        oldParentId: oldParent?.id,\n        newParentId: newParent.id\n      });\n    });\n  }\n  dfsTree(id, fn, treeKey) {\n    const navigator = nodeId => this.getChildren(nodeId, treeKey);\n    return doDFS(this.getNode(id), new Set(), fn, navigator);\n  }\n  bfsTree(id, fn, treeKey) {\n    const navigator = nodeId => this.getChildren(nodeId, treeKey);\n    return doBFS([this.getNode(id)], new Set(), fn, navigator);\n  }\n  // ================= Graph =================\n  /**\n   * Get all nodes in the graph as an array.\n   */\n  getAllNodes() {\n    return Array.from(this.nodeMap.values());\n  }\n  /**\n   * Get all edges in the graph as an array.\n   */\n  getAllEdges() {\n    return Array.from(this.edgeMap.values());\n  }\n  bfs(id, fn, direction = 'out') {\n    const navigator = {\n      in: this.getPredecessors.bind(this),\n      out: this.getSuccessors.bind(this),\n      both: this.getNeighbors.bind(this)\n    }[direction];\n    return doBFS([this.getNode(id)], new Set(), fn, navigator);\n  }\n  dfs(id, fn, direction = 'out') {\n    const navigator = {\n      in: this.getPredecessors.bind(this),\n      out: this.getSuccessors.bind(this),\n      both: this.getNeighbors.bind(this)\n    }[direction];\n    return doDFS(this.getNode(id), new Set(), fn, navigator);\n  }\n  clone() {\n    // Make a shallow copy of nodes and edges.\n    const newNodes = this.getAllNodes().map(oldNode => {\n      return {\n        ...oldNode,\n        data: {\n          ...oldNode.data\n        }\n      };\n    });\n    const newEdges = this.getAllEdges().map(oldEdge => {\n      return {\n        ...oldEdge,\n        data: {\n          ...oldEdge.data\n        }\n      };\n    });\n    // Create a new graph with shallow copied nodes and edges.\n    const newGraph = new Graph({\n      nodes: newNodes,\n      edges: newEdges\n    });\n    // Add tree indices.\n    this.treeIndices.forEach(({\n      parentMap: oldParentMap,\n      childrenMap: oldChildrenMap\n    }, treeKey) => {\n      const parentMap = new Map();\n      oldParentMap.forEach((parent, key) => {\n        parentMap.set(key, newGraph.getNode(parent.id));\n      });\n      const childrenMap = new Map();\n      oldChildrenMap.forEach((children, key) => {\n        childrenMap.set(key, new Set(Array.from(children).map(n => newGraph.getNode(n.id))));\n      });\n      newGraph.treeIndices.set(treeKey, {\n        parentMap: parentMap,\n        childrenMap: childrenMap\n      });\n    });\n    return newGraph;\n  }\n  toJSON() {\n    return JSON.stringify({\n      nodes: this.getAllNodes(),\n      edges: this.getAllEdges()\n      // FIXME: And tree structures?\n    });\n  }\n  createView(options) {\n    return new GraphView({\n      graph: this,\n      ...options\n    });\n  }\n}","map":{"version":3,"names":["EventEmitter","GraphView","doBFS","doDFS","Graph","nodeMap","Map","edgeMap","inEdgesMap","outEdgesMap","bothEdgesMap","treeIndices","changes","batchCount","onChanged","constructor","options","nodes","addNodes","edges","addEdges","tree","addTree","batch","fn","commit","event","graph","emit","reduceChanges","mergedChanges","forEach","change","type","isNewlyAdded","filter","pastChange","sameId","value","id","nodeId","push","index","findIndex","propertyName","undefined","existingChange","newValue","splice","treeKey","find","newParentId","checkNodeExistence","getNode","hasNode","has","areNeighbors","firstNodeId","secondNodeId","getNeighbors","some","neighbor","node","get","Error","getRelatedEdges","direction","inEdges","Array","from","outEdges","bothEdges","getDegree","length","getSuccessors","targets","map","edge","target","Set","getPredecessors","sources","source","predecessors","successors","doAddNode","set","childrenMap","addNode","doRemoveNode","doRemoveEdge","delete","child","parentMap","parent","removeNodes","idList","removeNode","updateNodeDataProperty","oldValue","data","mergeNodeData","patch","Object","entries","updateNodeData","args","update","checkEdgeExistence","hasEdge","getEdge","getEdgeDetail","doAddEdge","bothEdgesOfSource","bothEdgesOfTarget","add","addEdge","removeEdges","removeEdge","updateEdgeSource","oldSource","newSource","updateEdgeTarget","oldTarget","newTarget","updateEdgeDataProperty","updateEdgeData","mergeEdgeData","checkTreeExistence","hasTreeStructure","attachTreeStructure","detachTreeStructure","stack","isArray","shift","children","setParent","getRoots","getAllNodes","getParent","getChildren","getAncestors","ancestors","current","oldParent","newParent","oldParentId","dfsTree","navigator","bfsTree","values","getAllEdges","bfs","in","bind","out","both","dfs","clone","newNodes","oldNode","newEdges","oldEdge","newGraph","oldParentMap","oldChildrenMap","key","n","toJSON","JSON","stringify","createView"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/graphlib/src/graph.ts"],"sourcesContent":["import EventEmitter from '@antv/event-emitter';\nimport { GraphView } from './graphView';\nimport {\n  Node,\n  Edge,\n  GraphChange,\n  GraphChangedEvent,\n  GraphOptions,\n  ID,\n  TreeData,\n  PlainObject,\n  TreeIndices,\n  NodeDataUpdated,\n  TreeStructureChanged,\n  GraphViewOptions,\n} from './types';\nimport { doBFS, doDFS } from './utils/traverse';\n\nexport class Graph<\n  N extends PlainObject,\n  E extends PlainObject,\n> extends EventEmitter {\n  private nodeMap: Map<ID, Node<N>> = new Map();\n  private edgeMap: Map<ID, Edge<E>> = new Map();\n  private inEdgesMap: Map<ID, Set<Edge<E>>> = new Map();\n  private outEdgesMap: Map<ID, Set<Edge<E>>> = new Map();\n  private bothEdgesMap: Map<ID, Set<Edge<E>>> = new Map();\n  private treeIndices: TreeIndices<Node<N>> = new Map();\n\n  private changes: GraphChange<N, E>[] = [];\n  private batchCount = 0;\n\n  /**\n   * This function is called with a {@link GraphChangedEvent} each time a graph change happened.\n   *\n   * `event.changes` contains all the graph changes in order since last `onChanged`.\n   */\n  public onChanged: (event: GraphChangedEvent<N, E>) => void = () => {\n    // Do nothing.\n  };\n\n  /**\n   * Create a new Graph instance.\n   * @param options - The options to initialize a graph. See {@link GraphOptions}.\n   *\n   * ```ts\n   * const graph = new Graph({\n   *   // Optional, initial nodes.\n   *   nodes: [\n   *     // Each node has a unique ID.\n   *     { id: 'A', foo: 1 },\n   *     { id: 'B', foo: 1 },\n   *   ],\n   *   // Optional, initial edges.\n   *   edges: [\n   *     { id: 'C', source: 'B', target: 'B', weight: 1 },\n   *   ],\n   *   // Optional, called with a GraphChangedEvent.\n   *   onChanged: (event) => {\n   *     console.log(event);\n   *   }\n   * });\n   * ```\n   */\n  constructor(options?: GraphOptions<N, E>) {\n    super();\n    if (!options) return;\n    if (options.nodes) this.addNodes(options.nodes);\n    if (options.edges) this.addEdges(options.edges);\n    if (options.tree) this.addTree(options.tree);\n    if (options.onChanged) this.onChanged = options.onChanged;\n  }\n\n  /**\n   * Batch several graph changes into one.\n   *\n   * Make several changes, but dispatch only one ChangedEvent at the end of batch:\n   * ```ts\n   * graph.batch(() => {\n   *   graph.addNodes([]);\n   *   graph.addEdges([]);\n   * });\n   * ```\n   *\n   * Batches can be nested. Only the outermost batch will dispatch a ChangedEvent:\n   * ```ts\n   * graph.batch(() => {\n   *   graph.addNodes([]);\n   *   graph.batch(() => {\n   *     graph.addEdges([]);\n   *   });\n   * });\n   * ```\n   */\n  public batch = (fn: () => void): void => {\n    this.batchCount += 1;\n    fn();\n    this.batchCount -= 1;\n    if (!this.batchCount) {\n      this.commit();\n    }\n  };\n\n  /**\n   * Reset changes and dispatch a ChangedEvent.\n   */\n  private commit(): void {\n    const changes = this.changes;\n    this.changes = [];\n    const event = {\n      graph: this,\n      changes,\n    };\n    this.emit('changed', event);\n    this.onChanged(event);\n  }\n\n  /**\n   * Reduce the number of ordered graph changes by dropping or merging unnecessary changes.\n   *\n   * For example, if we update a node and remove it in a batch:\n   *\n   * ```ts\n   * graph.batch(() => {\n   *   graph.updateNodeData('A', 'foo', 2);\n   *   graph.removeNode('A');\n   * });\n   * ```\n   *\n   * We get 2 atomic graph changes like\n   *\n   * ```ts\n   * [\n   *   { type: 'NodeDataUpdated', id: 'A', propertyName: 'foo', oldValue: 1, newValue: 2 },\n   *   { type: 'NodeRemoved', value: { id: 'A', data: { foo: 2 } },\n   * ]\n   * ```\n   *\n   * Since node 'A' has been removed, we actually have no need to handle with NodeDataUpdated change.\n   *\n   * `reduceChanges()` here helps us remove such changes.\n   */\n  public reduceChanges(changes: GraphChange<N, E>[]): GraphChange<N, E>[] {\n    let mergedChanges: GraphChange<N, E>[] = [];\n    changes.forEach((change) => {\n      switch (change.type) {\n        case 'NodeRemoved': {\n          // NodeAdded: A added.\n          // NodeDataUpdated: A changed.\n          // TreeStructureChanged: A's parent changed.\n          // NodeRemoved: A removed. 👈🏻 Since A was removed, above three changes may be ignored.\n          let isNewlyAdded = false;\n          mergedChanges = mergedChanges.filter((pastChange) => {\n            if (pastChange.type === 'NodeAdded') {\n              const sameId = pastChange.value.id === change.value.id;\n              if (sameId) {\n                isNewlyAdded = true;\n              }\n              return !sameId;\n            } else if (pastChange.type === 'NodeDataUpdated') {\n              return pastChange.id !== change.value.id;\n            } else if (pastChange.type === 'TreeStructureChanged') {\n              return pastChange.nodeId !== change.value.id;\n            }\n            return true;\n          });\n          if (!isNewlyAdded) {\n            mergedChanges.push(change);\n          }\n          break;\n        }\n        case 'EdgeRemoved': {\n          // EdgeAdded: A added.\n          // EdgeDataUpdated: A changed.\n          // EdgeDataUpdated: A's source/target changed.\n          // EdgeRemoved: A removed. 👈🏻 Since A was removed, above three changes may be ignored.\n          let isNewlyAdded = false;\n          mergedChanges = mergedChanges.filter((pastChange) => {\n            if (pastChange.type === 'EdgeAdded') {\n              const sameId = pastChange.value.id === change.value.id;\n              if (sameId) {\n                isNewlyAdded = true;\n              }\n              return !sameId;\n            } else if (\n              pastChange.type === 'EdgeDataUpdated' ||\n              pastChange.type === 'EdgeUpdated'\n            ) {\n              return pastChange.id !== change.value.id;\n            }\n            return true;\n          });\n          if (!isNewlyAdded) {\n            mergedChanges.push(change);\n          }\n          break;\n        }\n        case 'NodeDataUpdated':\n        case 'EdgeDataUpdated':\n        case 'EdgeUpdated': {\n          // NodeDataUpdated: { id: A, propertyName: 'foo', oldValue: 1, newValue: 2 }.\n          // NodeDataUpdated: { id: A, propertyName: 'foo', oldValue: 2, newValue: 3 }.\n          // 👆 Could be merged as { id: A, propertyName: 'foo', oldValue: 1, newValue: 3 }.\n          const index = mergedChanges.findIndex((pastChange) => {\n            return (\n              pastChange.type === change.type &&\n              pastChange.id === change.id &&\n              (change.propertyName === undefined ||\n                pastChange.propertyName === change.propertyName)\n            );\n          });\n          const existingChange = mergedChanges[index];\n          if (existingChange) {\n            if (change.propertyName !== undefined) {\n              // The incoming change is of the same property of existing change.\n              (existingChange as NodeDataUpdated<N>).newValue = change.newValue;\n            } else {\n              // The incoming change is a whole data override.\n              mergedChanges.splice(index, 1);\n              mergedChanges.push(change);\n            }\n          } else {\n            mergedChanges.push(change);\n          }\n          break;\n        }\n        case 'TreeStructureDetached': {\n          // TreeStructureAttached\n          // TreeStructureChanged\n          // TreeStructureDetached 👈🏻 Since the tree struct was detached, above 2 changes may be ignored.\n          mergedChanges = mergedChanges.filter((pastChange) => {\n            if (pastChange.type === 'TreeStructureAttached') {\n              return pastChange.treeKey !== change.treeKey;\n            } else if (pastChange.type === 'TreeStructureChanged') {\n              return pastChange.treeKey !== change.treeKey;\n            }\n            return true;\n          });\n          mergedChanges.push(change);\n          break;\n        }\n        case 'TreeStructureChanged': {\n          const existingChange = mergedChanges.find((pastChange) => {\n            return (\n              pastChange.type === 'TreeStructureChanged' &&\n              pastChange.treeKey === change.treeKey &&\n              pastChange.nodeId === change.nodeId\n            );\n          });\n          if (existingChange) {\n            (existingChange as TreeStructureChanged).newParentId =\n              change.newParentId;\n          } else {\n            mergedChanges.push(change);\n          }\n          break;\n        }\n        default:\n          mergedChanges.push(change);\n          break;\n      }\n    });\n    return mergedChanges;\n  }\n\n  // ================= Node =================\n  private checkNodeExistence(id: ID): void {\n    this.getNode(id);\n  }\n\n  /**\n   * Check if a node exists in the graph.\n   * @group NodeMethods\n   */\n  public hasNode(id: ID): boolean {\n    return this.nodeMap.has(id);\n  }\n\n  /**\n   * Tell if two nodes are neighbors.\n   * @group NodeMethods\n   */\n  public areNeighbors(firstNodeId: ID, secondNodeId: ID): boolean {\n    return this.getNeighbors(secondNodeId).some(\n      (neighbor) => neighbor.id === firstNodeId,\n    );\n  }\n\n  /**\n   * Get the node data with given ID.\n   * @group NodeMethods\n   */\n  public getNode(id: ID): Node<N> {\n    const node = this.nodeMap.get(id);\n    if (!node) {\n      throw new Error('Node not found for id: ' + id);\n    }\n    return node;\n  }\n\n  /**\n   * Given a node ID, find all edges of the node.\n   * @param id - ID of the node\n   * @param direction - Edge direction, defaults to 'both'.\n   * @group NodeMethods\n   */\n  public getRelatedEdges(id: ID, direction?: 'in' | 'out' | 'both'): Edge<E>[] {\n    this.checkNodeExistence(id);\n\n    if (direction === 'in') {\n      const inEdges = this.inEdgesMap.get(id)!;\n      return Array.from(inEdges);\n    } else if (direction === 'out') {\n      const outEdges = this.outEdgesMap.get(id)!;\n      return Array.from(outEdges);\n    } else {\n      const bothEdges = this.bothEdgesMap.get(id)!;\n      return Array.from(bothEdges);\n    }\n  }\n\n  /**\n   * Get the degree of the given node.\n   * @group NodeMethods\n   */\n  public getDegree(id: ID, direction?: 'in' | 'out' | 'both'): number {\n    return this.getRelatedEdges(id, direction).length;\n  }\n\n  /**\n   * Get all successors of the given node.\n   */\n  public getSuccessors(id: ID): Node<N>[] {\n    const outEdges = this.getRelatedEdges(id, 'out');\n    const targets = outEdges.map((edge) => this.getNode(edge.target));\n    return Array.from(new Set(targets));\n  }\n\n  /**\n   * Get all predecessors of the given node.\n   */\n  public getPredecessors(id: ID): Node<N>[] {\n    const inEdges = this.getRelatedEdges(id, 'in');\n    const sources = inEdges.map((edge) => this.getNode(edge.source));\n    return Array.from(new Set(sources));\n  }\n\n  /**\n   * Given a node ID, find its neighbors.\n   * @param id - ID of the node\n   * @group NodeMethods\n   */\n  public getNeighbors(id: ID): Node<N>[] {\n    const predecessors = this.getPredecessors(id);\n    const successors = this.getSuccessors(id);\n    return Array.from(new Set([...predecessors, ...successors]));\n  }\n\n  private doAddNode(node: Node<N>): void {\n    if (this.hasNode(node.id)) {\n      throw new Error('Node already exists: ' + node.id);\n    }\n    this.nodeMap.set(node.id, node);\n    this.inEdgesMap.set(node.id, new Set());\n    this.outEdgesMap.set(node.id, new Set());\n    this.bothEdgesMap.set(node.id, new Set());\n    this.treeIndices.forEach((tree) => {\n      tree.childrenMap.set(node.id, new Set());\n    });\n    this.changes.push({ type: 'NodeAdded', value: node });\n  }\n\n  /**\n   * Add all nodes of the given array, or iterable, into the graph.\n   * @group NodeMethods\n   */\n  public addNodes(nodes: Iterable<Node<N>>) {\n    this.batch(() => {\n      for (const node of nodes) {\n        this.doAddNode(node);\n      }\n    });\n  }\n\n  /**\n   * Add a single node into the graph.\n   * @group NodeMethods\n   */\n  public addNode(node: Node<N>): void {\n    this.addNodes([node]);\n  }\n\n  private doRemoveNode(id: ID): void {\n    const node = this.getNode(id);\n    const bothEdges = this.bothEdgesMap.get(id);\n    bothEdges?.forEach((edge) => this.doRemoveEdge(edge.id));\n    this.nodeMap.delete(id);\n    this.treeIndices.forEach((tree) => {\n      tree.childrenMap.get(id)?.forEach((child) => {\n        tree.parentMap.delete(child.id);\n      });\n\n      const parent = tree.parentMap.get(id);\n      if (parent) tree.childrenMap.get(parent.id)?.delete(node);\n\n      tree.parentMap.delete(id);\n      tree.childrenMap.delete(id);\n    });\n    this.bothEdgesMap.delete(id);\n    this.inEdgesMap.delete(id);\n    this.outEdgesMap.delete(id);\n    this.changes.push({ type: 'NodeRemoved', value: node });\n  }\n\n  /**\n   * Remove nodes and their attached edges from the graph.\n   * @group NodeMethods\n   */\n  public removeNodes(idList: ID[]): void {\n    this.batch(() => {\n      idList.forEach((id) => this.doRemoveNode(id));\n    });\n  }\n\n  /**\n   * Remove a single node and its attached edges from the graph.\n   * @group NodeMethods\n   */\n  public removeNode(id: ID): void {\n    this.removeNodes([id]);\n  }\n\n  private updateNodeDataProperty<P extends keyof N>(\n    id: ID,\n    propertyName: P,\n    value: N[P],\n  ): void {\n    const node = this.getNode(id);\n    this.batch(() => {\n      const oldValue = node.data[propertyName];\n      const newValue = value;\n      node.data[propertyName] = newValue;\n      this.changes.push({\n        type: 'NodeDataUpdated',\n        id,\n        propertyName,\n        oldValue,\n        newValue,\n      });\n    });\n  }\n\n  /**\n   * Like Object.assign, merge all properties of `path` to the node data.\n   * @param id Node ID.\n   * @param patch A data object to merge.\n   */\n  public mergeNodeData(id: ID, patch: Partial<N>): void {\n    this.batch(() => {\n      Object.entries(patch).forEach(([propertyName, value]) => {\n        this.updateNodeDataProperty(id, propertyName, value);\n      });\n    });\n  }\n\n  /**\n   * Update node data. This will replace the whole data object.\n   *\n   * ```ts\n   * updateNodeData(id, data); // Works like `node.data = data`\n   * ```\n   *\n   * @group NodeMethods\n   */\n  public updateNodeData(id: ID, data: N): void;\n  /**\n   * Update a single property on the node data.\n   *\n   * To update multiple properties, you could {@link Graph.batch batch} several updates or use {@link Graph.mergeNodeData mergeNodeData}.\n   *\n   * ```ts\n   * updateNodeData(id, key, value); // Works like `node.data[key] = value`\n   * ```\n   *\n   * @group NodeMethods\n   */\n  public updateNodeData<P extends keyof N>(\n    id: ID,\n    propertyName: P,\n    value: N[P],\n  ): void;\n  /**\n   * Update node data by a update function.\n   *\n   * ```ts\n   * updateNodeData(id, oldData => newData);\n   * ```\n   * @group NodeMethods\n   */\n  public updateNodeData(id: ID, update: (data: N) => N): void;\n  public updateNodeData(...args: any[]): void {\n    const id: ID = args[0];\n    const node = this.getNode(id);\n    if (typeof args[1] === 'string') {\n      // id, propertyName, value\n      this.updateNodeDataProperty(id, args[1], args[2]);\n      return;\n    }\n    let data: N;\n    if (typeof args[1] === 'function') {\n      // id, update\n      const update = args[1];\n      data = update(node.data);\n    } else if (typeof args[1] === 'object') {\n      // id, data\n      data = args[1];\n    }\n    this.batch(() => {\n      const oldValue = node.data;\n      const newValue = data;\n      node.data = data;\n      this.changes.push({\n        type: 'NodeDataUpdated',\n        id,\n        oldValue,\n        newValue,\n      });\n    });\n  }\n\n  // ================= Edge =================\n  private checkEdgeExistence(id: ID): void {\n    if (!this.hasEdge(id)) {\n      throw new Error('Edge not found for id: ' + id);\n    }\n  }\n\n  /**\n   * Check if an edge exists in the graph.\n   * @group NodeMethods\n   */\n  public hasEdge(id: ID): boolean {\n    return this.edgeMap.has(id);\n  }\n\n  /**\n   * Get the edge data with given ID.\n   * @group EdgeMethods\n   */\n  public getEdge(id: ID): Edge<E> {\n    this.checkEdgeExistence(id);\n    return this.edgeMap.get(id)!;\n  }\n\n  /**\n   * Get the edge, the source node, and the target node by an edge ID.\n   * @group EdgeMethods\n   */\n  public getEdgeDetail(id: ID): {\n    edge: Edge<E>;\n    source: Node<N>;\n    target: Node<N>;\n  } {\n    const edge = this.getEdge(id);\n    return {\n      edge,\n      source: this.getNode(edge.source),\n      target: this.getNode(edge.target),\n    };\n  }\n\n  private doAddEdge(edge: Edge<E>): void {\n    if (this.hasEdge(edge.id)) {\n      throw new Error('Edge already exists: ' + edge.id);\n    }\n    this.checkNodeExistence(edge.source);\n    this.checkNodeExistence(edge.target);\n\n    this.edgeMap.set(edge.id, edge);\n    const inEdges = this.inEdgesMap.get(edge.target)!;\n    const outEdges = this.outEdgesMap.get(edge.source)!;\n    const bothEdgesOfSource = this.bothEdgesMap.get(edge.source)!;\n    const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target)!;\n    inEdges.add(edge);\n    outEdges.add(edge);\n    bothEdgesOfSource.add(edge);\n    bothEdgesOfTarget.add(edge);\n\n    this.changes.push({ type: 'EdgeAdded', value: edge });\n  }\n\n  /**\n   * Add all edges of the given iterable(an array, a set, etc.) into the graph.\n   * @group EdgeMethods\n   */\n  public addEdges(edges: Iterable<Edge<E>>): void {\n    this.batch(() => {\n      for (const edge of edges) {\n        this.doAddEdge(edge);\n      }\n    });\n  }\n\n  /**\n   * Add a single edge pointing from `source` to `target` into the graph.\n   *\n   * ```ts\n   * graph.addNode({ id: 'NodeA' });\n   * graph.addNode({ id: 'NodeB' });\n   * graph.addEdge({ id: 'EdgeA', source: 'NodeA', target: 'NodeB' });\n   * ```\n   *\n   * If `source` or `target` were not found in the current graph, it throws an Error.\n   * @group EdgeMethods\n   */\n  public addEdge(edge: Edge<E>): void {\n    this.addEdges([edge]);\n  }\n\n  private doRemoveEdge(id: ID): void {\n    const edge = this.getEdge(id);\n    const outEdges = this.outEdgesMap.get(edge.source)!;\n    const inEdges = this.inEdgesMap.get(edge.target)!;\n    const bothEdgesOfSource = this.bothEdgesMap.get(edge.source)!;\n    const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target)!;\n    outEdges.delete(edge);\n    inEdges.delete(edge);\n    bothEdgesOfSource.delete(edge);\n    bothEdgesOfTarget.delete(edge);\n    this.edgeMap.delete(id);\n    this.changes.push({ type: 'EdgeRemoved', value: edge });\n  }\n\n  /**\n   * Remove edges whose id was included in the given id list.\n   * @group EdgeMethods\n   */\n  public removeEdges(idList: ID[]): void {\n    this.batch(() => {\n      idList.forEach((id) => this.doRemoveEdge(id));\n    });\n  }\n\n  /**\n   * Remove a single edge of the given id.\n   * @group EdgeMethods\n   */\n  public removeEdge(id: ID): void {\n    this.removeEdges([id]);\n  }\n\n  /**\n   * Change the source of an edge. The source must be found in current graph.\n   * @group EdgeMethods\n   */\n  public updateEdgeSource(id: ID, source: ID): void {\n    const edge = this.getEdge(id);\n    this.checkNodeExistence(source);\n    const oldSource = edge.source;\n    const newSource = source;\n    this.outEdgesMap.get(oldSource)!.delete(edge);\n    this.bothEdgesMap.get(oldSource)!.delete(edge);\n    this.outEdgesMap.get(newSource)!.add(edge);\n    this.bothEdgesMap.get(newSource)!.add(edge);\n    edge.source = source;\n    this.batch(() => {\n      this.changes.push({\n        type: 'EdgeUpdated',\n        id,\n        propertyName: 'source',\n        oldValue: oldSource,\n        newValue: newSource,\n      });\n    });\n  }\n\n  /**\n   * Change the target of an edge. The target must be found in current graph.\n   * @group EdgeMethods\n   */\n  public updateEdgeTarget(id: ID, target: ID): void {\n    const edge = this.getEdge(id);\n    this.checkNodeExistence(target);\n    const oldTarget = edge.target;\n    const newTarget = target;\n    this.inEdgesMap.get(oldTarget)!.delete(edge);\n    this.bothEdgesMap.get(oldTarget)!.delete(edge);\n    this.inEdgesMap.get(newTarget)!.add(edge);\n    this.bothEdgesMap.get(newTarget)!.add(edge);\n    edge.target = target;\n    this.batch(() => {\n      this.changes.push({\n        type: 'EdgeUpdated',\n        id,\n        propertyName: 'target',\n        oldValue: oldTarget,\n        newValue: newTarget,\n      });\n    });\n  }\n\n  private updateEdgeDataProperty<P extends keyof E>(\n    id: ID,\n    propertyName: P,\n    value: E[P],\n  ): void {\n    const edge = this.getEdge(id);\n    this.batch(() => {\n      const oldValue = edge.data[propertyName];\n      const newValue = value;\n      edge.data[propertyName] = newValue;\n      this.changes.push({\n        type: 'EdgeDataUpdated',\n        id,\n        propertyName,\n        oldValue,\n        newValue,\n      });\n    });\n  }\n\n  /**\n   * Update edge data. This will replace the whole data object.\n   *\n   * ```ts\n   * updateEdgeData(id, data); // Works like `edge.data = data`\n   * ```\n   *\n   * @group EdgeMethods\n   */\n  public updateEdgeData(id: ID, data: E): void;\n  /**\n   * Update a single property on the edge data.\n   *\n   * To update multiple properties, you could {@link Graph.batch batch} several updates or use {@link Graph.mergeEdgeData mergeNodeData}.\n   *\n   * ```ts\n   * updateEdgeData(id, key, value); // Works like `edge.data[key] = value`\n   * ```\n   *\n   * @group EdgeMethods\n   */\n  public updateEdgeData<P extends keyof E>(\n    id: ID,\n    propertyName: P,\n    value: E[P],\n  ): void;\n  /**\n   * Update edge data by a update function.\n   *\n   * ```ts\n   * updateEdgeData(id, oldData => newData);\n   * ```\n   * @group EdgeMethods\n   */\n  public updateEdgeData(id: ID, update: (data: E) => E): void;\n  public updateEdgeData(...args: any[]): void {\n    const id: ID = args[0];\n    const edge = this.getEdge(id);\n    if (typeof args[1] === 'string') {\n      // id, propertyName, value\n      this.updateEdgeDataProperty(id, args[1], args[2]);\n      return;\n    }\n    let data: E;\n    if (typeof args[1] === 'function') {\n      // id, update\n      const update = args[1];\n      data = update(edge.data);\n    } else if (typeof args[1] === 'object') {\n      // id, data\n      data = args[1];\n    }\n    this.batch(() => {\n      const oldValue = edge.data;\n      const newValue = data;\n      edge.data = data;\n      this.changes.push({\n        type: 'EdgeDataUpdated',\n        id,\n        oldValue,\n        newValue,\n      });\n    });\n  }\n\n  /**\n   * @group EdgeMethods\n   */\n  public mergeEdgeData(id: ID, patch: Partial<E>): void {\n    this.batch(() => {\n      Object.entries(patch).forEach(([propertyName, value]) => {\n        this.updateEdgeDataProperty(id, propertyName, value);\n      });\n    });\n  }\n\n  // ================= Tree =================\n  private checkTreeExistence(treeKey: string | undefined): void {\n    if (!this.hasTreeStructure(treeKey)) {\n      throw new Error('Tree structure not found for treeKey: ' + treeKey);\n    }\n  }\n\n  public hasTreeStructure(treeKey: string | undefined): boolean {\n    return this.treeIndices.has(treeKey);\n  }\n\n  /**\n   * Attach a new tree structure representing the hierarchy of all nodes in the graph.\n   * @param treeKey A unique key of the tree structure. You can attach multiple tree structures with different keys.\n   *\n   * ```ts\n   * const graph = new Graph({\n   *   nodes: [{ id: 1 }, { id: 2 }, { id: 3 }],\n   * });\n   * graph.attachTreeStructure('Inheritance');\n   * graph.setParent(2, 1, 'Inheritance');\n   * graph.setParent(3, 1, 'Inheritance');\n   * graph.getRoots('Inheritance'); // [1]\n   * graph.getChildren(1, 'Inheritance'); // [2,3]\n   * ```\n   * @group TreeMethods\n   */\n  public attachTreeStructure(treeKey?: string): void {\n    if (this.treeIndices.has(treeKey)) {\n      // Already attached.\n      return;\n    }\n    this.treeIndices.set(treeKey, {\n      parentMap: new Map(),\n      childrenMap: new Map(),\n    });\n    this.batch(() => {\n      this.changes.push({\n        type: 'TreeStructureAttached',\n        treeKey,\n      });\n    });\n  }\n\n  /**\n   * Detach the tree structure of the given tree key from the graph.\n   *\n   * ```ts\n   * graph.detachTreeStructure('Inheritance');\n   * graph.getRoots('Inheritance'); // Error!\n   * ```\n   * @group TreeMethods\n   */\n  public detachTreeStructure(treeKey?: string): void {\n    this.checkTreeExistence(treeKey);\n    this.treeIndices.delete(treeKey);\n    this.batch(() => {\n      this.changes.push({\n        type: 'TreeStructureDetached',\n        treeKey,\n      });\n    });\n  }\n\n  /**\n   * Traverse the given tree data, add each node into the graph, then attach the tree structure.\n   *\n   * ```ts\n   * graph.addTree({\n   *   id: 1,\n   *   children: [\n   *     { id: 2 },\n   *     { id: 3 },\n   *   ],\n   * }, 'Inheritance');\n   * graph.getRoots('Inheritance'); // [1]\n   * graph.getChildren(1, 'Inheritance'); // [2, 3]\n   * graph.getAllNodes(); // [1, 2, 3]\n   * graph.getAllEdges(); // []\n   * ```\n   * @group TreeMethods\n   */\n  public addTree(tree: TreeData<N> | TreeData<N>[], treeKey?: string): void {\n    this.batch(() => {\n      this.attachTreeStructure(treeKey);\n\n      // Add Nodes\n      const nodes: TreeData<N>[] = [];\n      const stack = Array.isArray(tree) ? tree : [tree];\n      while (stack.length) {\n        const node = stack.shift()!;\n        nodes.push(node);\n        if (node.children) {\n          stack.push(...node.children);\n        }\n      }\n      this.addNodes(nodes);\n\n      // Set parent for each child node.\n      nodes.forEach((parent) => {\n        parent.children?.forEach((child) => {\n          this.setParent(child.id, parent.id, treeKey);\n        });\n      });\n    });\n  }\n\n  /**\n   * Get the root nodes of an attached tree structure.\n   *\n   * Consider a graph with the following tree structure attached:\n   * ```\n   * Tree structure:\n   *    O     3\n   *   / \\    |\n   *  1   2   4\n   * ```\n   * `graph.getRoots()` takes all nodes without a parent, therefore [0, 3] was returned.\n   *\n   * Newly added nodes are also unparented. So they are counted as roots.\n   * ```ts\n   * graph.addNode({ id: 5 });\n   * graph.getRoots(); // [0, 3, 5]\n   * ```\n   *\n   * Here is how the tree structure looks like:\n   * ```\n   * Tree structure:\n   *    O     3  5\n   *   / \\    |\n   *  1   2   4\n   * ```\n   *\n   * By setting a parent, a root node no more be a root.\n   * ```ts\n   * graph.setParent(5, 2);\n   * graph.getRoots(); // [0, 3]\n   * ```\n   *\n   * The tree structure now becomes:\n   * ```\n   * Tree structure:\n   *    O     3\n   *   / \\    |\n   *  1   2   4\n   *      |\n   *      5\n   * ```\n   *\n   * Removing a node forces its children to be unparented, or roots.\n   * ```ts\n   * graph.removeNode(0);\n   * graph.getRoots(); // [1, 2, 3]\n   * ```\n   *\n   * You might draw the the structure as follow:\n   * ```\n   * Tree structure:\n   *  1   2  3\n   *      |  |\n   *      5  4\n   * ```\n   * @group TreeMethods\n   */\n  public getRoots(treeKey?: string): Node<N>[] {\n    this.checkTreeExistence(treeKey);\n    return this.getAllNodes().filter(\n      (node) => !this.getParent(node.id, treeKey),\n    );\n  }\n\n  /**\n   * Given a node ID and an optional tree key, get the children of the node in the specified tree structure.\n   * @group TreeMethods\n   */\n  public getChildren(id: ID, treeKey?: string): Node<N>[] {\n    this.checkNodeExistence(id);\n    this.checkTreeExistence(treeKey);\n    const tree = this.treeIndices.get(treeKey)!;\n    const children = tree.childrenMap.get(id);\n    return Array.from(children || []);\n  }\n\n  /**\n   * Given a node ID and an optional tree key, get the parent of the node in the specified tree structure.\n   * If the given node is one of the tree roots, this returns null.\n   * @group TreeMethods\n   */\n  public getParent(id: ID, treeKey?: string): Node<N> | null {\n    this.checkNodeExistence(id);\n    this.checkTreeExistence(treeKey);\n    const tree = this.treeIndices.get(treeKey)!;\n    return tree.parentMap.get(id) || null;\n  }\n\n  /**\n   * Returns an array of all the ancestor nodes, staring from the parent to the root.\n   */\n  public getAncestors(id: ID, treeKey?: string): Node<N>[] {\n    const ancestors: Node<N>[] = [];\n    let current = this.getNode(id);\n    let parent: Node<N> | null;\n    // eslint-disable-next-line no-cond-assign\n    while ((parent = this.getParent(current.id, treeKey))) {\n      ancestors.push(parent);\n      current = parent;\n    }\n    return ancestors;\n  }\n\n  /**\n   * Set node parent. If this operation causes a circle, it fails with an error.\n   * @param id - ID of the child node.\n   * @param parent - ID of the parent node. If it is undefined or null, means unset parent for node with id.\n   * @param treeKey - Which tree structure the relation is applied to.\n   * @group TreeMethods\n   */\n  public setParent(id: ID, parent?: ID | null, treeKey?: string) {\n    this.checkTreeExistence(treeKey);\n\n    const tree = this.treeIndices.get(treeKey);\n\n    if (!tree) return;\n\n    const node = this.getNode(id);\n    const oldParent = tree.parentMap.get(id);\n\n    // Same parent id as old one, skip\n    if (oldParent?.id === parent) return;\n\n    // New parent is undefined or null, unset parent for the node\n    if (parent === undefined || parent === null) {\n      if (oldParent) {\n        tree.childrenMap.get(oldParent.id)?.delete(node);\n      }\n      tree.parentMap.delete(id);\n      return;\n    }\n\n    const newParent = this.getNode(parent);\n\n    // Set parent\n    tree.parentMap.set(id, newParent);\n\n    // Set children\n    if (oldParent) {\n      tree.childrenMap.get(oldParent.id)?.delete(node);\n    }\n    let children = tree.childrenMap.get(newParent.id);\n    if (!children) {\n      children = new Set();\n      tree.childrenMap.set(newParent.id, children);\n    }\n    children.add(node);\n\n    this.batch(() => {\n      this.changes.push({\n        type: 'TreeStructureChanged',\n        treeKey,\n        nodeId: id,\n        oldParentId: oldParent?.id,\n        newParentId: newParent.id,\n      });\n    });\n  }\n\n  dfsTree(id: ID, fn: (node: Node<N>) => boolean | void, treeKey?: string) {\n    const navigator = (nodeId: ID) => this.getChildren(nodeId, treeKey);\n    return doDFS(this.getNode(id), new Set(), fn, navigator);\n  }\n\n  bfsTree(id: ID, fn: (node: Node<N>) => boolean | void, treeKey?: string) {\n    const navigator = (nodeId: ID) => this.getChildren(nodeId, treeKey);\n    return doBFS([this.getNode(id)], new Set(), fn, navigator);\n  }\n\n  // ================= Graph =================\n  /**\n   * Get all nodes in the graph as an array.\n   */\n  public getAllNodes(): Node<N>[] {\n    return Array.from(this.nodeMap.values());\n  }\n\n  /**\n   * Get all edges in the graph as an array.\n   */\n  public getAllEdges(): Edge<E>[] {\n    return Array.from(this.edgeMap.values());\n  }\n\n  public bfs(\n    id: ID,\n    fn: (node: Node<N>) => boolean | void,\n    direction: 'in' | 'out' | 'both' = 'out',\n  ): boolean {\n    const navigator = {\n      in: this.getPredecessors.bind(this),\n      out: this.getSuccessors.bind(this),\n      both: this.getNeighbors.bind(this),\n    }[direction];\n    return doBFS([this.getNode(id)], new Set(), fn, navigator);\n  }\n\n  public dfs(\n    id: ID,\n    fn: (node: Node<N>) => boolean | void,\n    direction: 'in' | 'out' | 'both' = 'out',\n  ): boolean {\n    const navigator = {\n      in: this.getPredecessors.bind(this),\n      out: this.getSuccessors.bind(this),\n      both: this.getNeighbors.bind(this),\n    }[direction];\n    return doDFS(this.getNode(id), new Set(), fn, navigator);\n  }\n\n  public clone(): Graph<N, E> {\n    // Make a shallow copy of nodes and edges.\n    const newNodes = this.getAllNodes().map((oldNode) => {\n      return { ...oldNode, data: { ...oldNode.data } };\n    });\n    const newEdges = this.getAllEdges().map((oldEdge) => {\n      return { ...oldEdge, data: { ...oldEdge.data } };\n    });\n\n    // Create a new graph with shallow copied nodes and edges.\n    const newGraph = new Graph<N, E>({\n      nodes: newNodes,\n      edges: newEdges,\n    });\n\n    // Add tree indices.\n    this.treeIndices.forEach(\n      ({ parentMap: oldParentMap, childrenMap: oldChildrenMap }, treeKey) => {\n        const parentMap = new Map<ID, Node<N>>();\n        oldParentMap.forEach((parent, key) => {\n          parentMap.set(key, newGraph.getNode(parent.id));\n        });\n\n        const childrenMap = new Map<ID, Set<Node<N>>>();\n        oldChildrenMap.forEach((children, key) => {\n          childrenMap.set(\n            key,\n            new Set(Array.from(children).map((n) => newGraph.getNode(n.id))),\n          );\n        });\n\n        newGraph.treeIndices.set(treeKey, {\n          parentMap: parentMap,\n          childrenMap: childrenMap,\n        });\n      },\n    );\n\n    return newGraph;\n  }\n\n  public toJSON(): string {\n    return JSON.stringify({\n      nodes: this.getAllNodes(),\n      edges: this.getAllEdges(),\n      // FIXME: And tree structures?\n    });\n  }\n\n  public createView(\n    options: Omit<GraphViewOptions<N, E>, 'graph'>,\n  ): GraphView<N, E> {\n    return new GraphView({\n      graph: this,\n      ...options,\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}