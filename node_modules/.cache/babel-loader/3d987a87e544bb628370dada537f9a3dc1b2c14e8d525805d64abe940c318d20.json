{"ast":null,"code":"import { dfs, minBy, simplify } from '../util';\nimport { feasibleTree } from './feasible-tree';\nimport { longestPath as initRank, slack } from './util';\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nexport const networkSimplex = og => {\n  const g = simplify(og);\n  initRank(g);\n  const t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n  let e;\n  let f;\n  while (e = leaveEdge(t)) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n};\n/*\n * Initializes cut values for all edges in the tree.\n */\nexport const initCutValues = (t, g) => {\n  let vs = dfs(t, t.getAllNodes(), 'post', false);\n  vs = vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);\n  vs.forEach(v => {\n    assignCutValue(t, g, v);\n  });\n};\nconst assignCutValue = (t, g, child) => {\n  const childLab = t.getNode(child);\n  const parent = childLab.data.parent;\n  // FIXME: use undirected edge?\n  const edge = t.getRelatedEdges(child, 'both').find(e => e.target === parent || e.source === parent);\n  edge.data.cutvalue = calcCutValue(t, g, child);\n};\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nexport const calcCutValue = (t, g, child) => {\n  const childLab = t.getNode(child);\n  const parent = childLab.data.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  let childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  let graphEdge = g.getRelatedEdges(child, 'out').find(e => e.target === parent);\n  // The accumulated cut value for the edge between this node and its parent\n  let cutValue = 0;\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.getRelatedEdges(parent, 'out').find(e => e.target === child);\n  }\n  cutValue = graphEdge.data.weight;\n  g.getRelatedEdges(child, 'both').forEach(e => {\n    const isOutEdge = e.source === child;\n    const other = isOutEdge ? e.target : e.source;\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail;\n      const otherWeight = e.data.weight;\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        // FIXME: use undirected edge?\n        const otherCutValue = t.getRelatedEdges(child, 'both').find(e => e.source === other || e.target === other).data.cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n  return cutValue;\n};\nexport const initLowLimValues = (tree, root = tree.getAllNodes()[0].id) => {\n  dfsAssignLowLim(tree, {}, 1, root);\n};\nconst dfsAssignLowLim = (tree, visited, nextLim, v, parent) => {\n  var _a;\n  const low = nextLim;\n  let useNextLim = nextLim;\n  const label = tree.getNode(v);\n  visited[v] = true;\n  (_a = tree.getNeighbors(v)) === null || _a === void 0 ? void 0 : _a.forEach(w => {\n    if (!visited[w.id]) {\n      useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w.id, v);\n    }\n  });\n  label.data.low = low;\n  label.data.lim = useNextLim++;\n  if (parent) {\n    label.data.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.data.parent;\n  }\n  return useNextLim;\n};\nexport const leaveEdge = tree => {\n  return tree.getAllEdges().find(e => {\n    return e.data.cutvalue < 0;\n  });\n};\nexport const enterEdge = (t, g, edge) => {\n  let v = edge.source;\n  let w = edge.target;\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.getRelatedEdges(v, 'out').find(e => e.target === w)) {\n    v = edge.target;\n    w = edge.source;\n  }\n  const vLabel = t.getNode(v);\n  const wLabel = t.getNode(w);\n  let tailLabel = vLabel;\n  let flip = false;\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.data.lim > wLabel.data.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n  const candidates = g.getAllEdges().filter(edge => {\n    return flip === isDescendant(t.getNode(edge.source), tailLabel) && flip !== isDescendant(t.getNode(edge.target), tailLabel);\n  });\n  return minBy(candidates, edge => {\n    return slack(g, edge);\n  });\n};\n/**\n *\n * @param t\n * @param g\n * @param e edge to remove\n * @param f edge to add\n */\nexport const exchangeEdges = (t, g, e, f) => {\n  // FIXME: use undirected edge?\n  const existed = t.getRelatedEdges(e.source, 'both').find(edge => edge.source === e.target || edge.target === e.target);\n  if (existed) {\n    t.removeEdge(existed.id);\n  }\n  t.addEdge({\n    id: `e${Math.random()}`,\n    source: f.source,\n    target: f.target,\n    data: {}\n  });\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n};\nconst updateRanks = (t, g) => {\n  const root = t.getAllNodes().find(v => {\n    return !v.data.parent;\n  });\n  let vs = dfs(t, root, 'pre', false);\n  vs = vs.slice(1);\n  vs.forEach(v => {\n    const parent = t.getNode(v).data.parent;\n    let edge = g.getRelatedEdges(v, 'out').find(e => e.target === parent);\n    // let edge = g.edgeFromArgs(v, parent);\n    let flipped = false;\n    if (!edge && g.hasNode(parent)) {\n      // edge = g.edgeFromArgs(parent, v)!;\n      edge = g.getRelatedEdges(parent, 'out').find(e => e.target === v);\n      flipped = true;\n    }\n    g.getNode(v).data.rank = (g.hasNode(parent) && g.getNode(parent).data.rank || 0) + (flipped ? edge === null || edge === void 0 ? void 0 : edge.data.minlen : -(edge === null || edge === void 0 ? void 0 : edge.data.minlen));\n  });\n};\n/*\n * Returns true if the edge is in the tree.\n */\nconst isTreeEdge = (tree, u, v) => {\n  // FIXME: use undirected edge?\n  return tree.getRelatedEdges(u, 'both').find(e => e.source === v || e.target === v);\n};\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nconst isDescendant = (vLabel, rootLabel) => {\n  return rootLabel.data.low <= vLabel.data.lim && vLabel.data.lim <= rootLabel.data.lim;\n};","map":{"version":3,"names":["dfs","minBy","simplify","feasibleTree","longestPath","initRank","slack","networkSimplex","og","g","t","initLowLimValues","initCutValues","e","f","leaveEdge","enterEdge","exchangeEdges","vs","getAllNodes","slice","length","forEach","v","assignCutValue","child","childLab","getNode","parent","data","edge","getRelatedEdges","find","target","source","cutvalue","calcCutValue","childIsTail","graphEdge","cutValue","weight","isOutEdge","other","pointsToHead","otherWeight","isTreeEdge","otherCutValue","tree","root","id","dfsAssignLowLim","visited","nextLim","low","useNextLim","label","_a","getNeighbors","w","lim","getAllEdges","vLabel","wLabel","tailLabel","flip","candidates","filter","isDescendant","existed","removeEdge","addEdge","Math","random","updateRanks","flipped","hasNode","rank","minlen","u","rootLabel"],"sources":["../../../src/antv-dagre/rank/network-simplex.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}