{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Path } from '@antv/g';\nimport { Marker } from '@antv/component';\nimport { line as d3line } from '@antv/vendor/d3-shape';\nimport { isTranspose } from '../../utils/coordinate';\nimport { subObject } from '../../utils/helper';\nimport { select } from '../../utils/selection';\nimport { applyStyle } from '../utils';\nfunction inferSymbol(x, y, r) {\n  return [['M', x, y], ['L', x + 2 * r, y - r], ['L', x + 2 * r, y + r], ['Z']];\n}\n/**\n * @todo support polar later.\n */\nfunction inferConnectorPath(points) {\n  return d3line().x(d => d[0]).y(d => d[1])(points);\n}\nfunction getPoints(coordinate, points, sourceOffsetY, targetOffsetY, sourceOffsetX, targetOffsetX, length1 = 0) {\n  const [[x0, y0], [x1, y1]] = points;\n  if (isTranspose(coordinate)) {\n    const X0 = x0 + sourceOffsetY;\n    const X1 = x1 + targetOffsetY;\n    const X = X0 + length1;\n    const Y0 = y0 + sourceOffsetX;\n    const Y1 = y1 + targetOffsetX;\n    return [[X0, Y0], [X, Y0], [X, Y1], [X1, Y1]];\n  }\n  const Y0 = y0 - sourceOffsetY;\n  const Y1 = y1 - targetOffsetY;\n  const Y = Y0 - length1;\n  const X0 = x0 - sourceOffsetX;\n  const X1 = x1 - targetOffsetX;\n  return [[X0, Y0], [X0, Y], [X1, Y], [X1, Y1]];\n}\nexport const Connector = (options, context) => {\n  const {\n      offsetX = 0,\n      sourceOffsetX = offsetX,\n      targetOffsetX = offsetX,\n      offsetY = 0,\n      sourceOffsetY = offsetY,\n      targetOffsetY = offsetY,\n      connectLength1: length1,\n      endMarker = true\n    } = options,\n    style = __rest(options, [\"offsetX\", \"sourceOffsetX\", \"targetOffsetX\", \"offsetY\", \"sourceOffsetY\", \"targetOffsetY\", \"connectLength1\", \"endMarker\"]);\n  const {\n    coordinate\n  } = context;\n  return (points, value, defaults) => {\n    const {\n        color: defaultColor,\n        connectLength1\n      } = defaults,\n      rest = __rest(defaults, [\"color\", \"connectLength1\"]);\n    const {\n      color,\n      transform\n    } = value;\n    const P = getPoints(coordinate, points, sourceOffsetY, targetOffsetY, sourceOffsetX, targetOffsetX, length1 !== null && length1 !== void 0 ? length1 : connectLength1);\n    const makerStyle = subObject(Object.assign(Object.assign({}, style), defaults), 'endMarker');\n    return select(new Path()).call(applyStyle, rest).style('d', inferConnectorPath(P)).style('stroke', color || defaultColor).style('transform', transform).style('markerEnd', endMarker ? new Marker({\n      className: 'marker',\n      style: Object.assign(Object.assign({}, makerStyle), {\n        symbol: inferSymbol\n      })\n    }) : null).call(applyStyle, style).node();\n  };\n};\nConnector.props = {\n  defaultMarker: 'line',\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut'\n};","map":{"version":3,"names":["Path","Marker","line","d3line","isTranspose","subObject","select","applyStyle","inferSymbol","x","y","r","inferConnectorPath","points","d","getPoints","coordinate","sourceOffsetY","targetOffsetY","sourceOffsetX","targetOffsetX","length1","x0","y0","x1","y1","X0","X1","X","Y0","Y1","Y","Connector","options","context","offsetX","offsetY","connectLength1","endMarker","style","__rest","value","defaults","color","defaultColor","rest","transform","P","makerStyle","Object","assign","call","className","symbol","node","props","defaultMarker","defaultEnterAnimation","defaultUpdateAnimation","defaultExitAnimation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/connector/connector.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport type { PathArray } from '@antv/util';\nimport { PathStyleProps, Path } from '@antv/g';\nimport { Marker } from '@antv/component';\nimport { line as d3line } from '@antv/vendor/d3-shape';\nimport { ShapeComponent as SC, Vector2, WithPrefix } from '../../runtime';\nimport { isTranspose } from '../../utils/coordinate';\nimport { subObject } from '../../utils/helper';\nimport { select } from '../../utils/selection';\nimport { applyStyle } from '../utils';\n\nexport type ConnectorOptions = ConnectorPathStyleProps & Record<string, any>;\n\ntype MarkerStyleProps<P extends string> = WithPrefix<Record<string, any>, P>;\n\ntype ConnectorPathStyleProps = Omit<PathStyleProps, 'path'> &\n  MarkerStyleProps<'endMarker'> & {\n    connectorPath?: PathArray[];\n    endMarker?: boolean;\n  };\n\nfunction inferSymbol(x: number, y: number, r: number) {\n  return [['M', x, y], ['L', x + 2 * r, y - r], ['L', x + 2 * r, y + r], ['Z']];\n}\n\n/**\n * @todo support polar later.\n */\nfunction inferConnectorPath(points: Vector2[]) {\n  return d3line()\n    .x((d) => d[0])\n    .y((d) => d[1])(points);\n}\n\nfunction getPoints(\n  coordinate: Coordinate,\n  points: Vector2[],\n  sourceOffsetY: number,\n  targetOffsetY: number,\n  sourceOffsetX: number,\n  targetOffsetX: number,\n  length1 = 0,\n): Vector2[] {\n  const [[x0, y0], [x1, y1]] = points;\n\n  if (isTranspose(coordinate)) {\n    const X0 = x0 + sourceOffsetY;\n    const X1 = x1 + targetOffsetY;\n    const X = X0 + length1;\n    const Y0 = y0 + sourceOffsetX;\n    const Y1 = y1 + targetOffsetX;\n    return [\n      [X0, Y0],\n      [X, Y0],\n      [X, Y1],\n      [X1, Y1],\n    ];\n  }\n\n  const Y0 = y0 - sourceOffsetY;\n  const Y1 = y1 - targetOffsetY;\n  const Y = Y0 - length1;\n  const X0 = x0 - sourceOffsetX;\n  const X1 = x1 - targetOffsetX;\n  return [\n    [X0, Y0],\n    [X0, Y],\n    [X1, Y],\n    [X1, Y1],\n  ];\n}\n\nexport const Connector: SC<ConnectorOptions> = (options, context) => {\n  const {\n    offsetX = 0,\n    sourceOffsetX = offsetX,\n    targetOffsetX = offsetX,\n    offsetY = 0,\n    sourceOffsetY = offsetY,\n    targetOffsetY = offsetY,\n    connectLength1: length1,\n    endMarker = true,\n    ...style\n  } = options;\n  const { coordinate } = context;\n\n  return (points, value, defaults) => {\n    const { color: defaultColor, connectLength1, ...rest } = defaults;\n    const { color, transform } = value;\n    const P = getPoints(\n      coordinate,\n      points,\n      sourceOffsetY,\n      targetOffsetY,\n      sourceOffsetX,\n      targetOffsetX,\n      length1 ?? connectLength1,\n    );\n    const makerStyle = subObject({ ...style, ...defaults }, 'endMarker');\n\n    return select(new Path())\n      .call(applyStyle, rest)\n      .style('d', inferConnectorPath(P))\n      .style('stroke', color || defaultColor)\n      .style('transform', transform)\n      .style(\n        'markerEnd',\n        endMarker\n          ? new Marker({\n              className: 'marker',\n              style: {\n                ...makerStyle,\n                symbol: inferSymbol,\n              },\n            })\n          : null,\n      )\n      .call(applyStyle, style)\n      .node();\n  };\n};\n\nConnector.props = {\n  defaultMarker: 'line',\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut',\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}