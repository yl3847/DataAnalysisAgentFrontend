{"ast":null,"code":"import { Linear } from '@antv/scale';\nimport { isNumber, lowerFirst } from '@antv/util';\nimport { extent } from '@antv/vendor/d3-array';\nimport { indexOf } from '../utils/array';\nimport { isPolar, isTranspose } from '../utils/coordinate';\nimport { angle, angleWithQuadrant, dist, sub } from '../utils/vector';\nexport function applyStyle(selection, style) {\n  for (const [key, value] of Object.entries(style)) {\n    selection.style(key, value);\n  }\n}\n/**\n * Draw polygon path with points.\n * @param path\n * @param points\n */\nexport function appendPolygon(path, points) {\n  points.forEach((p, idx) => idx === 0 ? path.moveTo(p[0], p[1]) : path.lineTo(p[0], p[1]));\n  path.closePath();\n  return path;\n}\n/**\n * Draw arrow between `from` and `to`.\n * @param from\n * @param to\n * @returns\n */\nexport function arrowPoints(from, to, options) {\n  const {\n    arrowSize\n  } = options;\n  const size = typeof arrowSize === 'string' ? +parseFloat(arrowSize) / 100 * dist(from, to) : arrowSize;\n  // TODO Use config from style.\n  // Default arrow rotate is 30°.\n  const arrowAngle = Math.PI / 6;\n  const angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n  const arrowAngle1 = Math.PI / 2 - angle - arrowAngle;\n  const arrow1 = [to[0] - size * Math.sin(arrowAngle1), to[1] - size * Math.cos(arrowAngle1)];\n  const arrowAngle2 = angle - arrowAngle;\n  const arrow2 = [to[0] - size * Math.cos(arrowAngle2), to[1] - size * Math.sin(arrowAngle2)];\n  return [arrow1, arrow2];\n}\n/**\n * Draw arc by from -> to, with center and radius.\n * @param path\n * @param from\n * @param to\n * @param center\n * @param radius\n */\nexport function appendArc(path, from, to, center, radius) {\n  const startAngle = angle(sub(center, from)) + Math.PI;\n  const endAngle = angle(sub(center, to)) + Math.PI;\n  path.arc(center[0], center[1], radius, startAngle, endAngle, endAngle - startAngle < 0);\n  return path;\n}\n/**\n * @todo Fix wrong key point.\n */\nexport function computeGradient(C, X, Y, from = 'y', mode = 'between', tpShape = false) {\n  // The angles of gradients rendering are varies when 'from' and 'tpShape' are different.\n  const getTheta = (from, tpShape) => {\n    if (from === 'y' || from === true) {\n      if (tpShape) {\n        return 180;\n      } else {\n        return 90;\n      }\n    } else {\n      if (tpShape) {\n        return 90;\n      } else {\n        return 0;\n      }\n    }\n  };\n  const P = from === 'y' || from === true ? Y : X;\n  const theta = getTheta(from, tpShape);\n  const I = indexOf(P);\n  const [min, max] = extent(I, i => P[i]);\n  // This need to improve for non-uniform distributed colors.\n  const p = new Linear({\n    domain: [min, max],\n    range: [0, 100]\n  });\n  const percentage = i => isNumber(P[i]) && !Number.isNaN(P[i]) ? p.map(P[i]) : 0;\n  const gradientMode = {\n    // Interpolate the colors for this segment.\n    between: i => `${C[i]} ${percentage(i)}%`,\n    // Use the color of the start point as the color for this segment.\n    start: i => i === 0 ? `${C[i]} ${percentage(i)}%` : `${C[i - 1]} ${percentage(i)}%, ${C[i]} ${percentage(i)}%`,\n    // Use the color of the end point as the color for this segment.\n    end: i => i === C.length - 1 ? `${C[i]} ${percentage(i)}%` : `${C[i]} ${percentage(i)}%, ${C[i + 1]} ${percentage(i)}%`\n  };\n  const gradient = I.sort((a, b) => percentage(a) - percentage(b)).map(gradientMode[mode] || gradientMode['between']).join(',');\n  return `linear-gradient(${theta}deg, ${gradient})`;\n}\nexport function reorder(points) {\n  const [p0, p1, p2, p3] = points;\n  return [p3, p0, p1, p2];\n}\nexport function getArcObject(coordinate, points, Y) {\n  const [p0, p1,, p3] = isTranspose(coordinate) ? reorder(points) : points;\n  const [y, y1] = Y;\n  const center = coordinate.getCenter();\n  const a1 = angleWithQuadrant(sub(p0, center));\n  const a2 = angleWithQuadrant(sub(p1, center));\n  // There are two situations that a2 === a1:\n  // 1. a1 - a2 = 0\n  // 2. |a1 - a2| = Math.PI * 2\n  // Distinguish them by y and y1:\n  const a3 = a2 === a1 && y !== y1 ? a2 + Math.PI * 2 : a2;\n  const epsilon = 1e-4;\n  return {\n    startAngle: a1 + epsilon,\n    endAngle: (a3 - a1 >= 0 ? a3 : Math.PI * 2 + a3) - epsilon,\n    innerRadius: dist(p3, center),\n    outerRadius: dist(p0, center)\n  };\n}\n/**\n * Pick connectStyle from style.\n * @param style\n */\nexport function getConnectStyle(style) {\n  const PREFIX = 'connect';\n  return Object.fromEntries(Object.entries(style).filter(([key]) => key.startsWith(PREFIX)).map(([key, value]) => [lowerFirst(key.replace(PREFIX, '').trim()), value]).filter(([key]) => key !== undefined));\n}\nexport function toOpacityKey(options) {\n  const {\n    colorAttribute,\n    opacityAttribute = colorAttribute\n  } = options;\n  return `${opacityAttribute}Opacity`;\n}\nexport function getTransform(coordinate, value) {\n  if (!isPolar(coordinate)) return '';\n  const center = coordinate.getCenter();\n  const {\n    transform: suffix\n  } = value;\n  return `translate(${center[0]}, ${center[1]}) ${suffix || ''}`;\n}\nexport function getOrigin(points) {\n  if (points.length === 1) return points[0];\n  const [[x0, y0, z0 = 0], [x2, y2, z2 = 0]] = points;\n  return [(x0 + x2) / 2, (y0 + y2) / 2, (z0 + z2) / 2];\n}","map":{"version":3,"names":["Linear","isNumber","lowerFirst","extent","indexOf","isPolar","isTranspose","angle","angleWithQuadrant","dist","sub","applyStyle","selection","style","key","value","Object","entries","appendPolygon","path","points","forEach","p","idx","moveTo","lineTo","closePath","arrowPoints","from","to","options","arrowSize","size","parseFloat","arrowAngle","Math","PI","atan2","arrowAngle1","arrow1","sin","cos","arrowAngle2","arrow2","appendArc","center","radius","startAngle","endAngle","arc","computeGradient","C","X","Y","mode","tpShape","getTheta","P","theta","I","min","max","i","domain","range","percentage","Number","isNaN","map","gradientMode","between","start","end","length","gradient","sort","a","b","join","reorder","p0","p1","p2","p3","getArcObject","coordinate","y","y1","getCenter","a1","a2","a3","epsilon","innerRadius","outerRadius","getConnectStyle","PREFIX","fromEntries","filter","startsWith","replace","trim","undefined","toOpacityKey","colorAttribute","opacityAttribute","getTransform","transform","suffix","getOrigin","x0","y0","z0","x2","y2","z2"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/utils.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { Linear } from '@antv/scale';\nimport { isNumber, lowerFirst } from '@antv/util';\nimport { extent } from '@antv/vendor/d3-array';\nimport { Path as D3Path } from '@antv/vendor/d3-path';\nimport { Primitive, Vector2, Vector3 } from '../runtime';\nimport { indexOf } from '../utils/array';\nimport { isPolar, isTranspose } from '../utils/coordinate';\nimport { G2Element, Selection } from '../utils/selection';\nimport { angle, angleWithQuadrant, dist, sub } from '../utils/vector';\n\nexport function applyStyle(\n  selection: Selection,\n  style: Record<string, Primitive>,\n) {\n  for (const [key, value] of Object.entries(style)) {\n    selection.style(key, value);\n  }\n}\n\n/**\n * Draw polygon path with points.\n * @param path\n * @param points\n */\nexport function appendPolygon(path: D3Path, points: Vector2[]) {\n  points.forEach((p, idx) =>\n    idx === 0 ? path.moveTo(p[0], p[1]) : path.lineTo(p[0], p[1]),\n  );\n  path.closePath();\n  return path;\n}\n\nexport type ArrowOptions = {\n  /**\n   * Whether show arrow of line.\n   */\n  arrow?: boolean;\n  /**\n   * Arrow size, can be a px number, or a percentage string. Default: '40%'\n   */\n  arrowSize?: number | string;\n};\n\n/**\n * Draw arrow between `from` and `to`.\n * @param from\n * @param to\n * @returns\n */\nexport function arrowPoints(\n  from: Vector2,\n  to: Vector2,\n  options: ArrowOptions,\n): [Vector2, Vector2] {\n  const { arrowSize } = options;\n  const size =\n    typeof arrowSize === 'string'\n      ? (+parseFloat(arrowSize) / 100) * dist(from, to)\n      : arrowSize;\n  // TODO Use config from style.\n  // Default arrow rotate is 30°.\n  const arrowAngle = Math.PI / 6;\n\n  const angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n\n  const arrowAngle1 = Math.PI / 2 - angle - arrowAngle;\n  const arrow1: Vector2 = [\n    to[0] - size * Math.sin(arrowAngle1),\n    to[1] - size * Math.cos(arrowAngle1),\n  ];\n\n  const arrowAngle2 = angle - arrowAngle;\n  const arrow2: Vector2 = [\n    to[0] - size * Math.cos(arrowAngle2),\n    to[1] - size * Math.sin(arrowAngle2),\n  ];\n\n  return [arrow1, arrow2];\n}\n\n/**\n * Draw arc by from -> to, with center and radius.\n * @param path\n * @param from\n * @param to\n * @param center\n * @param radius\n */\nexport function appendArc(\n  path: D3Path,\n  from: Vector2,\n  to: Vector2,\n  center: Vector2,\n  radius: number,\n) {\n  const startAngle = angle(sub(center, from)) + Math.PI;\n  const endAngle = angle(sub(center, to)) + Math.PI;\n\n  path.arc(\n    center[0],\n    center[1],\n    radius,\n    startAngle,\n    endAngle,\n    endAngle - startAngle < 0,\n  );\n\n  return path;\n}\n\n/**\n * @todo Fix wrong key point.\n */\nexport function computeGradient(\n  C: string[],\n  X: number[],\n  Y: number[],\n  from: string | boolean = 'y',\n  mode: 'between' | 'start' | 'end' = 'between',\n  tpShape = false,\n): string {\n  // The angles of gradients rendering are varies when 'from' and 'tpShape' are different.\n  const getTheta = (from: string | boolean, tpShape: boolean) => {\n    if (from === 'y' || from === true) {\n      if (tpShape) {\n        return 180;\n      } else {\n        return 90;\n      }\n    } else {\n      if (tpShape) {\n        return 90;\n      } else {\n        return 0;\n      }\n    }\n  };\n\n  const P = from === 'y' || from === true ? Y : X;\n  const theta = getTheta(from, tpShape);\n  const I = indexOf(P);\n\n  const [min, max] = extent(I, (i) => P[i]);\n  // This need to improve for non-uniform distributed colors.\n  const p = new Linear({\n    domain: [min, max],\n    range: [0, 100],\n  });\n\n  const percentage = (i) =>\n    isNumber(P[i]) && !Number.isNaN(P[i]) ? p.map(P[i]) : 0;\n\n  const gradientMode = {\n    // Interpolate the colors for this segment.\n    between: (i: number) => `${C[i]} ${percentage(i)}%`,\n    // Use the color of the start point as the color for this segment.\n    start: (i: number) =>\n      i === 0\n        ? `${C[i]} ${percentage(i)}%`\n        : `${C[i - 1]} ${percentage(i)}%, ${C[i]} ${percentage(i)}%`,\n    // Use the color of the end point as the color for this segment.\n    end: (i: number) =>\n      i === C.length - 1\n        ? `${C[i]} ${percentage(i)}%`\n        : `${C[i]} ${percentage(i)}%, ${C[i + 1]} ${percentage(i)}%`,\n  };\n\n  const gradient = I.sort((a, b) => percentage(a) - percentage(b))\n    .map(gradientMode[mode] || gradientMode['between'])\n    .join(',');\n  return `linear-gradient(${theta}deg, ${gradient})`;\n}\n\nexport function reorder(points: Vector2[]): Vector2[] {\n  const [p0, p1, p2, p3] = points;\n  return [p3, p0, p1, p2];\n}\n\nexport function getArcObject(\n  coordinate: Coordinate,\n  points: Vector2[],\n  Y: [number, number],\n) {\n  const [p0, p1, , p3] = isTranspose(coordinate) ? reorder(points) : points;\n\n  const [y, y1] = Y;\n  const center = coordinate.getCenter() as Vector2;\n  const a1 = angleWithQuadrant(sub(p0, center));\n  const a2 = angleWithQuadrant(sub(p1, center));\n  // There are two situations that a2 === a1:\n  // 1. a1 - a2 = 0\n  // 2. |a1 - a2| = Math.PI * 2\n  // Distinguish them by y and y1:\n  const a3 = a2 === a1 && y !== y1 ? a2 + Math.PI * 2 : a2;\n  const epsilon = 1e-4;\n  return {\n    startAngle: a1 + epsilon,\n    endAngle: (a3 - a1 >= 0 ? a3 : Math.PI * 2 + a3) - epsilon,\n    innerRadius: dist(p3, center),\n    outerRadius: dist(p0, center),\n  };\n}\n\n/**\n * Pick connectStyle from style.\n * @param style\n */\nexport function getConnectStyle(\n  style: Record<string, any>,\n): Record<string, any> {\n  const PREFIX = 'connect';\n  return Object.fromEntries(\n    Object.entries(style)\n      .filter(([key]) => key.startsWith(PREFIX))\n      .map(([key, value]) => [\n        lowerFirst(key.replace(PREFIX, '').trim()),\n        value,\n      ])\n      .filter(([key]) => key !== undefined),\n  );\n}\n\nexport function toOpacityKey(options) {\n  const { colorAttribute, opacityAttribute = colorAttribute } = options;\n  return `${opacityAttribute}Opacity`;\n}\n\nexport function getTransform(coordinate, value) {\n  if (!isPolar(coordinate)) return '';\n  const center = coordinate.getCenter() as Vector2;\n  const { transform: suffix } = value;\n  return `translate(${center[0]}, ${center[1]}) ${suffix || ''}`;\n}\n\nexport function getOrigin(points: (Vector2 | Vector3)[]) {\n  if (points.length === 1) return points[0];\n  const [[x0, y0, z0 = 0], [x2, y2, z2 = 0]] = points;\n  return [(x0 + x2) / 2, (y0 + y2) / 2, (z0 + z2) / 2];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}