{"ast":null,"code":"const cloudRadians = Math.PI / 180,\n  cw = 1 << 11 >> 5,\n  ch = 1 << 11;\nfunction cloudText(d) {\n  return d.text;\n}\nfunction cloudFont() {\n  return 'serif';\n}\nfunction cloudFontNormal() {\n  return 'normal';\n}\nfunction cloudFontSize(d) {\n  return d.value;\n}\nfunction cloudRotate() {\n  return ~~(Math.random() * 2) * 90;\n}\nfunction cloudPadding() {\n  return 1;\n}\nfunction cloudDispatch() {\n  return;\n}\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  const c = contextAndRatio.context,\n    ratio = contextAndRatio.ratio;\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  let x = 0,\n    y = 0,\n    maxh = 0;\n  const n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\n    let w = c.measureText(d.text + 'm').width * ratio,\n      h = d.size << 1;\n    if (d.rotate) {\n      const sr = Math.sin(d.rotate * cloudRadians),\n        cr = Math.cos(d.rotate * cloudRadians),\n        wcr = w * cr,\n        wsr = w * sr,\n        hcr = h * cr,\n        hsr = h * sr;\n      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = w + 0x1f >> 5 << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= cw << 5) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n    if (d.padding) {\n      c.lineWidth = 2 * d.padding;\n      c.strokeText(d.text, 0, 0);\n    }\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  const pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n    sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    const w = d.width,\n      w32 = w >> 5;\n    let h = d.y1 - d.y0;\n    // Zero the buffer\n    for (let i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    let seen = 0,\n      seenRow = -1;\n    for (let j = 0; j < h; j++) {\n      for (let i = 0; i < w; i++) {\n        const k = w32 * j + (i >> 5),\n          m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  const sprite = tag.sprite,\n    w = tag.width >> 5,\n    lx = tag.x - (w << 4),\n    sx = lx & 0x7f,\n    msx = 32 - sx,\n    h = tag.y1 - tag.y0;\n  let x = (tag.y + tag.y0) * sw + (lx >> 5),\n    last;\n  for (let j = 0; j < h; j++) {\n    last = 0;\n    for (let i = 0; i <= w; i++) {\n      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;\n    }\n    x += sw;\n  }\n  return false;\n}\nfunction cloudBounds(bounds, d) {\n  const b0 = bounds[0],\n    b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\nfunction archimedeanSpiral(size) {\n  const e = size[0] / size[1];\n  return function (t) {\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\nfunction rectangularSpiral(size) {\n  const dy = 4,\n    dx = dy * size[0] / size[1];\n  let x = 0,\n    y = 0;\n  return function (t) {\n    const sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {\n      case 0:\n        x += dx;\n        break;\n      case 1:\n        y += dy;\n        break;\n      case 2:\n        x -= dx;\n        break;\n      default:\n        y -= dy;\n        break;\n    }\n    return [x, y];\n  };\n}\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  const a = [];\n  let i = -1;\n  while (++i < n) a[i] = 0;\n  return a;\n}\nfunction cloudCanvas() {\n  return document.createElement('canvas');\n}\nfunction functor(d) {\n  return typeof d === 'function' ? d : function () {\n    return d;\n  };\n}\nconst spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\nexport function tagCloud() {\n  let size = [256, 256],\n    text = cloudText,\n    font = cloudFont,\n    fontSize = cloudFontSize,\n    fontWeight = cloudFontNormal,\n    rotate = cloudRotate,\n    padding = cloudPadding,\n    spiral = archimedeanSpiral,\n    random = Math.random,\n    event = cloudDispatch,\n    words = [],\n    timer = null,\n    timeInterval = Infinity,\n    canvas = cloudCanvas;\n  const fontStyle = cloudFontNormal;\n  const cloud = {};\n  cloud.start = function () {\n    const [width, height] = size;\n    const contextAndRatio = getContext(canvas()),\n      board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\n      n = words.length,\n      tags = [],\n      data = words.map(function (d, i, data) {\n        d.text = text.call(this, d, i, data);\n        d.font = font.call(this, d, i, data);\n        d.style = fontStyle.call(this, d, i, data);\n        d.weight = fontWeight.call(this, d, i, data);\n        d.rotate = rotate.call(this, d, i, data);\n        d.size = ~~fontSize.call(this, d, i, data);\n        d.padding = padding.call(this, d, i, data);\n        return d;\n      }).sort(function (a, b) {\n        return b.size - a.size;\n      });\n    let i = -1,\n      bounds = !cloud.board ? undefined : [{\n        x: 0,\n        y: 0\n      }, {\n        x: width,\n        y: height\n      }];\n    if (timer) clearInterval(timer);\n    timer = setInterval(step, 0);\n    step();\n    function step() {\n      const start = Date.now();\n      while (Date.now() - start < timeInterval && ++i < n) {\n        const d = data[i];\n        d.x = width * (random() + 0.5) >> 1;\n        d.y = height * (random() + 0.5) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          event.call(null, 'word', {\n            cloud,\n            word: d\n          });\n          tags.push(d);\n          if (bounds) {\n            if (!cloud.hasImage) {\n              // update bounds if image mask not set\n              cloudBounds(bounds, d);\n            }\n          } else {\n            bounds = [{\n              x: d.x + d.x0,\n              y: d.y + d.y0\n            }, {\n              x: d.x + d.x1,\n              y: d.y + d.y1\n            }];\n          }\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n      cloud._tags = tags;\n      cloud._bounds = bounds;\n      if (i >= n) {\n        cloud.stop();\n        event.call(null, 'end', {\n          cloud,\n          words: tags,\n          bounds\n        });\n      }\n    }\n    return cloud;\n  };\n  cloud.stop = function () {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n    return cloud;\n  };\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    const ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n    const context = canvas.getContext('2d');\n    context.fillStyle = context.strokeStyle = 'red';\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    return {\n      context,\n      ratio\n    };\n  }\n  function place(board, tag, bounds) {\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n    const startX = tag.x,\n      startY = tag.y,\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n      s = spiral(size),\n      dt = random() < 0.5 ? 1 : -1;\n    let dxdy,\n      t = -dt,\n      dx,\n      dy;\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          const sprite = tag.sprite,\n            w = tag.width >> 5,\n            sw = size[0] >> 5,\n            lx = tag.x - (w << 4),\n            sx = lx & 0x7f,\n            msx = 32 - sx,\n            h = tag.y1 - tag.y0;\n          let last,\n            x = (tag.y + tag.y0) * sw + (lx >> 5);\n          for (let j = 0; j < h; j++) {\n            last = 0;\n            for (let i = 0; i <= w; i++) {\n              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  cloud.createMask = img => {\n    const can = document.createElement('canvas');\n    const [width, height] = size;\n    // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\n    if (!width || !height) {\n      return;\n    }\n    const w32 = width >> 5;\n    const board = zeroArray((width >> 5) * height);\n    can.width = width;\n    can.height = height;\n    const cxt = can.getContext('2d');\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n    const imageData = cxt.getImageData(0, 0, width, height).data;\n    for (let j = 0; j < height; j++) {\n      for (let i = 0; i < width; i++) {\n        const k = w32 * j + (i >> 5);\n        const tmp = j * width + i << 2;\n        const flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\n        const m = flag ? 1 << 31 - i % 32 : 0;\n        board[k] |= m;\n      }\n    }\n    cloud.board = board;\n    cloud.hasImage = true;\n  };\n  cloud.timeInterval = function (_) {\n    timeInterval = _ == null ? Infinity : _;\n  };\n  cloud.words = function (_) {\n    words = _;\n  };\n  cloud.size = function (_ = []) {\n    size = [+_[0], +_[1]];\n  };\n  cloud.text = function (_) {\n    text = functor(_);\n  };\n  cloud.font = function (_) {\n    font = functor(_);\n  };\n  cloud.fontWeight = function (_) {\n    fontWeight = functor(_);\n  };\n  cloud.rotate = function (_) {\n    rotate = functor(_);\n  };\n  cloud.canvas = function (_) {\n    canvas = functor(_);\n  };\n  cloud.spiral = function (_) {\n    spiral = spirals[_] || _;\n  };\n  cloud.fontSize = function (_) {\n    fontSize = functor(_);\n  };\n  cloud.padding = function (_) {\n    padding = functor(_);\n  };\n  cloud.random = function (_) {\n    random = functor(_);\n  };\n  cloud.on = function (_) {\n    event = functor(_);\n  };\n  return cloud;\n}","map":{"version":3,"names":["cloudRadians","Math","PI","cw","ch","cloudText","d","text","cloudFont","cloudFontNormal","cloudFontSize","value","cloudRotate","random","cloudPadding","cloudDispatch","cloudSprite","contextAndRatio","data","di","sprite","c","context","ratio","clearRect","x","y","maxh","n","length","save","font","style","weight","size","w","measureText","width","h","rotate","sr","sin","cr","cos","wcr","wsr","hcr","hsr","max","abs","translate","fillText","padding","lineWidth","strokeText","restore","height","xoff","yoff","x1","y1","x0","y0","hasText","pixels","getImageData","w32","i","seen","seenRow","j","k","m","slice","cloudCollide","tag","board","sw","lx","sx","msx","last","cloudBounds","bounds","b0","b1","collideRects","a","b","archimedeanSpiral","e","t","rectangularSpiral","dy","dx","sign","sqrt","zeroArray","cloudCanvas","document","createElement","functor","spirals","archimedean","rectangular","tagCloud","fontSize","fontWeight","spiral","event","words","timer","timeInterval","Infinity","canvas","fontStyle","cloud","start","getContext","tags","map","call","sort","undefined","clearInterval","setInterval","step","Date","now","place","word","push","hasImage","_tags","_bounds","stop","fillStyle","strokeStyle","textAlign","textBaseline","startX","startY","maxDelta","s","dt","dxdy","min","createMask","img","can","cxt","drawImage","imageData","tmp","flag","_","on"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/data/utils/d3-cloud/index.ts"],"sourcesContent":["/*\n * Synchronous version of d3-cloud\n * Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n * Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n */\ninterface Item {\n  value: number;\n  text: string;\n  sprite: boolean;\n}\n\nconst cloudRadians = Math.PI / 180,\n  cw = (1 << 11) >> 5,\n  ch = 1 << 11;\n\nfunction cloudText(d: Item) {\n  return d.text;\n}\n\nfunction cloudFont() {\n  return 'serif';\n}\n\nfunction cloudFontNormal() {\n  return 'normal';\n}\n\nfunction cloudFontSize(d: Item) {\n  return d.value;\n}\n\nfunction cloudRotate() {\n  return ~~(Math.random() * 2) * 90;\n}\n\nfunction cloudPadding() {\n  return 1;\n}\n\nfunction cloudDispatch() {\n  return;\n}\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  const c = contextAndRatio.context,\n    ratio = contextAndRatio.ratio;\n\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  let x = 0,\n    y = 0,\n    maxh = 0;\n  const n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font =\n      d.style +\n      ' ' +\n      d.weight +\n      ' ' +\n      ~~((d.size + 1) / ratio) +\n      'px ' +\n      d.font;\n    let w = c.measureText(d.text + 'm').width * ratio,\n      h = d.size << 1;\n    if (d.rotate) {\n      const sr = Math.sin(d.rotate * cloudRadians),\n        cr = Math.cos(d.rotate * cloudRadians),\n        wcr = w * cr,\n        wsr = w * sr,\n        hcr = h * cr,\n        hsr = h * sr;\n      w =\n        ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5) << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = ((w + 0x1f) >> 5) << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= cw << 5) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n    if (d.padding) {\n      c.lineWidth = 2 * d.padding;\n      c.strokeText(d.text, 0, 0);\n    }\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  const pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n    sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    const w = d.width,\n      w32 = w >> 5;\n    let h = d.y1 - d.y0;\n    // Zero the buffer\n    for (let i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    let seen = 0,\n      seenRow = -1;\n    for (let j = 0; j < h; j++) {\n      for (let i = 0; i < w; i++) {\n        const k = w32 * j + (i >> 5),\n          m = pixels[((y + j) * (cw << 5) + (x + i)) << 2]\n            ? 1 << (31 - (i % 32))\n            : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;\n      else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  const sprite = tag.sprite,\n    w = tag.width >> 5,\n    lx = tag.x - (w << 4),\n    sx = lx & 0x7f,\n    msx = 32 - sx,\n    h = tag.y1 - tag.y0;\n  let x = (tag.y + tag.y0) * sw + (lx >> 5),\n    last;\n  for (let j = 0; j < h; j++) {\n    last = 0;\n    for (let i = 0; i <= w; i++) {\n      if (\n        ((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) &\n        board[x + i]\n      )\n        return true;\n    }\n    x += sw;\n  }\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  const b0 = bounds[0],\n    b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return (\n    a.x + a.x1 > b[0].x &&\n    a.x + a.x0 < b[1].x &&\n    a.y + a.y1 > b[0].y &&\n    a.y + a.y0 < b[1].y\n  );\n}\n\nfunction archimedeanSpiral(size) {\n  const e = size[0] / size[1];\n  return function (t) {\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  const dy = 4,\n    dx = (dy * size[0]) / size[1];\n  let x = 0,\n    y = 0;\n  return function (t) {\n    const sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n      case 0:\n        x += dx;\n        break;\n      case 1:\n        y += dy;\n        break;\n      case 2:\n        x -= dx;\n        break;\n      default:\n        y -= dy;\n        break;\n    }\n    return [x, y];\n  };\n}\n\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  const a = [];\n  let i = -1;\n  while (++i < n) a[i] = 0;\n  return a;\n}\n\nfunction cloudCanvas() {\n  return document.createElement('canvas');\n}\n\nfunction functor(d) {\n  return typeof d === 'function'\n    ? d\n    : function () {\n        return d;\n      };\n}\n\nconst spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral,\n};\n\nexport function tagCloud() {\n  let size = [256, 256],\n    text = cloudText,\n    font = cloudFont,\n    fontSize = cloudFontSize,\n    fontWeight = cloudFontNormal,\n    rotate = cloudRotate,\n    padding = cloudPadding,\n    spiral = archimedeanSpiral,\n    random = Math.random,\n    event = cloudDispatch,\n    words = [],\n    timer = null,\n    timeInterval = Infinity,\n    canvas = cloudCanvas;\n\n  const fontStyle = cloudFontNormal;\n  const cloud: any = {};\n\n  cloud.start = function () {\n    const [width, height] = size;\n    const contextAndRatio = getContext(canvas()),\n      board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\n      n = words.length,\n      tags = [],\n      data = words\n        .map(function (d, i, data) {\n          d.text = text.call(this, d, i, data);\n          d.font = font.call(this, d, i, data);\n          d.style = fontStyle.call(this, d, i, data);\n          d.weight = fontWeight.call(this, d, i, data);\n          d.rotate = rotate.call(this, d, i, data);\n          d.size = ~~fontSize.call(this, d, i, data);\n          d.padding = padding.call(this, d, i, data);\n          return d;\n        })\n        .sort(function (a, b) {\n          return b.size - a.size;\n        });\n    let i = -1,\n      bounds = !cloud.board\n        ? undefined\n        : [\n            {\n              x: 0,\n              y: 0,\n            },\n            {\n              x: width,\n              y: height,\n            },\n          ];\n\n    if (timer) clearInterval(timer);\n    timer = setInterval(step, 0);\n    step();\n\n    function step() {\n      const start = Date.now();\n      while (Date.now() - start < timeInterval && ++i < n) {\n        const d = data[i];\n        d.x = (width * (random() + 0.5)) >> 1;\n        d.y = (height * (random() + 0.5)) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          event.call(null, 'word', { cloud, word: d });\n          tags.push(d);\n          if (bounds) {\n            if (!cloud.hasImage) {\n              // update bounds if image mask not set\n              cloudBounds(bounds, d);\n            }\n          } else {\n            bounds = [\n              { x: d.x + d.x0, y: d.y + d.y0 },\n              { x: d.x + d.x1, y: d.y + d.y1 },\n            ];\n          }\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n      cloud._tags = tags;\n      cloud._bounds = bounds;\n\n      if (i >= n) {\n        cloud.stop();\n        event.call(null, 'end', { cloud, words: tags, bounds });\n      }\n    }\n\n    return cloud;\n  };\n\n  cloud.stop = function () {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n    return cloud;\n  };\n\n  function getContext(canvas: HTMLCanvasElement) {\n    canvas.width = canvas.height = 1;\n    const ratio = Math.sqrt(\n      canvas.getContext('2d')!.getImageData(0, 0, 1, 1).data.length >> 2,\n    );\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n\n    const context = canvas.getContext('2d') as CanvasRenderingContext2D;\n    context.fillStyle = context.strokeStyle = 'red';\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    return { context, ratio };\n  }\n\n  function place(board, tag, bounds) {\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n    const startX = tag.x,\n      startY = tag.y,\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n      s = spiral(size),\n      dt = random() < 0.5 ? 1 : -1;\n    let dxdy,\n      t = -dt,\n      dx,\n      dy;\n\n    while ((dxdy = s((t += dt)))) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n\n      if (\n        tag.x + tag.x0 < 0 ||\n        tag.y + tag.y0 < 0 ||\n        tag.x + tag.x1 > size[0] ||\n        tag.y + tag.y1 > size[1]\n      )\n        continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          const sprite = tag.sprite,\n            w = tag.width >> 5,\n            sw = size[0] >> 5,\n            lx = tag.x - (w << 4),\n            sx = lx & 0x7f,\n            msx = 32 - sx,\n            h = tag.y1 - tag.y0;\n          let last,\n            x = (tag.y + tag.y0) * sw + (lx >> 5);\n          for (let j = 0; j < h; j++) {\n            last = 0;\n            for (let i = 0; i <= w; i++) {\n              board[x + i] |=\n                (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  cloud.createMask = (img: HTMLImageElement) => {\n    const can: HTMLCanvasElement = document.createElement('canvas');\n    const [width, height] = size;\n\n    // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\n    if (!width || !height) {\n      return;\n    }\n    const w32 = width >> 5;\n    const board = zeroArray((width >> 5) * height);\n    can.width = width;\n    can.height = height;\n    const cxt = can.getContext('2d') as CanvasRenderingContext2D;\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n    const imageData = cxt.getImageData(0, 0, width, height).data;\n    for (let j = 0; j < height; j++) {\n      for (let i = 0; i < width; i++) {\n        const k = w32 * j + (i >> 5);\n        const tmp = (j * width + i) << 2;\n        const flag =\n          imageData[tmp] >= 250 &&\n          imageData[tmp + 1] >= 250 &&\n          imageData[tmp + 2] >= 250;\n        const m = flag ? 1 << (31 - (i % 32)) : 0;\n        board[k] |= m;\n      }\n    }\n    cloud.board = board;\n    cloud.hasImage = true;\n  };\n\n  cloud.timeInterval = function (_) {\n    timeInterval = _ == null ? Infinity : _;\n  };\n\n  cloud.words = function (_) {\n    words = _;\n  };\n\n  cloud.size = function (_ = []) {\n    size = [+_[0], +_[1]];\n  };\n\n  cloud.text = function (_) {\n    text = functor(_);\n  };\n\n  cloud.font = function (_) {\n    font = functor(_);\n  };\n\n  cloud.fontWeight = function (_) {\n    fontWeight = functor(_);\n  };\n\n  cloud.rotate = function (_) {\n    rotate = functor(_);\n  };\n\n  cloud.canvas = function (_) {\n    canvas = functor(_);\n  };\n\n  cloud.spiral = function (_) {\n    spiral = spirals[_] || _;\n  };\n\n  cloud.fontSize = function (_) {\n    fontSize = functor(_);\n  };\n\n  cloud.padding = function (_) {\n    padding = functor(_);\n  };\n\n  cloud.random = function (_) {\n    random = functor(_);\n  };\n\n  cloud.on = function (_) {\n    event = functor(_);\n  };\n\n  return cloud;\n}\n"],"mappings":"AAWA,MAAMA,YAAY,GAAGC,IAAI,CAACC,EAAE,GAAG,GAAG;EAChCC,EAAE,GAAI,CAAC,IAAI,EAAE,IAAK,CAAC;EACnBC,EAAE,GAAG,CAAC,IAAI,EAAE;AAEd,SAASC,SAASA,CAACC,CAAO;EACxB,OAAOA,CAAC,CAACC,IAAI;AACf;AAEA,SAASC,SAASA,CAAA;EAChB,OAAO,OAAO;AAChB;AAEA,SAASC,eAAeA,CAAA;EACtB,OAAO,QAAQ;AACjB;AAEA,SAASC,aAAaA,CAACJ,CAAO;EAC5B,OAAOA,CAAC,CAACK,KAAK;AAChB;AAEA,SAASC,WAAWA,CAAA;EAClB,OAAO,CAAC,EAAEX,IAAI,CAACY,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE;AACnC;AAEA,SAASC,YAAYA,CAAA;EACnB,OAAO,CAAC;AACV;AAEA,SAASC,aAAaA,CAAA;EACpB;AACF;AACA;AACA;AACA,SAASC,WAAWA,CAACC,eAAe,EAAEX,CAAC,EAAEY,IAAI,EAAEC,EAAE;EAC/C,IAAIb,CAAC,CAACc,MAAM,EAAE;EACd,MAAMC,CAAC,GAAGJ,eAAe,CAACK,OAAO;IAC/BC,KAAK,GAAGN,eAAe,CAACM,KAAK;EAE/BF,CAAC,CAACG,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAACrB,EAAE,IAAI,CAAC,IAAIoB,KAAK,EAAEnB,EAAE,GAAGmB,KAAK,CAAC;EAChD,IAAIE,CAAC,GAAG,CAAC;IACPC,CAAC,GAAG,CAAC;IACLC,IAAI,GAAG,CAAC;EACV,MAAMC,CAAC,GAAGV,IAAI,CAACW,MAAM;EACrB,EAAEV,EAAE;EACJ,OAAO,EAAEA,EAAE,GAAGS,CAAC,EAAE;IACftB,CAAC,GAAGY,IAAI,CAACC,EAAE,CAAC;IACZE,CAAC,CAACS,IAAI,EAAE;IACRT,CAAC,CAACU,IAAI,GACJzB,CAAC,CAAC0B,KAAK,GACP,GAAG,GACH1B,CAAC,CAAC2B,MAAM,GACR,GAAG,GACH,CAAC,EAAE,CAAC3B,CAAC,CAAC4B,IAAI,GAAG,CAAC,IAAIX,KAAK,CAAC,GACxB,KAAK,GACLjB,CAAC,CAACyB,IAAI;IACR,IAAII,CAAC,GAAGd,CAAC,CAACe,WAAW,CAAC9B,CAAC,CAACC,IAAI,GAAG,GAAG,CAAC,CAAC8B,KAAK,GAAGd,KAAK;MAC/Ce,CAAC,GAAGhC,CAAC,CAAC4B,IAAI,IAAI,CAAC;IACjB,IAAI5B,CAAC,CAACiC,MAAM,EAAE;MACZ,MAAMC,EAAE,GAAGvC,IAAI,CAACwC,GAAG,CAACnC,CAAC,CAACiC,MAAM,GAAGvC,YAAY,CAAC;QAC1C0C,EAAE,GAAGzC,IAAI,CAAC0C,GAAG,CAACrC,CAAC,CAACiC,MAAM,GAAGvC,YAAY,CAAC;QACtC4C,GAAG,GAAGT,CAAC,GAAGO,EAAE;QACZG,GAAG,GAAGV,CAAC,GAAGK,EAAE;QACZM,GAAG,GAAGR,CAAC,GAAGI,EAAE;QACZK,GAAG,GAAGT,CAAC,GAAGE,EAAE;MACdL,CAAC,GACGlC,IAAI,CAAC+C,GAAG,CAAC/C,IAAI,CAACgD,GAAG,CAACL,GAAG,GAAGG,GAAG,CAAC,EAAE9C,IAAI,CAACgD,GAAG,CAACL,GAAG,GAAGG,GAAG,CAAC,CAAC,GAAG,IAAI,IAAK,CAAC,IAAK,CAAC;MACzET,CAAC,GAAG,CAAC,CAACrC,IAAI,CAAC+C,GAAG,CAAC/C,IAAI,CAACgD,GAAG,CAACJ,GAAG,GAAGC,GAAG,CAAC,EAAE7C,IAAI,CAACgD,GAAG,CAACJ,GAAG,GAAGC,GAAG,CAAC,CAAC;KACzD,MAAM;MACLX,CAAC,GAAKA,CAAC,GAAG,IAAI,IAAK,CAAC,IAAK,CAAC;;IAE5B,IAAIG,CAAC,GAAGX,IAAI,EAAEA,IAAI,GAAGW,CAAC;IACtB,IAAIb,CAAC,GAAGU,CAAC,IAAIhC,EAAE,IAAI,CAAC,EAAE;MACpBsB,CAAC,GAAG,CAAC;MACLC,CAAC,IAAIC,IAAI;MACTA,IAAI,GAAG,CAAC;;IAEV,IAAID,CAAC,GAAGY,CAAC,IAAIlC,EAAE,EAAE;IACjBiB,CAAC,CAAC6B,SAAS,CAAC,CAACzB,CAAC,IAAIU,CAAC,IAAI,CAAC,CAAC,IAAIZ,KAAK,EAAE,CAACG,CAAC,IAAIY,CAAC,IAAI,CAAC,CAAC,IAAIf,KAAK,CAAC;IAC3D,IAAIjB,CAAC,CAACiC,MAAM,EAAElB,CAAC,CAACkB,MAAM,CAACjC,CAAC,CAACiC,MAAM,GAAGvC,YAAY,CAAC;IAC/CqB,CAAC,CAAC8B,QAAQ,CAAC7C,CAAC,CAACC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;IACxB,IAAID,CAAC,CAAC8C,OAAO,EAAE;MACb/B,CAAC,CAACgC,SAAS,GAAG,CAAC,GAAG/C,CAAC,CAAC8C,OAAO;MAC3B/B,CAAC,CAACiC,UAAU,CAAChD,CAAC,CAACC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;;IAE5Bc,CAAC,CAACkC,OAAO,EAAE;IACXjD,CAAC,CAAC+B,KAAK,GAAGF,CAAC;IACX7B,CAAC,CAACkD,MAAM,GAAGlB,CAAC;IACZhC,CAAC,CAACmD,IAAI,GAAGhC,CAAC;IACVnB,CAAC,CAACoD,IAAI,GAAGhC,CAAC;IACVpB,CAAC,CAACqD,EAAE,GAAGxB,CAAC,IAAI,CAAC;IACb7B,CAAC,CAACsD,EAAE,GAAGtB,CAAC,IAAI,CAAC;IACbhC,CAAC,CAACuD,EAAE,GAAG,CAACvD,CAAC,CAACqD,EAAE;IACZrD,CAAC,CAACwD,EAAE,GAAG,CAACxD,CAAC,CAACsD,EAAE;IACZtD,CAAC,CAACyD,OAAO,GAAG,IAAI;IAChBtC,CAAC,IAAIU,CAAC;;EAER,MAAM6B,MAAM,GAAG3C,CAAC,CAAC4C,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC9D,EAAE,IAAI,CAAC,IAAIoB,KAAK,EAAEnB,EAAE,GAAGmB,KAAK,CAAC,CAACL,IAAI;IACrEE,MAAM,GAAG,EAAE;EACb,OAAO,EAAED,EAAE,IAAI,CAAC,EAAE;IAChBb,CAAC,GAAGY,IAAI,CAACC,EAAE,CAAC;IACZ,IAAI,CAACb,CAAC,CAACyD,OAAO,EAAE;IAChB,MAAM5B,CAAC,GAAG7B,CAAC,CAAC+B,KAAK;MACf6B,GAAG,GAAG/B,CAAC,IAAI,CAAC;IACd,IAAIG,CAAC,GAAGhC,CAAC,CAACsD,EAAE,GAAGtD,CAAC,CAACwD,EAAE;IACnB;IACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,CAAC,GAAG4B,GAAG,EAAEC,CAAC,EAAE,EAAE/C,MAAM,CAAC+C,CAAC,CAAC,GAAG,CAAC;IAC/C1C,CAAC,GAAGnB,CAAC,CAACmD,IAAI;IACV,IAAIhC,CAAC,IAAI,IAAI,EAAE;IACfC,CAAC,GAAGpB,CAAC,CAACoD,IAAI;IACV,IAAIU,IAAI,GAAG,CAAC;MACVC,OAAO,GAAG,CAAC,CAAC;IACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhC,CAAC,EAAEgC,CAAC,EAAE,EAAE;MAC1B,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhC,CAAC,EAAEgC,CAAC,EAAE,EAAE;QAC1B,MAAMI,CAAC,GAAGL,GAAG,GAAGI,CAAC,IAAIH,CAAC,IAAI,CAAC,CAAC;UAC1BK,CAAC,GAAGR,MAAM,CAAE,CAACtC,CAAC,GAAG4C,CAAC,KAAKnE,EAAE,IAAI,CAAC,CAAC,IAAIsB,CAAC,GAAG0C,CAAC,CAAC,IAAK,CAAC,CAAC,GAC5C,CAAC,IAAK,EAAE,GAAIA,CAAC,GAAG,EAAI,GACpB,CAAC;QACP/C,MAAM,CAACmD,CAAC,CAAC,IAAIC,CAAC;QACdJ,IAAI,IAAII,CAAC;;MAEX,IAAIJ,IAAI,EAAEC,OAAO,GAAGC,CAAC,CAAC,KACjB;QACHhE,CAAC,CAACwD,EAAE,EAAE;QACNxB,CAAC,EAAE;QACHgC,CAAC,EAAE;QACH5C,CAAC,EAAE;;;IAGPpB,CAAC,CAACsD,EAAE,GAAGtD,CAAC,CAACwD,EAAE,GAAGO,OAAO;IACrB/D,CAAC,CAACc,MAAM,GAAGA,MAAM,CAACqD,KAAK,CAAC,CAAC,EAAE,CAACnE,CAAC,CAACsD,EAAE,GAAGtD,CAAC,CAACwD,EAAE,IAAII,GAAG,CAAC;;AAEnD;AAEA;AACA,SAASQ,YAAYA,CAACC,GAAG,EAAEC,KAAK,EAAEC,EAAE;EAClCA,EAAE,KAAK,CAAC;EACR,MAAMzD,MAAM,GAAGuD,GAAG,CAACvD,MAAM;IACvBe,CAAC,GAAGwC,GAAG,CAACtC,KAAK,IAAI,CAAC;IAClByC,EAAE,GAAGH,GAAG,CAAClD,CAAC,IAAIU,CAAC,IAAI,CAAC,CAAC;IACrB4C,EAAE,GAAGD,EAAE,GAAG,IAAI;IACdE,GAAG,GAAG,EAAE,GAAGD,EAAE;IACbzC,CAAC,GAAGqC,GAAG,CAACf,EAAE,GAAGe,GAAG,CAACb,EAAE;EACrB,IAAIrC,CAAC,GAAG,CAACkD,GAAG,CAACjD,CAAC,GAAGiD,GAAG,CAACb,EAAE,IAAIe,EAAE,IAAIC,EAAE,IAAI,CAAC,CAAC;IACvCG,IAAI;EACN,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhC,CAAC,EAAEgC,CAAC,EAAE,EAAE;IAC1BW,IAAI,GAAG,CAAC;IACR,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIhC,CAAC,EAAEgC,CAAC,EAAE,EAAE;MAC3B,IACE,CAAEc,IAAI,IAAID,GAAG,IAAKb,CAAC,GAAGhC,CAAC,GAAG,CAAC8C,IAAI,GAAG7D,MAAM,CAACkD,CAAC,GAAGnC,CAAC,GAAGgC,CAAC,CAAC,MAAMY,EAAE,GAAG,CAAC,CAAC,IAChEH,KAAK,CAACnD,CAAC,GAAG0C,CAAC,CAAC,EAEZ,OAAO,IAAI;;IAEf1C,CAAC,IAAIoD,EAAE;;EAET,OAAO,KAAK;AACd;AAEA,SAASK,WAAWA,CAACC,MAAM,EAAE7E,CAAC;EAC5B,MAAM8E,EAAE,GAAGD,MAAM,CAAC,CAAC,CAAC;IAClBE,EAAE,GAAGF,MAAM,CAAC,CAAC,CAAC;EAChB,IAAI7E,CAAC,CAACmB,CAAC,GAAGnB,CAAC,CAACuD,EAAE,GAAGuB,EAAE,CAAC3D,CAAC,EAAE2D,EAAE,CAAC3D,CAAC,GAAGnB,CAAC,CAACmB,CAAC,GAAGnB,CAAC,CAACuD,EAAE;EACxC,IAAIvD,CAAC,CAACoB,CAAC,GAAGpB,CAAC,CAACwD,EAAE,GAAGsB,EAAE,CAAC1D,CAAC,EAAE0D,EAAE,CAAC1D,CAAC,GAAGpB,CAAC,CAACoB,CAAC,GAAGpB,CAAC,CAACwD,EAAE;EACxC,IAAIxD,CAAC,CAACmB,CAAC,GAAGnB,CAAC,CAACqD,EAAE,GAAG0B,EAAE,CAAC5D,CAAC,EAAE4D,EAAE,CAAC5D,CAAC,GAAGnB,CAAC,CAACmB,CAAC,GAAGnB,CAAC,CAACqD,EAAE;EACxC,IAAIrD,CAAC,CAACoB,CAAC,GAAGpB,CAAC,CAACsD,EAAE,GAAGyB,EAAE,CAAC3D,CAAC,EAAE2D,EAAE,CAAC3D,CAAC,GAAGpB,CAAC,CAACoB,CAAC,GAAGpB,CAAC,CAACsD,EAAE;AAC1C;AAEA,SAAS0B,YAAYA,CAACC,CAAC,EAAEC,CAAC;EACxB,OACED,CAAC,CAAC9D,CAAC,GAAG8D,CAAC,CAAC5B,EAAE,GAAG6B,CAAC,CAAC,CAAC,CAAC,CAAC/D,CAAC,IACnB8D,CAAC,CAAC9D,CAAC,GAAG8D,CAAC,CAAC1B,EAAE,GAAG2B,CAAC,CAAC,CAAC,CAAC,CAAC/D,CAAC,IACnB8D,CAAC,CAAC7D,CAAC,GAAG6D,CAAC,CAAC3B,EAAE,GAAG4B,CAAC,CAAC,CAAC,CAAC,CAAC9D,CAAC,IACnB6D,CAAC,CAAC7D,CAAC,GAAG6D,CAAC,CAACzB,EAAE,GAAG0B,CAAC,CAAC,CAAC,CAAC,CAAC9D,CAAC;AAEvB;AAEA,SAAS+D,iBAAiBA,CAACvD,IAAI;EAC7B,MAAMwD,CAAC,GAAGxD,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EAC3B,OAAO,UAAUyD,CAAC;IAChB,OAAO,CAACD,CAAC,IAAIC,CAAC,IAAI,GAAG,CAAC,GAAG1F,IAAI,CAAC0C,GAAG,CAACgD,CAAC,CAAC,EAAEA,CAAC,GAAG1F,IAAI,CAACwC,GAAG,CAACkD,CAAC,CAAC,CAAC;EACxD,CAAC;AACH;AAEA,SAASC,iBAAiBA,CAAC1D,IAAI;EAC7B,MAAM2D,EAAE,GAAG,CAAC;IACVC,EAAE,GAAID,EAAE,GAAG3D,IAAI,CAAC,CAAC,CAAC,GAAIA,IAAI,CAAC,CAAC,CAAC;EAC/B,IAAIT,CAAC,GAAG,CAAC;IACPC,CAAC,GAAG,CAAC;EACP,OAAO,UAAUiE,CAAC;IAChB,MAAMI,IAAI,GAAGJ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IAC3B;IACA,QAAS1F,IAAI,CAAC+F,IAAI,CAAC,CAAC,GAAG,CAAC,GAAGD,IAAI,GAAGJ,CAAC,CAAC,GAAGI,IAAI,GAAI,CAAC;MAC9C,KAAK,CAAC;QACJtE,CAAC,IAAIqE,EAAE;QACP;MACF,KAAK,CAAC;QACJpE,CAAC,IAAImE,EAAE;QACP;MACF,KAAK,CAAC;QACJpE,CAAC,IAAIqE,EAAE;QACP;MACF;QACEpE,CAAC,IAAImE,EAAE;QACP;;IAEJ,OAAO,CAACpE,CAAC,EAAEC,CAAC,CAAC;EACf,CAAC;AACH;AAEA;AACA,SAASuE,SAASA,CAACrE,CAAC;EAClB,MAAM2D,CAAC,GAAG,EAAE;EACZ,IAAIpB,CAAC,GAAG,CAAC,CAAC;EACV,OAAO,EAAEA,CAAC,GAAGvC,CAAC,EAAE2D,CAAC,CAACpB,CAAC,CAAC,GAAG,CAAC;EACxB,OAAOoB,CAAC;AACV;AAEA,SAASW,WAAWA,CAAA;EAClB,OAAOC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;AACzC;AAEA,SAASC,OAAOA,CAAC/F,CAAC;EAChB,OAAO,OAAOA,CAAC,KAAK,UAAU,GAC1BA,CAAC,GACD;IACE,OAAOA,CAAC;EACV,CAAC;AACP;AAEA,MAAMgG,OAAO,GAAG;EACdC,WAAW,EAAEd,iBAAiB;EAC9Be,WAAW,EAAEZ;CACd;AAED,OAAM,SAAUa,QAAQA,CAAA;EACtB,IAAIvE,IAAI,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;IACnB3B,IAAI,GAAGF,SAAS;IAChB0B,IAAI,GAAGvB,SAAS;IAChBkG,QAAQ,GAAGhG,aAAa;IACxBiG,UAAU,GAAGlG,eAAe;IAC5B8B,MAAM,GAAG3B,WAAW;IACpBwC,OAAO,GAAGtC,YAAY;IACtB8F,MAAM,GAAGnB,iBAAiB;IAC1B5E,MAAM,GAAGZ,IAAI,CAACY,MAAM;IACpBgG,KAAK,GAAG9F,aAAa;IACrB+F,KAAK,GAAG,EAAE;IACVC,KAAK,GAAG,IAAI;IACZC,YAAY,GAAGC,QAAQ;IACvBC,MAAM,GAAGhB,WAAW;EAEtB,MAAMiB,SAAS,GAAG1G,eAAe;EACjC,MAAM2G,KAAK,GAAQ,EAAE;EAErBA,KAAK,CAACC,KAAK,GAAG;IACZ,MAAM,CAAChF,KAAK,EAAEmB,MAAM,CAAC,GAAGtB,IAAI;IAC5B,MAAMjB,eAAe,GAAGqG,UAAU,CAACJ,MAAM,EAAE,CAAC;MAC1CtC,KAAK,GAAGwC,KAAK,CAACxC,KAAK,GAAGwC,KAAK,CAACxC,KAAK,GAAGqB,SAAS,CAAC,CAAC/D,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,CAAC;MACvEN,CAAC,GAAGkF,KAAK,CAACjF,MAAM;MAChB0F,IAAI,GAAG,EAAE;MACTrG,IAAI,GAAG4F,KAAK,CACTU,GAAG,CAAC,UAAUlH,CAAC,EAAE6D,CAAC,EAAEjD,IAAI;QACvBZ,CAAC,CAACC,IAAI,GAAGA,IAAI,CAACkH,IAAI,CAAC,IAAI,EAAEnH,CAAC,EAAE6D,CAAC,EAAEjD,IAAI,CAAC;QACpCZ,CAAC,CAACyB,IAAI,GAAGA,IAAI,CAAC0F,IAAI,CAAC,IAAI,EAAEnH,CAAC,EAAE6D,CAAC,EAAEjD,IAAI,CAAC;QACpCZ,CAAC,CAAC0B,KAAK,GAAGmF,SAAS,CAACM,IAAI,CAAC,IAAI,EAAEnH,CAAC,EAAE6D,CAAC,EAAEjD,IAAI,CAAC;QAC1CZ,CAAC,CAAC2B,MAAM,GAAG0E,UAAU,CAACc,IAAI,CAAC,IAAI,EAAEnH,CAAC,EAAE6D,CAAC,EAAEjD,IAAI,CAAC;QAC5CZ,CAAC,CAACiC,MAAM,GAAGA,MAAM,CAACkF,IAAI,CAAC,IAAI,EAAEnH,CAAC,EAAE6D,CAAC,EAAEjD,IAAI,CAAC;QACxCZ,CAAC,CAAC4B,IAAI,GAAG,CAAC,CAACwE,QAAQ,CAACe,IAAI,CAAC,IAAI,EAAEnH,CAAC,EAAE6D,CAAC,EAAEjD,IAAI,CAAC;QAC1CZ,CAAC,CAAC8C,OAAO,GAAGA,OAAO,CAACqE,IAAI,CAAC,IAAI,EAAEnH,CAAC,EAAE6D,CAAC,EAAEjD,IAAI,CAAC;QAC1C,OAAOZ,CAAC;MACV,CAAC,CAAC,CACDoH,IAAI,CAAC,UAAUnC,CAAC,EAAEC,CAAC;QAClB,OAAOA,CAAC,CAACtD,IAAI,GAAGqD,CAAC,CAACrD,IAAI;MACxB,CAAC,CAAC;IACN,IAAIiC,CAAC,GAAG,CAAC,CAAC;MACRgB,MAAM,GAAG,CAACiC,KAAK,CAACxC,KAAK,GACjB+C,SAAS,GACT,CACE;QACElG,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE;OACJ,EACD;QACED,CAAC,EAAEY,KAAK;QACRX,CAAC,EAAE8B;OACJ,CACF;IAEP,IAAIuD,KAAK,EAAEa,aAAa,CAACb,KAAK,CAAC;IAC/BA,KAAK,GAAGc,WAAW,CAACC,IAAI,EAAE,CAAC,CAAC;IAC5BA,IAAI,EAAE;IAEN,SAASA,IAAIA,CAAA;MACX,MAAMT,KAAK,GAAGU,IAAI,CAACC,GAAG,EAAE;MACxB,OAAOD,IAAI,CAACC,GAAG,EAAE,GAAGX,KAAK,GAAGL,YAAY,IAAI,EAAE7C,CAAC,GAAGvC,CAAC,EAAE;QACnD,MAAMtB,CAAC,GAAGY,IAAI,CAACiD,CAAC,CAAC;QACjB7D,CAAC,CAACmB,CAAC,GAAIY,KAAK,IAAIxB,MAAM,EAAE,GAAG,GAAG,CAAC,IAAK,CAAC;QACrCP,CAAC,CAACoB,CAAC,GAAI8B,MAAM,IAAI3C,MAAM,EAAE,GAAG,GAAG,CAAC,IAAK,CAAC;QACtCG,WAAW,CAACC,eAAe,EAAEX,CAAC,EAAEY,IAAI,EAAEiD,CAAC,CAAC;QACxC,IAAI7D,CAAC,CAACyD,OAAO,IAAIkE,KAAK,CAACrD,KAAK,EAAEtE,CAAC,EAAE6E,MAAM,CAAC,EAAE;UACxC0B,KAAK,CAACY,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE;YAAEL,KAAK;YAAEc,IAAI,EAAE5H;UAAC,CAAE,CAAC;UAC5CiH,IAAI,CAACY,IAAI,CAAC7H,CAAC,CAAC;UACZ,IAAI6E,MAAM,EAAE;YACV,IAAI,CAACiC,KAAK,CAACgB,QAAQ,EAAE;cACnB;cACAlD,WAAW,CAACC,MAAM,EAAE7E,CAAC,CAAC;;WAEzB,MAAM;YACL6E,MAAM,GAAG,CACP;cAAE1D,CAAC,EAAEnB,CAAC,CAACmB,CAAC,GAAGnB,CAAC,CAACuD,EAAE;cAAEnC,CAAC,EAAEpB,CAAC,CAACoB,CAAC,GAAGpB,CAAC,CAACwD;YAAE,CAAE,EAChC;cAAErC,CAAC,EAAEnB,CAAC,CAACmB,CAAC,GAAGnB,CAAC,CAACqD,EAAE;cAAEjC,CAAC,EAAEpB,CAAC,CAACoB,CAAC,GAAGpB,CAAC,CAACsD;YAAE,CAAE,CACjC;;UAEH;UACAtD,CAAC,CAACmB,CAAC,IAAIS,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;UACnB5B,CAAC,CAACoB,CAAC,IAAIQ,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;;;MAGvBkF,KAAK,CAACiB,KAAK,GAAGd,IAAI;MAClBH,KAAK,CAACkB,OAAO,GAAGnD,MAAM;MAEtB,IAAIhB,CAAC,IAAIvC,CAAC,EAAE;QACVwF,KAAK,CAACmB,IAAI,EAAE;QACZ1B,KAAK,CAACY,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE;UAAEL,KAAK;UAAEN,KAAK,EAAES,IAAI;UAAEpC;QAAM,CAAE,CAAC;;IAE3D;IAEA,OAAOiC,KAAK;EACd,CAAC;EAEDA,KAAK,CAACmB,IAAI,GAAG;IACX,IAAIxB,KAAK,EAAE;MACTa,aAAa,CAACb,KAAK,CAAC;MACpBA,KAAK,GAAG,IAAI;;IAEd,OAAOK,KAAK;EACd,CAAC;EAED,SAASE,UAAUA,CAACJ,MAAyB;IAC3CA,MAAM,CAAC7E,KAAK,GAAG6E,MAAM,CAAC1D,MAAM,GAAG,CAAC;IAChC,MAAMjC,KAAK,GAAGtB,IAAI,CAAC+F,IAAI,CACrBkB,MAAM,CAACI,UAAU,CAAC,IAAI,CAAE,CAACrD,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC/C,IAAI,CAACW,MAAM,IAAI,CAAC,CACnE;IACDqF,MAAM,CAAC7E,KAAK,GAAG,CAAClC,EAAE,IAAI,CAAC,IAAIoB,KAAK;IAChC2F,MAAM,CAAC1D,MAAM,GAAGpD,EAAE,GAAGmB,KAAK;IAE1B,MAAMD,OAAO,GAAG4F,MAAM,CAACI,UAAU,CAAC,IAAI,CAA6B;IACnEhG,OAAO,CAACkH,SAAS,GAAGlH,OAAO,CAACmH,WAAW,GAAG,KAAK;IAC/CnH,OAAO,CAACoH,SAAS,GAAG,QAAQ;IAC5BpH,OAAO,CAACqH,YAAY,GAAG,QAAQ;IAC/B,OAAO;MAAErH,OAAO;MAAEC;IAAK,CAAE;EAC3B;EAEA,SAAS0G,KAAKA,CAACrD,KAAK,EAAED,GAAG,EAAEQ,MAAM;IAC/B;IACA,MAAMyD,MAAM,GAAGjE,GAAG,CAAClD,CAAC;MAClBoH,MAAM,GAAGlE,GAAG,CAACjD,CAAC;MACdoH,QAAQ,GAAG7I,IAAI,CAAC+F,IAAI,CAAC9D,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC;MAC3D6G,CAAC,GAAGnC,MAAM,CAAC1E,IAAI,CAAC;MAChB8G,EAAE,GAAGnI,MAAM,EAAE,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;IAC9B,IAAIoI,IAAI;MACNtD,CAAC,GAAG,CAACqD,EAAE;MACPlD,EAAE;MACFD,EAAE;IAEJ,OAAQoD,IAAI,GAAGF,CAAC,CAAEpD,CAAC,IAAIqD,EAAG,CAAC,EAAG;MAC5BlD,EAAE,GAAG,CAAC,CAACmD,IAAI,CAAC,CAAC,CAAC;MACdpD,EAAE,GAAG,CAAC,CAACoD,IAAI,CAAC,CAAC,CAAC;MAEd,IAAIhJ,IAAI,CAACiJ,GAAG,CAACjJ,IAAI,CAACgD,GAAG,CAAC6C,EAAE,CAAC,EAAE7F,IAAI,CAACgD,GAAG,CAAC4C,EAAE,CAAC,CAAC,IAAIiD,QAAQ,EAAE;MAEtDnE,GAAG,CAAClD,CAAC,GAAGmH,MAAM,GAAG9C,EAAE;MACnBnB,GAAG,CAACjD,CAAC,GAAGmH,MAAM,GAAGhD,EAAE;MAEnB,IACElB,GAAG,CAAClD,CAAC,GAAGkD,GAAG,CAACd,EAAE,GAAG,CAAC,IAClBc,GAAG,CAACjD,CAAC,GAAGiD,GAAG,CAACb,EAAE,GAAG,CAAC,IAClBa,GAAG,CAAClD,CAAC,GAAGkD,GAAG,CAAChB,EAAE,GAAGzB,IAAI,CAAC,CAAC,CAAC,IACxByC,GAAG,CAACjD,CAAC,GAAGiD,GAAG,CAACf,EAAE,GAAG1B,IAAI,CAAC,CAAC,CAAC,EAExB;MACF;MACA,IAAI,CAACiD,MAAM,IAAI,CAACT,YAAY,CAACC,GAAG,EAAEC,KAAK,EAAE1C,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;QACjD,IAAI,CAACiD,MAAM,IAAIG,YAAY,CAACX,GAAG,EAAEQ,MAAM,CAAC,EAAE;UACxC,MAAM/D,MAAM,GAAGuD,GAAG,CAACvD,MAAM;YACvBe,CAAC,GAAGwC,GAAG,CAACtC,KAAK,IAAI,CAAC;YAClBwC,EAAE,GAAG3C,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YACjB4C,EAAE,GAAGH,GAAG,CAAClD,CAAC,IAAIU,CAAC,IAAI,CAAC,CAAC;YACrB4C,EAAE,GAAGD,EAAE,GAAG,IAAI;YACdE,GAAG,GAAG,EAAE,GAAGD,EAAE;YACbzC,CAAC,GAAGqC,GAAG,CAACf,EAAE,GAAGe,GAAG,CAACb,EAAE;UACrB,IAAImB,IAAI;YACNxD,CAAC,GAAG,CAACkD,GAAG,CAACjD,CAAC,GAAGiD,GAAG,CAACb,EAAE,IAAIe,EAAE,IAAIC,EAAE,IAAI,CAAC,CAAC;UACvC,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhC,CAAC,EAAEgC,CAAC,EAAE,EAAE;YAC1BW,IAAI,GAAG,CAAC;YACR,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIhC,CAAC,EAAEgC,CAAC,EAAE,EAAE;cAC3BS,KAAK,CAACnD,CAAC,GAAG0C,CAAC,CAAC,IACTc,IAAI,IAAID,GAAG,IAAKb,CAAC,GAAGhC,CAAC,GAAG,CAAC8C,IAAI,GAAG7D,MAAM,CAACkD,CAAC,GAAGnC,CAAC,GAAGgC,CAAC,CAAC,MAAMY,EAAE,GAAG,CAAC,CAAC;;YAEnEtD,CAAC,IAAIoD,EAAE;;UAET,OAAOF,GAAG,CAACvD,MAAM;UACjB,OAAO,IAAI;;;;IAIjB,OAAO,KAAK;EACd;EAEAgG,KAAK,CAAC+B,UAAU,GAAIC,GAAqB,IAAI;IAC3C,MAAMC,GAAG,GAAsBlD,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;IAC/D,MAAM,CAAC/D,KAAK,EAAEmB,MAAM,CAAC,GAAGtB,IAAI;IAE5B;IACA,IAAI,CAACG,KAAK,IAAI,CAACmB,MAAM,EAAE;MACrB;;IAEF,MAAMU,GAAG,GAAG7B,KAAK,IAAI,CAAC;IACtB,MAAMuC,KAAK,GAAGqB,SAAS,CAAC,CAAC5D,KAAK,IAAI,CAAC,IAAImB,MAAM,CAAC;IAC9C6F,GAAG,CAAChH,KAAK,GAAGA,KAAK;IACjBgH,GAAG,CAAC7F,MAAM,GAAGA,MAAM;IACnB,MAAM8F,GAAG,GAAGD,GAAG,CAAC/B,UAAU,CAAC,IAAI,CAA6B;IAC5DgC,GAAG,CAACC,SAAS,CAACH,GAAG,EAAE,CAAC,EAAE,CAAC,EAAEA,GAAG,CAAC/G,KAAK,EAAE+G,GAAG,CAAC5F,MAAM,EAAE,CAAC,EAAE,CAAC,EAAEnB,KAAK,EAAEmB,MAAM,CAAC;IACpE,MAAMgG,SAAS,GAAGF,GAAG,CAACrF,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE5B,KAAK,EAAEmB,MAAM,CAAC,CAACtC,IAAI;IAC5D,KAAK,IAAIoD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,MAAM,EAAEc,CAAC,EAAE,EAAE;MAC/B,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,KAAK,EAAE8B,CAAC,EAAE,EAAE;QAC9B,MAAMI,CAAC,GAAGL,GAAG,GAAGI,CAAC,IAAIH,CAAC,IAAI,CAAC,CAAC;QAC5B,MAAMsF,GAAG,GAAInF,CAAC,GAAGjC,KAAK,GAAG8B,CAAC,IAAK,CAAC;QAChC,MAAMuF,IAAI,GACRF,SAAS,CAACC,GAAG,CAAC,IAAI,GAAG,IACrBD,SAAS,CAACC,GAAG,GAAG,CAAC,CAAC,IAAI,GAAG,IACzBD,SAAS,CAACC,GAAG,GAAG,CAAC,CAAC,IAAI,GAAG;QAC3B,MAAMjF,CAAC,GAAGkF,IAAI,GAAG,CAAC,IAAK,EAAE,GAAIvF,CAAC,GAAG,EAAI,GAAG,CAAC;QACzCS,KAAK,CAACL,CAAC,CAAC,IAAIC,CAAC;;;IAGjB4C,KAAK,CAACxC,KAAK,GAAGA,KAAK;IACnBwC,KAAK,CAACgB,QAAQ,GAAG,IAAI;EACvB,CAAC;EAEDhB,KAAK,CAACJ,YAAY,GAAG,UAAU2C,CAAC;IAC9B3C,YAAY,GAAG2C,CAAC,IAAI,IAAI,GAAG1C,QAAQ,GAAG0C,CAAC;EACzC,CAAC;EAEDvC,KAAK,CAACN,KAAK,GAAG,UAAU6C,CAAC;IACvB7C,KAAK,GAAG6C,CAAC;EACX,CAAC;EAEDvC,KAAK,CAAClF,IAAI,GAAG,UAAUyH,CAAC,GAAG,EAAE;IAC3BzH,IAAI,GAAG,CAAC,CAACyH,CAAC,CAAC,CAAC,CAAC,EAAE,CAACA,CAAC,CAAC,CAAC,CAAC,CAAC;EACvB,CAAC;EAEDvC,KAAK,CAAC7G,IAAI,GAAG,UAAUoJ,CAAC;IACtBpJ,IAAI,GAAG8F,OAAO,CAACsD,CAAC,CAAC;EACnB,CAAC;EAEDvC,KAAK,CAACrF,IAAI,GAAG,UAAU4H,CAAC;IACtB5H,IAAI,GAAGsE,OAAO,CAACsD,CAAC,CAAC;EACnB,CAAC;EAEDvC,KAAK,CAACT,UAAU,GAAG,UAAUgD,CAAC;IAC5BhD,UAAU,GAAGN,OAAO,CAACsD,CAAC,CAAC;EACzB,CAAC;EAEDvC,KAAK,CAAC7E,MAAM,GAAG,UAAUoH,CAAC;IACxBpH,MAAM,GAAG8D,OAAO,CAACsD,CAAC,CAAC;EACrB,CAAC;EAEDvC,KAAK,CAACF,MAAM,GAAG,UAAUyC,CAAC;IACxBzC,MAAM,GAAGb,OAAO,CAACsD,CAAC,CAAC;EACrB,CAAC;EAEDvC,KAAK,CAACR,MAAM,GAAG,UAAU+C,CAAC;IACxB/C,MAAM,GAAGN,OAAO,CAACqD,CAAC,CAAC,IAAIA,CAAC;EAC1B,CAAC;EAEDvC,KAAK,CAACV,QAAQ,GAAG,UAAUiD,CAAC;IAC1BjD,QAAQ,GAAGL,OAAO,CAACsD,CAAC,CAAC;EACvB,CAAC;EAEDvC,KAAK,CAAChE,OAAO,GAAG,UAAUuG,CAAC;IACzBvG,OAAO,GAAGiD,OAAO,CAACsD,CAAC,CAAC;EACtB,CAAC;EAEDvC,KAAK,CAACvG,MAAM,GAAG,UAAU8I,CAAC;IACxB9I,MAAM,GAAGwF,OAAO,CAACsD,CAAC,CAAC;EACrB,CAAC;EAEDvC,KAAK,CAACwC,EAAE,GAAG,UAAUD,CAAC;IACpB9C,KAAK,GAAGR,OAAO,CAACsD,CAAC,CAAC;EACpB,CAAC;EAED,OAAOvC,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}