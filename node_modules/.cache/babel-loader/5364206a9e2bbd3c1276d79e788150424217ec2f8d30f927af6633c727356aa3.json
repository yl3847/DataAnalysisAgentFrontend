{"ast":null,"code":"import { groupBy } from '@antv/util';\nimport { getExtension } from '../registry/get';\nimport { idOf } from './id';\nimport { format } from './print';\n/**\n * <zh/> 解析色板配置\n *\n * <en/> Parse palette options\n * @param palette - <zh/> 色板配置 | <en/> PaletteOptions options\n * @returns <zh/> 标准色板配置 | <en/> Standard palette options\n */\nexport function parsePalette(palette) {\n  if (!palette) return undefined;\n  if (\n  // 色板名 palette name\n  typeof palette === 'string' ||\n  // 插值函数 interpolate function\n  typeof palette === 'function' ||\n  // 颜色数组 color array\n  Array.isArray(palette)) {\n    // 默认为离散色板\n    // Default to discrete palette, default group field is id\n    return {\n      type: 'group',\n      field: d => d.id,\n      color: palette,\n      invert: false\n    };\n  }\n  return palette;\n}\n/**\n * <zh/> 根据色板分配颜色\n *\n * <en/> Assign colors according to the palette\n * @param data - <zh/> 元素数据 | <en/> Element data\n * @param palette - <zh/> 色板配置 | <en/> PaletteOptions options\n * @returns <zh/> 元素颜色 | <en/> Element color\n * @remarks\n * <zh/> 返回值结果是一个以元素 id 为 key，颜色值为 value 的对象\n *\n * <en/> The return value is an object with element id as key and color value as value\n */\nexport function assignColorByPalette(data, palette) {\n  if (!palette) return {};\n  const {\n    type,\n    color: colorPalette,\n    field,\n    invert\n  } = palette;\n  const assignColor = args => {\n    const palette = typeof colorPalette === 'string' ? getExtension('palette', colorPalette) : colorPalette;\n    if (typeof palette === 'function') {\n      // assign by continuous\n      const result = {};\n      args.forEach(([id, value]) => {\n        result[id] = palette(invert ? 1 - value : value);\n      });\n      return result;\n    } else if (Array.isArray(palette)) {\n      // assign by discrete\n      const colors = invert ? [...palette].reverse() : palette;\n      const result = {};\n      args.forEach(([id, index]) => {\n        result[id] = colors[index % palette.length];\n      });\n      return result;\n    }\n    return {};\n  };\n  const parseField = (field, datum) => {\n    var _a;\n    return typeof field === 'string' ? (_a = datum.data) === null || _a === void 0 ? void 0 : _a[field] : field === null || field === void 0 ? void 0 : field(datum);\n  };\n  if (type === 'group') {\n    const groupData = groupBy(data, datum => {\n      if (!field) return 'default';\n      const key = parseField(field, datum);\n      return key ? String(key) : 'default';\n    });\n    const groupKeys = Object.keys(groupData);\n    const assignResult = assignColor(groupKeys.map((key, index) => [key, index]));\n    const result = {};\n    Object.entries(groupData).forEach(([groupKey, groupData]) => {\n      groupData.forEach(datum => {\n        result[idOf(datum)] = assignResult[groupKey];\n      });\n    });\n    return result;\n  } else if (type === 'value') {\n    const [min, max] = data.reduce(([min, max], datum) => {\n      const value = parseField(field, datum);\n      if (typeof value !== 'number') throw new Error(format(`Palette field ${field} is not a number`));\n      return [Math.min(min, value), Math.max(max, value)];\n    }, [Infinity, -Infinity]);\n    const range = max - min;\n    return assignColor(data.map(datum => [datum.id, (parseField(field, datum) - min) / range]));\n  }\n}\n/**\n * <zh/> 获取离散色板配色\n *\n * <en/> Get discrete palette colors\n * @param colorPalette - <zh/> 色板名或着颜色数组 | <en/> Palette name or color array\n * @returns <zh/> 色板上具体颜色 | <en/> Specific color on the palette\n */\nexport function getPaletteColors(colorPalette) {\n  const palette = typeof colorPalette === 'string' ? getExtension('palette', colorPalette) : colorPalette;\n  if (typeof palette === 'function') return undefined;\n  return palette;\n}","map":{"version":3,"names":["groupBy","getExtension","idOf","format","parsePalette","palette","undefined","Array","isArray","type","field","d","id","color","invert","assignColorByPalette","data","colorPalette","assignColor","args","result","forEach","value","colors","reverse","index","length","parseField","datum","_a","groupData","key","String","groupKeys","Object","keys","assignResult","map","entries","groupKey","min","max","reduce","Error","Math","Infinity","range","getPaletteColors"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/palette.ts"],"sourcesContent":["import { groupBy } from '@antv/util';\nimport type { CategoricalPalette } from '../palettes/types';\nimport { getExtension } from '../registry/get';\nimport type { PaletteOptions, STDPaletteOptions } from '../spec/element/palette';\nimport type { ID } from '../types';\nimport type { ElementData, ElementDatum } from '../types/data';\nimport { idOf } from './id';\nimport { format } from './print';\n\n/**\n * <zh/> 解析色板配置\n *\n * <en/> Parse palette options\n * @param palette - <zh/> 色板配置 | <en/> PaletteOptions options\n * @returns <zh/> 标准色板配置 | <en/> Standard palette options\n */\nexport function parsePalette(palette?: PaletteOptions): STDPaletteOptions | undefined {\n  if (!palette) return undefined;\n\n  if (\n    // 色板名 palette name\n    typeof palette === 'string' ||\n    // 插值函数 interpolate function\n    typeof palette === 'function' ||\n    // 颜色数组 color array\n    Array.isArray(palette)\n  ) {\n    // 默认为离散色板\n    // Default to discrete palette, default group field is id\n    return {\n      type: 'group',\n      field: (d: any) => d.id,\n      color: palette,\n      invert: false,\n    };\n  }\n  return palette;\n}\n\n/**\n * <zh/> 根据色板分配颜色\n *\n * <en/> Assign colors according to the palette\n * @param data - <zh/> 元素数据 | <en/> Element data\n * @param palette - <zh/> 色板配置 | <en/> PaletteOptions options\n * @returns <zh/> 元素颜色 | <en/> Element color\n * @remarks\n * <zh/> 返回值结果是一个以元素 id 为 key，颜色值为 value 的对象\n *\n * <en/> The return value is an object with element id as key and color value as value\n */\nexport function assignColorByPalette(data: ElementData, palette?: STDPaletteOptions) {\n  if (!palette) return {};\n\n  const { type, color: colorPalette, field, invert } = palette;\n\n  const assignColor = (args: [ID, number][]): Record<ID, string> => {\n    const palette = typeof colorPalette === 'string' ? getExtension('palette', colorPalette) : colorPalette;\n\n    if (typeof palette === 'function') {\n      // assign by continuous\n      const result: Record<ID, string> = {};\n      args.forEach(([id, value]) => {\n        result[id] = palette(invert ? 1 - value : value);\n      });\n      return result;\n    } else if (Array.isArray(palette)) {\n      // assign by discrete\n      const colors = invert ? [...palette].reverse() : palette;\n      const result: Record<ID, string> = {};\n      args.forEach(([id, index]) => {\n        result[id] = colors[index % palette.length];\n      });\n      return result;\n    }\n    return {};\n  };\n\n  const parseField = (field: STDPaletteOptions['field'], datum: ElementDatum) =>\n    typeof field === 'string' ? datum.data?.[field] : field?.(datum);\n\n  if (type === 'group') {\n    const groupData = groupBy<ElementDatum>(data, (datum) => {\n      if (!field) return 'default';\n      const key = parseField(field, datum);\n      return key ? String(key) : 'default';\n    });\n\n    const groupKeys = Object.keys(groupData);\n    const assignResult = assignColor(groupKeys.map((key, index) => [key, index]));\n\n    const result: Record<ID, string> = {};\n    Object.entries(groupData).forEach(([groupKey, groupData]) => {\n      groupData.forEach((datum) => {\n        result[idOf(datum)] = assignResult[groupKey];\n      });\n    });\n    return result;\n  } else if (type === 'value') {\n    const [min, max] = data.reduce(\n      ([min, max], datum) => {\n        const value = parseField(field, datum);\n        if (typeof value !== 'number') throw new Error(format(`Palette field ${field} is not a number`));\n        return [Math.min(min, value), Math.max(max, value)];\n      },\n      [Infinity, -Infinity],\n    );\n    const range = max - min;\n\n    return assignColor(\n      data.map((datum) => [datum.id, ((parseField(field, datum) as number) - min) / range]) as [ID, number][],\n    );\n  }\n}\n\n/**\n * <zh/> 获取离散色板配色\n *\n * <en/> Get discrete palette colors\n * @param colorPalette - <zh/> 色板名或着颜色数组 | <en/> Palette name or color array\n * @returns <zh/> 色板上具体颜色 | <en/> Specific color on the palette\n */\nexport function getPaletteColors(colorPalette?: string | CategoricalPalette): CategoricalPalette | undefined {\n  const palette = typeof colorPalette === 'string' ? getExtension('palette', colorPalette) : colorPalette;\n  if (typeof palette === 'function') return undefined;\n  return palette;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}