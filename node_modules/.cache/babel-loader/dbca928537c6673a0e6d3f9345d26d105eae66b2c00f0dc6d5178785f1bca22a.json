{"ast":null,"code":"import { deepMix } from '@antv/util';\nimport { calcBBox } from '../utils/vector';\nfunction pack(options) {\n  const {\n    padding = 0,\n    direction = 'col'\n  } = options;\n  return (P, count, layout) => {\n    const pcount = P.length;\n    if (pcount === 0) return [];\n    // col * row >= count\n    // row is close to col * aspect, so\n    // col * (col * aspect) >= count\n    const {\n      innerWidth,\n      innerHeight\n    } = layout;\n    const aspect = innerHeight / innerWidth;\n    let col = Math.ceil(Math.sqrt(count / aspect));\n    // Increase col to avoid total height of packed shape\n    // being large than height of bbox.\n    let size = innerWidth / col;\n    let row = Math.ceil(count / col);\n    let h0 = row * size;\n    while (h0 > innerHeight) {\n      col = col + 1;\n      size = innerWidth / col;\n      row = Math.ceil(count / col);\n      h0 = row * size;\n    }\n    // Some offset to increase the space usage.\n    const space = innerHeight - row * size;\n    const intervalY = row <= 1 ? 0 : space / (row - 1);\n    const [offsetX, offsetY] = row <= 1 ? [(innerWidth - pcount * size) / (pcount - 1), (innerHeight - size) / 2] : [0, 0];\n    return P.map((points, m) => {\n      const [x, y, width, height] = calcBBox(points);\n      const i = direction === 'col' ? m % col : Math.floor(m / row);\n      const j = direction === 'col' ? Math.floor(m / col) : m % row;\n      const newX = i * size;\n      const newY = (row - j - 1) * size + space;\n      const sx = (size - padding) / width;\n      const sy = (size - padding) / height;\n      // Translate the shape and mark to make sure the center of\n      // shape is overlap before and after scale transformation.\n      const tx = newX - x + offsetX * i + 1 / 2 * padding;\n      const ty = newY - y - intervalY * j - offsetY + 1 / 2 * padding;\n      return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;\n    });\n  };\n}\n/**\n * Uniform pack to avid overlap.\n * @todo Improve or change algorithm to increase space usage.\n * @todo Take some special case into account.\n */\nexport const Pack = options => {\n  return (I, mark) => {\n    return [I, deepMix({}, mark, {\n      modifier: pack(options),\n      axis: false\n    })];\n  };\n};\nPack.props = {};","map":{"version":3,"names":["deepMix","calcBBox","pack","options","padding","direction","P","count","layout","pcount","length","innerWidth","innerHeight","aspect","col","Math","ceil","sqrt","size","row","h0","space","intervalY","offsetX","offsetY","map","points","m","x","y","width","height","i","floor","j","newX","newY","sx","sy","tx","ty","Pack","I","mark","modifier","axis","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/pack.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { calcBBox } from '../utils/vector';\nimport { PackTransform } from '../spec';\n\nexport type PackOptions = Omit<PackTransform, 'type'>;\n\nfunction pack(options: PackOptions) {\n  const { padding = 0, direction = 'col' } = options;\n  return (P, count, layout) => {\n    const pcount = P.length;\n    if (pcount === 0) return [];\n\n    // col * row >= count\n    // row is close to col * aspect, so\n    // col * (col * aspect) >= count\n    const { innerWidth, innerHeight } = layout;\n    const aspect = innerHeight / innerWidth;\n    let col = Math.ceil(Math.sqrt(count / aspect));\n\n    // Increase col to avoid total height of packed shape\n    // being large than height of bbox.\n    let size = innerWidth / col;\n    let row = Math.ceil(count / col);\n    let h0 = row * size;\n    while (h0 > innerHeight) {\n      col = col + 1;\n      size = innerWidth / col;\n      row = Math.ceil(count / col);\n      h0 = row * size;\n    }\n\n    // Some offset to increase the space usage.\n    const space = innerHeight - row * size;\n    const intervalY = row <= 1 ? 0 : space / (row - 1);\n    const [offsetX, offsetY] =\n      row <= 1\n        ? [\n            (innerWidth - pcount * size) / (pcount - 1),\n            (innerHeight - size) / 2,\n          ]\n        : [0, 0];\n\n    return P.map((points, m) => {\n      const [x, y, width, height] = calcBBox(points);\n      const i = direction === 'col' ? m % col : Math.floor(m / row);\n      const j = direction === 'col' ? Math.floor(m / col) : m % row;\n\n      const newX = i * size;\n      const newY = (row - j - 1) * size + space;\n\n      const sx = (size - padding) / width;\n      const sy = (size - padding) / height;\n\n      // Translate the shape and mark to make sure the center of\n      // shape is overlap before and after scale transformation.\n      const tx = newX - x + offsetX * i + (1 / 2) * padding;\n      const ty = newY - y - intervalY * j - offsetY + (1 / 2) * padding;\n      return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;\n    });\n  };\n}\n\n/**\n * Uniform pack to avid overlap.\n * @todo Improve or change algorithm to increase space usage.\n * @todo Take some special case into account.\n */\nexport const Pack: TC<PackOptions> = (options) => {\n  return (I, mark) => {\n    return [I, deepMix({}, mark, { modifier: pack(options), axis: false })];\n  };\n};\n\nPack.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}