{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { path as d3path } from '@antv/vendor/d3-path';\nimport { isPolar } from '../../utils/coordinate';\nimport { applyStyle, appendPolygon, appendArc } from '../utils';\nimport { select } from '../../utils/selection';\nimport { dist } from '../../utils/vector';\nfunction getPolygonPath(points, coordinate) {\n  const path = d3path();\n  // In polar, draw arc.\n  if (isPolar(coordinate)) {\n    const center = coordinate.getCenter();\n    const closedPoints = [...points, points[0]];\n    // Calculate dist array for cache.\n    const dists = closedPoints.map(p => dist(p, center));\n    closedPoints.forEach((curr, idx) => {\n      if (idx === 0) {\n        path.moveTo(curr[0], curr[1]);\n        return;\n      }\n      const currDist = dists[idx];\n      const prev = points[idx - 1];\n      const prevDist = dists[idx - 1];\n      // When radius is equal, draw 2 point with arc.\n      // todo: choose a minimum value.\n      if (prevDist !== undefined && Math.abs(currDist - prevDist) < 1e-10) {\n        appendArc(path, prev, curr, center, currDist);\n      } else {\n        path.lineTo(curr[0], curr[1]);\n      }\n    });\n    path.closePath();\n    return path;\n  }\n  // In rect, draw polygon.\n  return appendPolygon(path, points);\n}\nexport const Polygon = (options, context) => {\n  const {\n    coordinate,\n    document\n  } = context;\n  return (points, value, defaults) => {\n    const {\n        color: defaultColor\n      } = defaults,\n      rest = __rest(defaults, [\"color\"]);\n    const {\n      color = defaultColor,\n      transform\n    } = value;\n    const path = getPolygonPath(points, coordinate);\n    return select(document.createElement('path', {})).call(applyStyle, rest).style('d', path.toString()).style('stroke', color).style('fill', color).style('transform', transform).call(applyStyle, options).node();\n  };\n};\nPolygon.props = {\n  defaultMarker: 'square',\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut'\n};","map":{"version":3,"names":["path","d3path","isPolar","applyStyle","appendPolygon","appendArc","select","dist","getPolygonPath","points","coordinate","center","getCenter","closedPoints","dists","map","p","forEach","curr","idx","moveTo","currDist","prev","prevDist","undefined","Math","abs","lineTo","closePath","Polygon","options","context","document","value","defaults","color","defaultColor","rest","__rest","transform","createElement","call","style","toString","node","props","defaultMarker","defaultEnterAnimation","defaultUpdateAnimation","defaultExitAnimation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/polygon/polygon.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { path as d3path } from '@antv/vendor/d3-path';\nimport { isPolar } from '../../utils/coordinate';\nimport { applyStyle, appendPolygon, appendArc } from '../utils';\nimport { select } from '../../utils/selection';\nimport { dist } from '../../utils/vector';\nimport { ShapeComponent as SC, Vector2 } from '../../runtime';\n\nexport type PolygonOptions = Record<string, any>;\n\nfunction getPolygonPath(points: Vector2[], coordinate: Coordinate) {\n  const path = d3path();\n  // In polar, draw arc.\n  if (isPolar(coordinate)) {\n    const center = coordinate.getCenter();\n    const closedPoints = [...points, points[0]];\n    // Calculate dist array for cache.\n    const dists = closedPoints.map((p) => dist(p, center));\n\n    closedPoints.forEach((curr, idx) => {\n      if (idx === 0) {\n        path.moveTo(curr[0], curr[1]);\n        return;\n      }\n      const currDist = dists[idx];\n      const prev = points[idx - 1];\n      const prevDist = dists[idx - 1];\n\n      // When radius is equal, draw 2 point with arc.\n      // todo: choose a minimum value.\n      if (prevDist !== undefined && Math.abs(currDist - prevDist) < 1e-10) {\n        appendArc(path, prev, curr, center, currDist);\n      } else {\n        path.lineTo(curr[0], curr[1]);\n      }\n    });\n    path.closePath();\n\n    return path;\n  }\n\n  // In rect, draw polygon.\n  return appendPolygon(path, points);\n}\n\nexport const Polygon: SC<PolygonOptions> = (options, context) => {\n  const { coordinate, document } = context;\n  return (points, value, defaults) => {\n    const { color: defaultColor, ...rest } = defaults;\n    const { color = defaultColor, transform } = value;\n    const path = getPolygonPath(points, coordinate);\n    return select(document.createElement('path', {}))\n      .call(applyStyle, rest)\n      .style('d', path.toString())\n      .style('stroke', color)\n      .style('fill', color)\n      .style('transform', transform)\n      .call(applyStyle, options)\n      .node();\n  };\n};\n\nPolygon.props = {\n  defaultMarker: 'square',\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut',\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}