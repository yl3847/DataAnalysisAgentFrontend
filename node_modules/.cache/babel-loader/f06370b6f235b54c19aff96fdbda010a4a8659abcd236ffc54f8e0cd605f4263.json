{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Linear } from '@antv/scale';\nimport { upperFirst } from '@antv/util';\nimport { geoPath, geoGraticule10 } from '@antv/vendor/d3-geo';\nimport { maybeTooltip } from '../utils/mark';\nimport * as d3Projection from './d3Projection';\n/**\n * Get projection factory from d3-projection.\n */\nfunction normalizeProjection(type) {\n  if (typeof type === 'function') return type;\n  const name = `geo${upperFirst(type)}`;\n  const projection = d3Projection[name];\n  if (!projection) throw new Error(`Unknown coordinate: ${type}`);\n  return projection;\n}\n/**\n * @see https://github.com/mapbox/geojson-merge/blob/master/index.js\n */\nfunction mergeGeoJSON(gjs) {\n  return {\n    type: 'FeatureCollection',\n    features: gjs.flatMap(gj => normalizeGeoJSON(gj).features)\n  };\n}\nfunction normalizeGeoJSON(gj) {\n  const types = {\n    Point: 'geometry',\n    MultiPoint: 'geometry',\n    LineString: 'geometry',\n    MultiLineString: 'geometry',\n    Polygon: 'geometry',\n    MultiPolygon: 'geometry',\n    GeometryCollection: 'geometry',\n    Feature: 'feature',\n    FeatureCollection: 'featureCollection'\n  };\n  if (!gj || !gj.type) return null;\n  const type = types[gj.type];\n  if (!type) return null;\n  if (type === 'geometry') {\n    return {\n      type: 'FeatureCollection',\n      features: [{\n        type: 'Feature',\n        properties: {},\n        geometry: gj\n      }]\n    };\n  } else if (type === 'feature') {\n    return {\n      type: 'FeatureCollection',\n      features: [gj]\n    };\n  } else if (type === 'featureCollection') {\n    return gj;\n  }\n}\n/**\n * Specify the options for d3 projection\n * @see https://github.com/d3/d3-geo#projections\n * @todo Specify key each by each.\n */\nfunction setProjectionOptions(projection, options) {\n  var _a;\n  for (const [key, value] of Object.entries(options)) {\n    (_a = projection[key]) === null || _a === void 0 ? void 0 : _a.call(projection, value);\n  }\n}\nfunction setProjectionSize(projection, nodes, layout, options) {\n  const defaultOutline = () => {\n    const geoNodes = nodes.filter(isGeoPath);\n    // For geoPath with sphere mark, use it as outline.\n    const sphere = geoNodes.find(d => d.sphere);\n    if (sphere) return {\n      type: 'Sphere'\n    };\n    // Merge all GeoJSON as the outline.\n    return mergeGeoJSON(geoNodes.filter(d => !d.sphere).flatMap(d => d.data.value));\n  };\n  const {\n    outline = defaultOutline()\n  } = options;\n  const {\n    size = 'fitExtent'\n  } = options;\n  if (size === 'fitExtent') {\n    return setFitExtent(projection, outline, layout);\n  } else if (size === 'fitWidth') {\n    return setFitWidth(projection, outline, layout);\n  }\n}\nfunction setFitExtent(projection, object, layout) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = layout;\n  projection.fitExtent([[x, y], [width, height]], object);\n}\nfunction setFitWidth(projection, object, layout) {\n  const {\n    width,\n    height\n  } = layout;\n  const [[x0, y0], [x1, y1]] = geoPath(projection.fitWidth(width, object)).bounds(object);\n  const dy = Math.ceil(y1 - y0);\n  const l = Math.min(Math.ceil(x1 - x0), dy);\n  const s = projection.scale() * (l - 1) / l;\n  const [tx, ty] = projection.translate();\n  const t = ty + (height - dy) / 2;\n  projection.scale(s).translate([tx, t]).precision(0.2);\n}\n/**\n * @todo Remove this.\n */\nfunction normalizeDataSource(node) {\n  const {\n    data\n  } = node;\n  if (Array.isArray(data)) return Object.assign(Object.assign({}, node), {\n    data: {\n      value: data\n    }\n  });\n  const {\n    type\n  } = data;\n  if (type === 'graticule10') {\n    return Object.assign(Object.assign({}, node), {\n      data: {\n        value: [geoGraticule10()]\n      }\n    });\n  } else if (type === 'sphere') {\n    // Sphere is not a standard type of GeoJSON.\n    // Mark this geoPath as sphere geoPath.\n    return Object.assign(Object.assign({}, node), {\n      sphere: true,\n      data: {\n        value: [{\n          type: 'Sphere'\n        }]\n      }\n    });\n  }\n  return node;\n}\nfunction isGeoPath(d) {\n  return d.type === 'geoPath';\n}\n/**\n * A view with geo coordinate.\n */\nexport const GeoView = () => {\n  return options => {\n    const {\n      children,\n      coordinate: projection = {}\n    } = options;\n    if (!Array.isArray(children)) return [];\n    // Get projection factory.\n    const {\n        type = 'equalEarth'\n      } = projection,\n      projectionOptions = __rest(projection, [\"type\"]);\n    const createProjection = normalizeProjection(type);\n    const nodes = children.map(normalizeDataSource);\n    // Set path generator lazily.\n    let path;\n    // A custom geo coordinate.\n    function Geo() {\n      return [['custom', (x, y, width, height) => {\n        // Create and set projection.\n        const visual = createProjection();\n        const layout = {\n          x,\n          y,\n          width,\n          height\n        };\n        setProjectionSize(visual, nodes, layout, projectionOptions);\n        setProjectionOptions(visual, projectionOptions);\n        // Create path generator.\n        path = geoPath(visual);\n        // Normalize projection and projection.invert,\n        // which normalize projected points.\n        const scaleX = new Linear({\n          domain: [x, x + width]\n        });\n        const scaleY = new Linear({\n          domain: [y, y + height]\n        });\n        const normalize = point => {\n          const visualPoint = visual(point);\n          if (!visualPoint) return [null, null];\n          const [vx, vy] = visualPoint;\n          return [scaleX.map(vx), scaleY.map(vy)];\n        };\n        const normalizeInvert = point => {\n          if (!point) return null;\n          const [px, py] = point;\n          const visualPoint = [scaleX.invert(px), scaleY.invert(py)];\n          return visual.invert(visualPoint);\n        };\n        return {\n          transform: point => normalize(point),\n          untransform: point => normalizeInvert(point)\n        };\n      }]];\n    }\n    function GeoPath(options) {\n      const {\n        style,\n        tooltip = {}\n      } = options;\n      return Object.assign(Object.assign({}, options), {\n        type: 'path',\n        tooltip: maybeTooltip(tooltip, {\n          title: 'id',\n          items: [{\n            channel: 'color'\n          }]\n        }),\n        style: Object.assign(Object.assign({}, style), {\n          d: d => path(d) || []\n        })\n      });\n    }\n    const t = d => isGeoPath(d) ? GeoPath(d) : d;\n    return [Object.assign(Object.assign({}, options), {\n      type: 'view',\n      scale: {\n        x: {\n          type: 'identity'\n        },\n        y: {\n          type: 'identity'\n        }\n      },\n      axis: false,\n      coordinate: {\n        type: Geo\n      },\n      children: nodes.flatMap(t)\n    })];\n  };\n};\nGeoView.props = {};","map":{"version":3,"names":["Linear","upperFirst","geoPath","geoGraticule10","maybeTooltip","d3Projection","normalizeProjection","type","name","projection","Error","mergeGeoJSON","gjs","features","flatMap","gj","normalizeGeoJSON","types","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","GeometryCollection","Feature","FeatureCollection","properties","geometry","setProjectionOptions","options","key","value","Object","entries","_a","call","setProjectionSize","nodes","layout","defaultOutline","geoNodes","filter","isGeoPath","sphere","find","d","data","outline","size","setFitExtent","setFitWidth","object","x","y","width","height","fitExtent","x0","y0","x1","y1","fitWidth","bounds","dy","Math","ceil","l","min","s","scale","tx","ty","translate","t","precision","normalizeDataSource","node","Array","isArray","assign","GeoView","children","coordinate","projectionOptions","__rest","createProjection","map","path","Geo","visual","scaleX","domain","scaleY","normalize","point","visualPoint","vx","vy","normalizeInvert","px","py","invert","transform","untransform","GeoPath","style","tooltip","title","items","channel","axis","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/composition/geoView.ts"],"sourcesContent":["import { Linear } from '@antv/scale';\nimport { upperFirst } from '@antv/util';\nimport { geoPath, geoGraticule10 } from '@antv/vendor/d3-geo';\nimport { maybeTooltip } from '../utils/mark';\nimport { CompositionComponent as CC } from '../runtime';\nimport { GeoViewComposition } from '../spec';\n\nimport * as d3Projection from './d3Projection';\n\n/**\n * Get projection factory from d3-projection.\n */\nfunction normalizeProjection(type: string) {\n  if (typeof type === 'function') return type;\n  const name = `geo${upperFirst(type)}`;\n  const projection = d3Projection[name];\n  if (!projection) throw new Error(`Unknown coordinate: ${type}`);\n  return projection;\n}\n\n/**\n * @see https://github.com/mapbox/geojson-merge/blob/master/index.js\n */\nfunction mergeGeoJSON(gjs) {\n  return {\n    type: 'FeatureCollection',\n    features: gjs.flatMap((gj) => normalizeGeoJSON(gj).features),\n  };\n}\n\nfunction normalizeGeoJSON(gj) {\n  const types = {\n    Point: 'geometry',\n    MultiPoint: 'geometry',\n    LineString: 'geometry',\n    MultiLineString: 'geometry',\n    Polygon: 'geometry',\n    MultiPolygon: 'geometry',\n    GeometryCollection: 'geometry',\n    Feature: 'feature',\n    FeatureCollection: 'featureCollection',\n  };\n  if (!gj || !gj.type) return null;\n  const type = types[gj.type];\n  if (!type) return null;\n  if (type === 'geometry') {\n    return {\n      type: 'FeatureCollection',\n      features: [\n        {\n          type: 'Feature',\n          properties: {},\n          geometry: gj,\n        },\n      ],\n    };\n  } else if (type === 'feature') {\n    return {\n      type: 'FeatureCollection',\n      features: [gj],\n    };\n  } else if (type === 'featureCollection') {\n    return gj;\n  }\n}\n\n/**\n * Specify the options for d3 projection\n * @see https://github.com/d3/d3-geo#projections\n * @todo Specify key each by each.\n */\nfunction setProjectionOptions(projection, options) {\n  for (const [key, value] of Object.entries(options)) {\n    projection[key]?.(value);\n  }\n}\n\nfunction setProjectionSize(projection, nodes, layout, options) {\n  const defaultOutline = () => {\n    const geoNodes = nodes.filter(isGeoPath);\n    // For geoPath with sphere mark, use it as outline.\n    const sphere = geoNodes.find((d) => d.sphere);\n    if (sphere) return { type: 'Sphere' };\n\n    // Merge all GeoJSON as the outline.\n    return mergeGeoJSON(\n      geoNodes.filter((d) => !d.sphere).flatMap((d) => d.data.value),\n    );\n  };\n  const { outline = defaultOutline() } = options;\n  const { size = 'fitExtent' } = options;\n  if (size === 'fitExtent') {\n    return setFitExtent(projection, outline, layout);\n  } else if (size === 'fitWidth') {\n    return setFitWidth(projection, outline, layout);\n  }\n}\n\nfunction setFitExtent(projection, object, layout) {\n  const { x, y, width, height } = layout;\n  projection.fitExtent(\n    [\n      [x, y],\n      [width, height],\n    ],\n    object,\n  );\n}\n\nfunction setFitWidth(projection, object, layout) {\n  const { width, height } = layout;\n  const [[x0, y0], [x1, y1]] = geoPath(\n    projection.fitWidth(width, object),\n  ).bounds(object);\n  const dy = Math.ceil(y1 - y0);\n  const l = Math.min(Math.ceil(x1 - x0), dy);\n  const s = (projection.scale() * (l - 1)) / l;\n  const [tx, ty] = projection.translate();\n  const t = ty + (height - dy) / 2;\n  projection.scale(s).translate([tx, t]).precision(0.2);\n}\n\n/**\n * @todo Remove this.\n */\nfunction normalizeDataSource(node) {\n  const { data } = node;\n  if (Array.isArray(data)) return { ...node, data: { value: data } };\n  const { type } = data;\n  if (type === 'graticule10') {\n    return { ...node, data: { value: [geoGraticule10()] } };\n  } else if (type === 'sphere') {\n    // Sphere is not a standard type of GeoJSON.\n    // Mark this geoPath as sphere geoPath.\n    return { ...node, sphere: true, data: { value: [{ type: 'Sphere' }] } };\n  }\n  return node;\n}\n\nfunction isGeoPath(d) {\n  return d.type === 'geoPath';\n}\n\nexport type GeoViewOptions = Omit<GeoViewComposition, 'type'>;\n\n/**\n * A view with geo coordinate.\n */\nexport const GeoView: CC<GeoViewOptions> = () => {\n  return (options) => {\n    const { children, coordinate: projection = {} } = options;\n    if (!Array.isArray(children)) return [];\n\n    // Get projection factory.\n    const { type = 'equalEarth', ...projectionOptions } = projection;\n    const createProjection = normalizeProjection(type);\n    const nodes = children.map(normalizeDataSource);\n\n    // Set path generator lazily.\n    let path;\n\n    // A custom geo coordinate.\n    function Geo() {\n      return [\n        [\n          'custom',\n          (x, y, width, height) => {\n            // Create and set projection.\n            const visual = createProjection();\n            const layout = { x, y, width, height };\n            setProjectionSize(visual, nodes, layout, projectionOptions);\n            setProjectionOptions(visual, projectionOptions);\n\n            // Create path generator.\n            path = geoPath(visual);\n\n            // Normalize projection and projection.invert,\n            // which normalize projected points.\n            const scaleX = new Linear({\n              domain: [x, x + width],\n            });\n            const scaleY = new Linear({\n              domain: [y, y + height],\n            });\n            const normalize = (point) => {\n              const visualPoint = visual(point);\n              if (!visualPoint) return [null, null];\n              const [vx, vy] = visualPoint;\n              return [scaleX.map(vx), scaleY.map(vy)];\n            };\n            const normalizeInvert = (point) => {\n              if (!point) return null;\n              const [px, py] = point;\n              const visualPoint = [scaleX.invert(px), scaleY.invert(py)];\n              return visual.invert(visualPoint);\n            };\n            return {\n              transform: (point) => normalize(point),\n              untransform: (point) => normalizeInvert(point),\n            };\n          },\n        ],\n      ];\n    }\n\n    function GeoPath(options) {\n      const { style, tooltip = {} } = options;\n      return {\n        ...options,\n        type: 'path',\n        tooltip: maybeTooltip(tooltip, {\n          title: 'id',\n          items: [{ channel: 'color' }],\n        }),\n        style: {\n          ...style,\n          d: (d) => path(d) || [],\n        },\n      };\n    }\n\n    const t = (d) => (isGeoPath(d) ? GeoPath(d) : d);\n\n    return [\n      {\n        ...options,\n        type: 'view',\n        scale: {\n          x: { type: 'identity' },\n          y: { type: 'identity' },\n        },\n        axis: false,\n        coordinate: { type: Geo },\n        children: nodes.flatMap(t),\n      },\n    ];\n  };\n};\n\nGeoView.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}