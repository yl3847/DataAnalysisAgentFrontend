{"ast":null,"code":"import { isEqual, isNumber } from '@antv/util';\nimport { getBBoxHeight, getBBoxSize, getBBoxWidth, getNearestBoundarySide, getNodeBBox } from './bbox';\nimport { isCollapsed } from './collapsibility';\nimport { getAllPorts, getNodeConnectionPoint, getPortConnectionPoint, getPortPosition } from './element';\nimport { idOf } from './id';\nimport { isCollinear, isHorizontal, moveTo, parsePoint } from './point';\nimport { freeJoin } from './router/orth';\nimport { add, distance, manhattanDistance, multiply, normalize, perpendicular, subtract } from './vector';\n/**\n * <zh/> 获取标签的位置样式\n *\n * <en/> Get the style of the label's position\n * @param key - <zh/> 边对象 | <en/> The edge object\n * @param placement - <zh/> 标签位置 | <en/> Position of the label\n * @param autoRotate - <zh/> 是否自动旋转 | <en/> Whether to auto-rotate\n * @param offsetX - <zh/> 标签相对于边的水平偏移量 | <en/> Horizontal offset of the label relative to the edge\n * @param offsetY - <zh/> 标签相对于边的垂直偏移量 | <en/> Vertical offset of the label relative to the edge\n * @returns <zh/> 标签的位置样式 | <en/> Returns the style of the label's position\n */\nexport function getLabelPositionStyle(key, placement, autoRotate, offsetX, offsetY) {\n  const START_RATIO = 0;\n  const MIDDLE_RATIO = 0.5;\n  const END_RATIO = 0.99;\n  let ratio = typeof placement === 'number' ? placement : MIDDLE_RATIO;\n  if (placement === 'start') ratio = START_RATIO;\n  if (placement === 'end') ratio = END_RATIO;\n  const point = parsePoint(key.getPoint(ratio));\n  const pointOffset = parsePoint(key.getPoint(ratio + 0.01));\n  let textAlign = placement === 'start' ? 'left' : placement === 'end' ? 'right' : 'center';\n  if (isHorizontal(point, pointOffset) || !autoRotate) {\n    const [x, y] = getXYByPlacement(key, ratio, offsetX, offsetY);\n    return {\n      transform: [['translate', x, y]],\n      textAlign\n    };\n  }\n  let angle = Math.atan2(pointOffset[1] - point[1], pointOffset[0] - point[0]);\n  const isRevert = pointOffset[0] < point[0];\n  if (isRevert) {\n    textAlign = textAlign === 'center' ? textAlign : textAlign === 'left' ? 'right' : 'left';\n    offsetX *= -1;\n    angle += Math.PI;\n  }\n  const [x, y] = getXYByPlacement(key, ratio, offsetX, offsetY, angle);\n  const transform = [['translate', x, y], ['rotate', angle / Math.PI * 180]];\n  return {\n    textAlign,\n    transform\n  };\n}\n/**\n * <zh/> 获取边上徽标的位置样式\n *\n * <en/> Get the position style of the badge on the edge\n * @param shapeMap - <zh/> 边上的图形映射 | <en/> Shape map on the edge\n * @param placement - <zh/> 徽标位置 | <en/> Badge position\n * @param labelPlacement - <zh/> 标签位置 | <en/> Label position\n * @param offsetX - <zh/> 水平偏移量 | <en/> Horizontal offset\n * @param offsetY - <zh/> 垂直偏移量 | <en/> Vertical offset\n * @returns <zh/> 徽标的位置样式 | <en/> Position style of the badge\n */\nexport function getBadgePositionStyle(shapeMap, placement, labelPlacement, offsetX, offsetY) {\n  var _a, _b;\n  const badgeWidth = ((_a = shapeMap.badge) === null || _a === void 0 ? void 0 : _a.getGeometryBounds().halfExtents[0]) * 2 || 0;\n  const labelWidth = ((_b = shapeMap.label) === null || _b === void 0 ? void 0 : _b.getGeometryBounds().halfExtents[0]) * 2 || 0;\n  return getLabelPositionStyle(shapeMap.key, labelPlacement, true, (labelWidth ? (labelWidth / 2 + badgeWidth / 2) * (placement === 'suffix' ? 1 : -1) : 0) + offsetX, offsetY);\n}\n/**\n * <zh/> 获取给定边上的指定位置的坐标\n *\n * <en/> Get the coordinates at the specified position on the given edge\n * @param key - <zh/> 边实例 | <en/> Edge instance\n * @param ratio - <zh/> 位置比率 | <en/> Position ratio\n * @param offsetX - <zh/> 水平偏移量 | <en/> Horizontal offset\n * @param offsetY - <zh/> 垂直偏移量 | <en/> Vertical offset\n * @param angle - <zh/> 旋转角度 | <en/> Rotation angle\n * @returns <zh/> 坐标 | <en/> Coordinates\n */\nfunction getXYByPlacement(key, ratio, offsetX, offsetY, angle) {\n  const [pointX, pointY] = parsePoint(key.getPoint(ratio));\n  let actualOffsetX = offsetX;\n  let actualOffsetY = offsetY;\n  if (angle) {\n    actualOffsetX = offsetX * Math.cos(angle) - offsetY * Math.sin(angle);\n    actualOffsetY = offsetX * Math.sin(angle) + offsetY * Math.cos(angle);\n  }\n  return [pointX + actualOffsetX, pointY + actualOffsetY];\n}\n/** ==================== Curve Edge =========================== */\n/**\n * <zh/> 计算曲线的控制点\n *\n * <en/> Calculate the control point of the curve\n * @param sourcePoint - <zh/> 起点 | <en/> Source point\n * @param targetPoint - <zh/> 终点 | <en/> Target point\n * @param curvePosition - <zh/> 控制点在连线上的相对位置（取值范围为 0-1） | <en/> The relative position of the control point on the line (value range from 0 to 1)\n * @param curveOffset - <zh/> 控制点距离两端点连线的距离 | <en/> The distance between the control point and the line\n * @returns <zh/> 控制点 | <en/> Control points\n */\nexport function getCurveControlPoint(sourcePoint, targetPoint, curvePosition, curveOffset) {\n  if (isEqual(sourcePoint, targetPoint)) return sourcePoint;\n  const lineVector = subtract(targetPoint, sourcePoint);\n  const controlPoint = [sourcePoint[0] + curvePosition * lineVector[0], sourcePoint[1] + curvePosition * lineVector[1]];\n  const perpVector = normalize(perpendicular(lineVector, false));\n  controlPoint[0] += curveOffset * perpVector[0];\n  controlPoint[1] += curveOffset * perpVector[1];\n  return controlPoint;\n}\n/**\n * <zh/> 解析控制点距离两端点连线的距离 `curveOffset`\n *\n * <en/> parse the distance of the control point from the line `curveOffset`\n * @param curveOffset - <zh/> curveOffset | <en/> curveOffset\n * @returns <zh/> 标准 curveOffset | <en/> standard curveOffset\n */\nexport function parseCurveOffset(curveOffset) {\n  if (isNumber(curveOffset)) return [curveOffset, -curveOffset];\n  return curveOffset;\n}\n/**\n * <zh/> 解析控制点在两端点连线上的相对位置 `curvePosition`，范围为`0-1`\n *\n * <en/> parse the relative position of the control point on the line `curvePosition`\n * @param curvePosition - <zh/> curvePosition | <en/> curvePosition\n * @returns <zh/> 标准 curvePosition | <en/> standard curvePosition\n */\nexport function parseCurvePosition(curvePosition) {\n  if (isNumber(curvePosition)) return [curvePosition, 1 - curvePosition];\n  return curvePosition;\n}\n/**\n * <zh/> 获取二次贝塞尔曲线绘制路径\n *\n * <en/> Calculate the path for drawing a quadratic Bessel curve\n * @param sourcePoint - <zh/> 边的起点 | <en/> Source point\n * @param targetPoint - <zh/> 边的终点 | <en/> Target point\n * @param controlPoint - <zh/> 控制点 | <en/> Control point\n * @returns <zh/> 返回绘制曲线的路径 | <en/> Returns curve path\n */\nexport function getQuadraticPath(sourcePoint, targetPoint, controlPoint) {\n  return [['M', sourcePoint[0], sourcePoint[1]], ['Q', controlPoint[0], controlPoint[1], targetPoint[0], targetPoint[1]]];\n}\n/**\n * <zh/> 获取三次贝塞尔曲线绘制路径\n *\n * <en/> Calculate the path for drawing a cubic Bessel curve\n * @param sourcePoint - <zh/> 边的起点 | <en/> Source point\n * @param targetPoint - <zh/> 边的终点 | <en/> Target point\n * @param controlPoints - <zh/> 控制点 | <en/> Control point\n * @returns <zh/> 返回绘制曲线的路径 | <en/> Returns curve path\n */\nexport function getCubicPath(sourcePoint, targetPoint, controlPoints) {\n  return [['M', sourcePoint[0], sourcePoint[1]], ['C', controlPoints[0][0], controlPoints[0][1], controlPoints[1][0], controlPoints[1][1], targetPoint[0], targetPoint[1]]];\n}\n/** ==================== Polyline Edge =========================== */\n/**\n * <zh/> 获取折线的绘制路径\n *\n * <en/> Calculates the path for drawing a polyline\n * @param points - <zh/> 折线的顶点 | <en/> The vertices of the polyline\n * @param radius - <zh/> 圆角半径 | <en/> Radius of the rounded corner\n * @param z - <zh/> 路径是否闭合 | <en/> Whether the path is closed\n * @returns <zh/> 返回绘制折线的路径 | <en/> Returns the path for drawing a polyline\n */\nexport function getPolylinePath(points, radius = 0, z = false) {\n  const targetIndex = points.length - 1;\n  const sourcePoint = points[0];\n  const targetPoint = points[targetIndex];\n  const controlPoints = points.slice(1, targetIndex);\n  const pathArray = [['M', sourcePoint[0], sourcePoint[1]]];\n  controlPoints.forEach((midPoint, i) => {\n    const prevPoint = controlPoints[i - 1] || sourcePoint;\n    const nextPoint = controlPoints[i + 1] || targetPoint;\n    if (!isCollinear(prevPoint, midPoint, nextPoint) && radius) {\n      const [ps, pt] = getBorderRadiusPoints(prevPoint, midPoint, nextPoint, radius);\n      pathArray.push(['L', ps[0], ps[1]], ['Q', midPoint[0], midPoint[1], pt[0], pt[1]], ['L', pt[0], pt[1]]);\n    } else {\n      pathArray.push(['L', midPoint[0], midPoint[1]]);\n    }\n  });\n  pathArray.push(['L', targetPoint[0], targetPoint[1]]);\n  if (z) pathArray.push(['Z']);\n  return pathArray;\n}\n/**\n * <zh/> 根据给定的半径计算出不共线的三点生成贝塞尔曲线的控制点，以模拟接近圆弧\n *\n * <en/> Calculates the control points of the Bezier curve generated by three non-collinear points according to the given radius to simulate an arc\n * @param prevPoint - <zh/> 前一个点 | <en/> Previous point\n * @param midPoint - <zh/> 中间点 | <en/> Middle point\n * @param nextPoint - <zh/> 后一个点 | <en/> Next point\n * @param radius - <zh/> 圆角半径 | <en/> Radius of the rounded corner\n * @returns <zh/> 返回控制点 | <en/> Returns control points\n */\nexport function getBorderRadiusPoints(prevPoint, midPoint, nextPoint, radius) {\n  const d0 = manhattanDistance(prevPoint, midPoint);\n  const d1 = manhattanDistance(nextPoint, midPoint);\n  // 取给定的半径和最小半径之间的较小值 | use the smaller value between the given radius and the minimum radius\n  const r = Math.min(radius, Math.min(d0, d1) / 2);\n  const ps = [midPoint[0] - r / d0 * (midPoint[0] - prevPoint[0]), midPoint[1] - r / d0 * (midPoint[1] - prevPoint[1])];\n  const pt = [midPoint[0] - r / d1 * (midPoint[0] - nextPoint[0]), midPoint[1] - r / d1 * (midPoint[1] - nextPoint[1])];\n  return [ps, pt];\n}\n/** ==================== Loop Edge =========================== */\nexport const getRadians = bbox => {\n  const halfPI = Math.PI / 2;\n  const halfHeight = getBBoxHeight(bbox) / 2;\n  const halfWidth = getBBoxWidth(bbox) / 2;\n  const angleWithX = Math.atan2(halfHeight, halfWidth) / 2;\n  const angleWithY = Math.atan2(halfWidth, halfHeight) / 2;\n  return {\n    top: [-halfPI - angleWithY, -halfPI + angleWithY],\n    'top-right': [-halfPI + angleWithY, -angleWithX],\n    'right-top': [-halfPI + angleWithY, -angleWithX],\n    right: [-angleWithX, angleWithX],\n    'bottom-right': [angleWithX, halfPI - angleWithY],\n    'right-bottom': [angleWithX, halfPI - angleWithY],\n    bottom: [halfPI - angleWithY, halfPI + angleWithY],\n    'bottom-left': [halfPI + angleWithY, Math.PI - angleWithX],\n    'left-bottom': [halfPI + angleWithY, Math.PI - angleWithX],\n    left: [Math.PI - angleWithX, Math.PI + angleWithX],\n    'top-left': [Math.PI + angleWithX, -halfPI - angleWithY],\n    'left-top': [Math.PI + angleWithX, -halfPI - angleWithY]\n  };\n};\n/**\n * <zh/> 获取环形边的起点和终点\n *\n * <en/> Get the start and end points of the loop edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param placement - <zh/> 环形边相对于节点位置 | <en/> Loop position relative to the node\n * @param clockwise - <zh/> 是否顺时针 | <en/> Whether to draw the loop clockwise\n * @param sourcePort - <zh/> 起点连接桩 | <en/> Source port\n * @param targetPort - <zh/> 终点连接桩 | <en/> Target port\n * @returns <zh/> 起点和终点 | <en/> Start and end points\n */\nexport function getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort) {\n  const bbox = getNodeBBox(node);\n  const center = node.getCenter();\n  let sourcePoint = sourcePort && getPortPosition(sourcePort);\n  let targetPoint = targetPort && getPortPosition(targetPort);\n  if (!sourcePoint || !targetPoint) {\n    const radians = getRadians(bbox);\n    const angle1 = radians[placement][0];\n    const angle2 = radians[placement][1];\n    const [width, height] = getBBoxSize(bbox);\n    const r = Math.max(width, height);\n    const point1 = add(center, [r * Math.cos(angle1), r * Math.sin(angle1), 0]);\n    const point2 = add(center, [r * Math.cos(angle2), r * Math.sin(angle2), 0]);\n    sourcePoint = getNodeConnectionPoint(node, point1);\n    targetPoint = getNodeConnectionPoint(node, point2);\n    if (!clockwise) {\n      [sourcePoint, targetPoint] = [targetPoint, sourcePoint];\n    }\n  }\n  return [sourcePoint, targetPoint];\n}\n/**\n * <zh/> 获取环形边的绘制路径\n *\n * <en/> Get the path of the loop edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param placement - <zh/> 环形边相对于节点位置 | <en/> Loop position relative to the node\n * @param clockwise - <zh/> 是否顺时针 | <en/> Whether to draw the loop clockwise\n * @param dist - <zh/> 从节点 keyShape 边缘到自环顶部的距离 | <en/> The distance from the edge of the node keyShape to the top of the self-loop\n * @param sourcePortKey - <zh/> 起点连接桩 key | <en/> Source port key\n * @param targetPortKey - <zh/> 终点连接桩 key | <en/> Target port key\n * @returns <zh/> 返回绘制环形边的路径 | <en/> Returns the path of the loop edge\n */\nexport function getCubicLoopPath(node, placement, clockwise, dist, sourcePortKey, targetPortKey) {\n  const sourcePort = node.getPorts()[sourcePortKey || targetPortKey];\n  const targetPort = node.getPorts()[targetPortKey || sourcePortKey];\n  // 1. 获取起点和终点 | Get the start and end points\n  let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);\n  // 2. 获取控制点 | Get the control points\n  const controlPoints = getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist);\n  // 3. 如果定义了连接桩，调整端点以与连接桩边界相交 | If the port is defined, adjust the endpoint to intersect with the port boundary\n  if (sourcePort) sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);\n  if (targetPort) targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1));\n  return getCubicPath(sourcePoint, targetPoint, controlPoints);\n}\n/**\n * <zh/> 获取环形边的控制点\n *\n * <en/> Get the control points of the loop edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param sourcePoint - <zh/> 起点 | <en/> Source point\n * @param targetPoint - <zh/> 终点 | <en/> Target point\n * @param dist - <zh/> 从节点 keyShape 边缘到自环顶部的距离 | <en/> The distance from the edge of the node keyShape to the top of the self-loop\n * @returns <zh/> 控制点 | <en/> Control points\n */\nexport function getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist) {\n  const center = node.getCenter();\n  if (isEqual(sourcePoint, targetPoint)) {\n    const direction = subtract(sourcePoint, center);\n    const adjustment = [dist * Math.sign(direction[0]) || dist / 2, dist * Math.sign(direction[1]) || -dist / 2, 0];\n    return [add(sourcePoint, adjustment), add(targetPoint, multiply(adjustment, [1, -1, 1]))];\n  }\n  return [moveTo(center, sourcePoint, distance(center, sourcePoint) + dist), moveTo(center, targetPoint, distance(center, targetPoint) + dist)];\n}\n/**\n * <zh/> 获取环形折线边的绘制路径\n *\n * <en/> Get the path of the loop polyline edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param radius - <zh/> 圆角半径 | <en/> Radius of the rounded corner\n * @param placement - <zh/> 环形边相对于节点位置 | <en/> Loop position relative to the node\n * @param clockwise - <zh/> 是否顺时针 | <en/> Whether to draw the loop clockwise\n * @param dist - <zh/> 从节点 keyShape 边缘到自环顶部的距离 | <en/> The distance from the edge of the node keyShape to the top of the self-loop\n * @param sourcePortKey - <zh/> 起点连接桩 key | <en/> Source port key\n * @param targetPortKey - <zh/> 终点连接桩 key | <en/> Target port key\n * @returns <zh/> 返回绘制环形折线边的路径 | <en/> Returns the path of the loop polyline edge\n */\nexport function getPolylineLoopPath(node, radius, placement, clockwise, dist, sourcePortKey, targetPortKey) {\n  const allPortsMap = getAllPorts(node);\n  const sourcePort = allPortsMap[sourcePortKey || targetPortKey];\n  const targetPort = allPortsMap[targetPortKey || sourcePortKey];\n  // 1. 获取起点和终点 | Get the start and end points\n  let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);\n  // 2. 获取控制点 | Get the control points\n  const controlPoints = getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist);\n  // 3. 如果定义了连接桩，调整端点以与连接桩边界相交 | If the port is defined, adjust the endpoint to intersect with the port boundary\n  if (sourcePort) sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);\n  if (targetPort) targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1));\n  return getPolylinePath([sourcePoint, ...controlPoints, targetPoint], radius);\n}\n/**\n * <zh/> 获取环形折线边的控制点\n *\n * <en/> Get the control points of the loop polyline edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param sourcePoint - <zh/> 起点 | <en/> Source point\n * @param targetPoint - <zh/> 终点 | <en/> Target point\n * @param dist - <zh/> 从节点 keyShape 边缘到自环顶部的距离 | <en/> The distance from the edge of the node keyShape to the top of the self-loop\n * @returns <zh/> 控制点 | <en/> Control points\n */\nexport function getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist) {\n  const controlPoints = [];\n  const bbox = getNodeBBox(node);\n  // 1. 起点和终点相同 | The start and end points are the same\n  if (isEqual(sourcePoint, targetPoint)) {\n    const side = getNearestBoundarySide(sourcePoint, bbox);\n    switch (side) {\n      case 'left':\n        controlPoints.push([sourcePoint[0] - dist, sourcePoint[1]]);\n        controlPoints.push([sourcePoint[0] - dist, sourcePoint[1] + dist]);\n        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);\n        break;\n      case 'right':\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] + dist]);\n        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);\n        break;\n      case 'top':\n        controlPoints.push([sourcePoint[0], sourcePoint[1] - dist]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] - dist]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);\n        break;\n      case 'bottom':\n        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] + dist]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);\n        break;\n    }\n  } else {\n    const sourceSide = getNearestBoundarySide(sourcePoint, bbox);\n    const targetSide = getNearestBoundarySide(targetPoint, bbox);\n    // 2. 起点与终点同边 | The start and end points are on the same side\n    if (sourceSide === targetSide) {\n      const side = sourceSide;\n      let x, y;\n      switch (side) {\n        case 'left':\n          x = Math.min(sourcePoint[0], targetPoint[0]) - dist;\n          controlPoints.push([x, sourcePoint[1]]);\n          controlPoints.push([x, targetPoint[1]]);\n          break;\n        case 'right':\n          x = Math.max(sourcePoint[0], targetPoint[0]) + dist;\n          controlPoints.push([x, sourcePoint[1]]);\n          controlPoints.push([x, targetPoint[1]]);\n          break;\n        case 'top':\n          y = Math.min(sourcePoint[1], targetPoint[1]) - dist;\n          controlPoints.push([sourcePoint[0], y]);\n          controlPoints.push([targetPoint[0], y]);\n          break;\n        case 'bottom':\n          y = Math.max(sourcePoint[1], targetPoint[1]) + dist;\n          controlPoints.push([sourcePoint[0], y]);\n          controlPoints.push([targetPoint[0], y]);\n          break;\n      }\n    } else {\n      // 3. 起点与终点不同边 | The start and end points are on different sides\n      const getPointOffSide = (side, point) => {\n        return {\n          left: [point[0] - dist, point[1]],\n          right: [point[0] + dist, point[1]],\n          top: [point[0], point[1] - dist],\n          bottom: [point[0], point[1] + dist]\n        }[side];\n      };\n      const p1 = getPointOffSide(sourceSide, sourcePoint);\n      const p2 = getPointOffSide(targetSide, targetPoint);\n      const p3 = freeJoin(p1, p2, bbox);\n      controlPoints.push(p1, p3, p2);\n    }\n  }\n  return controlPoints;\n}\n/**\n * <zh/> 获取子图内的所有边，并按照内部边和外部边分组\n *\n * <en/> Get all the edges in the subgraph and group them into internal and external edges\n * @param ids - <zh/> 节点 ID 数组 | <en/> Node ID array\n * @param getRelatedEdges - <zh/> 获取节点邻边 | <en/> Get node edges\n * @returns <zh/> 子图边 | <en/> Subgraph edges\n */\nexport function getSubgraphRelatedEdges(ids, getRelatedEdges) {\n  const edges = new Set();\n  const internal = new Set();\n  const external = new Set();\n  ids.forEach(id => {\n    const relatedEdges = getRelatedEdges(id);\n    relatedEdges.forEach(edge => {\n      edges.add(edge);\n      if (ids.includes(edge.source) && ids.includes(edge.target)) internal.add(edge);else external.add(edge);\n    });\n  });\n  return {\n    edges: Array.from(edges),\n    internal: Array.from(internal),\n    external: Array.from(external)\n  };\n}\n/**\n * <zh/> 获取边的实际连接节点\n *\n * <en/> Get the actual connected object of the edge\n * @param node - <zh/> 逻辑连接节点数据 | <en/> Logical connection node data\n * @param getParentData - <zh/> 获取父节点数据 | <en/> Get parent node data\n * @returns <zh/> 实际连接节点数据 | <en/> Actual connected node data\n */\nexport function findActualConnectNodeData(node, getParentData) {\n  const path = [];\n  let current = node;\n  while (current) {\n    path.push(current);\n    const parent = getParentData(idOf(current));\n    if (parent) current = parent;else break;\n  }\n  if (path.some(n => {\n    var _a;\n    return (_a = n.style) === null || _a === void 0 ? void 0 : _a.collapsed;\n  })) {\n    const index = path.reverse().findIndex(isCollapsed);\n    return path[index] || path.at(-1);\n  }\n  return node;\n}\n/**\n * <zh/> 获取箭头大小，若用户未指定，则根据线宽自动计算\n *\n * <en/> Get the size of the arrow\n * @param lineWidth - <zh/> 箭头所在边的线宽 | <en/> The line width of the edge where the arrow is located\n * @param size - <zh/> 自定义箭头大小 | <en/> Custom arrow size\n * @returns <zh/> 箭头大小 | <en/> Arrow size\n */\nexport function getArrowSize(lineWidth, size) {\n  if (size) return size;\n  if (lineWidth < 4) return 10;\n  if (lineWidth === 4) return 12;\n  return lineWidth * 2.5;\n}","map":{"version":3,"names":["isEqual","isNumber","getBBoxHeight","getBBoxSize","getBBoxWidth","getNearestBoundarySide","getNodeBBox","isCollapsed","getAllPorts","getNodeConnectionPoint","getPortConnectionPoint","getPortPosition","idOf","isCollinear","isHorizontal","moveTo","parsePoint","freeJoin","add","distance","manhattanDistance","multiply","normalize","perpendicular","subtract","getLabelPositionStyle","key","placement","autoRotate","offsetX","offsetY","START_RATIO","MIDDLE_RATIO","END_RATIO","ratio","point","getPoint","pointOffset","textAlign","x","y","getXYByPlacement","transform","angle","Math","atan2","isRevert","PI","getBadgePositionStyle","shapeMap","labelPlacement","badgeWidth","_a","badge","getGeometryBounds","halfExtents","labelWidth","_b","label","pointX","pointY","actualOffsetX","actualOffsetY","cos","sin","getCurveControlPoint","sourcePoint","targetPoint","curvePosition","curveOffset","lineVector","controlPoint","perpVector","parseCurveOffset","parseCurvePosition","getQuadraticPath","getCubicPath","controlPoints","getPolylinePath","points","radius","z","targetIndex","length","slice","pathArray","forEach","midPoint","i","prevPoint","nextPoint","ps","pt","getBorderRadiusPoints","push","d0","d1","r","min","getRadians","bbox","halfPI","halfHeight","halfWidth","angleWithX","angleWithY","top","right","bottom","left","getLoopEndpoints","node","clockwise","sourcePort","targetPort","center","getCenter","radians","angle1","angle2","width","height","max","point1","point2","getCubicLoopPath","dist","sourcePortKey","targetPortKey","getPorts","getCubicLoopControlPoints","at","direction","adjustment","sign","getPolylineLoopPath","allPortsMap","getPolylineLoopControlPoints","side","sourceSide","targetSide","getPointOffSide","p1","p2","p3","getSubgraphRelatedEdges","ids","getRelatedEdges","edges","Set","internal","external","id","relatedEdges","edge","includes","source","target","Array","from","findActualConnectNodeData","getParentData","path","current","parent","some","n","style","collapsed","index","reverse","findIndex","getArrowSize","lineWidth","size"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/edge.ts"],"sourcesContent":["import type { AABB, DisplayObject, TransformArray } from '@antv/g';\nimport type { PathArray } from '@antv/util';\nimport { isEqual, isNumber } from '@antv/util';\nimport type { EdgeData } from '../spec';\nimport type {\n  EdgeBadgeStyleProps,\n  EdgeKey,\n  EdgeLabelStyleProps,\n  ID,\n  LoopPlacement,\n  Node,\n  NodeLikeData,\n  Point,\n  Port,\n  Size,\n  Vector2,\n} from '../types';\nimport { getBBoxHeight, getBBoxSize, getBBoxWidth, getNearestBoundarySide, getNodeBBox } from './bbox';\nimport { isCollapsed } from './collapsibility';\nimport { getAllPorts, getNodeConnectionPoint, getPortConnectionPoint, getPortPosition } from './element';\nimport { idOf } from './id';\nimport { isCollinear, isHorizontal, moveTo, parsePoint } from './point';\nimport { freeJoin } from './router/orth';\nimport { add, distance, manhattanDistance, multiply, normalize, perpendicular, subtract } from './vector';\n\n/**\n * <zh/> 获取标签的位置样式\n *\n * <en/> Get the style of the label's position\n * @param key - <zh/> 边对象 | <en/> The edge object\n * @param placement - <zh/> 标签位置 | <en/> Position of the label\n * @param autoRotate - <zh/> 是否自动旋转 | <en/> Whether to auto-rotate\n * @param offsetX - <zh/> 标签相对于边的水平偏移量 | <en/> Horizontal offset of the label relative to the edge\n * @param offsetY - <zh/> 标签相对于边的垂直偏移量 | <en/> Vertical offset of the label relative to the edge\n * @returns <zh/> 标签的位置样式 | <en/> Returns the style of the label's position\n */\nexport function getLabelPositionStyle(\n  key: EdgeKey,\n  placement: EdgeLabelStyleProps['placement'],\n  autoRotate: boolean,\n  offsetX: number,\n  offsetY: number,\n): Partial<EdgeLabelStyleProps> {\n  const START_RATIO = 0;\n  const MIDDLE_RATIO = 0.5;\n  const END_RATIO = 0.99;\n\n  let ratio = typeof placement === 'number' ? placement : MIDDLE_RATIO;\n  if (placement === 'start') ratio = START_RATIO;\n  if (placement === 'end') ratio = END_RATIO;\n\n  const point = parsePoint(key.getPoint(ratio));\n  const pointOffset = parsePoint(key.getPoint(ratio + 0.01));\n\n  let textAlign: 'left' | 'right' | 'center' =\n    placement === 'start' ? 'left' : placement === 'end' ? 'right' : 'center';\n\n  if (isHorizontal(point, pointOffset) || !autoRotate) {\n    const [x, y] = getXYByPlacement(key, ratio, offsetX, offsetY);\n    return { transform: [['translate', x, y]], textAlign };\n  }\n\n  let angle = Math.atan2(pointOffset[1] - point[1], pointOffset[0] - point[0]);\n\n  const isRevert = pointOffset[0] < point[0];\n  if (isRevert) {\n    textAlign = textAlign === 'center' ? textAlign : textAlign === 'left' ? 'right' : 'left';\n    offsetX! *= -1;\n    angle += Math.PI;\n  }\n\n  const [x, y] = getXYByPlacement(key, ratio, offsetX, offsetY, angle);\n  const transform: TransformArray = [\n    ['translate', x, y],\n    ['rotate', (angle / Math.PI) * 180],\n  ];\n\n  return {\n    textAlign,\n    transform,\n  };\n}\n\n/**\n * <zh/> 获取边上徽标的位置样式\n *\n * <en/> Get the position style of the badge on the edge\n * @param shapeMap - <zh/> 边上的图形映射 | <en/> Shape map on the edge\n * @param placement - <zh/> 徽标位置 | <en/> Badge position\n * @param labelPlacement - <zh/> 标签位置 | <en/> Label position\n * @param offsetX - <zh/> 水平偏移量 | <en/> Horizontal offset\n * @param offsetY - <zh/> 垂直偏移量 | <en/> Vertical offset\n * @returns <zh/> 徽标的位置样式 | <en/> Position style of the badge\n */\nexport function getBadgePositionStyle(\n  shapeMap: Record<string, DisplayObject<any, any>>,\n  placement: EdgeBadgeStyleProps['placement'],\n  labelPlacement: EdgeLabelStyleProps['placement'],\n  offsetX: number,\n  offsetY: number,\n) {\n  const badgeWidth = shapeMap.badge?.getGeometryBounds().halfExtents[0] * 2 || 0;\n  const labelWidth = shapeMap.label?.getGeometryBounds().halfExtents[0] * 2 || 0;\n\n  return getLabelPositionStyle(\n    shapeMap.key as EdgeKey,\n    labelPlacement,\n    true,\n    (labelWidth ? (labelWidth / 2 + badgeWidth / 2) * (placement === 'suffix' ? 1 : -1) : 0) + offsetX,\n    offsetY,\n  );\n}\n\n/**\n * <zh/> 获取给定边上的指定位置的坐标\n *\n * <en/> Get the coordinates at the specified position on the given edge\n * @param key - <zh/> 边实例 | <en/> Edge instance\n * @param ratio - <zh/> 位置比率 | <en/> Position ratio\n * @param offsetX - <zh/> 水平偏移量 | <en/> Horizontal offset\n * @param offsetY - <zh/> 垂直偏移量 | <en/> Vertical offset\n * @param angle - <zh/> 旋转角度 | <en/> Rotation angle\n * @returns <zh/> 坐标 | <en/> Coordinates\n */\nfunction getXYByPlacement(key: EdgeKey, ratio: number, offsetX: number, offsetY: number, angle?: number) {\n  const [pointX, pointY] = parsePoint(key.getPoint(ratio));\n  let actualOffsetX = offsetX;\n  let actualOffsetY = offsetY;\n\n  if (angle) {\n    actualOffsetX = offsetX * Math.cos(angle) - offsetY * Math.sin(angle);\n    actualOffsetY = offsetX * Math.sin(angle) + offsetY * Math.cos(angle);\n  }\n\n  return [pointX + actualOffsetX, pointY + actualOffsetY];\n}\n\n/** ==================== Curve Edge =========================== */\n\n/**\n * <zh/> 计算曲线的控制点\n *\n * <en/> Calculate the control point of the curve\n * @param sourcePoint - <zh/> 起点 | <en/> Source point\n * @param targetPoint - <zh/> 终点 | <en/> Target point\n * @param curvePosition - <zh/> 控制点在连线上的相对位置（取值范围为 0-1） | <en/> The relative position of the control point on the line (value range from 0 to 1)\n * @param curveOffset - <zh/> 控制点距离两端点连线的距离 | <en/> The distance between the control point and the line\n * @returns <zh/> 控制点 | <en/> Control points\n */\nexport function getCurveControlPoint(\n  sourcePoint: Point,\n  targetPoint: Point,\n  curvePosition: number,\n  curveOffset: number,\n): Point {\n  if (isEqual(sourcePoint, targetPoint)) return sourcePoint;\n  const lineVector = subtract(targetPoint, sourcePoint);\n  const controlPoint: Point = [\n    sourcePoint[0] + curvePosition * lineVector[0],\n    sourcePoint[1] + curvePosition * lineVector[1],\n  ];\n  const perpVector = normalize(perpendicular(lineVector as Vector2, false));\n  controlPoint[0] += curveOffset * perpVector[0];\n  controlPoint[1] += curveOffset * perpVector[1];\n  return controlPoint;\n}\n\n/**\n * <zh/> 解析控制点距离两端点连线的距离 `curveOffset`\n *\n * <en/> parse the distance of the control point from the line `curveOffset`\n * @param curveOffset - <zh/> curveOffset | <en/> curveOffset\n * @returns <zh/> 标准 curveOffset | <en/> standard curveOffset\n */\nexport function parseCurveOffset(curveOffset: number | [number, number]): [number, number] {\n  if (isNumber(curveOffset)) return [curveOffset, -curveOffset];\n  return curveOffset;\n}\n\n/**\n * <zh/> 解析控制点在两端点连线上的相对位置 `curvePosition`，范围为`0-1`\n *\n * <en/> parse the relative position of the control point on the line `curvePosition`\n * @param curvePosition - <zh/> curvePosition | <en/> curvePosition\n * @returns <zh/> 标准 curvePosition | <en/> standard curvePosition\n */\nexport function parseCurvePosition(curvePosition: number | [number, number]): [number, number] {\n  if (isNumber(curvePosition)) return [curvePosition, 1 - curvePosition];\n  return curvePosition;\n}\n\n/**\n * <zh/> 获取二次贝塞尔曲线绘制路径\n *\n * <en/> Calculate the path for drawing a quadratic Bessel curve\n * @param sourcePoint - <zh/> 边的起点 | <en/> Source point\n * @param targetPoint - <zh/> 边的终点 | <en/> Target point\n * @param controlPoint - <zh/> 控制点 | <en/> Control point\n * @returns <zh/> 返回绘制曲线的路径 | <en/> Returns curve path\n */\nexport function getQuadraticPath(sourcePoint: Point, targetPoint: Point, controlPoint: Point): PathArray {\n  return [\n    ['M', sourcePoint[0], sourcePoint[1]],\n    ['Q', controlPoint[0], controlPoint[1], targetPoint[0], targetPoint[1]],\n  ];\n}\n\n/**\n * <zh/> 获取三次贝塞尔曲线绘制路径\n *\n * <en/> Calculate the path for drawing a cubic Bessel curve\n * @param sourcePoint - <zh/> 边的起点 | <en/> Source point\n * @param targetPoint - <zh/> 边的终点 | <en/> Target point\n * @param controlPoints - <zh/> 控制点 | <en/> Control point\n * @returns <zh/> 返回绘制曲线的路径 | <en/> Returns curve path\n */\nexport function getCubicPath(sourcePoint: Point, targetPoint: Point, controlPoints: [Point, Point]): PathArray {\n  return [\n    ['M', sourcePoint[0], sourcePoint[1]],\n    [\n      'C',\n      controlPoints[0][0],\n      controlPoints[0][1],\n      controlPoints[1][0],\n      controlPoints[1][1],\n      targetPoint[0],\n      targetPoint[1],\n    ],\n  ];\n}\n\n/** ==================== Polyline Edge =========================== */\n\n/**\n * <zh/> 获取折线的绘制路径\n *\n * <en/> Calculates the path for drawing a polyline\n * @param points - <zh/> 折线的顶点 | <en/> The vertices of the polyline\n * @param radius - <zh/> 圆角半径 | <en/> Radius of the rounded corner\n * @param z - <zh/> 路径是否闭合 | <en/> Whether the path is closed\n * @returns <zh/> 返回绘制折线的路径 | <en/> Returns the path for drawing a polyline\n */\nexport function getPolylinePath(points: Point[], radius = 0, z = false): PathArray {\n  const targetIndex = points.length - 1;\n  const sourcePoint = points[0];\n  const targetPoint = points[targetIndex];\n  const controlPoints = points.slice(1, targetIndex);\n  const pathArray: PathArray = [['M', sourcePoint[0], sourcePoint[1]]];\n  controlPoints.forEach((midPoint, i) => {\n    const prevPoint = controlPoints[i - 1] || sourcePoint;\n    const nextPoint = controlPoints[i + 1] || targetPoint;\n    if (!isCollinear(prevPoint, midPoint, nextPoint) && radius) {\n      const [ps, pt] = getBorderRadiusPoints(prevPoint, midPoint, nextPoint, radius);\n      pathArray.push(['L', ps[0], ps[1]], ['Q', midPoint[0], midPoint[1], pt[0], pt[1]], ['L', pt[0], pt[1]]);\n    } else {\n      pathArray.push(['L', midPoint[0], midPoint[1]]);\n    }\n  });\n  pathArray.push(['L', targetPoint[0], targetPoint[1]]);\n  if (z) pathArray.push(['Z']);\n  return pathArray;\n}\n\n/**\n * <zh/> 根据给定的半径计算出不共线的三点生成贝塞尔曲线的控制点，以模拟接近圆弧\n *\n * <en/> Calculates the control points of the Bezier curve generated by three non-collinear points according to the given radius to simulate an arc\n * @param prevPoint - <zh/> 前一个点 | <en/> Previous point\n * @param midPoint - <zh/> 中间点 | <en/> Middle point\n * @param nextPoint - <zh/> 后一个点 | <en/> Next point\n * @param radius - <zh/> 圆角半径 | <en/> Radius of the rounded corner\n * @returns <zh/> 返回控制点 | <en/> Returns control points\n */\nexport function getBorderRadiusPoints(\n  prevPoint: Point,\n  midPoint: Point,\n  nextPoint: Point,\n  radius: number,\n): [Point, Point] {\n  const d0 = manhattanDistance(prevPoint, midPoint);\n  const d1 = manhattanDistance(nextPoint, midPoint);\n  // 取给定的半径和最小半径之间的较小值 | use the smaller value between the given radius and the minimum radius\n  const r = Math.min(radius, Math.min(d0, d1) / 2);\n  const ps: Point = [\n    midPoint[0] - (r / d0) * (midPoint[0] - prevPoint[0]),\n    midPoint[1] - (r / d0) * (midPoint[1] - prevPoint[1]),\n  ];\n  const pt: Point = [\n    midPoint[0] - (r / d1) * (midPoint[0] - nextPoint[0]),\n    midPoint[1] - (r / d1) * (midPoint[1] - nextPoint[1]),\n  ];\n  return [ps, pt];\n}\n\n/** ==================== Loop Edge =========================== */\n\nexport const getRadians = (bbox: AABB): Record<LoopPlacement, [number, number]> => {\n  const halfPI = Math.PI / 2;\n  const halfHeight = getBBoxHeight(bbox) / 2;\n  const halfWidth = getBBoxWidth(bbox) / 2;\n  const angleWithX = Math.atan2(halfHeight, halfWidth) / 2;\n  const angleWithY = Math.atan2(halfWidth, halfHeight) / 2;\n  return {\n    top: [-halfPI - angleWithY, -halfPI + angleWithY],\n    'top-right': [-halfPI + angleWithY, -angleWithX],\n    'right-top': [-halfPI + angleWithY, -angleWithX],\n    right: [-angleWithX, angleWithX],\n    'bottom-right': [angleWithX, halfPI - angleWithY],\n    'right-bottom': [angleWithX, halfPI - angleWithY],\n    bottom: [halfPI - angleWithY, halfPI + angleWithY],\n    'bottom-left': [halfPI + angleWithY, Math.PI - angleWithX],\n    'left-bottom': [halfPI + angleWithY, Math.PI - angleWithX],\n    left: [Math.PI - angleWithX, Math.PI + angleWithX],\n    'top-left': [Math.PI + angleWithX, -halfPI - angleWithY],\n    'left-top': [Math.PI + angleWithX, -halfPI - angleWithY],\n  };\n};\n\n/**\n * <zh/> 获取环形边的起点和终点\n *\n * <en/> Get the start and end points of the loop edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param placement - <zh/> 环形边相对于节点位置 | <en/> Loop position relative to the node\n * @param clockwise - <zh/> 是否顺时针 | <en/> Whether to draw the loop clockwise\n * @param sourcePort - <zh/> 起点连接桩 | <en/> Source port\n * @param targetPort - <zh/> 终点连接桩 | <en/> Target port\n * @returns <zh/> 起点和终点 | <en/> Start and end points\n */\nexport function getLoopEndpoints(\n  node: Node,\n  placement: LoopPlacement,\n  clockwise: boolean,\n  sourcePort?: Port,\n  targetPort?: Port,\n): [Point, Point] {\n  const bbox = getNodeBBox(node);\n  const center = node.getCenter();\n\n  let sourcePoint = sourcePort && getPortPosition(sourcePort);\n  let targetPoint = targetPort && getPortPosition(targetPort);\n\n  if (!sourcePoint || !targetPoint) {\n    const radians = getRadians(bbox);\n    const angle1 = radians[placement][0];\n    const angle2 = radians[placement][1];\n    const [width, height] = getBBoxSize(bbox);\n    const r = Math.max(width, height);\n    const point1: Point = add(center, [r * Math.cos(angle1), r * Math.sin(angle1), 0]);\n    const point2: Point = add(center, [r * Math.cos(angle2), r * Math.sin(angle2), 0]);\n\n    sourcePoint = getNodeConnectionPoint(node, point1);\n    targetPoint = getNodeConnectionPoint(node, point2);\n\n    if (!clockwise) {\n      [sourcePoint, targetPoint] = [targetPoint, sourcePoint];\n    }\n  }\n\n  return [sourcePoint, targetPoint];\n}\n\n/**\n * <zh/> 获取环形边的绘制路径\n *\n * <en/> Get the path of the loop edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param placement - <zh/> 环形边相对于节点位置 | <en/> Loop position relative to the node\n * @param clockwise - <zh/> 是否顺时针 | <en/> Whether to draw the loop clockwise\n * @param dist - <zh/> 从节点 keyShape 边缘到自环顶部的距离 | <en/> The distance from the edge of the node keyShape to the top of the self-loop\n * @param sourcePortKey - <zh/> 起点连接桩 key | <en/> Source port key\n * @param targetPortKey - <zh/> 终点连接桩 key | <en/> Target port key\n * @returns <zh/> 返回绘制环形边的路径 | <en/> Returns the path of the loop edge\n */\nexport function getCubicLoopPath(\n  node: Node,\n  placement: LoopPlacement,\n  clockwise: boolean,\n  dist: number,\n  sourcePortKey?: string,\n  targetPortKey?: string,\n) {\n  const sourcePort = node.getPorts()[(sourcePortKey || targetPortKey)!];\n  const targetPort = node.getPorts()[(targetPortKey || sourcePortKey)!];\n\n  // 1. 获取起点和终点 | Get the start and end points\n  let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);\n\n  // 2. 获取控制点 | Get the control points\n  const controlPoints = getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist);\n\n  // 3. 如果定义了连接桩，调整端点以与连接桩边界相交 | If the port is defined, adjust the endpoint to intersect with the port boundary\n  if (sourcePort) sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);\n  if (targetPort) targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1) as Point);\n\n  return getCubicPath(sourcePoint, targetPoint, controlPoints);\n}\n\n/**\n * <zh/> 获取环形边的控制点\n *\n * <en/> Get the control points of the loop edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param sourcePoint - <zh/> 起点 | <en/> Source point\n * @param targetPoint - <zh/> 终点 | <en/> Target point\n * @param dist - <zh/> 从节点 keyShape 边缘到自环顶部的距离 | <en/> The distance from the edge of the node keyShape to the top of the self-loop\n * @returns <zh/> 控制点 | <en/> Control points\n */\nexport function getCubicLoopControlPoints(\n  node: Node,\n  sourcePoint: Point,\n  targetPoint: Point,\n  dist: number,\n): [Point, Point] {\n  const center = node.getCenter();\n\n  if (isEqual(sourcePoint, targetPoint)) {\n    const direction = subtract(sourcePoint, center);\n    const adjustment: Point = [\n      dist * Math.sign(direction[0]) || dist / 2,\n      dist * Math.sign(direction[1]) || -dist / 2,\n      0,\n    ];\n    return [add(sourcePoint, adjustment), add(targetPoint, multiply(adjustment, [1, -1, 1]))];\n  }\n\n  return [\n    moveTo(center, sourcePoint, distance(center, sourcePoint) + dist),\n    moveTo(center, targetPoint, distance(center, targetPoint) + dist),\n  ];\n}\n\n/**\n * <zh/> 获取环形折线边的绘制路径\n *\n * <en/> Get the path of the loop polyline edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param radius - <zh/> 圆角半径 | <en/> Radius of the rounded corner\n * @param placement - <zh/> 环形边相对于节点位置 | <en/> Loop position relative to the node\n * @param clockwise - <zh/> 是否顺时针 | <en/> Whether to draw the loop clockwise\n * @param dist - <zh/> 从节点 keyShape 边缘到自环顶部的距离 | <en/> The distance from the edge of the node keyShape to the top of the self-loop\n * @param sourcePortKey - <zh/> 起点连接桩 key | <en/> Source port key\n * @param targetPortKey - <zh/> 终点连接桩 key | <en/> Target port key\n * @returns <zh/> 返回绘制环形折线边的路径 | <en/> Returns the path of the loop polyline edge\n */\nexport function getPolylineLoopPath(\n  node: Node,\n  radius: number,\n  placement: LoopPlacement,\n  clockwise: boolean,\n  dist: number,\n  sourcePortKey?: string,\n  targetPortKey?: string,\n) {\n  const allPortsMap = getAllPorts(node);\n  const sourcePort = allPortsMap[(sourcePortKey || targetPortKey)!];\n  const targetPort = allPortsMap[(targetPortKey || sourcePortKey)!];\n\n  // 1. 获取起点和终点 | Get the start and end points\n  let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);\n\n  // 2. 获取控制点 | Get the control points\n  const controlPoints = getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist);\n\n  // 3. 如果定义了连接桩，调整端点以与连接桩边界相交 | If the port is defined, adjust the endpoint to intersect with the port boundary\n  if (sourcePort) sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);\n  if (targetPort) targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1) as Point);\n\n  return getPolylinePath([sourcePoint, ...controlPoints, targetPoint], radius);\n}\n\n/**\n * <zh/> 获取环形折线边的控制点\n *\n * <en/> Get the control points of the loop polyline edge\n * @param node - <zh/> 节点实例 | <en/> Node instance\n * @param sourcePoint - <zh/> 起点 | <en/> Source point\n * @param targetPoint - <zh/> 终点 | <en/> Target point\n * @param dist - <zh/> 从节点 keyShape 边缘到自环顶部的距离 | <en/> The distance from the edge of the node keyShape to the top of the self-loop\n * @returns <zh/> 控制点 | <en/> Control points\n */\nexport function getPolylineLoopControlPoints(node: Node, sourcePoint: Point, targetPoint: Point, dist: number) {\n  const controlPoints: Point[] = [];\n  const bbox = getNodeBBox(node);\n\n  // 1. 起点和终点相同 | The start and end points are the same\n  if (isEqual(sourcePoint, targetPoint)) {\n    const side = getNearestBoundarySide(sourcePoint, bbox);\n    switch (side) {\n      case 'left':\n        controlPoints.push([sourcePoint[0] - dist, sourcePoint[1]]);\n        controlPoints.push([sourcePoint[0] - dist, sourcePoint[1] + dist]);\n        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);\n        break;\n      case 'right':\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] + dist]);\n        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);\n        break;\n      case 'top':\n        controlPoints.push([sourcePoint[0], sourcePoint[1] - dist]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] - dist]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);\n        break;\n      case 'bottom':\n        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] + dist]);\n        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);\n        break;\n    }\n  } else {\n    const sourceSide = getNearestBoundarySide(sourcePoint, bbox);\n    const targetSide = getNearestBoundarySide(targetPoint, bbox);\n    // 2. 起点与终点同边 | The start and end points are on the same side\n    if (sourceSide === targetSide) {\n      const side = sourceSide;\n      let x, y;\n      switch (side) {\n        case 'left':\n          x = Math.min(sourcePoint[0], targetPoint[0]) - dist;\n          controlPoints.push([x, sourcePoint[1]]);\n          controlPoints.push([x, targetPoint[1]]);\n          break;\n        case 'right':\n          x = Math.max(sourcePoint[0], targetPoint[0]) + dist;\n          controlPoints.push([x, sourcePoint[1]]);\n          controlPoints.push([x, targetPoint[1]]);\n          break;\n        case 'top':\n          y = Math.min(sourcePoint[1], targetPoint[1]) - dist;\n          controlPoints.push([sourcePoint[0], y]);\n          controlPoints.push([targetPoint[0], y]);\n          break;\n        case 'bottom':\n          y = Math.max(sourcePoint[1], targetPoint[1]) + dist;\n          controlPoints.push([sourcePoint[0], y]);\n          controlPoints.push([targetPoint[0], y]);\n          break;\n      }\n    } else {\n      // 3. 起点与终点不同边 | The start and end points are on different sides\n      const getPointOffSide = (side: 'left' | 'right' | 'top' | 'bottom', point: Point): Point => {\n        return {\n          left: [point[0] - dist, point[1]],\n          right: [point[0] + dist, point[1]],\n          top: [point[0], point[1] - dist],\n          bottom: [point[0], point[1] + dist],\n        }[side] as Point;\n      };\n      const p1 = getPointOffSide(sourceSide, sourcePoint);\n      const p2 = getPointOffSide(targetSide, targetPoint);\n      const p3 = freeJoin(p1, p2, bbox);\n      controlPoints.push(p1, p3, p2);\n    }\n  }\n\n  return controlPoints;\n}\n\n/**\n * <zh/> 获取子图内的所有边，并按照内部边和外部边分组\n *\n * <en/> Get all the edges in the subgraph and group them into internal and external edges\n * @param ids - <zh/> 节点 ID 数组 | <en/> Node ID array\n * @param getRelatedEdges - <zh/> 获取节点邻边 | <en/> Get node edges\n * @returns <zh/> 子图边 | <en/> Subgraph edges\n */\nexport function getSubgraphRelatedEdges(ids: ID[], getRelatedEdges: (id: ID) => EdgeData[]) {\n  const edges = new Set<EdgeData>();\n  const internal = new Set<EdgeData>();\n  const external = new Set<EdgeData>();\n\n  ids.forEach((id) => {\n    const relatedEdges = getRelatedEdges(id);\n    relatedEdges.forEach((edge) => {\n      edges.add(edge);\n      if (ids.includes(edge.source) && ids.includes(edge.target)) internal.add(edge);\n      else external.add(edge);\n    });\n  });\n\n  return { edges: Array.from(edges), internal: Array.from(internal), external: Array.from(external) };\n}\n\n/**\n * <zh/> 获取边的实际连接节点\n *\n * <en/> Get the actual connected object of the edge\n * @param node - <zh/> 逻辑连接节点数据 | <en/> Logical connection node data\n * @param getParentData - <zh/> 获取父节点数据 | <en/> Get parent node data\n * @returns <zh/> 实际连接节点数据 | <en/> Actual connected node data\n */\nexport function findActualConnectNodeData(node: NodeLikeData, getParentData: (id: ID) => NodeLikeData | undefined) {\n  const path: NodeLikeData[] = [];\n  let current = node;\n  while (current) {\n    path.push(current);\n    const parent = getParentData(idOf(current));\n    if (parent) current = parent;\n    else break;\n  }\n\n  if (path.some((n) => n.style?.collapsed)) {\n    const index = path.reverse().findIndex(isCollapsed);\n    return path[index] || path.at(-1);\n  }\n\n  return node;\n}\n\n/**\n * <zh/> 获取箭头大小，若用户未指定，则根据线宽自动计算\n *\n * <en/> Get the size of the arrow\n * @param lineWidth - <zh/> 箭头所在边的线宽 | <en/> The line width of the edge where the arrow is located\n * @param size - <zh/> 自定义箭头大小 | <en/> Custom arrow size\n * @returns <zh/> 箭头大小 | <en/> Arrow size\n */\nexport function getArrowSize(lineWidth: number, size?: Size): Size {\n  if (size) return size;\n\n  if (lineWidth < 4) return 10;\n  if (lineWidth === 4) return 12;\n  return lineWidth * 2.5;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}