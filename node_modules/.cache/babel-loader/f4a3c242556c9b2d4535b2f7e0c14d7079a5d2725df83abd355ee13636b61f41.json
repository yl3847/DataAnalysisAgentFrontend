{"ast":null,"code":"import { sankey, left, right, center, justify } from './utils/d3-sankey';\nconst DEFAULT_OPTIONS = {\n  nodeAlign: 'justify',\n  nodeWidth: 0.008,\n  nodePadding: 0.03,\n  nodes: graph => graph.nodes,\n  links: graph => graph.links,\n  nodeSort: undefined,\n  linkSort: undefined,\n  iterations: 6\n};\nconst ALIGN_METHOD = {\n  left,\n  right,\n  center,\n  justify\n};\nfunction getNodeAlignFunction(nodeAlign) {\n  const type = typeof nodeAlign;\n  if (type === 'string') return ALIGN_METHOD[nodeAlign] || justify;\n  if (type === 'function') return nodeAlign;\n  return justify;\n}\n/**\n * Compute the node and edge position, return a graph representing the Sankey layout. All will be normalized to [[0, 0], [1, 1]]\n * Required graph data (nodes, edges)\n */\nexport const Sankey = options => {\n  return data => {\n    const {\n      nodeId,\n      nodeSort,\n      nodeAlign,\n      nodeWidth,\n      nodePadding,\n      nodeDepth,\n      nodes: nodeNodes,\n      links: nodeLinks,\n      linkSort,\n      iterations\n    } = Object.assign({}, DEFAULT_OPTIONS, options);\n    const sankeyProcessor = sankey().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations).extent([[0, 0], [1, 1]]);\n    if (typeof nodeId === 'function') {\n      sankeyProcessor.nodeId(nodeId);\n    }\n    const layoutData = sankeyProcessor(data);\n    const {\n      nodes: N,\n      links: L\n    } = layoutData;\n    const nodes = N.map(node => {\n      const {\n        x0,\n        x1,\n        y0,\n        y1\n      } = node;\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      return Object.assign(Object.assign({}, node), {\n        x: [x0, x1, x1, x0],\n        y: [y0, y0, y1, y1]\n      });\n    });\n    const links = L.map(edge => {\n      const {\n        source,\n        target\n      } = edge;\n      const sx = source.x1;\n      const tx = target.x0;\n      const offset = edge.width / 2;\n      return Object.assign(Object.assign({}, edge), {\n        x: [sx, sx, tx, tx],\n        y: [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset]\n      });\n    });\n    return {\n      nodes,\n      links\n    };\n  };\n};\nSankey.props = {};","map":{"version":3,"names":["sankey","left","right","center","justify","DEFAULT_OPTIONS","nodeAlign","nodeWidth","nodePadding","nodes","graph","links","nodeSort","undefined","linkSort","iterations","ALIGN_METHOD","getNodeAlignFunction","type","Sankey","options","data","nodeId","nodeDepth","nodeNodes","nodeLinks","Object","assign","sankeyProcessor","extent","layoutData","N","L","map","node","x0","x1","y0","y1","x","y","edge","source","target","sx","tx","offset","width","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/data/sankey.ts"],"sourcesContent":["import { DataComponent as DC } from '../runtime';\nimport { sankey, left, right, center, justify } from './utils/d3-sankey';\n\nconst DEFAULT_OPTIONS: Partial<SankeyOptions> = {\n  nodeAlign: 'justify',\n  nodeWidth: 0.008,\n  nodePadding: 0.03,\n  nodes: (graph) => graph.nodes,\n  links: (graph) => graph.links,\n  nodeSort: undefined,\n  linkSort: undefined,\n  iterations: 6,\n};\n\nconst ALIGN_METHOD = {\n  left,\n  right,\n  center,\n  justify,\n};\n\nfunction getNodeAlignFunction(nodeAlign: SankeyOptions['nodeAlign']) {\n  const type = typeof nodeAlign;\n  if (type === 'string') return ALIGN_METHOD[nodeAlign as string] || justify;\n  if (type === 'function') return nodeAlign;\n  return justify;\n}\n\nexport type SankeyOptions = Omit<Record<string, any>, 'type'>;\n\n/**\n * Compute the node and edge position, return a graph representing the Sankey layout. All will be normalized to [[0, 0], [1, 1]]\n * Required graph data (nodes, edges)\n */\nexport const Sankey: DC<SankeyOptions> = (options) => {\n  return (data) => {\n    const {\n      nodeId,\n      nodeSort,\n      nodeAlign,\n      nodeWidth,\n      nodePadding,\n      nodeDepth,\n      nodes: nodeNodes,\n      links: nodeLinks,\n      linkSort,\n      iterations,\n    } = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    const sankeyProcessor = sankey()\n      .nodeSort(nodeSort)\n      .linkSort(linkSort)\n      .links(nodeLinks)\n      .nodes(nodeNodes)\n      .nodeWidth(nodeWidth)\n      .nodePadding(nodePadding)\n      .nodeDepth(nodeDepth)\n      .nodeAlign(getNodeAlignFunction(nodeAlign))\n      .iterations(iterations)\n      .extent([\n        [0, 0],\n        [1, 1],\n      ]);\n\n    if (typeof nodeId === 'function') {\n      sankeyProcessor.nodeId(nodeId);\n    }\n\n    const layoutData = sankeyProcessor(data);\n\n    const { nodes: N, links: L } = layoutData;\n    const nodes = N.map((node) => {\n      const { x0, x1, y0, y1 } = node;\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      return { ...node, x: [x0, x1, x1, x0], y: [y0, y0, y1, y1] };\n    });\n    const links = L.map((edge) => {\n      const { source, target } = edge;\n      const sx = source.x1;\n      const tx = target.x0;\n      const offset = edge.width / 2;\n      return {\n        ...edge,\n        x: [sx, sx, tx, tx],\n        y: [\n          edge.y0 + offset,\n          edge.y0 - offset,\n          edge.y1 + offset,\n          edge.y1 - offset,\n        ],\n      };\n    });\n    return { nodes, links };\n  };\n};\n\nSankey.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}