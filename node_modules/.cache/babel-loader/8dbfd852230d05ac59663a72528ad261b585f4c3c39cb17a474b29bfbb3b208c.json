{"ast":null,"code":"import { Rect } from '@antv/g';\nimport { deepMix, isFunction } from '@antv/util';\nimport { CanvasEvent, CommonEvent } from '../constants';\nimport { idOf } from '../utils/id';\nimport { getBoundingPoints, isPointInPolygon } from '../utils/point';\nimport { Shortcut } from '../utils/shortcut';\nimport { BaseBehavior } from './base-behavior';\n/**\n * <zh/> 框选一组元素\n *\n * <en/> Brush select elements\n */\nexport class BrushSelect extends BaseBehavior {\n  constructor(context, options) {\n    super(context, deepMix({}, BrushSelect.defaultOptions, options));\n    this.shortcut = new Shortcut(context.graph);\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.clearStates = this.clearStates.bind(this);\n    this.bindEvents();\n  }\n  /**\n   * Triggered when the pointer is pressed\n   * @param event - Pointer event\n   * @internal\n   */\n  onPointerDown(event) {\n    if (!this.validate(event) || !this.isKeydown() || this.startPoint) return;\n    const {\n      canvas,\n      graph\n    } = this.context;\n    const style = Object.assign({}, this.options.style);\n    // 根据缩放比例调整 lineWidth\n    // Adjust lineWidth according to the zoom ratio\n    if (this.options.style.lineWidth) {\n      style.lineWidth = +this.options.style.lineWidth / graph.getZoom();\n    }\n    this.rectShape = new Rect({\n      id: 'g6-brush-select',\n      style\n    });\n    canvas.appendChild(this.rectShape);\n    this.startPoint = [event.canvas.x, event.canvas.y];\n  }\n  /**\n   * Triggered when the pointer is moved\n   * @param event - Pointer event\n   * @internal\n   */\n  onPointerMove(event) {\n    var _a;\n    if (!this.startPoint) return;\n    const {\n      immediately,\n      mode\n    } = this.options;\n    this.endPoint = getCursorPoint(event);\n    (_a = this.rectShape) === null || _a === void 0 ? void 0 : _a.attr({\n      x: Math.min(this.endPoint[0], this.startPoint[0]),\n      y: Math.min(this.endPoint[1], this.startPoint[1]),\n      width: Math.abs(this.endPoint[0] - this.startPoint[0]),\n      height: Math.abs(this.endPoint[1] - this.startPoint[1])\n    });\n    if (immediately && mode === 'default') this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));\n  }\n  /**\n   * Triggered when the pointer is released\n   * @param event - Pointer event\n   * @internal\n   */\n  onPointerUp(event) {\n    if (!this.startPoint) return;\n    if (!this.endPoint) {\n      this.clearBrush();\n      return;\n    }\n    this.endPoint = getCursorPoint(event);\n    this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));\n    this.clearBrush();\n  }\n  /**\n   * <zh/> 清除状态\n   *\n   * <en/> Clear state\n   * @internal\n   */\n  clearStates() {\n    if (this.endPoint) return;\n    this.clearElementsStates();\n  }\n  /**\n   * <zh/> 清除画布上所有元素的状态\n   *\n   * <en/> Clear the state of all elements on the canvas\n   * @internal\n   */\n  clearElementsStates() {\n    const {\n      graph\n    } = this.context;\n    const states = Object.values(graph.getData()).reduce((acc, data) => {\n      return Object.assign({}, acc, data.reduce((acc, datum) => {\n        var _a;\n        const restStates = (_a = datum.states || []) === null || _a === void 0 ? void 0 : _a.filter(state => state !== this.options.state);\n        acc[idOf(datum)] = restStates;\n        return acc;\n      }, {}));\n    }, {});\n    graph.setElementState(states, this.options.animation);\n  }\n  /**\n   * <zh/> 更新选中的元素状态\n   *\n   * <en/> Update the state of the selected elements\n   * @param points - <zh/> 框选区域的顶点 | <en/> The vertex of the selection area\n   * @internal\n   */\n  updateElementsStates(points) {\n    const {\n      graph\n    } = this.context;\n    const {\n      enableElements,\n      state,\n      mode,\n      onSelect\n    } = this.options;\n    const selectedIds = this.selector(graph, points, enableElements);\n    let states = {};\n    switch (mode) {\n      case 'union':\n        selectedIds.forEach(id => {\n          states[id] = [...graph.getElementState(id), state];\n        });\n        break;\n      case 'diff':\n        selectedIds.forEach(id => {\n          const prevStates = graph.getElementState(id);\n          states[id] = prevStates.includes(state) ? prevStates.filter(s => s !== state) : [...prevStates, state];\n        });\n        break;\n      case 'intersect':\n        selectedIds.forEach(id => {\n          const prevStates = graph.getElementState(id);\n          states[id] = prevStates.includes(state) ? [state] : [];\n        });\n        break;\n      case 'default':\n      default:\n        selectedIds.forEach(id => {\n          states[id] = [state];\n        });\n        break;\n    }\n    if (isFunction(onSelect)) states = onSelect(states);\n    graph.setElementState(states, this.options.animation);\n  }\n  /**\n   * <zh/> 查找画布上在指定区域内显示的元素。当节点的包围盒中心在矩形内时，节点被选中；当边的两端节点在矩形内时，边被选中；当 combo 的包围盒中心在矩形内时，combo 被选中。\n   *\n   * <en/> Find the elements displayed in the specified area on the canvas. A node is selected if the center of its bbox is inside the rect; An edge is selected if both end nodes are inside the rect ;A combo is selected if the center of its bbox is inside the rect.\n   * @param graph - <zh/> 图实例 | <en/> Graph instance\n   * @param points - <zh/> 框选区域的顶点 | <en/> The vertex of the selection area\n   * @param itemTypes - <zh/> 元素类型 | <en/> Element type\n   * @returns <zh/> 选中的元素 ID 数组 | <en/> Selected element ID array\n   * @internal\n   */\n  selector(graph, points, itemTypes) {\n    if (!itemTypes || itemTypes.length === 0) return [];\n    const elements = [];\n    const graphData = graph.getData();\n    itemTypes.forEach(itemType => {\n      graphData[`${itemType}s`].forEach(datum => {\n        const id = idOf(datum);\n        if (graph.getElementVisibility(id) !== 'hidden' && isPointInPolygon(graph.getElementPosition(id), points)) {\n          elements.push(id);\n        }\n      });\n    });\n    // 如果边的两端节点都在框选范围内，则边也被选中 | If source node and target node are within the selection range, that edge is also selected\n    if (itemTypes.includes('edge')) {\n      const edges = graphData.edges;\n      edges === null || edges === void 0 ? void 0 : edges.forEach(edge => {\n        const {\n          source,\n          target\n        } = edge;\n        if (elements.includes(source) && elements.includes(target)) {\n          elements.push(idOf(edge));\n        }\n      });\n    }\n    return elements;\n  }\n  clearBrush() {\n    var _a;\n    (_a = this.rectShape) === null || _a === void 0 ? void 0 : _a.remove();\n    this.rectShape = undefined;\n    this.startPoint = undefined;\n    this.endPoint = undefined;\n  }\n  /**\n   * <zh/> 当前按键是否和 trigger 配置一致\n   *\n   * <en/> Is the current key consistent with the trigger configuration\n   * @returns <zh/> 是否一致 | <en/> Is consistent\n   * @internal\n   */\n  isKeydown() {\n    const {\n      trigger\n    } = this.options;\n    const keys = Array.isArray(trigger) ? trigger : [trigger];\n    return this.shortcut.match(keys.filter(key => key !== 'drag'));\n  }\n  /**\n   * <zh/> 验证是否启用框选\n   *\n   * <en/> Verify whether brush select is enabled\n   * @param event - <zh/> 事件 | <en/> Event\n   * @returns <zh/> 是否启用 | <en/> Whether to enable\n   * @internal\n   */\n  validate(event) {\n    if (this.destroyed) return false;\n    const {\n      enable\n    } = this.options;\n    if (isFunction(enable)) return enable(event);\n    return !!enable;\n  }\n  bindEvents() {\n    const {\n      graph\n    } = this.context;\n    graph.on(CommonEvent.POINTER_DOWN, this.onPointerDown);\n    graph.on(CommonEvent.POINTER_MOVE, this.onPointerMove);\n    graph.on(CommonEvent.POINTER_UP, this.onPointerUp);\n    graph.on(CanvasEvent.CLICK, this.clearStates);\n  }\n  unbindEvents() {\n    const {\n      graph\n    } = this.context;\n    graph.off(CommonEvent.POINTER_DOWN, this.onPointerDown);\n    graph.off(CommonEvent.POINTER_MOVE, this.onPointerMove);\n    graph.off(CommonEvent.POINTER_UP, this.onPointerUp);\n    graph.off(CanvasEvent.CLICK, this.clearStates);\n  }\n  /**\n   * <zh/> 更新配置项\n   *\n   * <en/> Update configuration\n   * @param options - <zh/> 配置项 | <en/> Options\n   * @internal\n   */\n  update(options) {\n    this.unbindEvents();\n    this.options = deepMix(this.options, options);\n    this.bindEvents();\n  }\n  /**\n   * <zh/> 销毁\n   *\n   * <en/> Destroy\n   * @internal\n   */\n  destroy() {\n    this.unbindEvents();\n    super.destroy();\n  }\n}\nBrushSelect.defaultOptions = {\n  animation: false,\n  enable: true,\n  enableElements: ['node', 'combo', 'edge'],\n  immediately: false,\n  mode: 'default',\n  state: 'selected',\n  trigger: ['shift'],\n  style: {\n    width: 0,\n    height: 0,\n    lineWidth: 1,\n    fill: '#1677FF',\n    stroke: '#1677FF',\n    fillOpacity: 0.1,\n    zIndex: 2,\n    pointerEvents: 'none'\n  }\n};\nexport const getCursorPoint = event => {\n  return [event.canvas.x, event.canvas.y];\n};","map":{"version":3,"names":["Rect","deepMix","isFunction","CanvasEvent","CommonEvent","idOf","getBoundingPoints","isPointInPolygon","Shortcut","BaseBehavior","BrushSelect","constructor","context","options","defaultOptions","shortcut","graph","onPointerDown","bind","onPointerMove","onPointerUp","clearStates","bindEvents","event","validate","isKeydown","startPoint","canvas","style","Object","assign","lineWidth","getZoom","rectShape","id","appendChild","x","y","immediately","mode","endPoint","getCursorPoint","_a","attr","Math","min","width","abs","height","updateElementsStates","clearBrush","clearElementsStates","states","values","getData","reduce","acc","data","datum","restStates","filter","state","setElementState","animation","points","enableElements","onSelect","selectedIds","selector","forEach","getElementState","prevStates","includes","s","itemTypes","length","elements","graphData","itemType","getElementVisibility","getElementPosition","push","edges","edge","source","target","remove","undefined","trigger","keys","Array","isArray","match","key","destroyed","enable","on","POINTER_DOWN","POINTER_MOVE","POINTER_UP","CLICK","unbindEvents","off","update","destroy","fill","stroke","fillOpacity","zIndex","pointerEvents"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/behaviors/brush-select.ts"],"sourcesContent":["import type { RectStyleProps } from '@antv/g';\nimport { Rect } from '@antv/g';\nimport { deepMix, isFunction } from '@antv/util';\nimport { CanvasEvent, CommonEvent } from '../constants';\nimport type { Graph } from '../runtime/graph';\nimport type { RuntimeContext } from '../runtime/types';\nimport type { ElementDatum, ElementType, ID, IPointerEvent, Point, State } from '../types';\nimport { idOf } from '../utils/id';\nimport { getBoundingPoints, isPointInPolygon } from '../utils/point';\nimport type { ShortcutKey } from '../utils/shortcut';\nimport { Shortcut } from '../utils/shortcut';\nimport type { BaseBehaviorOptions } from './base-behavior';\nimport { BaseBehavior } from './base-behavior';\n\n/**\n * <zh/> 框选配置项\n *\n * <en/> Brush select options\n */\nexport interface BrushSelectOptions extends BaseBehaviorOptions {\n  /**\n   * <zh/> 是否启用动画\n   *\n   * <en/> Whether to enable animation.\n   * @defaultValue false\n   */\n  animation?: boolean;\n  /**\n   * <zh/> 是否启用框选功能\n   *\n   * <en/> Whether to enable Brush select element function.\n   * @defaultValue true\n   */\n  enable?: boolean | ((event: IPointerEvent) => boolean);\n  /**\n   * <zh/> 可框选的元素类型\n   *\n   * <en/> Enable Elements type.\n   * @defaultValue ['node', 'combo', 'edge']\n   */\n  enableElements?: ElementType[];\n  /**\n   * <zh/> 按下该快捷键配合鼠标点击进行框选\n   *\n   * <en/> Press this shortcut key to apply brush select with mouse click.\n   * @remarks\n   * <zh/> 注意，`trigger` 设置为 `['drag']` 时会导致 `drag-canvas` 行为失效。两者不可同时配置。\n   *\n   * <en/> Note that setting `trigger` to `['drag']` will cause the `drag-canvas` behavior to fail. The two cannot be configured at the same time.\n   * @defaultValue ['shift']\n   */\n  trigger?: ShortcutKey;\n  /**\n   * <zh/> 被选中时切换到该状态\n   *\n   * <en/> The state to switch to when selected.\n   * @defaultValue 'selected'\n   */\n  state?: State;\n  /**\n   * <zh/> 框选的选择模式\n   * - `'union'`：保持已选元素的当前状态，并添加指定的 state 状态。\n   * - `'intersect'`：如果已选元素已有指定的 state 状态，则保留；否则清除该状态。\n   * - `'diff'`：对已选元素的指定 state 状态进行取反操作。\n   * - `'default'`：清除已选元素的当前状态，并添加指定的 state 状态。\n   *\n   * <en/> Brush select mode\n   * - `'union'`: Keep the current state of the selected elements and add the specified state.\n   * - `'intersect'`: If the selected elements already have the specified state, keep it; otherwise, clearBrush it.\n   * - `'diff'`: Perform a negation operation on the specified state of the selected elements.\n   * - `'default'`: Clear the current state of the selected elements and add the specified state.\n   * @defaultValue 'default'\n   */\n  mode?: 'union' | 'intersect' | 'diff' | 'default';\n  /**\n   * <zh/> 是否及时框选, 仅在框选模式为 `default` 时生效\n   *\n   * <en/> Whether to brush select immediately, only valid when the brush select mode is `default`\n   * @defaultValue false\n   */\n  immediately?: boolean;\n  /**\n   * <zh/> 框选 框样式\n   *\n   * <en/> Timely screening.\n   */\n  style?: RectStyleProps;\n  /**\n   * <zh/> 框选元素状态回调。\n   *\n   * <en/> Callback when brush select elements.\n   * @param states - 选中的元素状态\n   * @returns 选中的元素状态\n   */\n  onSelect?: (states: Record<ID, State | State[]>) => Record<ID, State | State[]>;\n}\n/**\n * <zh/> 框选一组元素\n *\n * <en/> Brush select elements\n */\nexport class BrushSelect extends BaseBehavior<BrushSelectOptions> {\n  static defaultOptions: Partial<BrushSelectOptions> = {\n    animation: false,\n    enable: true,\n    enableElements: ['node', 'combo', 'edge'],\n    immediately: false,\n    mode: 'default',\n    state: 'selected',\n    trigger: ['shift'],\n    style: {\n      width: 0,\n      height: 0,\n      lineWidth: 1,\n      fill: '#1677FF',\n      stroke: '#1677FF',\n      fillOpacity: 0.1,\n      zIndex: 2,\n      pointerEvents: 'none',\n    },\n  };\n\n  private startPoint?: Point;\n  private endPoint?: Point;\n  private rectShape?: Rect;\n  private shortcut?: Shortcut;\n\n  constructor(context: RuntimeContext, options: BrushSelectOptions) {\n    super(context, deepMix({}, BrushSelect.defaultOptions, options));\n    this.shortcut = new Shortcut(context.graph);\n\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.clearStates = this.clearStates.bind(this);\n\n    this.bindEvents();\n  }\n\n  /**\n   * Triggered when the pointer is pressed\n   * @param event - Pointer event\n   * @internal\n   */\n  protected onPointerDown(event: IPointerEvent) {\n    if (!this.validate(event) || !this.isKeydown() || this.startPoint) return;\n    const { canvas, graph } = this.context;\n    const style = { ...this.options.style };\n\n    // 根据缩放比例调整 lineWidth\n    // Adjust lineWidth according to the zoom ratio\n    if (this.options.style.lineWidth) {\n      style.lineWidth = +this.options.style.lineWidth / graph.getZoom();\n    }\n\n    this.rectShape = new Rect({ id: 'g6-brush-select', style });\n    canvas.appendChild(this.rectShape);\n\n    this.startPoint = [event.canvas.x, event.canvas.y];\n  }\n\n  /**\n   * Triggered when the pointer is moved\n   * @param event - Pointer event\n   * @internal\n   */\n  protected onPointerMove(event: IPointerEvent) {\n    if (!this.startPoint) return;\n    const { immediately, mode } = this.options;\n\n    this.endPoint = getCursorPoint(event);\n\n    this.rectShape?.attr({\n      x: Math.min(this.endPoint[0], this.startPoint[0]),\n      y: Math.min(this.endPoint[1], this.startPoint[1]),\n      width: Math.abs(this.endPoint[0] - this.startPoint[0]),\n      height: Math.abs(this.endPoint[1] - this.startPoint[1]),\n    });\n\n    if (immediately && mode === 'default') this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));\n  }\n\n  /**\n   * Triggered when the pointer is released\n   * @param event - Pointer event\n   * @internal\n   */\n  protected onPointerUp(event: IPointerEvent) {\n    if (!this.startPoint) return;\n    if (!this.endPoint) {\n      this.clearBrush();\n      return;\n    }\n\n    this.endPoint = getCursorPoint(event);\n    this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));\n\n    this.clearBrush();\n  }\n\n  /**\n   * <zh/> 清除状态\n   *\n   * <en/> Clear state\n   * @internal\n   */\n  protected clearStates() {\n    if (this.endPoint) return;\n\n    this.clearElementsStates();\n  }\n\n  /**\n   * <zh/> 清除画布上所有元素的状态\n   *\n   * <en/> Clear the state of all elements on the canvas\n   * @internal\n   */\n  protected clearElementsStates() {\n    const { graph } = this.context;\n    const states = Object.values(graph.getData()).reduce((acc, data) => {\n      return Object.assign(\n        {},\n        acc,\n        data.reduce((acc: Record<ID, State[]>, datum: ElementDatum) => {\n          const restStates = (datum.states || [])?.filter((state) => state !== this.options.state);\n          acc[idOf(datum)] = restStates;\n          return acc;\n        }, {}),\n      );\n    }, {});\n\n    graph.setElementState(states, this.options.animation);\n  }\n\n  /**\n   * <zh/> 更新选中的元素状态\n   *\n   * <en/> Update the state of the selected elements\n   * @param points - <zh/> 框选区域的顶点 | <en/> The vertex of the selection area\n   * @internal\n   */\n  protected updateElementsStates(points: Point[]) {\n    const { graph } = this.context;\n    const { enableElements, state, mode, onSelect } = this.options;\n\n    const selectedIds = this.selector(graph, points, enableElements);\n\n    let states: Record<ID, State | State[]> = {};\n\n    switch (mode) {\n      case 'union':\n        selectedIds.forEach((id) => {\n          states[id] = [...graph.getElementState(id), state];\n        });\n        break;\n      case 'diff':\n        selectedIds.forEach((id) => {\n          const prevStates = graph.getElementState(id);\n          states[id] = prevStates.includes(state) ? prevStates.filter((s) => s !== state) : [...prevStates, state];\n        });\n        break;\n      case 'intersect':\n        selectedIds.forEach((id) => {\n          const prevStates = graph.getElementState(id);\n          states[id] = prevStates.includes(state) ? [state] : [];\n        });\n        break;\n      case 'default':\n      default:\n        selectedIds.forEach((id) => {\n          states[id] = [state];\n        });\n        break;\n    }\n\n    if (isFunction(onSelect)) states = onSelect(states);\n\n    graph.setElementState(states, this.options.animation);\n  }\n\n  /**\n   * <zh/> 查找画布上在指定区域内显示的元素。当节点的包围盒中心在矩形内时，节点被选中；当边的两端节点在矩形内时，边被选中；当 combo 的包围盒中心在矩形内时，combo 被选中。\n   *\n   * <en/> Find the elements displayed in the specified area on the canvas. A node is selected if the center of its bbox is inside the rect; An edge is selected if both end nodes are inside the rect ;A combo is selected if the center of its bbox is inside the rect.\n   * @param graph - <zh/> 图实例 | <en/> Graph instance\n   * @param points - <zh/> 框选区域的顶点 | <en/> The vertex of the selection area\n   * @param itemTypes - <zh/> 元素类型 | <en/> Element type\n   * @returns <zh/> 选中的元素 ID 数组 | <en/> Selected element ID array\n   * @internal\n   */\n  protected selector(graph: Graph, points: Point[], itemTypes: ElementType[]): ID[] {\n    if (!itemTypes || itemTypes.length === 0) return [];\n\n    const elements: ID[] = [];\n\n    const graphData = graph.getData();\n    itemTypes.forEach((itemType) => {\n      graphData[`${itemType}s`].forEach((datum) => {\n        const id = idOf(datum);\n        if (graph.getElementVisibility(id) !== 'hidden' && isPointInPolygon(graph.getElementPosition(id), points)) {\n          elements.push(id);\n        }\n      });\n    });\n\n    // 如果边的两端节点都在框选范围内，则边也被选中 | If source node and target node are within the selection range, that edge is also selected\n    if (itemTypes.includes('edge')) {\n      const edges = graphData.edges;\n      edges?.forEach((edge) => {\n        const { source, target } = edge;\n        if (elements.includes(source) && elements.includes(target)) {\n          elements.push(idOf(edge));\n        }\n      });\n    }\n\n    return elements;\n  }\n\n  private clearBrush() {\n    this.rectShape?.remove();\n    this.rectShape = undefined;\n    this.startPoint = undefined;\n    this.endPoint = undefined;\n  }\n\n  /**\n   * <zh/> 当前按键是否和 trigger 配置一致\n   *\n   * <en/> Is the current key consistent with the trigger configuration\n   * @returns <zh/> 是否一致 | <en/> Is consistent\n   * @internal\n   */\n  protected isKeydown(): boolean {\n    const { trigger } = this.options;\n    const keys = (Array.isArray(trigger) ? trigger : [trigger]) as string[];\n    return this.shortcut!.match(keys.filter((key) => key !== 'drag'));\n  }\n\n  /**\n   * <zh/> 验证是否启用框选\n   *\n   * <en/> Verify whether brush select is enabled\n   * @param event - <zh/> 事件 | <en/> Event\n   * @returns <zh/> 是否启用 | <en/> Whether to enable\n   * @internal\n   */\n  protected validate(event: IPointerEvent) {\n    if (this.destroyed) return false;\n    const { enable } = this.options;\n    if (isFunction(enable)) return enable(event);\n    return !!enable;\n  }\n\n  private bindEvents() {\n    const { graph } = this.context;\n\n    graph.on(CommonEvent.POINTER_DOWN, this.onPointerDown);\n    graph.on(CommonEvent.POINTER_MOVE, this.onPointerMove);\n    graph.on(CommonEvent.POINTER_UP, this.onPointerUp);\n    graph.on(CanvasEvent.CLICK, this.clearStates);\n  }\n\n  private unbindEvents() {\n    const { graph } = this.context;\n\n    graph.off(CommonEvent.POINTER_DOWN, this.onPointerDown);\n    graph.off(CommonEvent.POINTER_MOVE, this.onPointerMove);\n    graph.off(CommonEvent.POINTER_UP, this.onPointerUp);\n    graph.off(CanvasEvent.CLICK, this.clearStates);\n  }\n\n  /**\n   * <zh/> 更新配置项\n   *\n   * <en/> Update configuration\n   * @param options - <zh/> 配置项 | <en/> Options\n   * @internal\n   */\n  public update(options: Partial<BrushSelectOptions>) {\n    this.unbindEvents();\n    this.options = deepMix(this.options, options);\n    this.bindEvents();\n  }\n\n  /**\n   * <zh/> 销毁\n   *\n   * <en/> Destroy\n   * @internal\n   */\n  public destroy() {\n    this.unbindEvents();\n    super.destroy();\n  }\n}\n\nexport const getCursorPoint = (event: IPointerEvent): Point => {\n  return [event.canvas.x, event.canvas.y];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}