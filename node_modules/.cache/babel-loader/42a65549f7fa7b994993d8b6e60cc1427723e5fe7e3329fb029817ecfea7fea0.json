{"ast":null,"code":"import { isEqual } from '@antv/util';\nimport { pathToPoints } from './path';\nimport { findNearestLine, findNearestPointOnLine } from './point';\nimport { getXYByPlacement } from './position';\n/**\n * <zh/> 计算文本位置样式\n *\n * <en/> Calculate text position style\n * @param bounds - <zh/> 外包围盒 | <en/> contour bounds\n * @param placement - <zh/> 位置 | <en/> placement\n * @param offsetX - <zh/> x轴偏移 | <en/> x-axis offset\n * @param offsetY - <zh/> y轴偏移 | <en/> y-axis offset\n * @param closeToContour - <zh/> 标签位置是否贴合轮廓 | <en/> whether the label position is close to the contour\n * @param path - <zh/> 路径 | <en/> path\n * @param autoRotate - <zh/> 是否跟随轮廓旋转 | <en/> whether to rotate with the contour\n * @returns <zh/> 文本样式 | <en/> text style\n */\nexport function getPolygonTextStyleByPlacement(bounds, placement, offsetX, offsetY, closeToContour, path, autoRotate) {\n  const [x, y] = getXYByPlacement(bounds, placement);\n  const style = {\n    textAlign: placement === 'left' ? 'right' : placement === 'right' ? 'left' : 'center',\n    textBaseline: placement === 'top' ? 'bottom' : placement === 'bottom' ? 'top' : 'middle',\n    transform: [['translate', x + offsetX, y + offsetY]]\n  };\n  if (placement === 'center' || !closeToContour) return style;\n  const points = pathToPoints(path);\n  if (!points || points.length <= 3) return style;\n  const lines = points.map((point, index) => {\n    const p1 = point;\n    const p2 = points[(index + 1) % points.length];\n    if (isEqual(p1, p2)) return null;\n    return [p1, p2];\n  }).filter(Boolean);\n  const line = findNearestLine([x, y], lines);\n  const intersection = findNearestPointOnLine([x, y], line);\n  if (intersection && line) {\n    style.transform = [['translate', intersection[0] + offsetX, intersection[1] + offsetY]];\n    if (autoRotate) {\n      const angle = Math.atan((line[0][1] - line[1][1]) / (line[0][0] - line[1][0]));\n      style.transform.push(['rotate', angle / Math.PI * 180]);\n      style.textAlign = 'center';\n      if (placement === 'right' || placement === 'left') {\n        if (angle > 0) {\n          style.textBaseline = placement === 'right' ? 'bottom' : 'top';\n        } else {\n          style.textBaseline = placement === 'right' ? 'top' : 'bottom';\n        }\n      }\n    }\n  }\n  return style;\n}","map":{"version":3,"names":["isEqual","pathToPoints","findNearestLine","findNearestPointOnLine","getXYByPlacement","getPolygonTextStyleByPlacement","bounds","placement","offsetX","offsetY","closeToContour","path","autoRotate","x","y","style","textAlign","textBaseline","transform","points","length","lines","map","point","index","p1","p2","filter","Boolean","line","intersection","angle","Math","atan","push","PI"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/polygon.ts"],"sourcesContent":["import type { AABB, TextStyleProps } from '@antv/g';\nimport type { PathArray } from '@antv/util';\nimport { isEqual } from '@antv/util';\nimport type { CardinalPlacement, Point } from '../types';\nimport { pathToPoints } from './path';\nimport { findNearestLine, findNearestPointOnLine } from './point';\nimport { getXYByPlacement } from './position';\n\n/**\n * <zh/> 计算文本位置样式\n *\n * <en/> Calculate text position style\n * @param bounds - <zh/> 外包围盒 | <en/> contour bounds\n * @param placement - <zh/> 位置 | <en/> placement\n * @param offsetX - <zh/> x轴偏移 | <en/> x-axis offset\n * @param offsetY - <zh/> y轴偏移 | <en/> y-axis offset\n * @param closeToContour - <zh/> 标签位置是否贴合轮廓 | <en/> whether the label position is close to the contour\n * @param path - <zh/> 路径 | <en/> path\n * @param autoRotate - <zh/> 是否跟随轮廓旋转 | <en/> whether to rotate with the contour\n * @returns <zh/> 文本样式 | <en/> text style\n */\nexport function getPolygonTextStyleByPlacement(\n  bounds: AABB,\n  placement: CardinalPlacement | 'center',\n  offsetX: number,\n  offsetY: number,\n  closeToContour: boolean,\n  path: PathArray | string,\n  autoRotate: boolean,\n) {\n  const [x, y] = getXYByPlacement(bounds, placement);\n  const style: Partial<TextStyleProps> = {\n    textAlign: placement === 'left' ? 'right' : placement === 'right' ? 'left' : 'center',\n    textBaseline: placement === 'top' ? 'bottom' : placement === 'bottom' ? 'top' : 'middle',\n    transform: [['translate', x + offsetX, y + offsetY]],\n  };\n  if (placement === 'center' || !closeToContour) return style;\n\n  const points = pathToPoints(path);\n\n  if (!points || points.length <= 3) return style;\n\n  const lines = points\n    .map((point, index) => {\n      const p1 = point;\n      const p2 = points[(index + 1) % points.length];\n      if (isEqual(p1, p2)) return null;\n      return [p1, p2];\n    })\n    .filter(Boolean) as [Point, Point][];\n  const line = findNearestLine([x, y], lines);\n  const intersection = findNearestPointOnLine([x, y], line);\n  if (intersection && line) {\n    style.transform = [['translate', intersection[0] + offsetX, intersection[1] + offsetY]];\n    if (autoRotate) {\n      const angle = Math.atan((line[0][1] - line[1][1]) / (line[0][0] - line[1][0]));\n      style.transform.push(['rotate', (angle / Math.PI) * 180]);\n      style.textAlign = 'center';\n      if (placement === 'right' || placement === 'left') {\n        if (angle > 0) {\n          style.textBaseline = placement === 'right' ? 'bottom' : 'top';\n        } else {\n          style.textBaseline = placement === 'right' ? 'top' : 'bottom';\n        }\n      }\n    }\n  }\n  return style;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}