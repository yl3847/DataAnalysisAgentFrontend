{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { rollups } from '@antv/vendor/d3-array';\nimport { defined } from '../utils/helper';\nimport { useLibrary } from './library';\nimport { applyDefaults, applyDataTransform, extractColumns, flatEncode, inferChannelsType, maybeArrayField, maybeVisualChannel, addGuideToScale, maybeNonAnimate, normalizeTooltip, extractTooltip } from './transform';\nexport function initializeMark(partialMark, partialProps, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Apply transform to mark to derive indices, data, encode, etc,.\n    const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);\n    const {\n      encode,\n      scale,\n      data,\n      tooltip\n    } = transformedMark;\n    // Skip mark with non-tabular data. Do not skip empty\n    // data, they are useful for facet to display axes.\n    if (Array.isArray(data) === false) {\n      return null;\n    }\n    // Group non-independent channels with same prefix, such as x1, x2 => x.\n    // For independent channels, dot not group them, such as position1, position2.\n    const {\n      channels: channelDescriptors\n    } = partialProps;\n    const nameChannels = rollups(Object.entries(encode).filter(([, value]) => defined(value)), values => values.map(([key, options]) => Object.assign({\n      name: key\n    }, options)), ([key]) => {\n      var _a;\n      const prefix = (_a = /([^\\d]+)\\d*$/.exec(key)) === null || _a === void 0 ? void 0 : _a[1];\n      const descriptor = channelDescriptors.find(d => d.name === prefix);\n      if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent) return key;\n      return prefix;\n    });\n    // Check required channels and initialize scale options for each channel.\n    const channels = channelDescriptors.filter(descriptor => {\n      const {\n        name,\n        required\n      } = descriptor;\n      if (nameChannels.find(([d]) => d === name)) return true;\n      if (required) throw new Error(`Missing encoding for channel: ${name}.`);\n      return false;\n    }).flatMap(descriptor => {\n      const {\n        name,\n        scale: scaleType,\n        scaleKey,\n        range,\n        quantitative,\n        ordinal\n      } = descriptor;\n      const valuesArray = nameChannels.filter(([channel]) => channel.startsWith(name));\n      return valuesArray.map(([channel, values], i) => {\n        const visual = values.some(d => d.visual);\n        const constant = values.some(d => d.constant);\n        const _a = scale[channel] || {},\n          {\n            independent = false,\n            // Use channel name as default scale key.\n            key = scaleKey || channel,\n            // Visual channel use identity scale.\n            type = constant ? 'constant' : visual ? 'identity' : scaleType\n          } = _a,\n          scaleOptions = __rest(_a, [\"independent\", \"key\", \"type\"]);\n        // For constant scale, infer range from data.\n        const isConstant = type === 'constant';\n        const finalRange = isConstant ? undefined : range;\n        return {\n          name: channel,\n          values,\n          // Generate a unique key for independent channel,\n          // which will not group with any other channels.\n          scaleKey: independent || isConstant ? Symbol('independent') : key,\n          scale: Object.assign(Object.assign({\n            type,\n            range: finalRange\n          }, scaleOptions), {\n            quantitative,\n            ordinal\n          })\n        };\n      });\n    });\n    return [transformedMark, Object.assign(Object.assign({}, partialProps), {\n      index: I,\n      channels,\n      tooltip\n    })];\n  });\n}\nexport function createColumnOf(library) {\n  const [useEncode] = useLibrary('encode', library);\n  return (data, encode) => {\n    if (encode === undefined) return null;\n    if (data === undefined) return null;\n    return Object.assign(Object.assign({}, encode), {\n      type: 'column',\n      value: useEncode(encode)(data),\n      field: fieldOf(encode)\n    });\n  };\n}\nfunction applyMarkTransform(mark, props, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      library\n    } = context;\n    const [useTransform] = useLibrary('transform', library);\n    const {\n      preInference = [],\n      postInference = []\n    } = props;\n    const {\n      transform = []\n    } = mark;\n    const transforms = [applyDefaults, applyDataTransform, flatEncode, inferChannelsType, maybeVisualChannel, extractColumns, maybeArrayField, maybeNonAnimate, addGuideToScale, normalizeTooltip, ...preInference.map(useTransform), ...transform.map(useTransform), ...postInference.map(useTransform), extractTooltip];\n    let index = [];\n    let transformedMark = mark;\n    for (const t of transforms) {\n      [index, transformedMark] = yield t(index, transformedMark, context);\n    }\n    return [index, transformedMark];\n  });\n}\nfunction fieldOf(encode) {\n  const {\n    type,\n    value\n  } = encode;\n  if (type === 'field' && typeof value === 'string') return value;\n  return null;\n}","map":{"version":3,"names":["rollups","defined","useLibrary","applyDefaults","applyDataTransform","extractColumns","flatEncode","inferChannelsType","maybeArrayField","maybeVisualChannel","addGuideToScale","maybeNonAnimate","normalizeTooltip","extractTooltip","initializeMark","partialMark","partialProps","context","I","transformedMark","applyMarkTransform","encode","scale","data","tooltip","Array","isArray","channels","channelDescriptors","nameChannels","Object","entries","filter","value","values","map","key","options","assign","name","prefix","_a","exec","descriptor","find","d","independent","required","Error","flatMap","scaleType","scaleKey","range","quantitative","ordinal","valuesArray","channel","startsWith","i","visual","some","constant","type","scaleOptions","__rest","isConstant","finalRange","undefined","Symbol","index","createColumnOf","library","useEncode","field","fieldOf","mark","props","useTransform","preInference","postInference","transform","transforms","t"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/runtime/mark.ts"],"sourcesContent":["import { rollups } from '@antv/vendor/d3-array';\nimport { defined } from '../utils/helper';\nimport { useLibrary } from './library';\nimport { G2MarkState } from './types/common';\nimport {\n  G2Library,\n  G2Mark,\n  G2TransformOptions,\n  G2EncodeOptions,\n  G2Context,\n} from './types/options';\nimport { MarkProps } from './types/mark';\nimport { NormalizedEncodeSpec, EncodeComponent, Encode } from './types/encode';\nimport { ColumnOf, Transform, TransformComponent } from './types/transform';\nimport {\n  applyDefaults,\n  applyDataTransform,\n  extractColumns,\n  flatEncode,\n  inferChannelsType,\n  maybeArrayField,\n  maybeVisualChannel,\n  addGuideToScale,\n  maybeNonAnimate,\n  normalizeTooltip,\n  extractTooltip,\n} from './transform';\n\nexport async function initializeMark(\n  partialMark: G2Mark,\n  partialProps: MarkProps,\n  context: G2Library,\n): Promise<[G2Mark, G2MarkState]> {\n  // Apply transform to mark to derive indices, data, encode, etc,.\n  const [I, transformedMark] = await applyMarkTransform(\n    partialMark,\n    partialProps,\n    context,\n  );\n\n  const { encode, scale, data, tooltip } = transformedMark;\n\n  // Skip mark with non-tabular data. Do not skip empty\n  // data, they are useful for facet to display axes.\n  if (Array.isArray(data) === false) {\n    return null;\n  }\n\n  // Group non-independent channels with same prefix, such as x1, x2 => x.\n  // For independent channels, dot not group them, such as position1, position2.\n  const { channels: channelDescriptors } = partialProps;\n  const nameChannels = rollups(\n    Object.entries(encode).filter(([, value]) => defined(value)),\n    (values) =>\n      values.map(([key, options]) => ({\n        name: key,\n        ...options,\n      })),\n    ([key]) => {\n      const prefix = /([^\\d]+)\\d*$/.exec(key)?.[1];\n      const descriptor = channelDescriptors.find((d) => d.name === prefix);\n      if (descriptor?.independent) return key;\n      return prefix;\n    },\n  );\n\n  // Check required channels and initialize scale options for each channel.\n  const channels = channelDescriptors\n    .filter((descriptor) => {\n      const { name, required } = descriptor;\n      if (nameChannels.find(([d]) => d === name)) return true;\n      if (required) throw new Error(`Missing encoding for channel: ${name}.`);\n      return false;\n    })\n    .flatMap((descriptor) => {\n      const {\n        name,\n        scale: scaleType,\n        scaleKey,\n        range,\n        quantitative,\n        ordinal,\n      } = descriptor;\n      const valuesArray = nameChannels.filter(([channel]) =>\n        channel.startsWith(name),\n      );\n      return valuesArray.map(([channel, values], i) => {\n        const visual = values.some((d) => d.visual);\n        const constant = values.some((d) => d.constant);\n        const {\n          independent = false,\n          // Use channel name as default scale key.\n          key = scaleKey || channel,\n          // Visual channel use identity scale.\n          type = constant ? 'constant' : visual ? 'identity' : scaleType,\n          ...scaleOptions\n        } = scale[channel] || {};\n        // For constant scale, infer range from data.\n        const isConstant = type === 'constant';\n        const finalRange = isConstant ? undefined : range;\n        return {\n          name: channel,\n          values,\n          // Generate a unique key for independent channel,\n          // which will not group with any other channels.\n          scaleKey: independent || isConstant ? Symbol('independent') : key,\n          scale: {\n            type,\n            range: finalRange,\n            ...scaleOptions,\n            quantitative,\n            ordinal,\n          },\n        };\n      });\n    });\n\n  return [transformedMark, { ...partialProps, index: I, channels, tooltip }];\n}\n\nexport function createColumnOf(library: G2Library): ColumnOf {\n  const [useEncode] = useLibrary<G2EncodeOptions, EncodeComponent, Encode>(\n    'encode',\n    library,\n  );\n  return (data, encode) => {\n    if (encode === undefined) return null;\n    if (data === undefined) return null;\n    return {\n      ...encode,\n      type: 'column',\n      value: useEncode(encode)(data),\n      field: fieldOf(encode),\n    };\n  };\n}\n\nasync function applyMarkTransform(\n  mark: G2Mark,\n  props: MarkProps,\n  context: G2Context,\n): Promise<[number[], G2Mark]> {\n  const { library } = context;\n  const [useTransform] = useLibrary<\n    G2TransformOptions,\n    TransformComponent,\n    Transform\n  >('transform', library);\n  const { preInference = [], postInference = [] } = props;\n  const { transform = [] } = mark;\n  const transforms = [\n    applyDefaults,\n    applyDataTransform,\n    flatEncode,\n    inferChannelsType,\n    maybeVisualChannel,\n    extractColumns,\n    maybeArrayField,\n    maybeNonAnimate,\n    addGuideToScale,\n    normalizeTooltip,\n    ...preInference.map(useTransform),\n    ...transform.map(useTransform),\n    ...postInference.map(useTransform),\n    extractTooltip,\n  ];\n  let index = [];\n  let transformedMark = mark;\n  for (const t of transforms) {\n    [index, transformedMark] = await t(index, transformedMark, context);\n  }\n  return [index, transformedMark];\n}\n\nfunction fieldOf(encode: NormalizedEncodeSpec): string {\n  const { type, value } = encode;\n  if (type === 'field' && typeof value === 'string') return value;\n  return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}