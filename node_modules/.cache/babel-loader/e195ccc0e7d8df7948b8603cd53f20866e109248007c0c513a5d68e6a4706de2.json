{"ast":null,"code":"import { rotateVector } from '../util/rotate-vector';\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n */\nexport function arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {\n  var x1 = X1;\n  var y1 = Y1;\n  var rx = RX;\n  var ry = RY;\n  var x2 = X2;\n  var y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  var d120 = Math.PI * 120 / 180;\n  var rad = Math.PI / 180 * (+angle || 0);\n  /** @type {number[]} */\n  var res = [];\n  var xy;\n  var f1;\n  var f2;\n  var cx;\n  var cy;\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n    var x = (x1 - x2) / 2;\n    var y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    cx = k * rx * y / ry + (x1 + x2) / 2;\n    cy = k * -ry * x / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((y1 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((y2 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];\n  }\n  var df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    var f2old = f2;\n    var x2old = x2;\n    var y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  var c1 = Math.cos(f1);\n  var s1 = Math.sin(f1);\n  var c2 = Math.cos(f2);\n  var s2 = Math.sin(f2);\n  var t = Math.tan(df / 4);\n  var hx = 4 / 3 * rx * t;\n  var hy = 4 / 3 * ry * t;\n  var m1 = [x1, y1];\n  var m2 = [x1 + hx * s1, y1 - hy * c1];\n  var m3 = [x2 + hx * s2, y2 - hy * c2];\n  var m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return m2.concat(m3, m4, res);\n    // return [...m2, ...m3, ...m4, ...res];\n  }\n  res = m2.concat(m3, m4, res);\n  // res = [...m2, ...m3, ...m4, ...res];\n  var newres = [];\n  for (var i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n}\n// const TAU = Math.PI * 2;\n// const mapToEllipse = (\n//   { x, y }: { x: number; y: number },\n//   rx: number,\n//   ry: number,\n//   cosphi: number,\n//   sinphi: number,\n//   centerx: number,\n//   centery: number,\n// ) => {\n//   x *= rx;\n//   y *= ry;\n//   const xp = cosphi * x - sinphi * y;\n//   const yp = sinphi * x + cosphi * y;\n//   return {\n//     x: xp + centerx,\n//     y: yp + centery,\n//   };\n// };\n// const approxUnitArc = (ang1: number, ang2: number) => {\n//   // If 90 degree circular arc, use a constant\n//   // as derived from http://spencermortensen.com/articles/bezier-circle\n//   const a =\n//     ang2 === 1.5707963267948966\n//       ? 0.551915024494\n//       : ang2 === -1.5707963267948966\n//       ? -0.551915024494\n//       : (4 / 3) * Math.tan(ang2 / 4);\n//   const x1 = Math.cos(ang1);\n//   const y1 = Math.sin(ang1);\n//   const x2 = Math.cos(ang1 + ang2);\n//   const y2 = Math.sin(ang1 + ang2);\n//   return [\n//     {\n//       x: x1 - y1 * a,\n//       y: y1 + x1 * a,\n//     },\n//     {\n//       x: x2 + y2 * a,\n//       y: y2 - x2 * a,\n//     },\n//     {\n//       x: x2,\n//       y: y2,\n//     },\n//   ];\n// };\n// const vectorAngle = (ux: number, uy: number, vx: number, vy: number) => {\n//   const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n//   let dot = ux * vx + uy * vy;\n//   if (dot > 1) {\n//     dot = 1;\n//   }\n//   if (dot < -1) {\n//     dot = -1;\n//   }\n//   return sign * Math.acos(dot);\n// };\n// const getArcCenter = (\n//   px: any,\n//   py: any,\n//   cx: any,\n//   cy: any,\n//   rx: number,\n//   ry: number,\n//   largeArcFlag: number,\n//   sweepFlag: number,\n//   sinphi: number,\n//   cosphi: number,\n//   pxp: number,\n//   pyp: number,\n// ) => {\n//   const rxsq = Math.pow(rx, 2);\n//   const rysq = Math.pow(ry, 2);\n//   const pxpsq = Math.pow(pxp, 2);\n//   const pypsq = Math.pow(pyp, 2);\n//   let radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n//   if (radicant < 0) {\n//     radicant = 0;\n//   }\n//   radicant /= rxsq * pypsq + rysq * pxpsq;\n//   radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n//   const centerxp = ((radicant * rx) / ry) * pyp;\n//   const centeryp = ((radicant * -ry) / rx) * pxp;\n//   const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n//   const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n//   const vx1 = (pxp - centerxp) / rx;\n//   const vy1 = (pyp - centeryp) / ry;\n//   const vx2 = (-pxp - centerxp) / rx;\n//   const vy2 = (-pyp - centeryp) / ry;\n//   const ang1 = vectorAngle(1, 0, vx1, vy1);\n//   let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n//   if (sweepFlag === 0 && ang2 > 0) {\n//     ang2 -= TAU;\n//   }\n//   if (sweepFlag === 1 && ang2 < 0) {\n//     ang2 += TAU;\n//   }\n//   return [centerx, centery, ang1, ang2];\n// };\n// const arcToBezier = ({ px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0 }) => {\n//   const curves = [];\n//   if (rx === 0 || ry === 0) {\n//     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n//   }\n//   const sinphi = Math.sin((xAxisRotation * TAU) / 360);\n//   const cosphi = Math.cos((xAxisRotation * TAU) / 360);\n//   const pxp = (cosphi * (px - cx)) / 2 + (sinphi * (py - cy)) / 2;\n//   const pyp = (-sinphi * (px - cx)) / 2 + (cosphi * (py - cy)) / 2;\n//   if (pxp === 0 && pyp === 0) {\n//     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n//   }\n//   rx = Math.abs(rx);\n//   ry = Math.abs(ry);\n//   const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n//   if (lambda > 1) {\n//     rx *= Math.sqrt(lambda);\n//     ry *= Math.sqrt(lambda);\n//   }\n//   let [centerx, centery, ang1, ang2] = getArcCenter(\n//     px,\n//     py,\n//     cx,\n//     cy,\n//     rx,\n//     ry,\n//     largeArcFlag,\n//     sweepFlag,\n//     sinphi,\n//     cosphi,\n//     pxp,\n//     pyp,\n//   );\n//   // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n//   // 1.0000000001. This causes `segments` to be greater than one, which is an\n//   // unecessary split, and adds extra points to the bezier curve. To alleviate\n//   // this issue, we round to 1.0 when the ratio is close to 1.0.\n//   let ratio = Math.abs(ang2) / (TAU / 4);\n//   if (Math.abs(1.0 - ratio) < 0.0000001) {\n//     ratio = 1.0;\n//   }\n//   const segments = Math.max(Math.ceil(ratio), 1);\n//   ang2 /= segments;\n//   for (let i = 0; i < segments; i++) {\n//     curves.push(approxUnitArc(ang1, ang2));\n//     ang1 += ang2;\n//   }\n//   return curves.map((curve) => {\n//     const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery);\n//     const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery);\n//     const { x, y } = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery);\n//     return { x1, y1, x2, y2, x, y };\n//   });\n// };\n// export function arcToCubic(\n//   x1: number,\n//   y1: number,\n//   rx: number,\n//   ry: number,\n//   angle: number,\n//   LAF: number,\n//   SF: number,\n//   x2: number,\n//   y2: number,\n// ) {\n//   const curves = arcToBezier({\n//     px: x1,\n//     py: y1,\n//     cx: x2,\n//     cy: y2,\n//     rx,\n//     ry,\n//     xAxisRotation: angle,\n//     largeArcFlag: LAF,\n//     sweepFlag: SF,\n//   });\n//   return curves.reduce((prev, cur) => {\n//     const { x1, y1, x2, y2, x, y } = cur;\n//     prev.push(x1, y1, x2, y2, x, y);\n//     return prev;\n//   }, [] as number[]);\n// }","map":{"version":3,"names":["rotateVector","arcToCubic","X1","Y1","RX","RY","angle","LAF","SF","X2","Y2","recursive","x1","y1","rx","ry","x2","y2","d120","Math","PI","rad","res","xy","f1","f2","cx","cy","x","y","h","sqrt","rx2","ry2","k","abs","asin","pow","df","f2old","x2old","y2old","cos","sin","c1","s1","c2","s2","t","tan","hx","hy","m1","m2","m3","m4","concat","newres","i","ii","length"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/util/src/path/process/arc-2-cubic.ts"],"sourcesContent":["import { rotateVector } from '../util/rotate-vector';\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n */\nexport function arcToCubic(\n  X1: number,\n  Y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  X2: number,\n  Y2: number,\n  recursive: number[],\n) {\n  let x1 = X1;\n  let y1 = Y1;\n  let rx = RX;\n  let ry = RY;\n  let x2 = X2;\n  let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  /** @type {number[]} */\n  let res = [];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k =\n      (LAF === SF ? -1 : 1) *\n      Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n\n    cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((((y1 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((((y2 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return m2.concat(m3, m4, res);\n    // return [...m2, ...m3, ...m4, ...res];\n  }\n\n  res = m2.concat(m3, m4, res);\n  // res = [...m2, ...m3, ...m4, ...res];\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n}\n\n// const TAU = Math.PI * 2;\n\n// const mapToEllipse = (\n//   { x, y }: { x: number; y: number },\n//   rx: number,\n//   ry: number,\n//   cosphi: number,\n//   sinphi: number,\n//   centerx: number,\n//   centery: number,\n// ) => {\n//   x *= rx;\n//   y *= ry;\n\n//   const xp = cosphi * x - sinphi * y;\n//   const yp = sinphi * x + cosphi * y;\n\n//   return {\n//     x: xp + centerx,\n//     y: yp + centery,\n//   };\n// };\n\n// const approxUnitArc = (ang1: number, ang2: number) => {\n//   // If 90 degree circular arc, use a constant\n//   // as derived from http://spencermortensen.com/articles/bezier-circle\n//   const a =\n//     ang2 === 1.5707963267948966\n//       ? 0.551915024494\n//       : ang2 === -1.5707963267948966\n//       ? -0.551915024494\n//       : (4 / 3) * Math.tan(ang2 / 4);\n\n//   const x1 = Math.cos(ang1);\n//   const y1 = Math.sin(ang1);\n//   const x2 = Math.cos(ang1 + ang2);\n//   const y2 = Math.sin(ang1 + ang2);\n\n//   return [\n//     {\n//       x: x1 - y1 * a,\n//       y: y1 + x1 * a,\n//     },\n//     {\n//       x: x2 + y2 * a,\n//       y: y2 - x2 * a,\n//     },\n//     {\n//       x: x2,\n//       y: y2,\n//     },\n//   ];\n// };\n\n// const vectorAngle = (ux: number, uy: number, vx: number, vy: number) => {\n//   const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n//   let dot = ux * vx + uy * vy;\n\n//   if (dot > 1) {\n//     dot = 1;\n//   }\n\n//   if (dot < -1) {\n//     dot = -1;\n//   }\n\n//   return sign * Math.acos(dot);\n// };\n\n// const getArcCenter = (\n//   px: any,\n//   py: any,\n//   cx: any,\n//   cy: any,\n//   rx: number,\n//   ry: number,\n//   largeArcFlag: number,\n//   sweepFlag: number,\n//   sinphi: number,\n//   cosphi: number,\n//   pxp: number,\n//   pyp: number,\n// ) => {\n//   const rxsq = Math.pow(rx, 2);\n//   const rysq = Math.pow(ry, 2);\n//   const pxpsq = Math.pow(pxp, 2);\n//   const pypsq = Math.pow(pyp, 2);\n\n//   let radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n//   if (radicant < 0) {\n//     radicant = 0;\n//   }\n\n//   radicant /= rxsq * pypsq + rysq * pxpsq;\n//   radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n//   const centerxp = ((radicant * rx) / ry) * pyp;\n//   const centeryp = ((radicant * -ry) / rx) * pxp;\n\n//   const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n//   const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n//   const vx1 = (pxp - centerxp) / rx;\n//   const vy1 = (pyp - centeryp) / ry;\n//   const vx2 = (-pxp - centerxp) / rx;\n//   const vy2 = (-pyp - centeryp) / ry;\n\n//   const ang1 = vectorAngle(1, 0, vx1, vy1);\n//   let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n//   if (sweepFlag === 0 && ang2 > 0) {\n//     ang2 -= TAU;\n//   }\n\n//   if (sweepFlag === 1 && ang2 < 0) {\n//     ang2 += TAU;\n//   }\n\n//   return [centerx, centery, ang1, ang2];\n// };\n\n// const arcToBezier = ({ px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0 }) => {\n//   const curves = [];\n\n//   if (rx === 0 || ry === 0) {\n//     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n//   }\n\n//   const sinphi = Math.sin((xAxisRotation * TAU) / 360);\n//   const cosphi = Math.cos((xAxisRotation * TAU) / 360);\n\n//   const pxp = (cosphi * (px - cx)) / 2 + (sinphi * (py - cy)) / 2;\n//   const pyp = (-sinphi * (px - cx)) / 2 + (cosphi * (py - cy)) / 2;\n\n//   if (pxp === 0 && pyp === 0) {\n//     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n//   }\n\n//   rx = Math.abs(rx);\n//   ry = Math.abs(ry);\n\n//   const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n//   if (lambda > 1) {\n//     rx *= Math.sqrt(lambda);\n//     ry *= Math.sqrt(lambda);\n//   }\n\n//   let [centerx, centery, ang1, ang2] = getArcCenter(\n//     px,\n//     py,\n//     cx,\n//     cy,\n//     rx,\n//     ry,\n//     largeArcFlag,\n//     sweepFlag,\n//     sinphi,\n//     cosphi,\n//     pxp,\n//     pyp,\n//   );\n\n//   // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n//   // 1.0000000001. This causes `segments` to be greater than one, which is an\n//   // unecessary split, and adds extra points to the bezier curve. To alleviate\n//   // this issue, we round to 1.0 when the ratio is close to 1.0.\n//   let ratio = Math.abs(ang2) / (TAU / 4);\n//   if (Math.abs(1.0 - ratio) < 0.0000001) {\n//     ratio = 1.0;\n//   }\n\n//   const segments = Math.max(Math.ceil(ratio), 1);\n\n//   ang2 /= segments;\n\n//   for (let i = 0; i < segments; i++) {\n//     curves.push(approxUnitArc(ang1, ang2));\n//     ang1 += ang2;\n//   }\n\n//   return curves.map((curve) => {\n//     const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery);\n//     const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery);\n//     const { x, y } = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery);\n\n//     return { x1, y1, x2, y2, x, y };\n//   });\n// };\n\n// export function arcToCubic(\n//   x1: number,\n//   y1: number,\n//   rx: number,\n//   ry: number,\n//   angle: number,\n//   LAF: number,\n//   SF: number,\n//   x2: number,\n//   y2: number,\n// ) {\n//   const curves = arcToBezier({\n//     px: x1,\n//     py: y1,\n//     cx: x2,\n//     cy: y2,\n//     rx,\n//     ry,\n//     xAxisRotation: angle,\n//     largeArcFlag: LAF,\n//     sweepFlag: SF,\n//   });\n\n//   return curves.reduce((prev, cur) => {\n//     const { x1, y1, x2, y2, x, y } = cur;\n//     prev.push(x1, y1, x2, y2, x, y);\n//     return prev;\n//   }, [] as number[]);\n// }\n"],"mappings":"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G,CAACoC,CAAC,CAAC,EAAErC,GAAG,CAAC,CAACQ,CAAC,GAAG7B,YAAY,CAACsB,GAAG,CAACoC,CAAC,CAAC,EAAEpC,GAAG,CAACoC,CAAC,GAAG,CAAC,CAAC,EAAErC,GAAG,CAAC,CAACO,CAAC;EACvG;EACA,OAAO6B,MAAM;AACf;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}