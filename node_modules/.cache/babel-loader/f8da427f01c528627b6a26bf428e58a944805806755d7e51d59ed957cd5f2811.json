{"ast":null,"code":"import { debounce, throttle } from '@antv/util';\nimport { GraphEvent } from '../../constants';\nimport { isVisible } from '../../utils/element';\nimport { idOf } from '../../utils/id';\nimport { parsePadding } from '../../utils/padding';\nimport { toPointObject } from '../../utils/point';\nimport { BasePlugin } from '../base-plugin';\nimport { createPluginCanvas } from '../utils/canvas';\n/**\n * <zh/> 缩略图插件\n *\n * <en/> Minimap plugin\n */\nexport class Minimap extends BasePlugin {\n  constructor(context, options) {\n    super(context, Object.assign({}, Minimap.defaultOptions, options));\n    this.onDraw = event => {\n      var _a;\n      if ((_a = event === null || event === void 0 ? void 0 : event.data) === null || _a === void 0 ? void 0 : _a.render) return;\n      this.onRender();\n    };\n    this.shapes = new Map();\n    this.landmarkMap = new Map();\n    this.mask = null;\n    this.isMaskDragging = false;\n    this.onMaskDragStart = event => {\n      if (!this.mask) return;\n      this.isMaskDragging = true;\n      this.mask.setPointerCapture(event.pointerId);\n      this.mask.addEventListener('pointermove', this.onMaskDrag);\n      this.mask.addEventListener('pointerup', this.onMaskDragEnd);\n      this.mask.addEventListener('pointercancel', this.onMaskDragEnd);\n    };\n    this.onMaskDrag = event => {\n      if (!this.mask || !this.isMaskDragging) return;\n      const {\n        size: [minimapWidth, minimapHeight]\n      } = this.options;\n      const {\n        movementX,\n        movementY\n      } = event;\n      const {\n        left,\n        top,\n        width: w,\n        height: h\n      } = this.mask.style;\n      const [,, fullWidth, fullHeight] = this.maskBBox;\n      let x = parseInt(left) + movementX;\n      let y = parseInt(top) + movementY;\n      let width = parseInt(w);\n      let height = parseInt(h);\n      // 确保 mask 在 minimap 内部\n      // Ensure that the mask is inside the minimap\n      if (x < 0) x = 0;\n      if (y < 0) y = 0;\n      if (x + width > minimapWidth) x = lower(minimapWidth - width, 0);\n      if (y + height > minimapHeight) y = lower(minimapHeight - height, 0);\n      // 当拖拽画布导致 mask 缩小时，拖拽 mask 时，能够恢复到实际大小\n      // When dragging the canvas causes the mask to shrink, dragging the mask will restore it to its actual size\n      if (width < fullWidth) {\n        if (movementX > 0) x = lower(x - movementX, 0), width = upper(width + movementX, minimapWidth);else if (movementX < 0) width = upper(width - movementX, minimapWidth);\n      }\n      if (height < fullHeight) {\n        if (movementY > 0) y = lower(y - movementY, 0), height = upper(height + movementY, minimapHeight);else if (movementY < 0) height = upper(height - movementY, minimapHeight);\n      }\n      Object.assign(this.mask.style, {\n        left: x + 'px',\n        top: y + 'px',\n        width: width + 'px',\n        height: height + 'px'\n      });\n      // 基于 movement 进行相对移动\n      // Move relative to movement\n      const deltaX = parseInt(left) - x;\n      const deltaY = parseInt(top) - y;\n      if (deltaX === 0 && deltaY === 0) return;\n      const zoom1 = this.context.canvas.getCamera().getZoom();\n      const zoom2 = this.canvas.getCamera().getZoom();\n      const ratio = zoom1 / zoom2;\n      this.context.graph.translateBy([deltaX * ratio, deltaY * ratio], false);\n    };\n    this.onMaskDragEnd = event => {\n      if (!this.mask) return;\n      this.isMaskDragging = false;\n      this.mask.releasePointerCapture(event.pointerId);\n      this.mask.removeEventListener('pointermove', this.onMaskDrag);\n      this.mask.removeEventListener('pointerup', this.onMaskDragEnd);\n      this.mask.removeEventListener('pointercancel', this.onMaskDragEnd);\n    };\n    this.onTransform = throttle(() => {\n      if (this.isMaskDragging) return;\n      this.updateMask();\n      this.setCamera();\n    }, 32, {\n      leading: true\n    });\n    this.setOnRender();\n    this.bindEvents();\n  }\n  update(options) {\n    this.unbindEvents();\n    super.update(options);\n    if ('delay' in options) this.setOnRender();\n    this.bindEvents();\n  }\n  setOnRender() {\n    this.onRender = debounce(() => {\n      this.renderMinimap();\n      this.renderMask();\n    }, this.options.delay);\n  }\n  bindEvents() {\n    const {\n      graph\n    } = this.context;\n    graph.on(GraphEvent.AFTER_DRAW, this.onDraw);\n    graph.on(GraphEvent.AFTER_RENDER, this.onRender);\n    graph.on(GraphEvent.AFTER_ANIMATE, this.onRender);\n    graph.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);\n  }\n  unbindEvents() {\n    const {\n      graph\n    } = this.context;\n    graph.off(GraphEvent.AFTER_DRAW, this.onDraw);\n    graph.off(GraphEvent.AFTER_RENDER, this.onRender);\n    graph.off(GraphEvent.AFTER_ANIMATE, this.onRender);\n    graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);\n  }\n  /**\n   * <zh/> 创建或更新缩略图\n   *\n   * <en/> Create or update the minimap\n   */\n  renderMinimap() {\n    const data = this.getElements();\n    const canvas = this.initCanvas();\n    this.setShapes(canvas, data);\n  }\n  getElements() {\n    const {\n      filter\n    } = this.options;\n    const {\n      model,\n      element\n    } = this.context;\n    const originData = model.getData();\n    //过滤那些不存在于elementMap中的数据\n    const data = {\n      nodes: originData.nodes.filter(node => element === null || element === void 0 ? void 0 : element.getElement(idOf(node))),\n      edges: originData.edges.filter(edge => {\n        const edgeElement = element === null || element === void 0 ? void 0 : element.getElement(idOf(edge));\n        // 边数据存在且可见时才保留\n        return edgeElement && isVisible(edgeElement);\n      }),\n      combos: originData.combos.filter(combo => element === null || element === void 0 ? void 0 : element.getElement(idOf(combo)))\n    };\n    if (!filter) return data;\n    const {\n      nodes,\n      edges,\n      combos\n    } = data;\n    return {\n      nodes: nodes.filter(node => filter(idOf(node), 'node')),\n      edges: edges.filter(edge => filter(idOf(edge), 'edge')),\n      combos: combos.filter(combo => filter(idOf(combo), 'combo'))\n    };\n  }\n  setShapes(canvas, data) {\n    const {\n      nodes,\n      edges,\n      combos\n    } = data;\n    const {\n      shape\n    } = this.options;\n    const {\n      element\n    } = this.context;\n    if (shape === 'key') {\n      const ids = new Set();\n      const iterate = datum => {\n        const id = idOf(datum);\n        ids.add(id);\n        const target = element.getElement(id);\n        if (!target) return;\n        const shape = target.getShape('key');\n        const cloneShape = this.shapes.get(id) || shape.cloneNode();\n        cloneShape.setPosition(shape.getPosition());\n        // keep zIndex / id\n        if (target.style.zIndex) cloneShape.style.zIndex = target.style.zIndex;\n        cloneShape.id = target.id;\n        if (!this.shapes.has(id)) {\n          canvas.appendChild(cloneShape);\n          this.shapes.set(id, cloneShape);\n        } else {\n          Object.entries(shape.attributes).forEach(([key, value]) => {\n            if (cloneShape.style[key] !== value) cloneShape.style[key] = value;\n          });\n        }\n      };\n      // 注意执行顺序 / Note the execution order\n      edges.forEach(iterate);\n      combos.forEach(iterate);\n      nodes.forEach(iterate);\n      this.shapes.forEach((shape, id) => {\n        if (!ids.has(id)) {\n          canvas.removeChild(shape);\n          this.shapes.delete(id);\n        }\n      });\n      return;\n    }\n    const setPosition = (id, shape) => {\n      const target = element.getElement(id);\n      const position = target.getPosition();\n      shape.setPosition(position);\n      return shape;\n    };\n    canvas.removeChildren();\n    edges.forEach(datum => canvas.appendChild(shape(idOf(datum), 'edge')));\n    combos.forEach(datum => {\n      canvas.appendChild(setPosition(idOf(datum), shape(idOf(datum), 'combo')));\n    });\n    nodes.forEach(datum => {\n      canvas.appendChild(setPosition(idOf(datum), shape(idOf(datum), 'node')));\n    });\n  }\n  initCanvas() {\n    const {\n      renderer,\n      size: [width, height]\n    } = this.options;\n    if (this.canvas) {\n      const {\n        width: w,\n        height: h\n      } = this.canvas.getConfig();\n      if (width !== w || height !== h) this.canvas.resize(width, height);\n      if (renderer) this.canvas.setRenderer(renderer);\n    } else {\n      const {\n        className,\n        position,\n        container,\n        containerStyle\n      } = this.options;\n      const [$container, canvas] = createPluginCanvas({\n        renderer,\n        width,\n        height,\n        placement: position,\n        className: 'minimap',\n        container,\n        containerStyle,\n        graphCanvas: this.context.canvas\n      });\n      if (className) $container.classList.add(className);\n      this.container = $container;\n      this.canvas = canvas;\n    }\n    this.setCamera();\n    return this.canvas;\n  }\n  createLandmark(position, focalPoint, zoom) {\n    const key = `${position.join(',')}-${focalPoint.join(',')}-${zoom}`;\n    if (this.landmarkMap.has(key)) return this.landmarkMap.get(key);\n    const camera = this.canvas.getCamera();\n    const landmark = camera.createLandmark(key, {\n      position,\n      focalPoint,\n      zoom\n    });\n    this.landmarkMap.set(key, landmark);\n    return landmark;\n  }\n  setCamera() {\n    var _a;\n    const {\n      canvas\n    } = this.context;\n    const camera = (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.getCamera();\n    if (!camera) return;\n    const {\n      size: [minimapWidth, minimapHeight],\n      padding\n    } = this.options;\n    const [top, right, bottom, left] = parsePadding(padding);\n    const {\n      min: boundsMin,\n      max: boundsMax,\n      center\n    } = canvas.getBounds('elements');\n    const boundsWidth = boundsMax[0] - boundsMin[0];\n    const boundsHeight = boundsMax[1] - boundsMin[1];\n    const availableWidth = minimapWidth - left - right;\n    const availableHeight = minimapHeight - top - bottom;\n    const scaleX = availableWidth / boundsWidth;\n    const scaleY = availableHeight / boundsHeight;\n    const scale = Math.min(scaleX, scaleY);\n    const landmark = this.createLandmark(center, center, scale);\n    camera.gotoLandmark(landmark, 0);\n  }\n  get maskBBox() {\n    const {\n      canvas: graphCanvas\n    } = this.context;\n    const canvasSize = graphCanvas.getSize();\n    const canvasMin = graphCanvas.getCanvasByViewport([0, 0]);\n    const canvasMax = graphCanvas.getCanvasByViewport(canvasSize);\n    const maskMin = this.canvas.canvas2Viewport(toPointObject(canvasMin));\n    const maskMax = this.canvas.canvas2Viewport(toPointObject(canvasMax));\n    const width = maskMax.x - maskMin.x;\n    const height = maskMax.y - maskMin.y;\n    return [maskMin.x, maskMin.y, width, height];\n  }\n  /**\n   * <zh/> 计算遮罩包围盒\n   *\n   * <en/> Calculate the bounding box of the mask\n   * @returns <zh/> 遮罩包围盒 | <en/> Mask bounding box\n   */\n  calculateMaskBBox() {\n    const {\n      size: [minimapWidth, minimapHeight]\n    } = this.options;\n    let [x, y, width, height] = this.maskBBox;\n    // clamp x, y, width, height\n    if (x < 0) {\n      width = upper(width + x, minimapWidth);\n      x = 0;\n    }\n    if (y < 0) {\n      height = upper(height + y, minimapHeight);\n      y = 0;\n    }\n    if (x + width > minimapWidth) width = lower(minimapWidth - x, 0);\n    if (y + height > minimapHeight) height = lower(minimapHeight - y, 0);\n    return [upper(x, minimapWidth), upper(y, minimapHeight), lower(width, 0), lower(height, 0)];\n  }\n  /**\n   * <zh/> 创建或更新遮罩\n   *\n   * <en/> Create or update the mask\n   */\n  renderMask() {\n    const {\n      maskStyle\n    } = this.options;\n    if (!this.mask) {\n      this.mask = document.createElement('div');\n      this.mask.addEventListener('pointerdown', this.onMaskDragStart);\n      this.mask.draggable = true;\n      this.mask.addEventListener('dragstart', event => event.preventDefault && event.preventDefault());\n    }\n    this.container.appendChild(this.mask);\n    Object.assign(this.mask.style, Object.assign(Object.assign({}, maskStyle), {\n      cursor: 'move',\n      position: 'absolute',\n      pointerEvents: 'auto'\n    }));\n    this.updateMask();\n  }\n  updateMask() {\n    if (!this.mask) return;\n    const [x, y, width, height] = this.calculateMaskBBox();\n    Object.assign(this.mask.style, {\n      top: y + 'px',\n      left: x + 'px',\n      width: width + 'px',\n      height: height + 'px'\n    });\n  }\n  destroy() {\n    var _a, _b, _c;\n    this.unbindEvents();\n    (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this.mask) === null || _b === void 0 ? void 0 : _b.remove();\n    (_c = this.container) === null || _c === void 0 ? void 0 : _c.remove();\n    super.destroy();\n  }\n}\nMinimap.defaultOptions = {\n  size: [240, 160],\n  shape: 'key',\n  padding: 10,\n  position: 'right-bottom',\n  maskStyle: {\n    border: '1px solid #ddd',\n    background: 'rgba(0, 0, 0, 0.1)'\n  },\n  containerStyle: {\n    border: '1px solid #ddd',\n    background: '#fff'\n  },\n  delay: 128\n};\nconst upper = (value, max) => Math.min(value, max);\nconst lower = (value, min) => Math.max(value, min);","map":{"version":3,"names":["debounce","throttle","GraphEvent","isVisible","idOf","parsePadding","toPointObject","BasePlugin","createPluginCanvas","Minimap","constructor","context","options","Object","assign","defaultOptions","onDraw","event","_a","data","render","onRender","shapes","Map","landmarkMap","mask","isMaskDragging","onMaskDragStart","setPointerCapture","pointerId","addEventListener","onMaskDrag","onMaskDragEnd","size","minimapWidth","minimapHeight","movementX","movementY","left","top","width","w","height","h","style","fullWidth","fullHeight","maskBBox","x","parseInt","y","lower","upper","deltaX","deltaY","zoom1","canvas","getCamera","getZoom","zoom2","ratio","graph","translateBy","releasePointerCapture","removeEventListener","onTransform","updateMask","setCamera","leading","setOnRender","bindEvents","update","unbindEvents","renderMinimap","renderMask","delay","on","AFTER_DRAW","AFTER_RENDER","AFTER_ANIMATE","AFTER_TRANSFORM","off","getElements","initCanvas","setShapes","filter","model","element","originData","getData","nodes","node","getElement","edges","edge","edgeElement","combos","combo","shape","ids","Set","iterate","datum","id","add","target","getShape","cloneShape","get","cloneNode","setPosition","getPosition","zIndex","has","appendChild","set","entries","attributes","forEach","key","value","removeChild","delete","position","removeChildren","renderer","getConfig","resize","setRenderer","className","container","containerStyle","$container","placement","graphCanvas","classList","createLandmark","focalPoint","zoom","join","camera","landmark","padding","right","bottom","min","boundsMin","max","boundsMax","center","getBounds","boundsWidth","boundsHeight","availableWidth","availableHeight","scaleX","scaleY","scale","Math","gotoLandmark","canvasSize","getSize","canvasMin","getCanvasByViewport","canvasMax","maskMin","canvas2Viewport","maskMax","calculateMaskBBox","maskStyle","document","createElement","draggable","preventDefault","cursor","pointerEvents","destroy","_b","remove","_c","border","background"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/plugins/minimap/index.ts"],"sourcesContent":["import { Canvas, DisplayObject, IRenderer, Landmark } from '@antv/g';\nimport { debounce, throttle } from '@antv/util';\nimport { GraphEvent } from '../../constants';\nimport type { RuntimeContext } from '../../runtime/types';\nimport { GraphData } from '../../spec';\nimport type { ElementDatum, ElementType, ID, IGraphLifeCycleEvent, Padding, Placement, Vector3 } from '../../types';\nimport { isVisible } from '../../utils/element';\nimport { idOf } from '../../utils/id';\nimport { parsePadding } from '../../utils/padding';\nimport { toPointObject } from '../../utils/point';\nimport type { BasePluginOptions } from '../base-plugin';\nimport { BasePlugin } from '../base-plugin';\nimport { createPluginCanvas } from '../utils/canvas';\n\n/**\n * <zh/> 缩略图插件配置项\n *\n * <en/> Minimap plugin options\n */\nexport interface MinimapOptions extends BasePluginOptions {\n  /**\n   * <zh/> 宽度和高度\n   *\n   * <en/> Width and height\n   * @defaultValue [240, 160]\n   */\n  size?: [number, number];\n  /**\n   * <zh/> 内边距\n   *\n   * <en/> Padding\n   * @defaultValue 10\n   */\n  padding?: Padding;\n  /**\n   * <zh/> 缩略图相对于画布的位置\n   *\n   * <en/> The position of the minimap relative to the canvas\n   * @defaultValue 'right-bottom'\n   */\n  position?: Placement;\n  /**\n   * <zh/> 过滤器，用于过滤不必显示的元素\n   *\n   * <en/> Filter, used to filter elements that do not need to be displayed\n   * @param id - <zh/> 元素的 id | <en/> The id of the element\n   * @param elementType - <zh/> 元素的类型 | <en/> The type of the element\n   * @returns <zh/> 是否显示 | <en/> Whether to display\n   */\n  filter?: (id: string, elementType: ElementType) => boolean;\n  /**\n   * <zh/> 元素缩略图形的生成方法\n   *\n   * <en/> The method of generating the thumbnail of the element\n   * @defaultValue 'key'\n   * @remarks\n   * <zh/>\n   * - 'key' 使用元素的主图形作为缩略图形\n   * - 也可以传入一个函数，接收元素的 id 和类型，返回一个图形\n   *\n   * <en/>\n   * - 'key' uses the key shape of the element as the thumbnail shape\n   * - You can also pass in a function that receives the id and type of the element and returns a shape\n   */\n  shape?: 'key' | ((id: string, elementType: ElementType) => DisplayObject);\n  /**\n   * <zh/> 缩略图画布类名，传入外置容器时不生效\n   *\n   * <en/> The class name of the minimap canvas, which does not take effect when an external container is passed in\n   */\n  className?: string;\n  /**\n   * <zh/> 缩略图挂载的容器，无则挂载到 Graph 所在容器\n   *\n   * <en/> The container where the minimap is mounted, if not, it will be mounted to the container where the Graph is located\n   */\n  container?: HTMLElement | string;\n  /**\n   * <zh/> 缩略图的容器样式，传入外置容器时不生效\n   *\n   * <en/> The style of the minimap container, which does not take effect when an external container is passed in\n   */\n  containerStyle?: Partial<CSSStyleDeclaration>;\n  /**\n   * <zh/> 遮罩的样式\n   *\n   * <en/> The style of the mask\n   */\n  maskStyle?: Partial<CSSStyleDeclaration>;\n  /**\n   * <zh/> 渲染器，默认使用 Canvas 渲染器\n   *\n   * <en/> Renderer, default to use Canvas renderer\n   */\n  renderer?: IRenderer;\n  /**\n   * <zh/> 延迟更新时间(毫秒)，用于性能优化\n   *\n   * <en/> Delay update time(ms), used for performance optimization\n   * @defaultValue 128\n   */\n  delay?: number;\n}\n\n/**\n * <zh/> 缩略图插件\n *\n * <en/> Minimap plugin\n */\nexport class Minimap extends BasePlugin<MinimapOptions> {\n  static defaultOptions: Partial<MinimapOptions> = {\n    size: [240, 160],\n    shape: 'key',\n    padding: 10,\n    position: 'right-bottom',\n    maskStyle: {\n      border: '1px solid #ddd',\n      background: 'rgba(0, 0, 0, 0.1)',\n    },\n    containerStyle: {\n      border: '1px solid #ddd',\n      background: '#fff',\n    },\n    delay: 128,\n  };\n\n  private canvas!: Canvas;\n\n  constructor(context: RuntimeContext, options: MinimapOptions) {\n    super(context, Object.assign({}, Minimap.defaultOptions, options));\n    this.setOnRender();\n    this.bindEvents();\n  }\n\n  public update(options: Partial<MinimapOptions>): void {\n    this.unbindEvents();\n    super.update(options);\n    if ('delay' in options) this.setOnRender();\n    this.bindEvents();\n  }\n\n  private setOnRender() {\n    this.onRender = debounce(() => {\n      this.renderMinimap();\n      this.renderMask();\n    }, this.options.delay);\n  }\n\n  private bindEvents() {\n    const { graph } = this.context;\n    graph.on(GraphEvent.AFTER_DRAW, this.onDraw);\n    graph.on(GraphEvent.AFTER_RENDER, this.onRender);\n    graph.on(GraphEvent.AFTER_ANIMATE, this.onRender);\n    graph.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);\n  }\n\n  private unbindEvents() {\n    const { graph } = this.context;\n    graph.off(GraphEvent.AFTER_DRAW, this.onDraw);\n    graph.off(GraphEvent.AFTER_RENDER, this.onRender);\n    graph.off(GraphEvent.AFTER_ANIMATE, this.onRender);\n    graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);\n  }\n\n  private onDraw = (event: IGraphLifeCycleEvent) => {\n    if (event?.data?.render) return;\n    this.onRender();\n  };\n\n  private onRender!: () => void;\n\n  private shapes = new Map<ID, DisplayObject>();\n\n  /**\n   * <zh/> 创建或更新缩略图\n   *\n   * <en/> Create or update the minimap\n   */\n  private renderMinimap() {\n    const data = this.getElements();\n    const canvas = this.initCanvas();\n    this.setShapes(canvas, data);\n  }\n\n  private getElements(): Required<GraphData> {\n    const { filter } = this.options;\n    const { model, element } = this.context;\n    const originData = model.getData();\n    //过滤那些不存在于elementMap中的数据\n    const data = {\n      nodes: originData.nodes.filter((node) => element?.getElement(idOf(node))),\n      edges: originData.edges.filter((edge) => {\n        const edgeElement = element?.getElement(idOf(edge));\n        // 边数据存在且可见时才保留\n        return edgeElement && isVisible(edgeElement);\n      }),\n      combos: originData.combos.filter((combo) => element?.getElement(idOf(combo))),\n    };\n\n    if (!filter) return data;\n\n    const { nodes, edges, combos } = data;\n\n    return {\n      nodes: nodes.filter((node) => filter(idOf(node), 'node')),\n      edges: edges.filter((edge) => filter(idOf(edge), 'edge')),\n      combos: combos.filter((combo) => filter(idOf(combo), 'combo')),\n    };\n  }\n\n  private setShapes(canvas: Canvas, data: Required<GraphData>) {\n    const { nodes, edges, combos } = data;\n\n    const { shape } = this.options;\n    const { element } = this.context;\n\n    if (shape === 'key') {\n      const ids = new Set<ID>();\n\n      const iterate = (datum: ElementDatum) => {\n        const id = idOf(datum);\n        ids.add(id);\n\n        const target = element!.getElement(id);\n        if (!target) return;\n\n        const shape = target.getShape('key');\n        const cloneShape = this.shapes.get(id) || shape.cloneNode();\n\n        cloneShape.setPosition(shape.getPosition());\n        // keep zIndex / id\n        if (target.style.zIndex) cloneShape.style.zIndex = target.style.zIndex;\n        cloneShape.id = target.id;\n\n        if (!this.shapes.has(id)) {\n          canvas.appendChild(cloneShape);\n          this.shapes.set(id, cloneShape);\n        } else {\n          Object.entries(shape.attributes).forEach(([key, value]) => {\n            if (cloneShape.style[key] !== value) cloneShape.style[key] = value;\n          });\n        }\n      };\n\n      // 注意执行顺序 / Note the execution order\n      edges.forEach(iterate);\n      combos.forEach(iterate);\n      nodes.forEach(iterate);\n\n      this.shapes.forEach((shape, id) => {\n        if (!ids.has(id)) {\n          canvas.removeChild(shape);\n          this.shapes.delete(id);\n        }\n      });\n\n      return;\n    }\n\n    const setPosition = (id: ID, shape: DisplayObject) => {\n      const target = element!.getElement(id)!;\n      const position = target.getPosition();\n      shape.setPosition(position);\n      return shape;\n    };\n\n    canvas.removeChildren();\n\n    edges.forEach((datum) => canvas.appendChild(shape(idOf(datum), 'edge')));\n    combos.forEach((datum) => {\n      canvas.appendChild(setPosition(idOf(datum), shape(idOf(datum), 'combo')));\n    });\n    nodes.forEach((datum) => {\n      canvas.appendChild(setPosition(idOf(datum), shape(idOf(datum), 'node')));\n    });\n  }\n\n  private container!: HTMLElement;\n\n  private initCanvas() {\n    const {\n      renderer,\n      size: [width, height],\n    } = this.options;\n\n    if (this.canvas) {\n      const { width: w, height: h } = this.canvas.getConfig();\n      if (width !== w || height !== h) this.canvas.resize(width, height);\n      if (renderer) this.canvas.setRenderer(renderer);\n    } else {\n      const { className, position, container, containerStyle } = this.options;\n\n      const [$container, canvas] = createPluginCanvas({\n        renderer,\n        width,\n        height,\n        placement: position,\n        className: 'minimap',\n        container,\n        containerStyle,\n        graphCanvas: this.context.canvas,\n      });\n\n      if (className) $container.classList.add(className);\n\n      this.container = $container;\n      this.canvas = canvas;\n    }\n\n    this.setCamera();\n\n    return this.canvas;\n  }\n\n  private landmarkMap = new Map<string, Landmark>();\n\n  private createLandmark(position: Vector3, focalPoint: Vector3, zoom: number) {\n    const key = `${position.join(',')}-${focalPoint.join(',')}-${zoom}`;\n\n    if (this.landmarkMap.has(key)) return this.landmarkMap.get(key)!;\n\n    const camera = this.canvas.getCamera();\n    const landmark = camera.createLandmark(key, {\n      position,\n      focalPoint,\n      zoom,\n    });\n    this.landmarkMap.set(key, landmark);\n    return landmark;\n  }\n\n  private setCamera() {\n    const { canvas } = this.context;\n\n    const camera = this.canvas?.getCamera();\n    if (!camera) return;\n\n    const {\n      size: [minimapWidth, minimapHeight],\n      padding,\n    } = this.options;\n    const [top, right, bottom, left] = parsePadding(padding);\n    const { min: boundsMin, max: boundsMax, center } = canvas.getBounds('elements');\n    const boundsWidth = boundsMax[0] - boundsMin[0];\n    const boundsHeight = boundsMax[1] - boundsMin[1];\n\n    const availableWidth = minimapWidth - left - right;\n    const availableHeight = minimapHeight - top - bottom;\n\n    const scaleX = availableWidth / boundsWidth;\n    const scaleY = availableHeight / boundsHeight;\n    const scale = Math.min(scaleX, scaleY);\n\n    const landmark = this.createLandmark(center, center, scale);\n    camera.gotoLandmark(landmark, 0);\n  }\n\n  private mask: HTMLElement | null = null;\n\n  private get maskBBox(): [number, number, number, number] {\n    const { canvas: graphCanvas } = this.context;\n    const canvasSize = graphCanvas.getSize();\n    const canvasMin = graphCanvas.getCanvasByViewport([0, 0]);\n    const canvasMax = graphCanvas.getCanvasByViewport(canvasSize);\n\n    const maskMin = this.canvas.canvas2Viewport(toPointObject(canvasMin));\n    const maskMax = this.canvas.canvas2Viewport(toPointObject(canvasMax));\n\n    const width = maskMax.x - maskMin.x;\n    const height = maskMax.y - maskMin.y;\n\n    return [maskMin.x, maskMin.y, width, height];\n  }\n\n  /**\n   * <zh/> 计算遮罩包围盒\n   *\n   * <en/> Calculate the bounding box of the mask\n   * @returns <zh/> 遮罩包围盒 | <en/> Mask bounding box\n   */\n  private calculateMaskBBox(): [number, number, number, number] {\n    const {\n      size: [minimapWidth, minimapHeight],\n    } = this.options;\n\n    let [x, y, width, height] = this.maskBBox;\n\n    // clamp x, y, width, height\n    if (x < 0) {\n      width = upper(width + x, minimapWidth);\n      x = 0;\n    }\n    if (y < 0) {\n      height = upper(height + y, minimapHeight);\n      y = 0;\n    }\n    if (x + width > minimapWidth) width = lower(minimapWidth - x, 0);\n    if (y + height > minimapHeight) height = lower(minimapHeight - y, 0);\n\n    return [upper(x, minimapWidth), upper(y, minimapHeight), lower(width, 0), lower(height, 0)];\n  }\n\n  /**\n   * <zh/> 创建或更新遮罩\n   *\n   * <en/> Create or update the mask\n   */\n  private renderMask() {\n    const { maskStyle } = this.options;\n\n    if (!this.mask) {\n      this.mask = document.createElement('div');\n      this.mask.addEventListener('pointerdown', this.onMaskDragStart);\n      this.mask.draggable = true;\n      this.mask.addEventListener('dragstart', (event) => event.preventDefault && event.preventDefault());\n    }\n\n    this.container.appendChild(this.mask);\n\n    Object.assign(this.mask.style, {\n      ...maskStyle,\n      cursor: 'move',\n      position: 'absolute',\n      pointerEvents: 'auto',\n    });\n\n    this.updateMask();\n  }\n\n  private isMaskDragging = false;\n\n  private onMaskDragStart = (event: PointerEvent) => {\n    if (!this.mask) return;\n    this.isMaskDragging = true;\n    this.mask.setPointerCapture(event.pointerId);\n    this.mask.addEventListener('pointermove', this.onMaskDrag);\n    this.mask.addEventListener('pointerup', this.onMaskDragEnd);\n    this.mask.addEventListener('pointercancel', this.onMaskDragEnd);\n  };\n\n  private onMaskDrag = (event: PointerEvent) => {\n    if (!this.mask || !this.isMaskDragging) return;\n    const {\n      size: [minimapWidth, minimapHeight],\n    } = this.options;\n    const { movementX, movementY } = event;\n\n    const { left, top, width: w, height: h } = this.mask.style;\n    const [, , fullWidth, fullHeight] = this.maskBBox;\n\n    let x = parseInt(left) + movementX;\n    let y = parseInt(top) + movementY;\n    let width = parseInt(w);\n    let height = parseInt(h);\n\n    // 确保 mask 在 minimap 内部\n    // Ensure that the mask is inside the minimap\n    if (x < 0) x = 0;\n    if (y < 0) y = 0;\n    if (x + width > minimapWidth) x = lower(minimapWidth - width, 0);\n    if (y + height > minimapHeight) y = lower(minimapHeight - height, 0);\n\n    // 当拖拽画布导致 mask 缩小时，拖拽 mask 时，能够恢复到实际大小\n    // When dragging the canvas causes the mask to shrink, dragging the mask will restore it to its actual size\n    if (width < fullWidth) {\n      if (movementX > 0) ((x = lower(x - movementX, 0)), (width = upper(width + movementX, minimapWidth)));\n      else if (movementX < 0) width = upper(width - movementX, minimapWidth);\n    }\n    if (height < fullHeight) {\n      if (movementY > 0) ((y = lower(y - movementY, 0)), (height = upper(height + movementY, minimapHeight)));\n      else if (movementY < 0) height = upper(height - movementY, minimapHeight);\n    }\n\n    Object.assign(this.mask.style, {\n      left: x + 'px',\n      top: y + 'px',\n      width: width + 'px',\n      height: height + 'px',\n    });\n\n    // 基于 movement 进行相对移动\n    // Move relative to movement\n    const deltaX = parseInt(left) - x;\n    const deltaY = parseInt(top) - y;\n    if (deltaX === 0 && deltaY === 0) return;\n\n    const zoom1 = this.context.canvas.getCamera().getZoom();\n    const zoom2 = this.canvas.getCamera().getZoom();\n    const ratio = zoom1 / zoom2;\n\n    this.context.graph.translateBy([deltaX * ratio, deltaY * ratio], false);\n  };\n\n  private onMaskDragEnd = (event: PointerEvent) => {\n    if (!this.mask) return;\n    this.isMaskDragging = false;\n    this.mask.releasePointerCapture(event.pointerId);\n    this.mask.removeEventListener('pointermove', this.onMaskDrag);\n    this.mask.removeEventListener('pointerup', this.onMaskDragEnd);\n    this.mask.removeEventListener('pointercancel', this.onMaskDragEnd);\n  };\n\n  private onTransform = throttle(\n    () => {\n      if (this.isMaskDragging) return;\n      this.updateMask();\n      this.setCamera();\n    },\n    32,\n    { leading: true },\n  ) as () => void;\n\n  private updateMask() {\n    if (!this.mask) return;\n    const [x, y, width, height] = this.calculateMaskBBox();\n\n    Object.assign(this.mask.style, {\n      top: y + 'px',\n      left: x + 'px',\n      width: width + 'px',\n      height: height + 'px',\n    });\n  }\n\n  public destroy(): void {\n    this.unbindEvents();\n    this.canvas?.destroy();\n    this.mask?.remove();\n    this.container?.remove();\n    super.destroy();\n  }\n}\n\nconst upper = (value: number, max: number) => Math.min(value, max);\n\nconst lower = (value: number, min: number) => Math.max(value, min);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}