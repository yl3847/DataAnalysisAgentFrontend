{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { isFunction } from '@antv/util';\nimport { CanvasEvent, CommonEvent } from '../constants';\nimport { ELEMENT_TYPES } from '../constants/element';\nimport { idOf } from '../utils/id';\nimport { getElementNthDegreeIds } from '../utils/relation';\nimport { Shortcut } from '../utils/shortcut';\nimport { statesOf } from '../utils/state';\nimport { BaseBehavior } from './base-behavior';\n/**\n * <zh/> 点击元素\n *\n * <en/> Click Element\n * @remarks\n * <zh/> 当鼠标点击元素时，可以激活元素的状态，例如选中节点或边。当 degree 设置为 `1` 时，点击节点会高亮当前节点及其直接相邻的节点和边。\n *\n * <en/> When the mouse clicks on an element, you can activate the state of the element, such as selecting nodes or edges. When the degree is 1, clicking on a node will highlight the current node and its directly adjacent nodes and edges.\n */\nexport class ClickSelect extends BaseBehavior {\n  constructor(context, options) {\n    super(context, Object.assign({}, ClickSelect.defaultOptions, options));\n    this.onClickSelect = event => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (!this.validate(event)) return;\n      yield this.updateState(event);\n      (_b = (_a = this.options).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    });\n    this.onClickCanvas = event => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (!this.validate(event)) return;\n      yield this.clearState();\n      (_b = (_a = this.options).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    });\n    this.shortcut = new Shortcut(context.graph);\n    this.bindEvents();\n  }\n  bindEvents() {\n    const {\n      graph\n    } = this.context;\n    this.unbindEvents();\n    ELEMENT_TYPES.forEach(type => {\n      graph.on(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);\n    });\n    graph.on(CanvasEvent.CLICK, this.onClickCanvas);\n  }\n  get isMultipleSelect() {\n    const {\n      multiple,\n      trigger\n    } = this.options;\n    return multiple && this.shortcut.match(trigger);\n  }\n  getNeighborIds(event) {\n    const {\n      target,\n      targetType\n    } = event;\n    const {\n      graph\n    } = this.context;\n    const {\n      degree\n    } = this.options;\n    return getElementNthDegreeIds(graph, targetType, target.id, typeof degree === 'function' ? degree(event) : degree).filter(id => id !== target.id);\n  }\n  updateState(event) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        state: selectState,\n        unselectedState,\n        neighborState,\n        animation\n      } = this.options;\n      if (!selectState && !neighborState && !unselectedState) return;\n      const {\n        target\n      } = event;\n      const {\n        graph\n      } = this.context;\n      const datum = graph.getElementData(target.id);\n      const type = statesOf(datum).includes(selectState) ? 'unselect' : 'select';\n      const states = {};\n      const isMultipleSelect = this.isMultipleSelect;\n      const click = [target.id];\n      const neighbor = this.getNeighborIds(event);\n      if (!isMultipleSelect) {\n        if (type === 'select') {\n          Object.assign(states, this.getClearStates(!!unselectedState));\n          const addState = (list, state) => {\n            list.forEach(id => {\n              if (!states[id]) states[id] = graph.getElementState(id);\n              states[id].push(state);\n            });\n          };\n          addState(click, selectState);\n          addState(neighbor, neighborState);\n          if (unselectedState) {\n            Object.keys(states).forEach(id => {\n              if (!click.includes(id) && !neighbor.includes(id)) states[id].push(unselectedState);\n            });\n          }\n        } else Object.assign(states, this.getClearStates());\n      } else {\n        Object.assign(states, this.getDataStates());\n        if (type === 'select') {\n          const addState = (list, state) => {\n            list.forEach(id => {\n              const dataStatesSet = new Set(graph.getElementState(id));\n              dataStatesSet.add(state);\n              dataStatesSet.delete(unselectedState);\n              states[id] = Array.from(dataStatesSet);\n            });\n          };\n          addState(click, selectState);\n          addState(neighbor, neighborState);\n          if (unselectedState) {\n            Object.keys(states).forEach(id => {\n              const _states = states[id];\n              if (!_states.includes(selectState) && !_states.includes(neighborState) && !_states.includes(unselectedState)) {\n                states[id].push(unselectedState);\n              }\n            });\n          }\n        } else {\n          const targetState = states[target.id];\n          states[target.id] = targetState.filter(s => s !== selectState && s !== neighborState);\n          if (!targetState.includes(unselectedState)) states[target.id].push(unselectedState);\n          neighbor.forEach(id => {\n            states[id] = states[id].filter(s => s !== neighborState);\n            if (!states[id].includes(selectState)) states[id].push(unselectedState);\n          });\n        }\n      }\n      yield graph.setElementState(states, animation);\n    });\n  }\n  getDataStates() {\n    const {\n      graph\n    } = this.context;\n    const {\n      nodes,\n      edges,\n      combos\n    } = graph.getData();\n    const states = {};\n    [...nodes, ...edges, ...combos].forEach(data => {\n      states[idOf(data)] = statesOf(data);\n    });\n    return states;\n  }\n  /**\n   * <zh/> 获取需要清除的状态\n   *\n   * <en/> Get the states that need to be cleared\n   * @param complete - <zh/> 是否返回所有状态 | <en/> Whether to return all states\n   * @returns - <zh/> 需要清除的状态 | <en/> States that need to be cleared\n   */\n  getClearStates(complete = false) {\n    const {\n      graph\n    } = this.context;\n    const {\n      state,\n      unselectedState,\n      neighborState\n    } = this.options;\n    const statesToClear = new Set([state, unselectedState, neighborState]);\n    const {\n      nodes,\n      edges,\n      combos\n    } = graph.getData();\n    const states = {};\n    [...nodes, ...edges, ...combos].forEach(data => {\n      const datumStates = statesOf(data);\n      const newStates = datumStates.filter(s => !statesToClear.has(s));\n      if (complete) states[idOf(data)] = newStates;else if (newStates.length !== datumStates.length) states[idOf(data)] = newStates;\n    });\n    return states;\n  }\n  clearState() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        graph\n      } = this.context;\n      yield graph.setElementState(this.getClearStates(), this.options.animation);\n    });\n  }\n  validate(event) {\n    if (this.destroyed) return false;\n    const {\n      enable\n    } = this.options;\n    if (isFunction(enable)) return enable(event);\n    return !!enable;\n  }\n  unbindEvents() {\n    const {\n      graph\n    } = this.context;\n    ELEMENT_TYPES.forEach(type => {\n      graph.off(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);\n    });\n    graph.off(CanvasEvent.CLICK, this.onClickCanvas);\n  }\n  destroy() {\n    this.unbindEvents();\n    super.destroy();\n  }\n}\nClickSelect.defaultOptions = {\n  animation: true,\n  enable: true,\n  multiple: false,\n  trigger: ['shift'],\n  state: 'selected',\n  neighborState: 'selected',\n  unselectedState: undefined,\n  degree: 0\n};","map":{"version":3,"names":["isFunction","CanvasEvent","CommonEvent","ELEMENT_TYPES","idOf","getElementNthDegreeIds","Shortcut","statesOf","BaseBehavior","ClickSelect","constructor","context","options","Object","assign","defaultOptions","onClickSelect","event","__awaiter","validate","updateState","_b","_a","onClick","call","onClickCanvas","clearState","shortcut","graph","bindEvents","unbindEvents","forEach","type","on","CLICK","isMultipleSelect","multiple","trigger","match","getNeighborIds","target","targetType","degree","id","filter","state","selectState","unselectedState","neighborState","animation","datum","getElementData","includes","states","click","neighbor","getClearStates","addState","list","getElementState","push","keys","getDataStates","dataStatesSet","Set","add","delete","Array","from","_states","targetState","s","setElementState","nodes","edges","combos","getData","data","complete","statesToClear","datumStates","newStates","has","length","destroyed","enable","off","destroy","undefined"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/behaviors/click-select.ts"],"sourcesContent":["import { isFunction } from '@antv/util';\nimport { CanvasEvent, CommonEvent } from '../constants';\nimport { ELEMENT_TYPES } from '../constants/element';\nimport type { RuntimeContext } from '../runtime/types';\nimport type { Element, ElementType, ID, IPointerEvent, State } from '../types';\nimport { idOf } from '../utils/id';\nimport { getElementNthDegreeIds } from '../utils/relation';\nimport type { ShortcutKey } from '../utils/shortcut';\nimport { Shortcut } from '../utils/shortcut';\nimport { statesOf } from '../utils/state';\nimport type { BaseBehaviorOptions } from './base-behavior';\nimport { BaseBehavior } from './base-behavior';\n\n/**\n * <zh/> 点击元素交互配置项\n *\n * <en/> Click element behavior options\n */\nexport interface ClickSelectOptions extends BaseBehaviorOptions {\n  /**\n   * <zh/> 是否启用动画\n   *\n   * <en/> Whether to enable animation\n   * @defaultValue true\n   */\n  animation?: boolean;\n  /**\n   * <zh/> 是否启用点击元素的功能\n   *\n   * <en/> Whether to enable the function of clicking the element\n   * @defaultValue true\n   * @remarks\n   * <zh/> 可以通过函数的方式动态控制是否启用，例如只有节点被选中时才启用。\n   *\n   * <en/> Whether to enable can be dynamically controlled by functions, such as only when nodes are selected.\n   *\n   * ```json\n   * { enable: event => event.targetType === 'node'}\n   * ```\n   */\n  enable?: boolean | ((event: IPointerEvent) => boolean);\n  /**\n   * <zh/> 是否允许多选\n   *\n   * <en/> Whether to allow multiple selection\n   * @defaultValue false\n   */\n  multiple?: boolean;\n  /**\n   * <zh/> 按下该快捷键配合鼠标点击进行多选\n   *\n   * <en/> Press this shortcut key to apply multiple selection with mouse click\n   * @defaultValue ['shift']\n   */\n  trigger?: ShortcutKey;\n  /**\n   * <zh/> 当元素被选中时应用的状态\n   *\n   * <en/> The state to be applied when an element is selected\n   * @defaultValue 'selected'\n   */\n  state?: State;\n  /**\n   * <zh/> 当有元素选中时，其相邻 n 度关系的元素应用的状态。n 的值由属性 degree 控制，例如 degree 为 1 时表示直接相邻的元素\n   *\n   * <en/> The state to be applied to the neighboring elements within n degrees when an element is selected. The value of n is controlled by the degree property, for instance, a degree of 1 indicates direct neighbors\n   * @defaultValue 'selected'\n   */\n  neighborState?: State;\n  /**\n   * <zh/> 当有元素被选中时，除了选中元素及其受影响的邻居元素外，其他所有元素应用的状态。\n   *\n   * <en/> The state to be applied to all unselected elements when some elements are selected, excluding the selected element and its affected neighbors\n   */\n  unselectedState?: State;\n  /**\n   * <zh/> 选中元素的度，即决定了影响范围\n   *\n   * <en/> The degree to determine the scope of influence\n   * @defaultValue 0\n   * @remarks\n   * <zh/> 对于节点来说，`0` 表示只选中当前节点，`1` 表示选中当前节点及其直接相邻的节点和边，以此类推。\n   *\n   * <zh/> 对于边来说，`0` 表示只选中当前边，`1` 表示选中当前边及其直接相邻的节点，以此类推。\n   *\n   * <en/> For nodes, `0` means only the current node is selected, `1` means the current node and its directly adjacent nodes and edges are selected, etc.\n   *\n   * <en/> For edges, `0 `means only the current edge is selected,`1` means the current edge and its directly adjacent nodes are selected, etc.\n   */\n  degree?: number | ((event: IPointerEvent) => number);\n  /**\n   * <zh/> 点击元素时的回调\n   *\n   * <en/> Callback when the element is clicked\n   * @param event - <zh/> 点击事件 | <en/> click event\n   */\n  onClick?: (event: IPointerEvent) => void;\n}\n\n/**\n * <zh/> 点击元素\n *\n * <en/> Click Element\n * @remarks\n * <zh/> 当鼠标点击元素时，可以激活元素的状态，例如选中节点或边。当 degree 设置为 `1` 时，点击节点会高亮当前节点及其直接相邻的节点和边。\n *\n * <en/> When the mouse clicks on an element, you can activate the state of the element, such as selecting nodes or edges. When the degree is 1, clicking on a node will highlight the current node and its directly adjacent nodes and edges.\n */\nexport class ClickSelect extends BaseBehavior<ClickSelectOptions> {\n  private shortcut: Shortcut;\n\n  static defaultOptions: Partial<ClickSelectOptions> = {\n    animation: true,\n    enable: true,\n    multiple: false,\n    trigger: ['shift'],\n    state: 'selected',\n    neighborState: 'selected',\n    unselectedState: undefined,\n    degree: 0,\n  };\n\n  constructor(context: RuntimeContext, options: ClickSelectOptions) {\n    super(context, Object.assign({}, ClickSelect.defaultOptions, options));\n    this.shortcut = new Shortcut(context.graph);\n    this.bindEvents();\n  }\n\n  private bindEvents() {\n    const { graph } = this.context;\n    this.unbindEvents();\n    ELEMENT_TYPES.forEach((type) => {\n      graph.on(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);\n    });\n    graph.on(CanvasEvent.CLICK, this.onClickCanvas);\n  }\n\n  private onClickSelect = async (event: IPointerEvent<Element>) => {\n    if (!this.validate(event)) return;\n    await this.updateState(event);\n    this.options.onClick?.(event);\n  };\n\n  private onClickCanvas = async (event: IPointerEvent) => {\n    if (!this.validate(event)) return;\n    await this.clearState();\n    this.options.onClick?.(event);\n  };\n\n  private get isMultipleSelect() {\n    const { multiple, trigger } = this.options;\n    return multiple && this.shortcut.match(trigger);\n  }\n\n  private getNeighborIds(event: IPointerEvent<Element>) {\n    const { target, targetType } = event;\n    const { graph } = this.context;\n    const { degree } = this.options;\n    return getElementNthDegreeIds(\n      graph,\n      targetType as ElementType,\n      target.id,\n      typeof degree === 'function' ? degree(event) : degree,\n    ).filter((id) => id !== target.id);\n  }\n\n  private async updateState(event: IPointerEvent<Element>) {\n    const { state: selectState, unselectedState, neighborState, animation } = this.options;\n    if (!selectState && !neighborState && !unselectedState) return;\n\n    const { target } = event;\n    const { graph } = this.context;\n\n    const datum = graph.getElementData(target.id);\n\n    const type = statesOf(datum).includes(selectState) ? 'unselect' : 'select';\n\n    const states: Record<ID, State[]> = {};\n\n    const isMultipleSelect = this.isMultipleSelect;\n\n    const click = [target.id];\n    const neighbor = this.getNeighborIds(event);\n\n    if (!isMultipleSelect) {\n      if (type === 'select') {\n        Object.assign(states, this.getClearStates(!!unselectedState));\n        const addState = (list: ID[], state: State) => {\n          list.forEach((id) => {\n            if (!states[id]) states[id] = graph.getElementState(id);\n            states[id].push(state);\n          });\n        };\n        addState(click, selectState);\n        addState(neighbor, neighborState);\n        if (unselectedState) {\n          Object.keys(states).forEach((id) => {\n            if (!click.includes(id) && !neighbor.includes(id)) states[id].push(unselectedState);\n          });\n        }\n      } else Object.assign(states, this.getClearStates());\n    } else {\n      Object.assign(states, this.getDataStates());\n\n      if (type === 'select') {\n        const addState = (list: ID[], state: State) => {\n          list.forEach((id) => {\n            const dataStatesSet = new Set(graph.getElementState(id));\n            dataStatesSet.add(state);\n            dataStatesSet.delete(unselectedState);\n            states[id] = Array.from(dataStatesSet);\n          });\n        };\n\n        addState(click, selectState);\n        addState(neighbor, neighborState);\n        if (unselectedState) {\n          Object.keys(states).forEach((id) => {\n            const _states = states[id];\n            if (\n              !_states.includes(selectState) &&\n              !_states.includes(neighborState) &&\n              !_states.includes(unselectedState)\n            ) {\n              states[id].push(unselectedState);\n            }\n          });\n        }\n      } else {\n        const targetState = states[target.id];\n        states[target.id] = targetState.filter((s) => s !== selectState && s !== neighborState);\n        if (!targetState.includes(unselectedState)) states[target.id].push(unselectedState);\n        neighbor.forEach((id) => {\n          states[id] = states[id].filter((s) => s !== neighborState);\n          if (!states[id].includes(selectState)) states[id].push(unselectedState);\n        });\n      }\n    }\n\n    await graph.setElementState(states, animation);\n  }\n\n  private getDataStates() {\n    const { graph } = this.context;\n    const { nodes, edges, combos } = graph.getData();\n\n    const states: Record<ID, State[]> = {};\n    [...nodes, ...edges, ...combos].forEach((data) => {\n      states[idOf(data)] = statesOf(data);\n    });\n\n    return states;\n  }\n\n  /**\n   * <zh/> 获取需要清除的状态\n   *\n   * <en/> Get the states that need to be cleared\n   * @param complete - <zh/> 是否返回所有状态 | <en/> Whether to return all states\n   * @returns - <zh/> 需要清除的状态 | <en/> States that need to be cleared\n   */\n  private getClearStates(complete = false) {\n    const { graph } = this.context;\n    const { state, unselectedState, neighborState } = this.options;\n    const statesToClear = new Set([state, unselectedState, neighborState]);\n    const { nodes, edges, combos } = graph.getData();\n\n    const states: Record<ID, State[]> = {};\n    [...nodes, ...edges, ...combos].forEach((data) => {\n      const datumStates = statesOf(data);\n      const newStates = datumStates.filter((s) => !statesToClear.has(s));\n      if (complete) states[idOf(data)] = newStates;\n      else if (newStates.length !== datumStates.length) states[idOf(data)] = newStates;\n    });\n\n    return states;\n  }\n\n  private async clearState() {\n    const { graph } = this.context;\n    await graph.setElementState(this.getClearStates(), this.options.animation);\n  }\n\n  private validate(event: IPointerEvent) {\n    if (this.destroyed) return false;\n    const { enable } = this.options;\n    if (isFunction(enable)) return enable(event);\n    return !!enable;\n  }\n\n  private unbindEvents() {\n    const { graph } = this.context;\n\n    ELEMENT_TYPES.forEach((type) => {\n      graph.off(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);\n    });\n    graph.off(CanvasEvent.CLICK, this.onClickCanvas);\n  }\n\n  public destroy() {\n    this.unbindEvents();\n    super.destroy();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}