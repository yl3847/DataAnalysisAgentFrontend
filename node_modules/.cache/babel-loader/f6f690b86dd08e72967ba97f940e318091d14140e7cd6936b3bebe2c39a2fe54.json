{"ast":null,"code":"import { MaybeZeroY1, MaybeZeroX } from '../transform';\nimport { IntervalShape, IntervalHollow, IntervalFunnel, IntervalPyramid } from '../shape';\nimport { baseGeometryChannels, basePostInference, basePreInference, tooltip1d } from './utils';\nfunction bandWidth(scale, x) {\n  return scale.getBandWidth(scale.invert(x));\n}\nconst shape = {\n  rect: IntervalShape,\n  hollow: IntervalHollow,\n  funnel: IntervalFunnel,\n  pyramid: IntervalPyramid\n};\n/**\n * Convert value for each channel to rect shapes.\n * p0        p1\n *    ┌────┐\n *    │    │\n *    │    │\n * p3 └────┘ p2\n */\nexport const Interval = () => {\n  return (index, scale, value, coordinate) => {\n    const {\n      x: X,\n      y: Y,\n      y1: Y1,\n      series: S,\n      size: SZ\n    } = value;\n    // Calc width for each interval.\n    // The scales for x and series channels must be band scale.\n    const x = scale.x;\n    const series = scale.series;\n    const [width] = coordinate.getSize();\n    const NSZ = SZ ? SZ.map(d => +d / width) : null;\n    const x1x2 = !SZ ? (x, w, i) => [x, x + w] : (x, w, i) => {\n      const mx = x + w / 2;\n      const s = NSZ[i];\n      return [mx - s / 2, mx + s / 2];\n    };\n    // Calc the points of bounding box for the interval.\n    // They are start from left-top corner in clock wise order.\n    const P = Array.from(index, i => {\n      const groupWidth = bandWidth(x, X[i]);\n      const ratio = series ? bandWidth(series, S === null || S === void 0 ? void 0 : S[i]) : 1;\n      const width = groupWidth * ratio;\n      const offset = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;\n      const x0 = +X[i] + offset;\n      const [x1, x2] = x1x2(x0, width, i);\n      const y1 = +Y[i];\n      const y2 = +Y1[i];\n      const p1 = [x1, y1];\n      const p2 = [x2, y1];\n      const p3 = [x2, y2];\n      const p4 = [x1, y2];\n      return [p1, p2, p3, p4].map(d => coordinate.map(d));\n    });\n    return [index, P];\n  };\n};\nInterval.props = {\n  defaultShape: 'rect',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [...baseGeometryChannels({\n    shapes: Object.keys(shape)\n  }), {\n    name: 'x',\n    scale: 'band',\n    required: true\n  }, {\n    name: 'y',\n    required: true\n  }, {\n    name: 'series',\n    scale: 'band'\n  }, {\n    name: 'size'\n  }],\n  preInference: [...basePreInference(), {\n    type: MaybeZeroY1\n  }, {\n    type: MaybeZeroX\n  }],\n  postInference: [...basePostInference(), ...tooltip1d()],\n  interaction: {\n    shareTooltip: true\n  }\n};","map":{"version":3,"names":["MaybeZeroY1","MaybeZeroX","IntervalShape","IntervalHollow","IntervalFunnel","IntervalPyramid","baseGeometryChannels","basePostInference","basePreInference","tooltip1d","bandWidth","scale","x","getBandWidth","invert","shape","rect","hollow","funnel","pyramid","Interval","index","value","coordinate","X","y","Y","y1","Y1","series","S","size","SZ","width","getSize","NSZ","map","d","x1x2","w","i","mx","s","P","Array","from","groupWidth","ratio","offset","x0","x1","x2","y2","p1","p2","p3","p4","props","defaultShape","defaultLabelShape","composite","channels","shapes","Object","keys","name","required","preInference","type","postInference","interaction","shareTooltip"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/mark/interval.ts"],"sourcesContent":["import { Band } from '@antv/scale';\nimport { MarkComponent as MC, Vector2 } from '../runtime';\nimport { IntervalMark } from '../spec';\nimport { MaybeZeroY1, MaybeZeroX } from '../transform';\nimport {\n  IntervalShape,\n  IntervalHollow,\n  IntervalFunnel,\n  IntervalPyramid,\n} from '../shape';\nimport {\n  baseGeometryChannels,\n  basePostInference,\n  basePreInference,\n  tooltip1d,\n} from './utils';\n\nfunction bandWidth(scale: Band, x: any): number {\n  return scale.getBandWidth(scale.invert(x));\n}\n\nconst shape = {\n  rect: IntervalShape,\n  hollow: IntervalHollow,\n  funnel: IntervalFunnel,\n  pyramid: IntervalPyramid,\n};\n\nexport type IntervalOptions = Omit<IntervalMark, 'type'>;\n\n/**\n * Convert value for each channel to rect shapes.\n * p0        p1\n *    ┌────┐\n *    │    │\n *    │    │\n * p3 └────┘ p2\n */\nexport const Interval: MC<IntervalOptions> = () => {\n  return (index, scale, value, coordinate) => {\n    const { x: X, y: Y, y1: Y1, series: S, size: SZ } = value;\n\n    // Calc width for each interval.\n    // The scales for x and series channels must be band scale.\n    const x = scale.x as Band;\n    const series = scale.series as Band;\n    const [width] = coordinate.getSize();\n    const NSZ = SZ ? SZ.map((d) => +d / width) : null;\n    const x1x2 = !SZ\n      ? (x: number, w: number, i: number) => [x, x + w]\n      : (x: number, w: number, i: number) => {\n          const mx = x + w / 2;\n          const s = NSZ[i];\n          return [mx - s / 2, mx + s / 2];\n        };\n\n    // Calc the points of bounding box for the interval.\n    // They are start from left-top corner in clock wise order.\n    const P = Array.from(index, (i) => {\n      const groupWidth = bandWidth(x, X[i]);\n      const ratio = series ? bandWidth(series, S?.[i]) : 1;\n      const width = groupWidth * ratio;\n      const offset = (+S?.[i] || 0) * groupWidth;\n      const x0 = +X[i] + offset;\n      const [x1, x2] = x1x2(x0, width, i);\n      const y1 = +Y[i];\n      const y2 = +Y1[i];\n      const p1 = [x1, y1];\n      const p2 = [x2, y1];\n      const p3 = [x2, y2];\n      const p4 = [x1, y2];\n      return [p1, p2, p3, p4].map((d) => coordinate.map(d)) as Vector2[];\n    });\n    return [index, P];\n  };\n};\n\nInterval.props = {\n  defaultShape: 'rect',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [\n    ...baseGeometryChannels({ shapes: Object.keys(shape) }),\n    { name: 'x', scale: 'band', required: true },\n    { name: 'y', required: true },\n    { name: 'series', scale: 'band' },\n    { name: 'size' },\n  ],\n  preInference: [\n    ...basePreInference(),\n    { type: MaybeZeroY1 },\n    { type: MaybeZeroX },\n  ],\n  postInference: [...basePostInference(), ...tooltip1d()],\n  interaction: { shareTooltip: true },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}