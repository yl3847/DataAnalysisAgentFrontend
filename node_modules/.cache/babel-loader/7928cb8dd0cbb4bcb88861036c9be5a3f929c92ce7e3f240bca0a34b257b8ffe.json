{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/graphlib/src/types.ts"],"sourcesContent":["import type { Graph } from './graph';\n\n/**\n * Supported node/edge ID type.\n *\n * \"1\" and 1 are treated as different IDs.\n */\nexport type ID = string | number;\n\nexport type PlainObject = Record<string, unknown>;\n\nexport interface Node<D extends PlainObject> {\n  /**\n   * Every node in a graph must have a unique ID.\n   */\n  id: ID;\n\n  /**\n   * Node data should be an object with string key and any value.\n   */\n  data: D;\n}\n\nexport interface Edge<D extends PlainObject> {\n  /**\n   * Every edge in a graph must have a unique ID.\n   */\n  id: ID;\n\n  /**\n   * The ID of the starting node of the edge.\n   */\n  source: ID;\n\n  /**\n   * The ID of the ending node of the edge.\n   */\n  target: ID;\n\n  /**\n   * Edge data should be an object with string key and any value.\n   */\n  data: D;\n}\n\n/**\n * TreeData is a nested data structure that contains nodes represent a tree.\n */\nexport interface TreeData<D> {\n  /**\n   * Tree node IDs must be unique within the whole graph, not only the current tree.\n   */\n  id: ID;\n\n  /**\n   * An object with string key and any value.\n   */\n  data: D;\n\n  /**\n   * Children nodes. Each node itself is a TreeData object, allowing for an arbitrary depth of nesting.\n   */\n  children?: TreeData<D>[];\n}\n\n/** Options to create a graph. */\nexport interface GraphOptions<N extends PlainObject, E extends PlainObject> {\n  /**\n   * An array of node data representing the initial nodes.\n   *\n   * Each node must have a unique ID.\n   *\n   * @example\n   * [\n   *   { id: 1, color: 'red' },\n   *   { id: 2, color: 'blue' },\n   * ]\n   */\n  nodes?: Node<N>[];\n\n  /**\n   * An array of edge data representing the initial edges.\n   *\n   * Each edge must have a unique ID.\n   *\n   * The source and target of each edge must be present in `nodes`.\n   *\n   * @example\n   * [\n   *   { id: 9, source: 1, target: 2, weight: 10 },\n   * ]\n   */\n  edges?: Edge<E>[];\n\n  tree?: TreeData<N> | TreeData<N>[];\n\n  /**\n   * A listener function which will be called with a {@link GraphChangedEvent} whenever a graph change happened.\n   */\n  onChanged?: (event: GraphChangedEvent<N, E>) => void;\n}\n\nexport type TreeIndices<N> = Map<\n  string | undefined,\n  {\n    parentMap: Map<ID, N>;\n    childrenMap: Map<ID, Set<N>>;\n  }\n>;\n\nexport interface GraphChangedEvent<\n  N extends PlainObject,\n  E extends PlainObject,\n> {\n  /**\n   * The {@link Graph} instance which triggered this event.\n   */\n  graph: Graph<N, E>;\n\n  /**\n   * Atomic changes that have occurred in the graph since the last time `graph.onChanged` was triggered.\n   *\n   * `changes` are ordered by the time they occurred.\n   *\n   * Each change object is a smallest unit of change that can be made to a graph, including addition, removal, or modification of nodes or edges.\n   *\n   * You can call {@link Graph.reduceChanges} to reduce them.\n   */\n  changes: GraphChange<N, E>[];\n}\n\nexport type GraphChange<N extends PlainObject, E extends PlainObject> =\n  | NodeAdded<N>\n  | NodeRemoved<N>\n  | NodeDataUpdated<N>\n  | EdgeAdded<E>\n  | EdgeRemoved<E>\n  | EdgeUpdated<E>\n  | EdgeDataUpdated<E>\n  | TreeStructureAttached\n  | TreeStructureDetached\n  | TreeStructureChanged;\n\nexport type NodeAdded<D extends PlainObject> = {\n  type: 'NodeAdded';\n  value: Node<D>;\n};\n\nexport type NodeRemoved<D extends PlainObject> = {\n  type: 'NodeRemoved';\n  value: Node<D>;\n};\n\nexport type NodeDataUpdated<D extends PlainObject> = {\n  type: 'NodeDataUpdated';\n  id: ID;\n  propertyName?: PropertyKey;\n  oldValue: any;\n  newValue: any;\n};\n\nexport type EdgeAdded<D extends PlainObject> = {\n  type: 'EdgeAdded';\n  value: Edge<D>;\n};\n\nexport type EdgeRemoved<D extends PlainObject> = {\n  type: 'EdgeRemoved';\n  value: Edge<D>;\n};\n\nexport type EdgeUpdated<D extends PlainObject> = {\n  type: 'EdgeUpdated';\n  id: ID;\n  propertyName: 'source' | 'target';\n  oldValue: ID;\n  newValue: ID;\n};\n\nexport type EdgeDataUpdated<D extends PlainObject> = {\n  type: 'EdgeDataUpdated';\n  id: ID;\n  propertyName?: PropertyKey;\n  oldValue: any;\n  newValue: any;\n};\n\nexport type TreeStructureAttached = {\n  type: 'TreeStructureAttached';\n  treeKey: string | undefined;\n};\n\nexport type TreeStructureDetached = {\n  type: 'TreeStructureDetached';\n  treeKey: string | undefined;\n};\n\nexport type TreeStructureChanged = {\n  type: 'TreeStructureChanged';\n  treeKey: string | undefined;\n  nodeId: ID;\n  oldParentId?: ID;\n  newParentId: ID;\n};\n\n/** Options to create a GraphView */\nexport interface GraphViewOptions<\n  N extends PlainObject,\n  E extends PlainObject,\n> {\n  /** The original Graph */\n  graph: Graph<N, E>;\n  nodeFilter?: (node: Node<N>) => boolean;\n  edgeFilter?: (edge: Edge<E>, source: Node<N>, target: Node<N>) => boolean;\n  /**\n   * Cache mode of the GraphView. Defaults to 'none'.\n   *\n   * - `none`: Use no cache. Filters are applied when reading data. Fast to create but a bit\n   * slow to read data.\n   *\n   * - `auto`: Automatically cache data when view created or graph changed. Fast to read\n   * data but takes time to build up cache. You should call `stopAutoCache()` to avoid\n   * unnecessary updates if the GraphView is no longer active.\n   *\n   * - `manual` Manage cache manually. `clearCache()` `refreshCache()` `updateCache()`\n   * might be useful.\n   */\n  cache?: 'none' | 'auto' | 'manual';\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}