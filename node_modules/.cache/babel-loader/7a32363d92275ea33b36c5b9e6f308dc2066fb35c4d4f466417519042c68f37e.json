{"ast":null,"code":"// @ts-ignore medianIndex exist in d3-array@3.2.0, but @types/d3-array Expired.\nimport { maxIndex, minIndex, medianIndex } from '@antv/vendor/d3-array';\nimport { createGroups } from './utils/order';\nimport { columnOf } from './utils/helper';\nimport { lttb } from './utils/lttb';\nfunction normalizeSample(strategy) {\n  if (typeof strategy === 'function') return strategy;\n  if (strategy === 'lttb') return lttb;\n  const strategies = {\n    first: f => [f[0]],\n    last: f => [f[f.length - 1]],\n    min: (f, X, Y) => [f[minIndex(f, i => Y[i])]],\n    max: (f, X, Y) => [f[maxIndex(f, i => Y[i])]],\n    median: (f, X, Y) => [f[medianIndex(f, i => Y[i])]]\n  };\n  const sampleFunction = strategies[strategy] || strategies.median;\n  return (I, X, Y, thresholds) => {\n    // Sepreate group to frames, then sample each frame.\n    // Keep more data as possible.\n    const frameSize = Math.max(1, Math.floor(I.length / thresholds));\n    const frames = getFrames(I, frameSize);\n    return frames.flatMap(frame => sampleFunction(frame, X, Y));\n  };\n}\n/**\n * Split the array into frame with each frameSize.\n */\nfunction getFrames(I, frameSize) {\n  const size = I.length;\n  const frames = [];\n  let i = 0;\n  while (i < size) {\n    frames.push(I.slice(i, i += frameSize));\n  }\n  return frames;\n}\n/**\n * The sample transform groups marks with specified groupBy fields, and\n * sample data for each group when data.length >= threshold(default = 2000).\n */\nexport const Sample = (options = {}) => {\n  const {\n    strategy = 'median',\n    thresholds = 2000,\n    groupBy = ['series', 'color']\n  } = options;\n  const sampleFunction = normalizeSample(strategy);\n  return (I, mark) => {\n    const {\n      encode\n    } = mark;\n    const groups = createGroups(groupBy, I, mark);\n    const [X] = columnOf(encode, 'x');\n    const [Y] = columnOf(encode, 'y');\n    return [groups.flatMap(g => sampleFunction(g, X, Y, thresholds)), mark];\n  };\n};\nSample.props = {};","map":{"version":3,"names":["maxIndex","minIndex","medianIndex","createGroups","columnOf","lttb","normalizeSample","strategy","strategies","first","f","last","length","min","X","Y","i","max","median","sampleFunction","I","thresholds","frameSize","Math","floor","frames","getFrames","flatMap","frame","size","push","slice","Sample","options","groupBy","mark","encode","groups","g","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/sample.ts"],"sourcesContent":["// @ts-ignore medianIndex exist in d3-array@3.2.0, but @types/d3-array Expired.\nimport { maxIndex, minIndex, medianIndex } from '@antv/vendor/d3-array';\nimport { TransformComponent as TC, Primitive } from '../runtime';\nimport { SampleTransform, SampleFunction } from '../spec';\nimport { createGroups } from './utils/order';\nimport { columnOf } from './utils/helper';\nimport { lttb } from './utils/lttb';\n\nexport type SampleOptions = Omit<SampleTransform, 'type'>;\n\nfunction normalizeSample(\n  strategy: SampleTransform['strategy'],\n): SampleFunction {\n  if (typeof strategy === 'function') return strategy;\n  if (strategy === 'lttb') return lttb;\n\n  const strategies = {\n    first: (f: number[]) => [f[0]],\n    last: (f: number[]) => [f[f.length - 1]],\n    min: (f: number[], X: number[], Y: number[]) => [\n      f[minIndex(f, (i) => Y[i])],\n    ],\n    max: (f: number[], X: number[], Y: number[]) => [\n      f[maxIndex(f, (i) => Y[i])],\n    ],\n    median: (f: number[], X: number[], Y: number[]) => [\n      f[medianIndex(f, (i) => Y[i])],\n    ],\n  };\n  const sampleFunction = strategies[strategy] || strategies.median;\n  return (I: number[], X: number[], Y: number[], thresholds: number) => {\n    // Sepreate group to frames, then sample each frame.\n    // Keep more data as possible.\n    const frameSize = Math.max(1, Math.floor(I.length / thresholds));\n    const frames = getFrames(I, frameSize);\n    return frames.flatMap((frame) => sampleFunction(frame, X, Y));\n  };\n}\n\n/**\n * Split the array into frame with each frameSize.\n */\nfunction getFrames(I: Primitive[], frameSize: number): number[][] {\n  const size = I.length;\n  const frames = [];\n  let i = 0;\n  while (i < size) {\n    frames.push(I.slice(i, (i += frameSize)));\n  }\n  return frames;\n}\n\n/**\n * The sample transform groups marks with specified groupBy fields, and\n * sample data for each group when data.length >= threshold(default = 2000).\n */\nexport const Sample: TC<SampleOptions> = (options = {}) => {\n  const {\n    strategy = 'median',\n    thresholds = 2000,\n    groupBy = ['series', 'color'],\n  } = options;\n  const sampleFunction = normalizeSample(strategy);\n\n  return (I, mark) => {\n    const { encode } = mark;\n    const groups = createGroups(groupBy, I, mark);\n    const [X] = columnOf(encode, 'x');\n    const [Y] = columnOf(encode, 'y');\n\n    return [\n      groups.flatMap((g) =>\n        sampleFunction(g, X as number[], Y as number[], thresholds),\n      ),\n      mark,\n    ];\n  };\n};\n\nSample.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}