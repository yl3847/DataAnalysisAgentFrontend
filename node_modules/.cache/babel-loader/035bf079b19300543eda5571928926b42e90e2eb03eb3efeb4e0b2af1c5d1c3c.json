{"ast":null,"code":"import { parsePathString } from '../parser/parse-path-string';\nimport { normalizePath } from '../process/normalize-path';\nimport { getPointAtLength } from './get-point-at-length';\nimport { getPropertiesAtLength } from './get-properties-at-length';\nimport { getTotalLength } from './get-total-length';\n/**\n * Returns the point and segment in path closest to a given point as well as\n * the distance to the path stroke.\n * @see https://bl.ocks.org/mbostock/8027637\n */\nexport function getPropertiesAtPoint(pathInput, point) {\n  var path = parsePathString(pathInput);\n  var normalPath = normalizePath(path);\n  var pathLength = getTotalLength(path);\n  var distanceTo = function (p) {\n    var dx = p.x - point.x;\n    var dy = p.y - point.y;\n    return dx * dx + dy * dy;\n  };\n  var precision = 8;\n  var scan;\n  var scanDistance = 0;\n  var closest;\n  var bestLength = 0;\n  var bestDistance = Infinity;\n  // linear scan for coarse approximation\n  for (var scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    scan = getPointAtLength(normalPath, scanLength);\n    scanDistance = distanceTo(scan);\n    if (scanDistance < bestDistance) {\n      closest = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n  // binary search for precise estimate\n  precision /= 2;\n  var before;\n  var after;\n  var beforeLength = 0;\n  var afterLength = 0;\n  var beforeDistance = 0;\n  var afterDistance = 0;\n  while (precision > 0.5) {\n    beforeLength = bestLength - precision;\n    before = getPointAtLength(normalPath, beforeLength);\n    beforeDistance = distanceTo(before);\n    afterLength = bestLength + precision;\n    after = getPointAtLength(normalPath, afterLength);\n    afterDistance = distanceTo(after);\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      closest = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\n      closest = after;\n      bestLength = afterLength;\n      bestDistance = afterDistance;\n    } else {\n      precision /= 2;\n    }\n  }\n  var segment = getPropertiesAtLength(path, bestLength);\n  var distance = Math.sqrt(bestDistance);\n  return {\n    closest: closest,\n    distance: distance,\n    segment: segment\n  };\n}","map":{"version":3,"names":["parsePathString","normalizePath","getPointAtLength","getPropertiesAtLength","getTotalLength","getPropertiesAtPoint","pathInput","point","path","normalPath","pathLength","distanceTo","p","dx","x","dy","y","precision","scan","scanDistance","closest","bestLength","bestDistance","Infinity","scanLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","segment","distance","Math","sqrt"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/util/src/path/util/get-properties-at-point.ts"],"sourcesContent":["import type { Point, PathArray, PointProperties } from '../types';\nimport { parsePathString } from '../parser/parse-path-string';\nimport { normalizePath } from '../process/normalize-path';\nimport { getPointAtLength } from './get-point-at-length';\nimport { getPropertiesAtLength } from './get-properties-at-length';\nimport { getTotalLength } from './get-total-length';\n\n/**\n * Returns the point and segment in path closest to a given point as well as\n * the distance to the path stroke.\n * @see https://bl.ocks.org/mbostock/8027637\n */\nexport function getPropertiesAtPoint(pathInput: string | PathArray, point: Point): PointProperties {\n  const path = parsePathString(pathInput);\n  const normalPath = normalizePath(path);\n  const pathLength = getTotalLength(path);\n  const distanceTo = (p: Point) => {\n    const dx = p.x - point.x;\n    const dy = p.y - point.y;\n    return dx * dx + dy * dy;\n  };\n  let precision = 8;\n  let scan: Point;\n  let scanDistance = 0;\n  let closest: Point;\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    scan = getPointAtLength(normalPath, scanLength);\n    scanDistance = distanceTo(scan);\n    if (scanDistance < bestDistance) {\n      closest = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  let before: Point;\n  let after: Point;\n  let beforeLength = 0;\n  let afterLength = 0;\n  let beforeDistance = 0;\n  let afterDistance = 0;\n\n  while (precision > 0.5) {\n    beforeLength = bestLength - precision;\n    before = getPointAtLength(normalPath, beforeLength);\n    beforeDistance = distanceTo(before);\n    afterLength = bestLength + precision;\n    after = getPointAtLength(normalPath, afterLength);\n    afterDistance = distanceTo(after);\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      closest = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\n      closest = after;\n      bestLength = afterLength;\n      bestDistance = afterDistance;\n    } else {\n      precision /= 2;\n    }\n  }\n\n  const segment = getPropertiesAtLength(path, bestLength);\n  const distance = Math.sqrt(bestDistance);\n\n  return { closest, distance, segment };\n}\n"],"mappings":"AACA,SAASA,eAAe,QAAQ,6BAA6B;AAC7D,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,gBAAgB,QAAQ,uBAAuB;AACxD,SAASC,qBAAqB,QAAQ,4BAA4B;AAClE,SAASC,cAAc,QAAQ,oBAAoB;AAEnD;;;;;AAKA,OAAM,SAAUC,oBAAoBA,CAACC,SAA6B,EAAEC,KAAY;EAC9E,IAAMC,IAAI,GAAGR,eAAe,CAACM,SAAS,CAAC;EACvC,IAAMG,UAAU,GAAGR,aAAa,CAACO,IAAI,CAAC;EACtC,IAAME,UAAU,GAAGN,cAAc,CAACI,IAAI,CAAC;EACvC,IAAMG,UAAU,GAAG,SAAAA,CAACC,CAAQ;IAC1B,IAAMC,EAAE,GAAGD,CAAC,CAACE,CAAC,GAAGP,KAAK,CAACO,CAAC;IACxB,IAAMC,EAAE,GAAGH,CAAC,CAACI,CAAC,GAAGT,KAAK,CAACS,CAAC;IACxB,OAAOH,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE;EAC1B,CAAC;EACD,IAAIE,SAAS,GAAG,CAAC;EACjB,IAAIC,IAAW;EACf,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAIC,OAAc;EAClB,IAAIC,UAAU,GAAG,CAAC;EAClB,IAAIC,YAAY,GAAGC,QAAQ;EAE3B;EACA,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEA,UAAU,IAAId,UAAU,EAAEc,UAAU,IAAIP,SAAS,EAAE;IAC1EC,IAAI,GAAGhB,gBAAgB,CAACO,UAAU,EAAEe,UAAU,CAAC;IAC/CL,YAAY,GAAGR,UAAU,CAACO,IAAI,CAAC;IAC/B,IAAIC,YAAY,GAAGG,YAAY,EAAE;MAC/BF,OAAO,GAAGF,IAAI;MACdG,UAAU,GAAGG,UAAU;MACvBF,YAAY,GAAGH,YAAY;IAC7B;EACF;EAEA;EACAF,SAAS,IAAI,CAAC;EACd,IAAIQ,MAAa;EACjB,IAAIC,KAAY;EAChB,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,aAAa,GAAG,CAAC;EAErB,OAAOb,SAAS,GAAG,GAAG,EAAE;IACtBU,YAAY,GAAGN,UAAU,GAAGJ,SAAS;IACrCQ,MAAM,GAAGvB,gBAAgB,CAACO,UAAU,EAAEkB,YAAY,CAAC;IACnDE,cAAc,GAAGlB,UAAU,CAACc,MAAM,CAAC;IACnCG,WAAW,GAAGP,UAAU,GAAGJ,SAAS;IACpCS,KAAK,GAAGxB,gBAAgB,CAACO,UAAU,EAAEmB,WAAW,CAAC;IACjDE,aAAa,GAAGnB,UAAU,CAACe,KAAK,CAAC;IACjC,IAAIC,YAAY,IAAI,CAAC,IAAIE,cAAc,GAAGP,YAAY,EAAE;MACtDF,OAAO,GAAGK,MAAM;MAChBJ,UAAU,GAAGM,YAAY;MACzBL,YAAY,GAAGO,cAAc;IAC/B,CAAC,MAAM,IAAID,WAAW,IAAIlB,UAAU,IAAIoB,aAAa,GAAGR,YAAY,EAAE;MACpEF,OAAO,GAAGM,KAAK;MACfL,UAAU,GAAGO,WAAW;MACxBN,YAAY,GAAGQ,aAAa;IAC9B,CAAC,MAAM;MACLb,SAAS,IAAI,CAAC;IAChB;EACF;EAEA,IAAMc,OAAO,GAAG5B,qBAAqB,CAACK,IAAI,EAAEa,UAAU,CAAC;EACvD,IAAMW,QAAQ,GAAGC,IAAI,CAACC,IAAI,CAACZ,YAAY,CAAC;EAExC,OAAO;IAAEF,OAAO,EAAAA,OAAA;IAAEY,QAAQ,EAAAA,QAAA;IAAED,OAAO,EAAAA;EAAA,CAAE;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}