{"ast":null,"code":"import { group } from '@antv/vendor/d3-array';\nimport { isParallel, isPolar } from '../utils/coordinate';\nimport { LineShape, LineHV, LineVH, LineHVH, LineTrail, LineSmooth } from '../shape';\nimport { MaybeSeries, MaybeGradient } from '../transform';\nimport { baseGeometryChannels, basePostInference, basePreInference, tooltip1d, tooltipXd } from './utils';\nconst shape = {\n  line: LineShape,\n  smooth: LineSmooth,\n  hv: LineHV,\n  vh: LineVH,\n  hvh: LineHVH,\n  trail: LineTrail\n};\nconst line = (index, scale, value, coordinate) => {\n  var _a, _b;\n  const {\n    series: S,\n    x: X,\n    y: Y\n  } = value;\n  const {\n    x,\n    y\n  } = scale;\n  // Because x and y channel is not strictly required in Line.props,\n  // it should throw error with empty x or y channels.\n  if (X === undefined || Y === undefined) {\n    throw new Error('Missing encode for x or y channel.');\n  }\n  // Group data into series.\n  // There is only one series without specified series encode.\n  const series = S ? Array.from(group(index, i => S[i]).values()) : [index];\n  const I = series.map(group => group[0]).filter(i => i !== undefined);\n  // A group of data corresponds to one line.\n  const xoffset = (((_a = x === null || x === void 0 ? void 0 : x.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x)) || 0) / 2;\n  const yoffset = (((_b = y === null || y === void 0 ? void 0 : y.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y)) || 0) / 2;\n  const P = Array.from(series, I => {\n    return I.map(i => coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]));\n  });\n  return [I, P, series];\n};\nconst parallel = (index, scale, value, coordinate) => {\n  // Extract all value for position[number] channels.\n  const PV = Object.entries(value).filter(([key]) => key.startsWith('position')).map(([, value]) => value);\n  // Because position channel is not strictly required in Line.props,\n  // it should throw error with empty position values.\n  if (PV.length === 0) {\n    throw new Error('Missing encode for position channel.');\n  }\n  // Close the loop for radar(= parallel + polar) coordinate.\n  if (isPolar(coordinate)) PV.push(PV[0]);\n  // One data corresponds to one line.\n  const P = Array.from(index, i => {\n    // Transform high dimension vector to a list of two-dimension vectors.\n    // [a, b, c] -> [d, e, f, g, h, i]\n    const vector = PV.map(pv => +pv[i]);\n    const vectors = coordinate.map(vector);\n    // Two-dimension vectors are stored in a flat array, so extract them.\n    // [d, e, f, g, h, i] -> [d, e], [f, g], [h, i]\n    const points = [];\n    for (let i = 0; i < vectors.length; i += 2) {\n      points.push([vectors[i], vectors[i + 1]]);\n    }\n    return points;\n  });\n  return [index, P];\n};\n/**\n * Convert value for each channel to line shapes.\n */\nexport const Line = () => {\n  return (index, scale, value, coordinate) => {\n    const mark = isParallel(coordinate) ? parallel : line;\n    return mark(index, scale, value, coordinate);\n  };\n};\nLine.props = {\n  defaultShape: 'line',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [...baseGeometryChannels({\n    shapes: Object.keys(shape)\n  }), {\n    name: 'x'\n  }, {\n    name: 'y'\n  }, {\n    name: 'position',\n    independent: true\n  }, {\n    name: 'size'\n  }, {\n    name: 'series',\n    scale: 'band'\n  }],\n  preInference: [...basePreInference(),\n  // !!!Note This order is very important.\n  {\n    type: MaybeGradient\n  }, {\n    type: MaybeSeries\n  }],\n  postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],\n  interaction: {\n    shareTooltip: true,\n    seriesTooltip: true,\n    crosshairs: true\n  }\n};","map":{"version":3,"names":["group","isParallel","isPolar","LineShape","LineHV","LineVH","LineHVH","LineTrail","LineSmooth","MaybeSeries","MaybeGradient","baseGeometryChannels","basePostInference","basePreInference","tooltip1d","tooltipXd","shape","line","smooth","hv","vh","hvh","trail","index","scale","value","coordinate","series","S","x","X","y","Y","undefined","Error","Array","from","i","values","I","map","filter","xoffset","_a","getBandWidth","call","yoffset","_b","P","parallel","PV","Object","entries","key","startsWith","length","push","vector","pv","vectors","points","Line","mark","props","defaultShape","defaultLabelShape","composite","channels","shapes","keys","name","independent","preInference","type","postInference","interaction","shareTooltip","seriesTooltip","crosshairs"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/mark/line.ts"],"sourcesContent":["import { Vector } from '@antv/coord';\nimport { group } from '@antv/vendor/d3-array';\nimport { isParallel, isPolar } from '../utils/coordinate';\nimport { Mark, MarkComponent as MC, SingleMark, Vector2 } from '../runtime';\nimport { LineMark } from '../spec';\nimport {\n  LineShape,\n  LineHV,\n  LineVH,\n  LineHVH,\n  LineTrail,\n  LineSmooth,\n} from '../shape';\nimport { MaybeSeries, MaybeGradient } from '../transform';\nimport {\n  baseGeometryChannels,\n  basePostInference,\n  basePreInference,\n  tooltip1d,\n  tooltipXd,\n} from './utils';\n\nconst shape = {\n  line: LineShape,\n  smooth: LineSmooth,\n  hv: LineHV,\n  vh: LineVH,\n  hvh: LineHVH,\n  trail: LineTrail,\n};\n\nexport type LineOptions = Omit<LineMark, 'type'>;\n\nconst line: Mark = (index, scale, value, coordinate) => {\n  const { series: S, x: X, y: Y } = value;\n  const { x, y } = scale;\n\n  // Because x and y channel is not strictly required in Line.props,\n  // it should throw error with empty x or y channels.\n  if (X === undefined || Y === undefined) {\n    throw new Error('Missing encode for x or y channel.');\n  }\n\n  // Group data into series.\n  // There is only one series without specified series encode.\n  const series = S ? Array.from(group(index, (i) => S[i]).values()) : [index];\n  const I = series.map((group) => group[0]).filter((i) => i !== undefined);\n\n  // A group of data corresponds to one line.\n  const xoffset = (x?.getBandWidth?.() || 0) / 2;\n  const yoffset = (y?.getBandWidth?.() || 0) / 2;\n  const P = Array.from(series, (I) => {\n    return I.map((i) =>\n      coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]),\n    ) as Vector2[];\n  });\n  return [I, P, series];\n};\n\nconst parallel: Mark = (index, scale, value, coordinate) => {\n  // Extract all value for position[number] channels.\n  const PV = Object.entries(value)\n    .filter(([key]) => key.startsWith('position'))\n    .map(([, value]) => value);\n\n  // Because position channel is not strictly required in Line.props,\n  // it should throw error with empty position values.\n  if (PV.length === 0) {\n    throw new Error('Missing encode for position channel.');\n  }\n  // Close the loop for radar(= parallel + polar) coordinate.\n  if (isPolar(coordinate)) PV.push(PV[0]);\n\n  // One data corresponds to one line.\n  const P = Array.from(index, (i) => {\n    // Transform high dimension vector to a list of two-dimension vectors.\n    // [a, b, c] -> [d, e, f, g, h, i]\n    const vector = PV.map((pv) => +pv[i]);\n    const vectors = coordinate.map(vector) as Vector;\n\n    // Two-dimension vectors are stored in a flat array, so extract them.\n    // [d, e, f, g, h, i] -> [d, e], [f, g], [h, i]\n    const points = [];\n    for (let i = 0; i < vectors.length; i += 2) {\n      points.push([vectors[i], vectors[i + 1]]);\n    }\n    return points;\n  });\n  return [index, P];\n};\n\n/**\n * Convert value for each channel to line shapes.\n */\nexport const Line: MC<LineOptions> = () => {\n  return (index, scale, value, coordinate) => {\n    const mark = isParallel(coordinate) ? parallel : line;\n    return (mark as SingleMark)(index, scale, value, coordinate);\n  };\n};\n\nLine.props = {\n  defaultShape: 'line',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [\n    ...baseGeometryChannels({ shapes: Object.keys(shape) }),\n    { name: 'x' },\n    { name: 'y' },\n    { name: 'position', independent: true },\n    { name: 'size' },\n    { name: 'series', scale: 'band' },\n  ],\n  preInference: [\n    ...basePreInference(),\n    // !!!Note This order is very important.\n    { type: MaybeGradient },\n    { type: MaybeSeries },\n  ],\n  postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],\n  interaction: {\n    shareTooltip: true,\n    seriesTooltip: true,\n    crosshairs: true,\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}