{"ast":null,"code":"import { deepMix } from '@antv/util';\nimport { column, columnOf, inferredColumn, maybeColumnOf } from './utils/helper';\nimport { normalizeComparator, createGroups, applyOrder } from './utils/order';\n/**\n * The stack transform group marks into series by color channel,\n * and then produce new y channel for each series by specified order,\n * say to form vertical \"stacks\" by specified channels.\n */\nexport const StackY = (options = {}) => {\n  const {\n    groupBy = 'x',\n    orderBy = null,\n    reverse = false,\n    y: fromY = 'y',\n    y1: fromY1 = 'y1',\n    series = true\n  } = options;\n  return (I, mark) => {\n    var _a;\n    const {\n      data,\n      encode,\n      style = {}\n    } = mark;\n    const [Y, fy] = columnOf(encode, 'y');\n    const [Y1, fy1] = columnOf(encode, 'y1');\n    const [S] = series ? maybeColumnOf(encode, 'series', 'color') : columnOf(encode, 'color');\n    // Create groups and apply specified order for each group.\n    const groups = createGroups(groupBy, I, mark);\n    const createComparator = (_a = normalizeComparator(orderBy)) !== null && _a !== void 0 ? _a : () => null;\n    const comparator = createComparator(data, Y, S);\n    if (comparator) applyOrder(groups, comparator);\n    // Stack y channels to produce new y and y1 channel.\n    const newY = new Array(I.length);\n    const newY1 = new Array(I.length);\n    const TY = new Array(I.length);\n    const F = [];\n    const L = [];\n    for (const G of groups) {\n      if (reverse) G.reverse();\n      // For range interval with specified y and y1.\n      const start = Y1 ? +Y1[G[0]] : 0;\n      // Split positive indices of Y and negative Y.\n      const PG = [];\n      const NG = [];\n      for (const i of G) {\n        const y = TY[i] = +Y[i] - start;\n        if (y < 0) NG.push(i);else if (y >= 0) PG.push(i);\n      }\n      // Store the first and last layer.\n      const FG = PG.length > 0 ? PG : NG;\n      const LG = NG.length > 0 ? NG : PG;\n      let i = PG.length - 1;\n      let j = 0;\n      // Find the last non-zero index.\n      while (i > 0 && Y[FG[i]] === 0) i--;\n      // Find the first non-zero index.\n      while (j < LG.length - 1 && Y[LG[j]] === 0) j++;\n      F.push(FG[i]);\n      L.push(LG[j]);\n      // Stack negative y in reverse order.\n      let ny = start;\n      for (const i of NG.reverse()) {\n        const y = TY[i];\n        ny = newY[i] = (newY1[i] = ny) + y;\n      }\n      // Stack positive y in input order.\n      let py = start;\n      for (const i of PG) {\n        const y = TY[i];\n        if (y > 0) py = newY[i] = (newY1[i] = py) + y;else newY[i] = newY1[i] = py;\n      }\n    }\n    // Only set top radius for the first layer,\n    // and set bottom radius for the last layer.\n    const FS = new Set(F);\n    const LS = new Set(L);\n    // Choose new y or y1 channel as the new y channel.\n    const V = fromY === 'y' ? newY : newY1;\n    const V1 = fromY1 === 'y' ? newY : newY1;\n    let newEncode;\n    // mark point will compute the actural Y = (y + y1) / 2 if y1 exists\n    if (mark.type === 'point') {\n      newEncode = {\n        y0: inferredColumn(Y, fy),\n        y: column(V, fy)\n      };\n    } else {\n      newEncode = {\n        y0: inferredColumn(Y, fy),\n        y: column(V, fy),\n        y1: column(V1, fy1)\n      };\n    }\n    return [I, deepMix({}, mark, {\n      encode: Object.assign({}, newEncode),\n      style: Object.assign({\n        first: (_, i) => FS.has(i),\n        last: (_, i) => LS.has(i)\n      }, style)\n    })];\n  };\n};\nStackY.props = {};","map":{"version":3,"names":["deepMix","column","columnOf","inferredColumn","maybeColumnOf","normalizeComparator","createGroups","applyOrder","StackY","options","groupBy","orderBy","reverse","y","fromY","y1","fromY1","series","I","mark","data","encode","style","Y","fy","Y1","fy1","S","groups","createComparator","_a","comparator","newY","Array","length","newY1","TY","F","L","G","start","PG","NG","i","push","FG","LG","j","ny","py","FS","Set","LS","V","V1","newEncode","type","y0","Object","assign","first","_","has","last","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/stackY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { TransformComponent as TC } from '../runtime';\nimport { StackYTransform } from '../spec';\nimport {\n  column,\n  columnOf,\n  inferredColumn,\n  maybeColumnOf,\n} from './utils/helper';\nimport { normalizeComparator, createGroups, applyOrder } from './utils/order';\n\nexport type StackYOptions = Omit<StackYTransform, 'type'>;\n\n/**\n * The stack transform group marks into series by color channel,\n * and then produce new y channel for each series by specified order,\n * say to form vertical \"stacks\" by specified channels.\n */\nexport const StackY: TC<StackYOptions> = (options = {}) => {\n  const {\n    groupBy = 'x',\n    orderBy = null,\n    reverse = false,\n    y: fromY = 'y',\n    y1: fromY1 = 'y1',\n    series = true,\n  } = options;\n  return (I, mark) => {\n    const { data, encode, style = {} } = mark;\n    const [Y, fy] = columnOf(encode, 'y');\n    const [Y1, fy1] = columnOf(encode, 'y1');\n    const [S] = series\n      ? maybeColumnOf(encode, 'series', 'color')\n      : columnOf(encode, 'color');\n\n    // Create groups and apply specified order for each group.\n    const groups = createGroups(groupBy, I, mark);\n    const createComparator = normalizeComparator(orderBy) ?? (() => null);\n    const comparator = createComparator(data, Y, S);\n    if (comparator) applyOrder(groups, comparator);\n\n    // Stack y channels to produce new y and y1 channel.\n    const newY = new Array(I.length);\n    const newY1 = new Array(I.length);\n    const TY = new Array(I.length);\n    const F = [];\n    const L = [];\n    for (const G of groups) {\n      if (reverse) G.reverse();\n      // For range interval with specified y and y1.\n      const start = Y1 ? +Y1[G[0]] : 0;\n\n      // Split positive indices of Y and negative Y.\n      const PG = [];\n      const NG = [];\n      for (const i of G) {\n        const y = (TY[i] = +Y[i] - start);\n        if (y < 0) NG.push(i);\n        else if (y >= 0) PG.push(i);\n      }\n\n      // Store the first and last layer.\n      const FG = PG.length > 0 ? PG : NG;\n      const LG = NG.length > 0 ? NG : PG;\n      let i = PG.length - 1;\n      let j = 0;\n      // Find the last non-zero index.\n      while (i > 0 && Y[FG[i]] === 0) i--;\n      // Find the first non-zero index.\n      while (j < LG.length - 1 && Y[LG[j]] === 0) j++;\n      F.push(FG[i]);\n      L.push(LG[j]);\n\n      // Stack negative y in reverse order.\n      let ny = start;\n      for (const i of NG.reverse()) {\n        const y = TY[i];\n        ny = newY[i] = (newY1[i] = ny) + y;\n      }\n\n      // Stack positive y in input order.\n      let py = start;\n      for (const i of PG) {\n        const y = TY[i];\n        if (y > 0) py = newY[i] = (newY1[i] = py) + y;\n        else newY[i] = newY1[i] = py;\n      }\n    }\n\n    // Only set top radius for the first layer,\n    // and set bottom radius for the last layer.\n    const FS = new Set(F);\n    const LS = new Set(L);\n\n    // Choose new y or y1 channel as the new y channel.\n    const V = fromY === 'y' ? newY : newY1;\n    const V1 = fromY1 === 'y' ? newY : newY1;\n    let newEncode: Record<string, any>;\n    // mark point will compute the actural Y = (y + y1) / 2 if y1 exists\n    if (mark.type === 'point') {\n      newEncode = {\n        y0: inferredColumn(Y, fy), // Store original Y.\n        y: column(V, fy),\n      };\n    } else {\n      newEncode = {\n        y0: inferredColumn(Y, fy), // Store original Y.\n        y: column(V, fy),\n        y1: column(V1, fy1),\n      };\n    }\n\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: {\n          ...newEncode,\n        },\n        style: {\n          first: (_, i) => FS.has(i),\n          last: (_, i) => LS.has(i),\n          ...style,\n        },\n      }),\n    ];\n  };\n};\n\nStackY.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}