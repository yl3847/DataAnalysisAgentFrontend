{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix } from '@antv/util';\nimport { mean, deviation, median, sum, max, min } from '@antv/vendor/d3-array';\nimport { isUnset } from '../utils/helper';\nimport { column, columnOf } from './utils/helper';\nimport { createGroups } from './utils/order';\nfunction normalizeBasis(basis) {\n  if (typeof basis === 'function') return basis;\n  const registry = {\n    min: (I, Y) => min(I, i => Y[+i]),\n    max: (I, Y) => max(I, i => Y[+i]),\n    first: (I, Y) => Y[I[0]],\n    last: (I, Y) => Y[I[I.length - 1]],\n    mean: (I, Y) => mean(I, i => Y[+i]),\n    median: (I, Y) => median(I, i => Y[+i]),\n    sum: (I, Y) => sum(I, i => Y[+i]),\n    deviation: (I, Y) => deviation(I, i => Y[+i])\n  };\n  return registry[basis] || max;\n}\n/**\n * Group marks into series by specified channels, and then transform\n * each series's value, say to transform them relative to some basis\n * to apply a moving average.\n */\nexport const NormalizeY = (options = {}) => {\n  const {\n    groupBy = 'x',\n    basis = 'max'\n  } = options;\n  return (I, mark) => {\n    const {\n      encode,\n      tooltip\n    } = mark;\n    const {\n        x\n      } = encode,\n      rest = __rest(encode, [\"x\"]);\n    // Extract and create new channels starts with y, such as y, y1.\n    const Yn = Object.entries(rest).filter(([k]) => k.startsWith('y')).map(([k]) => [k, columnOf(encode, k)[0]]);\n    const [, Y] = Yn.find(([k]) => k === 'y');\n    const newYn = Yn.map(([k]) => [k, new Array(I.length)]);\n    // Group marks into series by specified keys.\n    const groups = createGroups(groupBy, I, mark);\n    // Transform y channels for each group based on basis.\n    const basisFunction = normalizeBasis(basis);\n    for (const I of groups) {\n      // Compute basis only base on y.\n      const basisValue = basisFunction(I, Y);\n      for (const i of I) {\n        for (let j = 0; j < Yn.length; j++) {\n          const [, V] = Yn[j];\n          const [, newV] = newYn[j];\n          newV[i] = +V[i] / basisValue;\n        }\n      }\n    }\n    const specifiedTooltip = isUnset(tooltip) || (tooltip === null || tooltip === void 0 ? void 0 : tooltip.items) && (tooltip === null || tooltip === void 0 ? void 0 : tooltip.items.length) !== 0;\n    return [I, deepMix({}, mark, Object.assign({\n      encode: Object.fromEntries(newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])]))\n    }, !specifiedTooltip && encode.y0 && {\n      tooltip: {\n        items: [{\n          channel: 'y0'\n        }]\n      }\n    }))];\n  };\n};\nNormalizeY.props = {};","map":{"version":3,"names":["deepMix","mean","deviation","median","sum","max","min","isUnset","column","columnOf","createGroups","normalizeBasis","basis","registry","I","Y","i","first","last","length","NormalizeY","options","groupBy","mark","encode","tooltip","x","rest","__rest","Yn","Object","entries","filter","k","startsWith","map","find","newYn","Array","groups","basisFunction","basisValue","j","V","newV","specifiedTooltip","items","assign","fromEntries","v","y0","channel","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/normalizeY.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { mean, deviation, median, sum, max, min } from '@antv/vendor/d3-array';\nimport { isUnset } from '../utils/helper';\nimport { TransformComponent as TC } from '../runtime';\nimport { NormalizeYTransform } from '../spec';\nimport { column, columnOf } from './utils/helper';\nimport { createGroups } from './utils/order';\n\nexport type NormalizeYOptions = Omit<NormalizeYTransform, 'type'>;\n\nfunction normalizeBasis(basis: NormalizeYOptions['basis']) {\n  if (typeof basis === 'function') return basis;\n  const registry = {\n    min: (I, Y) => min(I, (i) => Y[+i]),\n    max: (I, Y) => max(I, (i) => Y[+i]),\n    first: (I, Y) => Y[I[0]],\n    last: (I, Y) => Y[I[I.length - 1]],\n    mean: (I, Y) => mean(I, (i) => Y[+i]),\n    median: (I, Y) => median(I, (i) => Y[+i]),\n    sum: (I, Y) => sum(I, (i) => Y[+i]),\n    deviation: (I, Y) => deviation(I, (i) => Y[+i]),\n  };\n  return registry[basis] || max;\n}\n\n/**\n * Group marks into series by specified channels, and then transform\n * each series's value, say to transform them relative to some basis\n * to apply a moving average.\n */\nexport const NormalizeY: TC<NormalizeYOptions> = (options = {}) => {\n  const { groupBy = 'x', basis = 'max' } = options;\n  return (I, mark) => {\n    const { encode, tooltip } = mark;\n    const { x, ...rest } = encode;\n\n    // Extract and create new channels starts with y, such as y, y1.\n    const Yn = Object.entries(rest)\n      .filter(([k]) => k.startsWith('y'))\n      .map(([k]) => [k, columnOf(encode, k)[0]] as const);\n    const [, Y] = Yn.find(([k]) => k === 'y');\n    const newYn = Yn.map(([k]) => [k, new Array(I.length)] as const);\n\n    // Group marks into series by specified keys.\n    const groups = createGroups(groupBy, I, mark);\n\n    // Transform y channels for each group based on basis.\n    const basisFunction = normalizeBasis(basis);\n    for (const I of groups) {\n      // Compute basis only base on y.\n      const basisValue = basisFunction(I, Y);\n      for (const i of I) {\n        for (let j = 0; j < Yn.length; j++) {\n          const [, V] = Yn[j];\n          const [, newV] = newYn[j];\n          newV[i] = +V[i] / basisValue;\n        }\n      }\n    }\n\n    const specifiedTooltip =\n      isUnset(tooltip) || (tooltip?.items && tooltip?.items.length !== 0);\n    return [\n      I,\n      deepMix({}, mark, {\n        encode: Object.fromEntries(\n          newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])]),\n        ),\n        // Infer tooltip item.\n        ...(!specifiedTooltip &&\n          encode.y0 && {\n            tooltip: { items: [{ channel: 'y0' }] },\n          }),\n      }),\n    ];\n  };\n};\n\nNormalizeY.props = {};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}