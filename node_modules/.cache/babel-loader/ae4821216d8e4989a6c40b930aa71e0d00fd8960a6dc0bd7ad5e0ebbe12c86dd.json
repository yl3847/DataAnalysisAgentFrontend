{"ast":null,"code":"import { isArray, get } from '@antv/util';\nimport { stratify, hierarchy, treemap as treemapLayout, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify } from '@antv/vendor/d3-hierarchy';\nimport { field } from '../mark/utils';\n/**\n * @description Path need when the data is a flat json structure,\n * and the tree object structure do not need.\n */\nfunction generateHierarchyRoot(data, path) {\n  if (Array.isArray(data)) {\n    return typeof path === 'function' ? stratify().path(path)(data) : stratify()(data);\n  }\n  return hierarchy(data);\n}\nfunction addObjectDataPath(root, path = [root.data.name]) {\n  // @ts-ignore\n  root.id = root.id || root.data.name;\n  root.path = path;\n  if (root.children) {\n    root.children.forEach(item => {\n      // @ts-ignore\n      item.id = `${root.id}/${item.data.name}`;\n      item.path = [...path, item.data.name];\n      addObjectDataPath(item, item.path);\n    });\n  }\n}\nfunction addArrayDataPath(root) {\n  const name = get(root, ['data', 'name']);\n  if (name.replaceAll) {\n    root.path = name.replaceAll('.', '/').split('/');\n  }\n  if (root.children) {\n    root.children.forEach(item => {\n      addArrayDataPath(item);\n    });\n  }\n}\nfunction getTileMethod(tile, ratio) {\n  const tiles = {\n    treemapBinary,\n    treemapDice,\n    treemapSlice,\n    treemapSliceDice,\n    treemapSquarify,\n    treemapResquarify\n  };\n  const tileMethod = tile === 'treemapSquarify' ? tiles[tile].ratio(ratio) : tiles[tile];\n  if (!tileMethod) {\n    throw new TypeError('Invalid tile method!');\n  }\n  return tileMethod;\n}\nexport function treeDataTransform(data, layout, encode) {\n  const {\n    value\n  } = encode;\n  const tileMethod = getTileMethod(layout.tile, layout.ratio);\n  const root = generateHierarchyRoot(data, layout.path);\n  if (isArray(data)) {\n    addArrayDataPath(root);\n  } else {\n    addObjectDataPath(root);\n  }\n  // Calculate the value and sort.\n  value ? root.sum(d => layout.ignoreParentValue && d.children ? 0 : field(value)(d)).sort(layout.sort) : root.count();\n  treemapLayout().tile(tileMethod)\n  // @ts-ignore\n  .size(layout.size).round(layout.round).paddingInner(layout.paddingInner).paddingOuter(layout.paddingOuter).paddingTop(layout.paddingTop).paddingRight(layout.paddingRight).paddingBottom(layout.paddingBottom).paddingLeft(layout.paddingLeft)(root);\n  const nodes = root.descendants().map(d => Object.assign(d, {\n    id: d.id.replace(/^\\//, ''),\n    x: [d.x0, d.x1],\n    y: [d.y0, d.y1]\n  }));\n  const filterData = nodes.filter(typeof layout.layer === 'function' ? layout.layer : d => d.height === layout.layer);\n  return [filterData, nodes];\n}","map":{"version":3,"names":["isArray","get","stratify","hierarchy","treemap","treemapLayout","treemapBinary","treemapDice","treemapSlice","treemapSliceDice","treemapSquarify","treemapResquarify","field","generateHierarchyRoot","data","path","Array","addObjectDataPath","root","name","id","children","forEach","item","addArrayDataPath","replaceAll","split","getTileMethod","tile","ratio","tiles","tileMethod","TypeError","treeDataTransform","layout","encode","value","sum","d","ignoreParentValue","sort","count","size","round","paddingInner","paddingOuter","paddingTop","paddingRight","paddingBottom","paddingLeft","nodes","descendants","map","Object","assign","replace","x","x0","x1","y","y0","y1","filterData","filter","layer","height"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/utils/treeDataTransform.ts"],"sourcesContent":["import { isArray, get } from '@antv/util';\nimport {\n  stratify,\n  hierarchy,\n  treemap as treemapLayout,\n  treemapBinary,\n  treemapDice,\n  treemapSlice,\n  treemapSliceDice,\n  treemapSquarify,\n  treemapResquarify,\n} from '@antv/vendor/d3-hierarchy';\nimport type { HierarchyNode } from '@antv/vendor/d3-hierarchy';\nimport { field } from '../mark/utils';\n\ntype Data = any[] | Record<string, any>;\n\nexport interface Node<T> extends HierarchyNode<T> {\n  x0?: number;\n  y0?: number;\n  x1?: number;\n  y1?: number;\n}\n\ntype Layout = {\n  tile?:\n    | 'treemapBinary'\n    | 'treemapDice'\n    | 'treemapSlice'\n    | 'treemapSliceDice'\n    | 'treemapSquarify'\n    | 'treemapResquarify';\n  size?: [number, number];\n  round?: boolean;\n  // Ignore the value of the parent node when calculating the total value.\n  ignoreParentValue?: boolean;\n  ratio?: number;\n  padding?: number;\n  paddingInner?: number;\n  paddingOuter?: number;\n  paddingTop?: number;\n  paddingRight?: number;\n  paddingBottom?: number;\n  paddingLeft?: number;\n  sort?(a: any, b: any): number;\n  path?: (d: any) => any;\n  /** The granularity of Display layer.  */\n  layer?: number | ((d: any) => any);\n};\n\n/**\n * @description Path need when the data is a flat json structure,\n * and the tree object structure do not need.\n */\nfunction generateHierarchyRoot(data: Data, path: (d: any) => any): Node<Data> {\n  if (Array.isArray(data)) {\n    return typeof path === 'function'\n      ? stratify().path(path)(data)\n      : stratify()(data);\n  }\n  return hierarchy(data);\n}\n\nfunction addObjectDataPath(\n  root: Node<Record<string, any>>,\n  path: any = [root.data.name],\n) {\n  // @ts-ignore\n  root.id = root.id || root.data.name;\n  root.path = path;\n\n  if (root.children) {\n    root.children.forEach((item) => {\n      // @ts-ignore\n      item.id = `${root.id}/${item.data.name}`;\n      item.path = [...path, item.data.name] as any;\n      addObjectDataPath(item, item.path);\n    });\n  }\n}\n\nfunction addArrayDataPath(root: Node<any[]>) {\n  const name = get(root, ['data', 'name']);\n  if (name.replaceAll) {\n    root.path = name.replaceAll('.', '/').split('/');\n  }\n\n  if (root.children) {\n    root.children.forEach((item) => {\n      addArrayDataPath(item);\n    });\n  }\n}\n\nfunction getTileMethod(tile: string, ratio: number) {\n  const tiles = {\n    treemapBinary,\n    treemapDice,\n    treemapSlice,\n    treemapSliceDice,\n    treemapSquarify,\n    treemapResquarify,\n  };\n  const tileMethod =\n    tile === 'treemapSquarify' ? tiles[tile].ratio(ratio) : tiles[tile];\n  if (!tileMethod) {\n    throw new TypeError('Invalid tile method!');\n  }\n  return tileMethod;\n}\n\nexport function treeDataTransform(\n  data,\n  layout: Layout,\n  encode,\n): [Node<Data>[], Node<Data>[]] {\n  const { value } = encode;\n  const tileMethod = getTileMethod(layout.tile, layout.ratio);\n\n  const root = generateHierarchyRoot(data, layout.path);\n\n  if (isArray(data)) {\n    addArrayDataPath(root as HierarchyNode<any[]>);\n  } else {\n    addObjectDataPath(root as HierarchyNode<Record<string, any>>);\n  }\n\n  // Calculate the value and sort.\n  value\n    ? root\n        .sum((d) =>\n          layout.ignoreParentValue && (d as Record<string, any>).children\n            ? 0\n            : field(value)(d),\n        )\n        .sort(layout.sort)\n    : root.count();\n\n  treemapLayout()\n    .tile(tileMethod)\n    // @ts-ignore\n    .size(layout.size)\n    .round(layout.round)\n    .paddingInner(layout.paddingInner)\n    .paddingOuter(layout.paddingOuter)\n    .paddingTop(layout.paddingTop)\n    .paddingRight(layout.paddingRight)\n    .paddingBottom(layout.paddingBottom)\n    .paddingLeft(layout.paddingLeft)(root);\n\n  const nodes = root.descendants().map((d) =>\n    Object.assign(d, {\n      id: d.id.replace(/^\\//, ''),\n      x: [d.x0, d.x1],\n      y: [d.y0, d.y1],\n    }),\n  );\n\n  const filterData = nodes.filter(\n    typeof layout.layer === 'function'\n      ? layout.layer\n      : (d) => d.height === layout.layer,\n  );\n\n  return [filterData, nodes];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}