{"ast":null,"code":"import { group } from '@antv/vendor/d3-array';\nimport { AreaShape, AreaHV, AreaHVH, AreaSmooth, AreaVH } from '../shape';\nimport { MaybeSeries, MaybeZeroY1, MaybeZeroPadding } from '../transform';\nimport { baseGeometryChannels, basePostInference, basePreInference, tooltip1d } from './utils';\nconst shape = {\n  area: AreaShape,\n  smooth: AreaSmooth,\n  hvh: AreaHVH,\n  vh: AreaVH,\n  hv: AreaHV\n};\n/*\n * Convert value for each channel to area shapes.\n *\n *     ▲\n *     │\n *     │                                         y2\n *     │\n *     │                     y1     xxxxxxxxxxxxx\n *     │                         xxxx            x\n *     │                      xxx                x\n *     │                    xxx                  x\n *     │        y0       xxx                     x\n *     │           xxxxxxx                       x\n *     │          x                              x\n *     │         xx                              x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n * ────┼─────────x───────────────────────────────x──────────────►\n *     │        y3             y4                y5\n */\nexport const Area = () => {\n  return (index, scale, value, coordinate) => {\n    var _a, _b;\n    const {\n      x: X,\n      y: Y,\n      y1: Y1,\n      series: S\n    } = value;\n    const {\n      x,\n      y\n    } = scale;\n    // Group data by series field.\n    const series = S ? Array.from(group(index, i => S[i]).values()) : [index];\n    const I = series.map(group => group[0]).filter(i => i !== undefined);\n    // A group of data corresponds to one area.\n    const xoffset = (((_a = x === null || x === void 0 ? void 0 : x.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x)) || 0) / 2;\n    const yoffset = (((_b = y === null || y === void 0 ? void 0 : y.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y)) || 0) / 2;\n    const P = Array.from(series, SI => {\n      const l = SI.length;\n      const points = new Array(l * 2);\n      for (let idx = 0; idx < SI.length; idx++) {\n        const i = SI[idx];\n        points[idx] = coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]); // y1\n        points[l + idx] = coordinate.map([+X[i] + xoffset, +Y1[i] + yoffset]); // y0\n      }\n      return points;\n    });\n    return [I, P, series];\n  };\n};\nArea.props = {\n  defaultShape: 'area',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [...baseGeometryChannels({\n    shapes: Object.keys(shape)\n  }), {\n    name: 'x',\n    required: true\n  }, {\n    name: 'y',\n    required: true\n  }, {\n    name: 'size'\n  }, {\n    name: 'series',\n    scale: 'band'\n  }],\n  preInference: [...basePreInference(), {\n    type: MaybeSeries\n  }, {\n    type: MaybeZeroY1\n  }, {\n    type: MaybeZeroPadding\n  }],\n  postInference: [...basePostInference(), ...tooltip1d()],\n  interaction: {\n    shareTooltip: true,\n    seriesTooltip: true,\n    crosshairs: true\n  }\n};","map":{"version":3,"names":["group","AreaShape","AreaHV","AreaHVH","AreaSmooth","AreaVH","MaybeSeries","MaybeZeroY1","MaybeZeroPadding","baseGeometryChannels","basePostInference","basePreInference","tooltip1d","shape","area","smooth","hvh","vh","hv","Area","index","scale","value","coordinate","x","X","y","Y","y1","Y1","series","S","Array","from","i","values","I","map","filter","undefined","xoffset","_a","getBandWidth","call","yoffset","_b","P","SI","l","length","points","idx","props","defaultShape","defaultLabelShape","composite","channels","shapes","Object","keys","name","required","preInference","type","postInference","interaction","shareTooltip","seriesTooltip","crosshairs"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/mark/area.ts"],"sourcesContent":["import { group } from '@antv/vendor/d3-array';\nimport { MarkComponent as MC } from '../runtime';\nimport { AreaMark } from '../spec';\nimport { AreaShape, AreaHV, AreaHVH, AreaSmooth, AreaVH } from '../shape';\nimport { MaybeSeries, MaybeZeroY1, MaybeZeroPadding } from '../transform';\nimport {\n  baseGeometryChannels,\n  basePostInference,\n  basePreInference,\n  tooltip1d,\n} from './utils';\n\nconst shape = {\n  area: AreaShape,\n  smooth: AreaSmooth,\n  hvh: AreaHVH,\n  vh: AreaVH,\n  hv: AreaHV,\n};\n\nexport type AreaOptions = Omit<AreaMark, 'type'>;\n\n/*\n * Convert value for each channel to area shapes.\n *\n *     ▲\n *     │\n *     │                                         y2\n *     │\n *     │                     y1     xxxxxxxxxxxxx\n *     │                         xxxx            x\n *     │                      xxx                x\n *     │                    xxx                  x\n *     │        y0       xxx                     x\n *     │           xxxxxxx                       x\n *     │          x                              x\n *     │         xx                              x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n *     │         x                               x\n * ────┼─────────x───────────────────────────────x──────────────►\n *     │        y3             y4                y5\n */\n\nexport const Area: MC<AreaOptions> = () => {\n  return (index, scale, value, coordinate) => {\n    const { x: X, y: Y, y1: Y1, series: S } = value;\n    const { x, y } = scale;\n\n    // Group data by series field.\n    const series = S ? Array.from(group(index, (i) => S[i]).values()) : [index];\n    const I = series.map((group) => group[0]).filter((i) => i !== undefined);\n\n    // A group of data corresponds to one area.\n    const xoffset = (x?.getBandWidth?.() || 0) / 2;\n    const yoffset = (y?.getBandWidth?.() || 0) / 2;\n    const P = Array.from(series, (SI) => {\n      const l = SI.length;\n      const points = new Array(l * 2);\n\n      for (let idx = 0; idx < SI.length; idx++) {\n        const i = SI[idx];\n        points[idx] = coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]); // y1\n        points[l + idx] = coordinate.map([+X[i] + xoffset, +Y1[i] + yoffset]); // y0\n      }\n\n      return points;\n    });\n\n    return [I, P, series];\n  };\n};\n\nArea.props = {\n  defaultShape: 'area',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [\n    ...baseGeometryChannels({ shapes: Object.keys(shape) }),\n    { name: 'x', required: true },\n    { name: 'y', required: true },\n    { name: 'size' },\n    { name: 'series', scale: 'band' },\n  ],\n  preInference: [\n    ...basePreInference(),\n    { type: MaybeSeries },\n    { type: MaybeZeroY1 },\n    { type: MaybeZeroPadding },\n  ],\n  postInference: [...basePostInference(), ...tooltip1d()],\n  interaction: {\n    shareTooltip: true,\n    seriesTooltip: true,\n    crosshairs: true,\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}