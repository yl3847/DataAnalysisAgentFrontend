{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { angleOf } from '../utils/coordinate';\nimport { LinearAxis } from './axis';\nfunction inferTitleTransform(orientation) {\n  const internalOrientation = orientation % (Math.PI * 2);\n  if (internalOrientation === Math.PI / 2) {\n    return {\n      titleTransform: 'translate(0, 50%)'\n    };\n  }\n  if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {\n    return {\n      titleTransform: 'translate(50%, 0)'\n    };\n  }\n  if (internalOrientation > Math.PI / 2 && internalOrientation < Math.PI * 3 / 2) {\n    return {\n      titleTransform: 'translate(-50%, 0)'\n    };\n  }\n  return {};\n}\nfunction inferAxisStyle(options, theme, coordinate, scales) {\n  const {\n    radar\n  } = options;\n  const [scale] = scales;\n  const name = scale.getOptions().name;\n  const [startAngle, endAngle] = angleOf(coordinate);\n  const {\n    axisRadar: radarTheme = {}\n  } = theme;\n  return Object.assign(Object.assign({}, radarTheme), {\n    grid: name === 'position',\n    gridConnect: 'line',\n    gridControlAngles: new Array(radar.count).fill(0).map((_, i) => {\n      const angle = (endAngle - startAngle) / radar.count;\n      return angle * i;\n    })\n  });\n}\nexport const AxisRadar = options => {\n  const {\n      important = {}\n    } = options,\n    restOptions = __rest(options, [\"important\"]);\n  return context => {\n    const {\n      theme,\n      coordinate,\n      scales\n    } = context;\n    return LinearAxis(Object.assign(Object.assign(Object.assign({}, restOptions), inferTitleTransform(options.orientation)), {\n      important: Object.assign(Object.assign({}, inferAxisStyle(options, theme, coordinate, scales)), important)\n    }))(context);\n  };\n};\nAxisRadar.props = Object.assign(Object.assign({}, LinearAxis.props), {\n  defaultPosition: 'center'\n});","map":{"version":3,"names":["angleOf","LinearAxis","inferTitleTransform","orientation","internalOrientation","Math","PI","titleTransform","inferAxisStyle","options","theme","coordinate","scales","radar","scale","name","getOptions","startAngle","endAngle","axisRadar","radarTheme","Object","assign","grid","gridConnect","gridControlAngles","Array","count","fill","map","_","i","angle","AxisRadar","important","restOptions","__rest","context","props","defaultPosition"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/component/axisRadar.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { G2Theme, GuideComponentComponent as GCC, Scale } from '../runtime';\nimport { angleOf } from '../utils/coordinate';\nimport { AxisOptions, LinearAxis } from './axis';\n\nexport type AxisRadarOptions = AxisOptions & {\n  radar: {\n    count: number;\n    index: number;\n  };\n};\n\nfunction inferTitleTransform(orientation: number) {\n  const internalOrientation = orientation % (Math.PI * 2);\n\n  if (internalOrientation === Math.PI / 2) {\n    return { titleTransform: 'translate(0, 50%)' };\n  }\n  if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {\n    return { titleTransform: 'translate(50%, 0)' };\n  }\n  if (\n    internalOrientation > Math.PI / 2 &&\n    internalOrientation < (Math.PI * 3) / 2\n  ) {\n    return { titleTransform: 'translate(-50%, 0)' };\n  }\n  return {};\n}\n\nfunction inferAxisStyle(\n  options: AxisRadarOptions,\n  theme: G2Theme,\n  coordinate: Coordinate,\n  scales: Scale[],\n) {\n  const { radar } = options;\n  const [scale] = scales;\n  const name = scale.getOptions().name;\n  const [startAngle, endAngle] = angleOf(coordinate);\n  const { axisRadar: radarTheme = {} } = theme;\n\n  return {\n    ...radarTheme,\n    grid: name === 'position',\n    gridConnect: 'line',\n    gridControlAngles: new Array(radar.count).fill(0).map((_, i) => {\n      const angle = (endAngle - startAngle) / radar.count;\n      return angle * i;\n    }),\n  };\n}\n\nexport const AxisRadar: GCC<AxisRadarOptions> = (options) => {\n  const { important = {}, ...restOptions } = options;\n  return (context) => {\n    const { theme, coordinate, scales } = context;\n    return LinearAxis({\n      ...restOptions,\n      ...inferTitleTransform(options.orientation),\n      important: {\n        ...inferAxisStyle(options, theme, coordinate, scales),\n        ...important,\n      },\n    })(context);\n  };\n};\n\nAxisRadar.props = {\n  ...LinearAxis.props,\n  defaultPosition: 'center',\n};\n"],"mappings":";;;;;;;;AAEA,SAASA,OAAO,QAAQ,qBAAqB;AAC7C,SAAsBC,UAAU,QAAQ,QAAQ;AAShD,SAASC,mBAAmBA,CAACC,WAAmB;EAC9C,MAAMC,mBAAmB,GAAGD,WAAW,IAAIE,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;EAEvD,IAAIF,mBAAmB,KAAKC,IAAI,CAACC,EAAE,GAAG,CAAC,EAAE;IACvC,OAAO;MAAEC,cAAc,EAAE;IAAmB,CAAE;;EAEhD,IAAIH,mBAAmB,GAAG,CAACC,IAAI,CAACC,EAAE,GAAG,CAAC,IAAIF,mBAAmB,GAAGC,IAAI,CAACC,EAAE,GAAG,CAAC,EAAE;IAC3E,OAAO;MAAEC,cAAc,EAAE;IAAmB,CAAE;;EAEhD,IACEH,mBAAmB,GAAGC,IAAI,CAACC,EAAE,GAAG,CAAC,IACjCF,mBAAmB,GAAIC,IAAI,CAACC,EAAE,GAAG,CAAC,GAAI,CAAC,EACvC;IACA,OAAO;MAAEC,cAAc,EAAE;IAAoB,CAAE;;EAEjD,OAAO,EAAE;AACX;AAEA,SAASC,cAAcA,CACrBC,OAAyB,EACzBC,KAAc,EACdC,UAAsB,EACtBC,MAAe;EAEf,MAAM;IAAEC;EAAK,CAAE,GAAGJ,OAAO;EACzB,MAAM,CAACK,KAAK,CAAC,GAAGF,MAAM;EACtB,MAAMG,IAAI,GAAGD,KAAK,CAACE,UAAU,EAAE,CAACD,IAAI;EACpC,MAAM,CAACE,UAAU,EAAEC,QAAQ,CAAC,GAAGlB,OAAO,CAACW,UAAU,CAAC;EAClD,MAAM;IAAEQ,SAAS,EAAEC,UAAU,GAAG;EAAE,CAAE,GAAGV,KAAK;EAE5C,OAAAW,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKF,UAAU;IACbG,IAAI,EAAER,IAAI,KAAK,UAAU;IACzBS,WAAW,EAAE,MAAM;IACnBC,iBAAiB,EAAE,IAAIC,KAAK,CAACb,KAAK,CAACc,KAAK,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAI;MAC7D,MAAMC,KAAK,GAAG,CAACd,QAAQ,GAAGD,UAAU,IAAIJ,KAAK,CAACc,KAAK;MACnD,OAAOK,KAAK,GAAGD,CAAC;IAClB,CAAC;EAAC;AAEN;AAEA,OAAO,MAAME,SAAS,GAA2BxB,OAAO,IAAI;EAC1D,MAAM;MAAEyB,SAAS,GAAG;IAAE,IAAqBzB,OAAO;IAAvB0B,WAAW,GAAAC,MAAA,CAAK3B,OAAO,EAA5C,aAAkC,CAAU;EAClD,OAAQ4B,OAAO,IAAI;IACjB,MAAM;MAAE3B,KAAK;MAAEC,UAAU;MAAEC;IAAM,CAAE,GAAGyB,OAAO;IAC7C,OAAOpC,UAAU,CAAAoB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACZa,WAAW,GACXjC,mBAAmB,CAACO,OAAO,CAACN,WAAW,CAAC;MAC3C+B,SAAS,EAAAb,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACJd,cAAc,CAACC,OAAO,EAAEC,KAAK,EAAEC,UAAU,EAAEC,MAAM,CAAC,GAClDsB,SAAS;IAAA,GAEd,CAACG,OAAO,CAAC;EACb,CAAC;AACH,CAAC;AAEDJ,SAAS,CAACK,KAAK,GAAAjB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACVrB,UAAU,CAACqC,KAAK;EACnBC,eAAe,EAAE;AAAQ,EAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}