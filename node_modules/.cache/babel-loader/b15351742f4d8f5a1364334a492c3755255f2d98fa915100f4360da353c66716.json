{"ast":null,"code":"import { RangeShape } from '../shape';\nimport { baseAnnotationChannels, basePostInference, basePreInference } from './utils';\nfunction extend(channel, extended, value, scale) {\n  if (extended) return () => [0, 1];\n  const {\n    [channel]: C,\n    [`${channel}1`]: C1\n  } = value;\n  return i => {\n    var _a;\n    const offset = ((_a = scale.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale, scale.invert(+C1[i]))) || 0;\n    return [C[i], C1[i] + offset];\n  };\n}\nexport function AbstractRange(options = {}) {\n  const {\n    extendX = false,\n    extendY = false\n  } = options;\n  return (index, scale, value, coordinate) => {\n    const x = extend('x', extendX, value, scale.x);\n    const y = extend('y', extendY, value, scale.y);\n    const P = Array.from(index, i => {\n      const [x1, x2] = x(i);\n      const [y1, y2] = y(i);\n      const p1 = [x1, y1];\n      const p2 = [x2, y1];\n      const p3 = [x2, y2];\n      const p4 = [x1, y2];\n      return [p1, p2, p3, p4].map(d => coordinate.map(d));\n    });\n    return [index, P];\n  };\n}\nconst shape = {\n  range: RangeShape\n};\nexport const Range = () => {\n  return AbstractRange();\n};\nRange.props = {\n  defaultShape: 'range',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [...baseAnnotationChannels({\n    shapes: Object.keys(shape)\n  }), {\n    name: 'x',\n    required: true\n  }, {\n    name: 'y',\n    required: true\n  }],\n  preInference: [...basePreInference()],\n  postInference: [...basePostInference()]\n};","map":{"version":3,"names":["RangeShape","baseAnnotationChannels","basePostInference","basePreInference","extend","channel","extended","value","scale","C","C1","i","offset","_a","getBandWidth","call","invert","AbstractRange","options","extendX","extendY","index","coordinate","x","y","P","Array","from","x1","x2","y1","y2","p1","p2","p3","p4","map","d","shape","range","Range","props","defaultShape","defaultLabelShape","composite","channels","shapes","Object","keys","name","required","preInference","postInference"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/mark/range.ts"],"sourcesContent":["import { Mark, MarkComponent as MC, Vector2 } from '../runtime';\nimport { RangeMark } from '../spec';\nimport { RangeShape } from '../shape';\nimport {\n  baseAnnotationChannels,\n  basePostInference,\n  basePreInference,\n} from './utils';\n\nfunction extend(channel: string, extended: boolean, value, scale) {\n  if (extended) return () => [0, 1];\n  const { [channel]: C, [`${channel}1`]: C1 } = value;\n  return (i) => {\n    const offset = scale.getBandWidth?.(scale.invert(+C1[i])) || 0;\n    return [C[i], C1[i] + offset];\n  };\n}\n\nexport function AbstractRange(\n  options: { extendX?: boolean; extendY?: boolean } = {},\n): Mark {\n  const { extendX = false, extendY = false } = options;\n  return (index, scale, value, coordinate) => {\n    const x = extend('x', extendX, value, scale.x);\n    const y = extend('y', extendY, value, scale.y);\n    const P = Array.from(index, (i) => {\n      const [x1, x2] = x(i);\n      const [y1, y2] = y(i);\n\n      const p1 = [x1, y1];\n      const p2 = [x2, y1];\n      const p3 = [x2, y2];\n      const p4 = [x1, y2];\n      return [p1, p2, p3, p4].map((d) => coordinate.map(d)) as Vector2[];\n    });\n    return [index, P];\n  };\n}\n\nconst shape = { range: RangeShape };\n\nexport type RangeOptions = Omit<RangeMark, 'type'>;\n\nexport const Range: MC<RangeOptions> = () => {\n  return AbstractRange();\n};\n\nRange.props = {\n  defaultShape: 'range',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [\n    ...baseAnnotationChannels({ shapes: Object.keys(shape) }),\n    { name: 'x', required: true },\n    { name: 'y', required: true },\n  ],\n  preInference: [...basePreInference()],\n  postInference: [...basePostInference()],\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}