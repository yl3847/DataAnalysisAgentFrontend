{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { select } from '../../utils/selection';\nimport { applyStyle, getOrigin, toOpacityKey } from '../utils';\nimport { getRadius } from './color';\n/**\n * Render point in different coordinate.\n */\nexport const BaseCircle = (options, context) => {\n  // Render border only when colorAttribute is stroke.\n  const {\n      colorAttribute,\n      mode = 'auto'\n    } = options,\n    style = __rest(options, [\"colorAttribute\", \"mode\"]);\n  const {\n    coordinate,\n    document\n  } = context;\n  return (points, value, defaults) => {\n    const {\n      lineWidth,\n      color: defaultColor\n    } = defaults;\n    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;\n    const {\n      color = defaultColor,\n      transform,\n      opacity\n    } = value;\n    const [cx, cy] = getOrigin(points);\n    const r = getRadius(mode, points, value, coordinate);\n    const finalRadius = r || style.r || defaults.r;\n    return select(document.createElement('circle', {})).call(applyStyle, defaults).style('fill', 'transparent').style('cx', cx).style('cy', cy).style('r', finalRadius).style('lineWidth', finalLineWidth).style('transform', transform).style('transformOrigin', `${cx} ${cy}`).style('stroke', color).style(toOpacityKey(options), opacity).style(colorAttribute, color).call(applyStyle, style).node();\n  };\n};\n/**\n * ●\n */\nexport const Circle = (options, context) => {\n  return BaseCircle(Object.assign({\n    colorAttribute: 'fill'\n  }, options), context);\n};\nCircle.props = {\n  defaultMarker: 'circle',\n  defaultEnterAnimation: 'fadeIn',\n  defaultExitAnimation: 'fadeOut'\n};","map":{"version":3,"names":["select","applyStyle","getOrigin","toOpacityKey","getRadius","BaseCircle","options","context","colorAttribute","mode","style","__rest","coordinate","document","points","value","defaults","lineWidth","color","defaultColor","finalLineWidth","stroke","transform","opacity","cx","cy","r","finalRadius","createElement","call","node","Circle","Object","assign","props","defaultMarker","defaultEnterAnimation","defaultExitAnimation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/point/circle.ts"],"sourcesContent":["import { ShapeComponent as SC } from '../../runtime';\nimport { select } from '../../utils/selection';\nimport { applyStyle, getOrigin, toOpacityKey } from '../utils';\nimport { getRadius } from './color';\n\nexport type PointOptions = Record<string, any>;\n\ntype ColorOptions = {\n  colorAttribute: 'fill' | 'stroke';\n  mode?: 'fixed' | 'auto' | 'normal';\n  [key: string]: any;\n};\n\n/**\n * Render point in different coordinate.\n */\nexport const BaseCircle: SC<ColorOptions> = (options, context) => {\n  // Render border only when colorAttribute is stroke.\n  const { colorAttribute, mode = 'auto', ...style } = options;\n\n  const { coordinate, document } = context;\n  return (points, value, defaults) => {\n    const { lineWidth, color: defaultColor } = defaults;\n    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;\n    const { color = defaultColor, transform, opacity } = value;\n    const [cx, cy] = getOrigin(points);\n    const r = getRadius(mode, points, value, coordinate);\n    const finalRadius = r || style.r || defaults.r;\n    return select(document.createElement('circle', {}))\n      .call(applyStyle, defaults)\n      .style('fill', 'transparent')\n      .style('cx', cx)\n      .style('cy', cy)\n      .style('r', finalRadius)\n      .style('lineWidth', finalLineWidth)\n      .style('transform', transform)\n      .style('transformOrigin', `${cx} ${cy}`)\n      .style('stroke', color)\n      .style(toOpacityKey(options), opacity)\n      .style(colorAttribute, color)\n      .call(applyStyle, style)\n      .node();\n  };\n};\n\n/**\n * ●\n */\nexport const Circle: SC<PointOptions> = (options, context) => {\n  return BaseCircle({ colorAttribute: 'fill', ...options }, context);\n};\n\nCircle.props = {\n  defaultMarker: 'circle',\n  defaultEnterAnimation: 'fadeIn',\n  defaultExitAnimation: 'fadeOut',\n};\n"],"mappings":";;;;;;;;AACA,SAASA,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,UAAU,EAAEC,SAAS,EAAEC,YAAY,QAAQ,UAAU;AAC9D,SAASC,SAAS,QAAQ,SAAS;AAUnC;;;AAGA,OAAO,MAAMC,UAAU,GAAqBA,CAACC,OAAO,EAAEC,OAAO,KAAI;EAC/D;EACA,MAAM;MAAEC,cAAc;MAAEC,IAAI,GAAG;IAAM,IAAeH,OAAO;IAAjBI,KAAK,GAAAC,MAAA,CAAKL,OAAO,EAArD,0BAA2C,CAAU;EAE3D,MAAM;IAAEM,UAAU;IAAEC;EAAQ,CAAE,GAAGN,OAAO;EACxC,OAAO,CAACO,MAAM,EAAEC,KAAK,EAAEC,QAAQ,KAAI;IACjC,MAAM;MAAEC,SAAS;MAAEC,KAAK,EAAEC;IAAY,CAAE,GAAGH,QAAQ;IACnD,MAAMI,cAAc,GAAGV,KAAK,CAACW,MAAM,GAAGJ,SAAS,IAAI,CAAC,GAAGA,SAAS;IAChE,MAAM;MAAEC,KAAK,GAAGC,YAAY;MAAEG,SAAS;MAAEC;IAAO,CAAE,GAAGR,KAAK;IAC1D,MAAM,CAACS,EAAE,EAAEC,EAAE,CAAC,GAAGvB,SAAS,CAACY,MAAM,CAAC;IAClC,MAAMY,CAAC,GAAGtB,SAAS,CAACK,IAAI,EAAEK,MAAM,EAAEC,KAAK,EAAEH,UAAU,CAAC;IACpD,MAAMe,WAAW,GAAGD,CAAC,IAAIhB,KAAK,CAACgB,CAAC,IAAIV,QAAQ,CAACU,CAAC;IAC9C,OAAO1B,MAAM,CAACa,QAAQ,CAACe,aAAa,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAChDC,IAAI,CAAC5B,UAAU,EAAEe,QAAQ,CAAC,CAC1BN,KAAK,CAAC,MAAM,EAAE,aAAa,CAAC,CAC5BA,KAAK,CAAC,IAAI,EAAEc,EAAE,CAAC,CACfd,KAAK,CAAC,IAAI,EAAEe,EAAE,CAAC,CACff,KAAK,CAAC,GAAG,EAAEiB,WAAW,CAAC,CACvBjB,KAAK,CAAC,WAAW,EAAEU,cAAc,CAAC,CAClCV,KAAK,CAAC,WAAW,EAAEY,SAAS,CAAC,CAC7BZ,KAAK,CAAC,iBAAiB,EAAE,GAAGc,EAAE,IAAIC,EAAE,EAAE,CAAC,CACvCf,KAAK,CAAC,QAAQ,EAAEQ,KAAK,CAAC,CACtBR,KAAK,CAACP,YAAY,CAACG,OAAO,CAAC,EAAEiB,OAAO,CAAC,CACrCb,KAAK,CAACF,cAAc,EAAEU,KAAK,CAAC,CAC5BW,IAAI,CAAC5B,UAAU,EAAES,KAAK,CAAC,CACvBoB,IAAI,EAAE;EACX,CAAC;AACH,CAAC;AAED;;;AAGA,OAAO,MAAMC,MAAM,GAAqBA,CAACzB,OAAO,EAAEC,OAAO,KAAI;EAC3D,OAAOF,UAAU,CAAA2B,MAAA,CAAAC,MAAA;IAAGzB,cAAc,EAAE;EAAM,GAAKF,OAAO,GAAIC,OAAO,CAAC;AACpE,CAAC;AAEDwB,MAAM,CAACG,KAAK,GAAG;EACbC,aAAa,EAAE,QAAQ;EACvBC,qBAAqB,EAAE,QAAQ;EAC/BC,oBAAoB,EAAE;CACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}