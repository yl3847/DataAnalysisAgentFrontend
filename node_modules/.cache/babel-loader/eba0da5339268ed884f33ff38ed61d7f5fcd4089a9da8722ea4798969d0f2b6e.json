{"ast":null,"code":"import { Linear, createInterpolateValue } from '@antv/scale';\nimport { extent, max, rollups } from '@antv/vendor/d3-array';\nimport * as d3ScaleChromatic from '@antv/vendor/d3-scale-chromatic';\nimport { deepMix, omit, upperFirst } from '@antv/util';\nimport { firstOf, lastOf, unique } from '../utils/array';\nimport { defined, identity, isStrictObject } from '../utils/helper';\nimport { isTheta } from './coordinate';\nimport { useLibrary } from './library';\nexport function inferScale(name, values, options, coordinates, theme, library) {\n  const {\n    guide = {}\n  } = options;\n  const type = inferScaleType(name, values, options);\n  if (typeof type !== 'string') return options;\n  const expectedDomain = inferScaleDomain(type, name, values, options);\n  const actualDomain = maybeRatio(type, expectedDomain, options);\n  return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name, values, options, coordinates)), {\n    domain: actualDomain,\n    range: inferScaleRange(type, name, values, options, actualDomain, theme, library),\n    expectedDomain,\n    guide,\n    name,\n    type\n  });\n}\nexport function applyScale(channels, scale) {\n  const scaledValue = {};\n  for (const channel of channels) {\n    const {\n      values,\n      name: scaleName\n    } = channel;\n    const scaleInstance = scale[scaleName];\n    for (const value of values) {\n      const {\n        name,\n        value: V\n      } = value;\n      scaledValue[name] = V.map(d => scaleInstance.map(d));\n    }\n  }\n  return scaledValue;\n}\nexport function groupTransform(markState, uidScale) {\n  const channels = Array.from(markState.values()).flatMap(d => d.channels);\n  const scaleGroups = rollups(channels, channels => channels.map(d => uidScale.get(d.scale.uid)), d => d.name).filter(([, scales]) => scales.some(d => typeof d.getOptions().groupTransform === 'function') &&\n  // only sync scales with groupTransform options\n  scales.every(d => d.getTicks)).map(d => d[1]);\n  scaleGroups.forEach(group => {\n    const groupTransform = group.map(d => d.getOptions().groupTransform)[0];\n    groupTransform(group);\n  });\n}\nexport function collectScales(states, options) {\n  var _a;\n  const {\n    components = []\n  } = options;\n  const NONE_STATIC_KEYS = ['scale', 'encode', 'axis', 'legend', 'data', 'transform'];\n  // From normal marks.\n  const scales = Array.from(new Set(states.flatMap(d => d.channels.map(d => d.scale))));\n  // From static marks.\n  const nameScale = new Map(scales.map(scale => [scale.name, scale]));\n  for (const component of components) {\n    const channels = inferChannelsForComponent(component);\n    for (const channel of channels) {\n      const scale = nameScale.get(channel);\n      const staticScale = ((_a = component.scale) === null || _a === void 0 ? void 0 : _a[channel]) || {};\n      const {\n        independent = false\n      } = staticScale;\n      if (scale && !independent) {\n        // Merged with exist scales if is not independent.\n        const {\n          guide\n        } = scale;\n        const guide1 = typeof guide === 'boolean' ? {} : guide;\n        scale.guide = deepMix({}, guide1, component);\n        Object.assign(scale, staticScale);\n      } else {\n        // Append new scales without exit scales or independent.\n        const options1 = Object.assign(Object.assign({}, staticScale), {\n          expectedDomain: staticScale.domain,\n          name: channel,\n          guide: omit(component, NONE_STATIC_KEYS)\n        });\n        scales.push(options1);\n      }\n    }\n  }\n  return scales;\n}\nexport function useRelation(relations) {\n  if (!relations || !Array.isArray(relations)) return [identity, identity];\n  // Store original map and invert.\n  let map;\n  let invert;\n  const conditionalize = scale => {\n    var _a;\n    map = scale.map.bind(scale);\n    invert = (_a = scale.invert) === null || _a === void 0 ? void 0 : _a.bind(scale);\n    // Distinguish functions[function, output] and value[vale, output] relations.\n    const funcRelations = relations.filter(([v]) => typeof v === 'function');\n    const valueRelations = relations.filter(([v]) => typeof v !== 'function');\n    // Update scale.map\n    const valueOutput = new Map(valueRelations);\n    scale.map = x => {\n      for (const [verify, value] of funcRelations) {\n        if (verify(x)) return value;\n      }\n      if (valueOutput.has(x)) return valueOutput.get(x);\n      return map(x);\n    };\n    if (!invert) return scale;\n    // Update scale.invert\n    const outputValue = new Map(valueRelations.map(([a, b]) => [b, a]));\n    const outputFunc = new Map(funcRelations.map(([a, b]) => [b, a]));\n    scale.invert = x => {\n      if (outputFunc.has(x)) return x;\n      if (outputValue.has(x)) return outputValue.get(x);\n      return invert(x);\n    };\n    return scale;\n  };\n  const deconditionalize = scale => {\n    if (map !== null) scale.map = map;\n    if (invert !== null) scale.invert = invert;\n    return scale;\n  };\n  return [conditionalize, deconditionalize];\n}\nexport function assignScale(target, source) {\n  const keys = Object.keys(target);\n  for (const scale of Object.values(source)) {\n    const {\n      name\n    } = scale.getOptions();\n    if (!(name in target)) target[name] = scale;else {\n      const I = keys.filter(d => d.startsWith(name))\n      // Reg is for extract `1` from `x1`;\n      .map(d => +(d.replace(name, '') || 0));\n      const index = max(I) + 1;\n      const newKey = `${name}${index}`;\n      target[newKey] = scale;\n      scale.getOptions().key = newKey;\n    }\n  }\n  return target;\n}\nexport function useRelationScale(options, library) {\n  const [useScale] = useLibrary('scale', library);\n  const {\n    relations\n  } = options;\n  const [conditionalize] = useRelation(relations);\n  const scale = useScale(options);\n  return conditionalize(scale);\n}\nexport function syncFacetsScales(states) {\n  const scales = states.flatMap(d => Array.from(d.values())).flatMap(d => d.channels.map(d => d.scale));\n  syncFacetsScaleByChannel(scales, 'x');\n  syncFacetsScaleByChannel(scales, 'y');\n}\nfunction inferChannelsForComponent(component) {\n  const {\n    channels = [],\n    type,\n    scale = {}\n  } = component;\n  const L = ['shape', 'color', 'opacity', 'size'];\n  if (channels.length !== 0) return channels;\n  if (type === 'axisX') return ['x'];\n  if (type === 'axisY') return ['y'];\n  if (type === 'legends') return Object.keys(scale).filter(d => L.includes(d));\n  return [];\n}\nfunction syncFacetsScaleByChannel(scales, channel) {\n  const S = scales.filter(({\n    name,\n    facet = true\n  }) => facet && name === channel);\n  const D = S.flatMap(d => d.domain);\n  const syncedD = S.every(isQuantitativeScale) ? extent(D) : S.every(isDiscreteScale) ? Array.from(new Set(D)) : null;\n  if (syncedD === null) return;\n  for (const scale of S) {\n    scale.domain = syncedD;\n  }\n}\nfunction maybeRatio(type, domain, options) {\n  const {\n    ratio\n  } = options;\n  if (ratio === undefined || ratio === null) return domain;\n  if (isQuantitativeScale({\n    type\n  })) {\n    return clampQuantitativeScale(domain, ratio, type);\n  }\n  if (isDiscreteScale({\n    type\n  })) return clampDiscreteScale(domain, ratio);\n  return domain;\n}\nfunction clampQuantitativeScale(domain, ratio, type) {\n  const D = domain.map(Number);\n  const scale = new Linear({\n    domain: D,\n    range: [D[0], D[0] + (D[D.length - 1] - D[0]) * ratio]\n  });\n  if (type === 'time') return domain.map(d => new Date(scale.map(d)));\n  return domain.map(d => scale.map(d));\n}\nfunction clampDiscreteScale(domain, ratio) {\n  const index = Math.round(domain.length * ratio);\n  return domain.slice(0, index);\n}\nfunction isQuantitativeScale(scale) {\n  const {\n    type\n  } = scale;\n  if (typeof type !== 'string') return false;\n  // Do not take quantize, quantile or threshold scale into account,\n  // because they are not for position scales. If they are, there is\n  // no need to sync them.\n  const names = ['linear', 'log', 'pow', 'time'];\n  return names.includes(type);\n}\nfunction isDiscreteScale(scale) {\n  const {\n    type\n  } = scale;\n  if (typeof type !== 'string') return false;\n  const names = ['band', 'point', 'ordinal'];\n  return names.includes(type);\n}\n// @todo More accurate inference for different cases.\nfunction inferScaleType(name, values, options) {\n  const {\n    type,\n    domain,\n    range,\n    quantitative,\n    ordinal\n  } = options;\n  if (type !== undefined) return type;\n  if (isObject(values)) return 'identity';\n  if (typeof range === 'string') return 'linear';\n  if ((domain || range || []).length > 2) return asOrdinalType(name, ordinal);\n  if (domain !== undefined) {\n    if (isOrdinal([domain])) return asOrdinalType(name, ordinal);\n    if (isTemporal(values)) return 'time';\n    return asQuantitativeType(name, range, quantitative);\n  }\n  if (isOrdinal(values)) return asOrdinalType(name, ordinal);\n  if (isTemporal(values)) return 'time';\n  return asQuantitativeType(name, range, quantitative);\n}\nfunction inferScaleDomain(type, name, values, options) {\n  const {\n    domain\n  } = options;\n  if (domain !== undefined) return domain;\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt':\n    case 'quantize':\n    case 'threshold':\n      return maybeMinMax(inferDomainQ(values, options), options);\n    case 'band':\n    case 'ordinal':\n    case 'point':\n      return inferDomainC(values);\n    case 'quantile':\n      return inferDomainO(values);\n    case 'sequential':\n      return maybeMinMax(inferDomainS(values), options);\n    default:\n      return [];\n  }\n}\nfunction inferScaleRange(type, name, values, options, domain, theme, library) {\n  const {\n    range\n  } = options;\n  if (typeof range === 'string') return gradientColors(range);\n  if (range !== undefined) return range;\n  const {\n    rangeMin,\n    rangeMax\n  } = options;\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt':\n      {\n        const colors = categoricalColors(values, options, domain, theme, library);\n        const [r0, r1] = inferRangeQ(name, colors);\n        return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : r0, rangeMax !== null && rangeMax !== void 0 ? rangeMax : r1];\n      }\n    case 'band':\n    case 'point':\n      {\n        const min = name === 'size' ? 5 : 0;\n        const max = name === 'size' ? 10 : 1;\n        return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : min, rangeMax !== null && rangeMax !== void 0 ? rangeMax : max];\n      }\n    case 'ordinal':\n      {\n        return categoricalColors(values, options, domain, theme, library);\n      }\n    case 'sequential':\n      return undefined;\n    case 'constant':\n      return [values[0][0]];\n    default:\n      return [];\n  }\n}\nfunction inferScaleOptions(type, name, values, options, coordinates) {\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt':\n      return inferOptionsQ(coordinates, options);\n    case 'band':\n    case 'point':\n      return inferOptionsC(type, name, coordinates, options);\n    case 'sequential':\n      return inferOptionsS(options);\n    default:\n      return options;\n  }\n}\nfunction categoricalColors(values, options, domain, theme, library) {\n  const [usePalette] = useLibrary('palette', library);\n  const {\n    category10: c10,\n    category20: c20\n  } = theme;\n  const defaultPalette = unique(domain).length <= c10.length ? c10 : c20;\n  const {\n    palette = defaultPalette,\n    offset\n  } = options;\n  if (Array.isArray(palette)) return palette;\n  // Built-in palettes have higher priority.\n  try {\n    return usePalette({\n      type: palette\n    });\n  } catch (e) {\n    const colors = interpolatedColors(palette, domain, offset);\n    if (colors) return colors;\n    throw new Error(`Unknown Component: ${palette} `);\n  }\n}\nfunction gradientColors(range) {\n  return range.split('-');\n}\nfunction interpolatedColors(palette, domain, offset = d => d) {\n  if (!palette) return null;\n  const fullName = upperFirst(palette);\n  // If scheme have enough colors, then return pre-defined colors.\n  const scheme = d3ScaleChromatic[`scheme${fullName}`];\n  const interpolator = d3ScaleChromatic[`interpolate${fullName}`];\n  if (!scheme && !interpolator) return null;\n  if (scheme) {\n    // If is a one dimension array, return it.\n    if (!scheme.some(Array.isArray)) return scheme;\n    const schemeColors = scheme[domain.length];\n    if (schemeColors) return schemeColors;\n  }\n  // Otherwise interpolate to get full colors.\n  return domain.map((_, i) => interpolator(offset(i / domain.length)));\n}\nfunction inferOptionsS(options) {\n  const {\n    palette = 'ylGnBu',\n    offset\n  } = options;\n  const name = upperFirst(palette);\n  const interpolator = d3ScaleChromatic[`interpolate${name}`];\n  if (!interpolator) throw new Error(`Unknown palette: ${name}`);\n  return {\n    interpolator: offset ? x => interpolator(offset(x)) : interpolator\n  };\n}\nfunction inferOptionsQ(coordinates, options) {\n  const {\n    interpolate = createInterpolateValue,\n    nice = false,\n    tickCount = 5\n  } = options;\n  return Object.assign(Object.assign({}, options), {\n    interpolate,\n    nice,\n    tickCount\n  });\n}\nfunction inferOptionsC(type, name, coordinates, options) {\n  if (options.padding !== undefined || options.paddingInner !== undefined || options.paddingOuter !== undefined) {\n    return Object.assign(Object.assign({}, options), {\n      unknown: NaN\n    });\n  }\n  const padding = inferPadding(type, name, coordinates);\n  const {\n    paddingInner = padding,\n    paddingOuter = padding\n  } = options;\n  return Object.assign(Object.assign({}, options), {\n    paddingInner,\n    paddingOuter,\n    padding,\n    unknown: NaN\n  });\n}\nfunction inferPadding(type, name, coordinates) {\n  // The scale for enterDelay and enterDuration should has zero padding by default.\n  // Because there is no need to add extra delay for the start and the end.\n  if (name === 'enterDelay' || name === 'enterDuration') return 0;\n  if (name === 'size') return 0;\n  if (type === 'band') return isTheta(coordinates) ? 0 : 0.1;\n  // Point scale need 0.5 padding to make interval between first and last point\n  // equal to other intervals in polar coordinate.\n  if (type === 'point') return 0.5;\n  return 0;\n}\nfunction asOrdinalType(name, defaults) {\n  if (defaults) return defaults;\n  return isQuantitative(name) ? 'point' : 'ordinal';\n}\nfunction asQuantitativeType(name, range, defaults) {\n  if (defaults) return defaults;\n  if (name !== 'color') return 'linear';\n  return range ? 'linear' : 'sequential';\n}\nfunction maybeMinMax(domain, options) {\n  if (domain.length === 0) return domain;\n  const {\n    domainMin,\n    domainMax\n  } = options;\n  const [d0, d1] = domain;\n  return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];\n}\nfunction inferDomainQ(values, options) {\n  const {\n    zero = false\n  } = options;\n  let min = Infinity;\n  let max = -Infinity;\n  for (const value of values) {\n    for (const d of value) {\n      if (defined(d)) {\n        min = Math.min(min, +d);\n        max = Math.max(max, +d);\n      }\n    }\n  }\n  if (min === Infinity) return [];\n  return zero ? [Math.min(0, min), max] : [min, max];\n}\nfunction inferDomainC(values) {\n  return Array.from(new Set(values.flat()));\n}\nfunction inferDomainO(values) {\n  return values.flat().sort();\n}\nfunction inferDomainS(values) {\n  let min = Infinity;\n  let max = -Infinity;\n  for (const value of values) {\n    for (const d of value) {\n      if (defined(d)) {\n        min = Math.min(min, +d);\n        max = Math.max(max, +d);\n      }\n    }\n  }\n  if (min === Infinity) return [];\n  return [min < 0 ? -max : min, max];\n}\n/**\n * @todo More nice default range for enterDelay and enterDuration.\n * @todo Move these to channel definition.\n */\nfunction inferRangeQ(name, palette) {\n  if (name === 'enterDelay') return [0, 1000];\n  if (name == 'enterDuration') return [300, 1000];\n  if (name.startsWith('y') || name.startsWith('position')) return [1, 0];\n  if (name === 'color') return [firstOf(palette), lastOf(palette)];\n  if (name === 'opacity') return [0, 1];\n  if (name === 'size') return [1, 10];\n  return [0, 1];\n}\nfunction isOrdinal(values) {\n  return some(values, d => {\n    const type = typeof d;\n    return type === 'string' || type === 'boolean';\n  });\n}\nfunction isTemporal(values) {\n  return some(values, d => d instanceof Date);\n}\nfunction isObject(values) {\n  return some(values, isStrictObject);\n}\nfunction some(values, callback) {\n  for (const V of values) {\n    if (V.some(callback)) return true;\n  }\n  return false;\n}\nfunction isQuantitative(name) {\n  return name.startsWith('x') || name.startsWith('y') || name.startsWith('position') || name.startsWith('size');\n}\n// Spatial and temporal position.\nexport function isPosition(name) {\n  return name.startsWith('x') || name.startsWith('y') || name.startsWith('position') || name === 'enterDelay' || name === 'enterDuration' || name === 'updateDelay' || name === 'updateDuration' || name === 'exitDelay' || name === 'exitDuration';\n}\nexport function isValidScale(scale) {\n  if (!scale || !scale.type) return false;\n  if (typeof scale.type === 'function') return true;\n  const {\n    type,\n    domain,\n    range,\n    interpolator\n  } = scale;\n  const isValidDomain = domain && domain.length > 0;\n  const isValidRange = range && range.length > 0;\n  if (['linear', 'sqrt', 'log', 'time', 'pow', 'threshold', 'quantize', 'quantile', 'ordinal', 'band', 'point'].includes(type) && isValidDomain && isValidRange) {\n    return true;\n  }\n  if (['sequential'].includes(type) && isValidDomain && (isValidRange || interpolator)) {\n    return true;\n  }\n  if (['constant', 'identity'].includes(type) && isValidRange) return true;\n  return false;\n}","map":{"version":3,"names":["Linear","createInterpolateValue","extent","max","rollups","d3ScaleChromatic","deepMix","omit","upperFirst","firstOf","lastOf","unique","defined","identity","isStrictObject","isTheta","useLibrary","inferScale","name","values","options","coordinates","theme","library","guide","type","inferScaleType","expectedDomain","inferScaleDomain","actualDomain","maybeRatio","Object","assign","inferScaleOptions","domain","range","inferScaleRange","applyScale","channels","scale","scaledValue","channel","scaleName","scaleInstance","value","V","map","d","groupTransform","markState","uidScale","Array","from","flatMap","scaleGroups","get","uid","filter","scales","some","getOptions","every","getTicks","forEach","group","collectScales","states","components","NONE_STATIC_KEYS","Set","nameScale","Map","component","inferChannelsForComponent","staticScale","_a","independent","guide1","options1","push","useRelation","relations","isArray","invert","conditionalize","bind","funcRelations","v","valueRelations","valueOutput","x","verify","has","outputValue","a","b","outputFunc","deconditionalize","assignScale","target","source","keys","I","startsWith","replace","index","newKey","key","useRelationScale","useScale","syncFacetsScales","syncFacetsScaleByChannel","L","length","includes","S","facet","D","syncedD","isQuantitativeScale","isDiscreteScale","ratio","undefined","clampQuantitativeScale","clampDiscreteScale","Number","Date","Math","round","slice","names","quantitative","ordinal","isObject","asOrdinalType","isOrdinal","isTemporal","asQuantitativeType","maybeMinMax","inferDomainQ","inferDomainC","inferDomainO","inferDomainS","gradientColors","rangeMin","rangeMax","colors","categoricalColors","r0","r1","inferRangeQ","min","inferOptionsQ","inferOptionsC","inferOptionsS","usePalette","category10","c10","category20","c20","defaultPalette","palette","offset","e","interpolatedColors","Error","split","fullName","scheme","interpolator","schemeColors","_","i","interpolate","nice","tickCount","padding","paddingInner","paddingOuter","unknown","NaN","inferPadding","defaults","isQuantitative","domainMin","domainMax","d0","d1","zero","Infinity","flat","sort","callback","isPosition","isValidScale","isValidDomain","isValidRange"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/runtime/scale.ts"],"sourcesContent":["import { Linear, createInterpolateValue } from '@antv/scale';\nimport { extent, max, rollups } from '@antv/vendor/d3-array';\nimport * as d3ScaleChromatic from '@antv/vendor/d3-scale-chromatic';\nimport { deepMix, omit, upperFirst } from '@antv/util';\nimport { firstOf, lastOf, unique } from '../utils/array';\nimport { defined, identity, isStrictObject } from '../utils/helper';\nimport { Primitive, G2Theme, G2MarkState, ChannelGroups } from './types/common';\nimport {\n  G2CoordinateOptions,\n  G2Library,\n  G2ScaleOptions,\n  G2PaletteOptions,\n  G2Mark,\n  G2View,\n} from './types/options';\nimport {\n  ScaleComponent,\n  PaletteComponent,\n  Palette,\n  Scale,\n} from './types/component';\nimport { isTheta } from './coordinate';\nimport { useLibrary } from './library';\nimport { MarkChannel } from './types/mark';\n\nexport function inferScale(\n  name: string,\n  values: Primitive[][],\n  options: Record<string, any>,\n  coordinates: G2CoordinateOptions[],\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const { guide = {} } = options;\n  const type = inferScaleType(name, values, options);\n  if (typeof type !== 'string') return options;\n  const expectedDomain = inferScaleDomain(type, name, values, options);\n  const actualDomain = maybeRatio(type, expectedDomain, options);\n  return {\n    ...options,\n    ...inferScaleOptions(type, name, values, options, coordinates),\n    domain: actualDomain,\n    range: inferScaleRange(\n      type,\n      name,\n      values,\n      options,\n      actualDomain,\n      theme,\n      library,\n    ),\n    expectedDomain,\n    guide,\n    name,\n    type,\n  };\n}\n\nexport function applyScale(\n  channels: ChannelGroups[],\n  scale: Record<string, Scale>,\n): MarkChannel {\n  const scaledValue = {};\n  for (const channel of channels) {\n    const { values, name: scaleName } = channel;\n    const scaleInstance = scale[scaleName];\n    for (const value of values) {\n      const { name, value: V } = value;\n      scaledValue[name] = V.map((d) => scaleInstance.map(d));\n    }\n  }\n  return scaledValue;\n}\n\nexport function groupTransform(\n  markState: Map<G2Mark, G2MarkState>,\n  uidScale: Map<symbol, Scale>,\n) {\n  const channels = Array.from(markState.values()).flatMap((d) => d.channels);\n\n  const scaleGroups = rollups(\n    channels,\n    (channels) => channels.map((d) => uidScale.get(d.scale.uid)),\n    (d) => d.name,\n  )\n    .filter(\n      ([, scales]) =>\n        scales.some(\n          (d) => typeof d.getOptions().groupTransform === 'function',\n        ) && // only sync scales with groupTransform options\n        scales.every((d) => d.getTicks), // only sync quantitative scales\n    )\n    .map((d) => d[1]);\n\n  scaleGroups.forEach((group) => {\n    const groupTransform = group.map((d) => d.getOptions().groupTransform)[0];\n    groupTransform(group);\n  });\n}\n\nexport function collectScales(states: G2MarkState[], options: G2View) {\n  const { components = [] } = options;\n\n  const NONE_STATIC_KEYS = [\n    'scale',\n    'encode',\n    'axis',\n    'legend',\n    'data',\n    'transform',\n  ];\n\n  // From normal marks.\n  const scales = Array.from(\n    new Set(states.flatMap((d) => d.channels.map((d) => d.scale))),\n  );\n\n  // From static marks.\n  const nameScale = new Map(scales.map((scale) => [scale.name, scale]));\n  for (const component of components) {\n    const channels = inferChannelsForComponent(component);\n    for (const channel of channels) {\n      const scale = nameScale.get(channel);\n      const staticScale = component.scale?.[channel] || {};\n      const { independent = false } = staticScale;\n\n      if (scale && !independent) {\n        // Merged with exist scales if is not independent.\n        const { guide } = scale;\n        const guide1 = typeof guide === 'boolean' ? {} : guide;\n        scale.guide = deepMix({}, guide1, component);\n        Object.assign(scale, staticScale);\n      } else {\n        // Append new scales without exit scales or independent.\n        const options1 = {\n          ...staticScale,\n          expectedDomain: staticScale.domain,\n          name: channel,\n          guide: omit(component, NONE_STATIC_KEYS),\n        };\n        scales.push(options1);\n      }\n    }\n  }\n  return scales;\n}\n\nexport function useRelation(\n  relations: [any, any][],\n): [(scale: Scale) => Scale, (scale: Scale) => Scale] {\n  if (!relations || !Array.isArray(relations)) return [identity, identity];\n\n  // Store original map and invert.\n  let map;\n  let invert;\n\n  const conditionalize = (scale: Scale) => {\n    map = scale.map.bind(scale);\n    invert = scale.invert?.bind(scale);\n\n    // Distinguish functions[function, output] and value[vale, output] relations.\n    const funcRelations = relations.filter(([v]) => typeof v === 'function');\n    const valueRelations = relations.filter(([v]) => typeof v !== 'function');\n\n    // Update scale.map\n    const valueOutput = new Map(valueRelations);\n    scale.map = (x) => {\n      for (const [verify, value] of funcRelations) {\n        if (verify(x)) return value;\n      }\n      if (valueOutput.has(x)) return valueOutput.get(x);\n      return map(x);\n    };\n\n    if (!invert) return scale;\n\n    // Update scale.invert\n    const outputValue = new Map(valueRelations.map(([a, b]) => [b, a]));\n    const outputFunc = new Map(funcRelations.map(([a, b]) => [b, a]));\n    scale.invert = (x) => {\n      if (outputFunc.has(x)) return x;\n      if (outputValue.has(x)) return outputValue.get(x);\n      return invert(x);\n    };\n    return scale;\n  };\n\n  const deconditionalize = (scale: Scale) => {\n    if (map !== null) scale.map = map;\n    if (invert !== null) scale.invert = invert;\n    return scale;\n  };\n\n  return [conditionalize, deconditionalize];\n}\n\nexport function assignScale(\n  target: Record<string, Scale>,\n  source: Record<string, Scale>,\n): Record<string, Scale> {\n  const keys = Object.keys(target);\n  for (const scale of Object.values(source)) {\n    const { name } = scale.getOptions();\n    if (!(name in target)) target[name] = scale;\n    else {\n      const I = keys\n        .filter((d) => d.startsWith(name))\n        // Reg is for extract `1` from `x1`;\n        .map((d) => +(d.replace(name, '') || 0));\n      const index = max(I) + 1;\n      const newKey = `${name}${index}`;\n      target[newKey] = scale;\n      scale.getOptions().key = newKey;\n    }\n  }\n  return target;\n}\n\nexport function useRelationScale(\n  options: Record<string, any>,\n  library: G2Library,\n) {\n  const [useScale] = useLibrary<G2ScaleOptions, ScaleComponent, Scale>(\n    'scale',\n    library,\n  );\n  const { relations } = options;\n  const [conditionalize] = useRelation(relations);\n  const scale = useScale(options);\n  return conditionalize(scale);\n}\n\nexport function syncFacetsScales(states: Map<G2Mark, G2MarkState>[]): void {\n  const scales = states\n    .flatMap((d) => Array.from(d.values()))\n    .flatMap((d) => d.channels.map((d) => d.scale));\n  syncFacetsScaleByChannel(scales, 'x');\n  syncFacetsScaleByChannel(scales, 'y');\n}\n\nfunction inferChannelsForComponent(component) {\n  const { channels = [], type, scale = {} } = component;\n  const L = ['shape', 'color', 'opacity', 'size'];\n  if (channels.length !== 0) return channels;\n  if (type === 'axisX') return ['x'];\n  if (type === 'axisY') return ['y'];\n  if (type === 'legends')\n    return Object.keys(scale).filter((d) => L.includes(d));\n  return [];\n}\n\nfunction syncFacetsScaleByChannel(\n  scales: G2ScaleOptions[],\n  channel: 'x' | 'y',\n): void {\n  const S = scales.filter(\n    ({ name, facet = true }) => facet && name === channel,\n  );\n  const D = S.flatMap((d) => d.domain);\n  const syncedD = S.every(isQuantitativeScale)\n    ? extent(D)\n    : S.every(isDiscreteScale)\n    ? Array.from(new Set(D))\n    : null;\n  if (syncedD === null) return;\n  for (const scale of S) {\n    scale.domain = syncedD;\n  }\n}\n\nfunction maybeRatio(\n  type: string,\n  domain: Primitive[],\n  options: G2ScaleOptions,\n) {\n  const { ratio } = options;\n  if (ratio === undefined || ratio === null) return domain;\n  if (isQuantitativeScale({ type })) {\n    return clampQuantitativeScale(domain as number[], ratio, type);\n  }\n  if (isDiscreteScale({ type })) return clampDiscreteScale(domain, ratio);\n  return domain;\n}\n\nfunction clampQuantitativeScale(domain: number[], ratio: number, type: string) {\n  const D = domain.map(Number);\n  const scale = new Linear({\n    domain: D,\n    range: [D[0], D[0] + (D[D.length - 1] - D[0]) * ratio],\n  });\n  if (type === 'time') return domain.map((d) => new Date(scale.map(d)));\n  return domain.map((d) => scale.map(d));\n}\n\nfunction clampDiscreteScale(domain: Primitive[], ratio: number) {\n  const index = Math.round(domain.length * ratio);\n  return domain.slice(0, index);\n}\n\nfunction isQuantitativeScale(scale: G2ScaleOptions) {\n  const { type } = scale;\n  if (typeof type !== 'string') return false;\n  // Do not take quantize, quantile or threshold scale into account,\n  // because they are not for position scales. If they are, there is\n  // no need to sync them.\n  const names = ['linear', 'log', 'pow', 'time'];\n  return names.includes(type);\n}\n\nfunction isDiscreteScale(scale: G2ScaleOptions) {\n  const { type } = scale;\n  if (typeof type !== 'string') return false;\n  const names = ['band', 'point', 'ordinal'];\n  return names.includes(type);\n}\n\n// @todo More accurate inference for different cases.\nfunction inferScaleType(\n  name: string,\n  values: Primitive[][],\n  options: G2ScaleOptions,\n): string | ScaleComponent {\n  const { type, domain, range, quantitative, ordinal } = options;\n  if (type !== undefined) return type;\n  if (isObject(values)) return 'identity';\n  if (typeof range === 'string') return 'linear';\n  if ((domain || range || []).length > 2) return asOrdinalType(name, ordinal);\n  if (domain !== undefined) {\n    if (isOrdinal([domain])) return asOrdinalType(name, ordinal);\n    if (isTemporal(values)) return 'time';\n    return asQuantitativeType(name, range, quantitative);\n  }\n  if (isOrdinal(values)) return asOrdinalType(name, ordinal);\n  if (isTemporal(values)) return 'time';\n  return asQuantitativeType(name, range, quantitative);\n}\n\nfunction inferScaleDomain(\n  type: string,\n  name: string,\n  values,\n  options: G2ScaleOptions,\n): Primitive[] {\n  const { domain } = options;\n  if (domain !== undefined) return domain;\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt':\n    case 'quantize':\n    case 'threshold':\n      return maybeMinMax(inferDomainQ(values, options), options);\n    case 'band':\n    case 'ordinal':\n    case 'point':\n      return inferDomainC(values);\n    case 'quantile':\n      return inferDomainO(values);\n    case 'sequential':\n      return maybeMinMax(inferDomainS(values), options);\n    default:\n      return [];\n  }\n}\n\nfunction inferScaleRange(\n  type: string,\n  name: string,\n  values: Primitive[][],\n  options: G2ScaleOptions,\n  domain: Primitive[],\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const { range } = options;\n  if (typeof range === 'string') return gradientColors(range);\n  if (range !== undefined) return range;\n  const { rangeMin, rangeMax } = options;\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt': {\n      const colors = categoricalColors(values, options, domain, theme, library);\n      const [r0, r1] = inferRangeQ(name, colors);\n      return [rangeMin ?? r0, rangeMax ?? r1];\n    }\n    case 'band':\n    case 'point': {\n      const min = name === 'size' ? 5 : 0;\n      const max = name === 'size' ? 10 : 1;\n      return [rangeMin ?? min, rangeMax ?? max];\n    }\n    case 'ordinal': {\n      return categoricalColors(values, options, domain, theme, library);\n    }\n    case 'sequential':\n      return undefined;\n    case 'constant':\n      return [values[0][0]];\n    default:\n      return [];\n  }\n}\n\nfunction inferScaleOptions(\n  type: string,\n  name: string,\n  values: Primitive[][],\n  options: G2ScaleOptions,\n  coordinates: G2CoordinateOptions[],\n): G2ScaleOptions {\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt':\n      return inferOptionsQ(coordinates, options);\n    case 'band':\n    case 'point':\n      return inferOptionsC(type, name, coordinates, options);\n    case 'sequential':\n      return inferOptionsS(options);\n    default:\n      return options;\n  }\n}\n\nfunction categoricalColors(\n  values: Primitive[][],\n  options: G2ScaleOptions,\n  domain: Primitive[],\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const [usePalette] = useLibrary<G2PaletteOptions, PaletteComponent, Palette>(\n    'palette',\n    library,\n  );\n  const { category10: c10, category20: c20 } = theme;\n  const defaultPalette = unique(domain).length <= c10.length ? c10 : c20;\n  const { palette = defaultPalette, offset } = options;\n  if (Array.isArray(palette)) return palette;\n  // Built-in palettes have higher priority.\n  try {\n    return usePalette({ type: palette });\n  } catch (e) {\n    const colors = interpolatedColors(palette, domain, offset);\n    if (colors) return colors;\n    throw new Error(`Unknown Component: ${palette} `);\n  }\n}\n\nfunction gradientColors(range: string): string[] {\n  return range.split('-');\n}\n\nfunction interpolatedColors(\n  palette: string,\n  domain: Primitive[],\n  offset = (d) => d,\n): string[] {\n  if (!palette) return null;\n  const fullName = upperFirst(palette);\n\n  // If scheme have enough colors, then return pre-defined colors.\n  const scheme = d3ScaleChromatic[`scheme${fullName}`];\n  const interpolator = d3ScaleChromatic[`interpolate${fullName}`];\n  if (!scheme && !interpolator) return null;\n\n  if (scheme) {\n    // If is a one dimension array, return it.\n    if (!scheme.some(Array.isArray)) return scheme;\n    const schemeColors = scheme[domain.length];\n    if (schemeColors) return schemeColors;\n  }\n\n  // Otherwise interpolate to get full colors.\n  return domain.map((_, i) => interpolator(offset(i / domain.length)));\n}\n\nfunction inferOptionsS(options) {\n  const { palette = 'ylGnBu', offset } = options;\n  const name = upperFirst(palette);\n  const interpolator = d3ScaleChromatic[`interpolate${name}`];\n  if (!interpolator) throw new Error(`Unknown palette: ${name}`);\n  return {\n    interpolator: offset ? (x) => interpolator(offset(x)) : interpolator,\n  };\n}\n\nfunction inferOptionsQ(\n  coordinates: G2CoordinateOptions[],\n  options: G2ScaleOptions,\n): G2ScaleOptions {\n  const {\n    interpolate = createInterpolateValue,\n    nice = false,\n    tickCount = 5,\n  } = options;\n  return { ...options, interpolate, nice, tickCount };\n}\n\nfunction inferOptionsC(\n  type: string,\n  name: string,\n  coordinates: G2CoordinateOptions[],\n  options: G2ScaleOptions,\n): G2ScaleOptions {\n  if (\n    options.padding !== undefined ||\n    options.paddingInner !== undefined ||\n    options.paddingOuter !== undefined\n  ) {\n    return { ...options, unknown: NaN };\n  }\n  const padding = inferPadding(type, name, coordinates);\n  const { paddingInner = padding, paddingOuter = padding } = options;\n  return {\n    ...options,\n    paddingInner,\n    paddingOuter,\n    padding,\n    unknown: NaN,\n  };\n}\n\nfunction inferPadding(\n  type: string,\n  name: string,\n  coordinates: G2CoordinateOptions[],\n): number {\n  // The scale for enterDelay and enterDuration should has zero padding by default.\n  // Because there is no need to add extra delay for the start and the end.\n  if (name === 'enterDelay' || name === 'enterDuration') return 0;\n  if (name === 'size') return 0;\n  if (type === 'band') return isTheta(coordinates) ? 0 : 0.1;\n  // Point scale need 0.5 padding to make interval between first and last point\n  // equal to other intervals in polar coordinate.\n  if (type === 'point') return 0.5;\n  return 0;\n}\n\nfunction asOrdinalType(name: string, defaults: string) {\n  if (defaults) return defaults;\n  return isQuantitative(name) ? 'point' : 'ordinal';\n}\n\nfunction asQuantitativeType(\n  name: string,\n  range: Primitive[],\n  defaults: string,\n) {\n  if (defaults) return defaults;\n  if (name !== 'color') return 'linear';\n  return range ? 'linear' : 'sequential';\n}\n\nfunction maybeMinMax(\n  domain: Primitive[],\n  options: G2ScaleOptions,\n): Primitive[] {\n  if (domain.length === 0) return domain;\n  const { domainMin, domainMax } = options;\n  const [d0, d1] = domain;\n  return [domainMin ?? d0, domainMax ?? d1];\n}\n\nfunction inferDomainQ(values: Primitive[][], options: G2ScaleOptions) {\n  const { zero = false } = options;\n  let min = Infinity;\n  let max = -Infinity;\n  for (const value of values) {\n    for (const d of value) {\n      if (defined(d)) {\n        min = Math.min(min, +d);\n        max = Math.max(max, +d);\n      }\n    }\n  }\n  if (min === Infinity) return [];\n  return zero ? [Math.min(0, min), max] : [min, max];\n}\n\nfunction inferDomainC(values: Primitive[][]) {\n  return Array.from(new Set(values.flat()));\n}\n\nfunction inferDomainO(values: Primitive[][]) {\n  return values.flat().sort();\n}\n\nfunction inferDomainS(values: Primitive[][]) {\n  let min = Infinity;\n  let max = -Infinity;\n  for (const value of values) {\n    for (const d of value) {\n      if (defined(d)) {\n        min = Math.min(min, +d);\n        max = Math.max(max, +d);\n      }\n    }\n  }\n  if (min === Infinity) return [];\n  return [min < 0 ? -max : min, max];\n}\n\n/**\n * @todo More nice default range for enterDelay and enterDuration.\n * @todo Move these to channel definition.\n */\nfunction inferRangeQ(name: string, palette: Palette): Primitive[] {\n  if (name === 'enterDelay') return [0, 1000];\n  if (name == 'enterDuration') return [300, 1000];\n  if (name.startsWith('y') || name.startsWith('position')) return [1, 0];\n  if (name === 'color') return [firstOf(palette), lastOf(palette)];\n  if (name === 'opacity') return [0, 1];\n  if (name === 'size') return [1, 10];\n  return [0, 1];\n}\n\nfunction isOrdinal(values: Primitive[][]): boolean {\n  return some(values, (d) => {\n    const type = typeof d;\n    return type === 'string' || type === 'boolean';\n  });\n}\n\nfunction isTemporal(values: Primitive[][]): boolean {\n  return some(values, (d) => d instanceof Date);\n}\n\nfunction isObject(values: Primitive[][]): boolean {\n  return some(values, isStrictObject);\n}\n\nfunction some(values, callback) {\n  for (const V of values) {\n    if (V.some(callback)) return true;\n  }\n  return false;\n}\n\nfunction isQuantitative(name: string): boolean {\n  return (\n    name.startsWith('x') ||\n    name.startsWith('y') ||\n    name.startsWith('position') ||\n    name.startsWith('size')\n  );\n}\n\n// Spatial and temporal position.\nexport function isPosition(name: string): boolean {\n  return (\n    name.startsWith('x') ||\n    name.startsWith('y') ||\n    name.startsWith('position') ||\n    name === 'enterDelay' ||\n    name === 'enterDuration' ||\n    name === 'updateDelay' ||\n    name === 'updateDuration' ||\n    name === 'exitDelay' ||\n    name === 'exitDuration'\n  );\n}\n\nexport function isValidScale(scale: G2ScaleOptions) {\n  if (!scale || !scale.type) return false;\n  if (typeof scale.type === 'function') return true;\n  const { type, domain, range, interpolator } = scale;\n  const isValidDomain = domain && domain.length > 0;\n  const isValidRange = range && range.length > 0;\n\n  if (\n    [\n      'linear',\n      'sqrt',\n      'log',\n      'time',\n      'pow',\n      'threshold',\n      'quantize',\n      'quantile',\n      'ordinal',\n      'band',\n      'point',\n    ].includes(type) &&\n    isValidDomain &&\n    isValidRange\n  ) {\n    return true;\n  }\n\n  if (\n    ['sequential'].includes(type) &&\n    isValidDomain &&\n    (isValidRange || interpolator)\n  ) {\n    return true;\n  }\n\n  if (['constant', 'identity'].includes(type) && isValidRange) return true;\n\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}