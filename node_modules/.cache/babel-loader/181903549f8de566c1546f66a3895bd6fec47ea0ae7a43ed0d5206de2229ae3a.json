{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isNumber } from '@antv/util';\nimport { Marker } from '@antv/component';\nimport { line } from '@antv/vendor/d3-shape';\nimport { createElement } from '../../utils/createElement';\nimport { applyStyle } from '../utils';\nimport { subObject } from '../../utils/helper';\nimport { select } from '../../utils/selection';\nimport { dist } from '../../utils/vector';\nfunction getConnectorPoint(shape) {\n  const {\n    min: [x0, y0],\n    max: [x1, y1]\n  } = shape.getLocalBounds();\n  let x = 0;\n  let y = 0;\n  if (x0 > 0) x = x0;\n  if (x1 < 0) x = x1;\n  if (y0 > 0) y = y0;\n  if (y1 < 0) y = y1;\n  return [x, y];\n}\nfunction inferBackgroundBounds(textShape, padding = []) {\n  const [top = 0, right = 0, bottom = top, left = right] = padding;\n  const container = textShape.parentNode;\n  const angle = container.getEulerAngles();\n  container.setEulerAngles(0);\n  const {\n    min,\n    halfExtents\n  } = textShape.getLocalBounds();\n  const [x, y] = min;\n  const [hw, hh] = halfExtents;\n  container.setEulerAngles(angle);\n  return {\n    x: x - left,\n    y: y - top,\n    width: hw * 2 + left + right,\n    height: hh * 2 + top + bottom\n  };\n}\nconst cos = (p0, p1, p2) => {\n  const a = dist(p0, p1);\n  const b = dist(p1, p2);\n  const c = dist(p2, p0);\n  return (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b);\n};\n// A path from element to label.\n// Adapted drawLabelLine from https://github.com/antvis/G2/blob/master/src/geometry/label/layout/pie/spider.ts\nfunction inferConnectorPath(shape, end, control, coordCenter, left = true, top = true) {\n  const path = points => line()(points);\n  if (!end[0] && !end[1]) return path([getConnectorPoint(shape), end]);\n  if (!control.length) return path([[0, 0], end]);\n  const [inflection, start] = control;\n  const p1 = [...start];\n  const p2 = [...inflection];\n  // Label has been adjusted, so add offset to the label.\n  if (start[0] !== inflection[0]) {\n    const offset = left ? -4 : 4;\n    p1[1] = start[1];\n    // For the label in the first quadrant.\n    if (top && !left) {\n      p1[0] = Math.max(inflection[0], start[0] - offset);\n      if (start[1] < inflection[1]) {\n        p2[1] = p1[1];\n      } else {\n        p2[1] = inflection[1];\n        p2[0] = Math.max(p2[0], p1[0] - offset);\n      }\n    }\n    // For the label in the second quadrant.\n    if (!top && !left) {\n      p1[0] = Math.max(inflection[0], start[0] - offset);\n      if (start[1] > inflection[1]) {\n        p2[1] = p1[1];\n      } else {\n        p2[1] = inflection[1];\n        p2[0] = Math.max(p2[0], p1[0] - offset);\n      }\n    }\n    // For the label in the third quadrant.\n    if (!top && left) {\n      p1[0] = Math.min(inflection[0], start[0] - offset);\n      if (start[1] > inflection[1]) {\n        p2[1] = p1[1];\n      } else {\n        p2[1] = inflection[1];\n        p2[0] = Math.min(p2[0], p1[0] - offset);\n      }\n    }\n    // For the label in the fourth quadrant.\n    if (top && left) {\n      p1[0] = Math.min(inflection[0], start[0] - offset);\n      if (start[1] < inflection[1]) {\n        p2[1] = p1[1];\n      } else {\n        p2[1] = inflection[1];\n        p2[0] = Math.min(p2[0], p1[0] - offset);\n      }\n    }\n  }\n  return path([start, p1, p2, inflection, end]);\n}\nexport const Advance = createElement(g => {\n  const _a = g.attributes,\n    {\n      className,\n      // Do not pass className\n      class: _c,\n      transform,\n      rotate,\n      labelTransform,\n      labelTransformOrigin,\n      x,\n      y,\n      x0 = x,\n      y0 = y,\n      text,\n      background,\n      connector,\n      startMarker,\n      endMarker,\n      coordCenter,\n      innerHTML\n    } = _a,\n    rest = __rest(_a, [\"className\", \"class\", \"transform\", \"rotate\", \"labelTransform\", \"labelTransformOrigin\", \"x\", \"y\", \"x0\", \"y0\", \"text\", \"background\", \"connector\", \"startMarker\", \"endMarker\", \"coordCenter\", \"innerHTML\"]);\n  g.style.transform = `translate(${x}, ${y})`;\n  // Position is invalid, do not render the UI,\n  // or clear previous elements.\n  if ([x, y, x0, y0].some(v => !isNumber(v))) {\n    g.children.forEach(d => d.remove());\n    return;\n  }\n  const _b = subObject(rest, 'background'),\n    {\n      padding\n    } = _b,\n    backgroundStyle = __rest(_b, [\"padding\"]);\n  const _d = subObject(rest, 'connector'),\n    {\n      points: controlPoints = []\n    } = _d,\n    connectorStyle = __rest(_d, [\"points\"]);\n  let textShape;\n  if (innerHTML) {\n    textShape = select(g).maybeAppend('html', 'html', className).style('zIndex', 0).style('innerHTML', innerHTML).call(applyStyle, Object.assign({\n      transform: labelTransform,\n      transformOrigin: labelTransformOrigin\n    }, rest)).node();\n  } else {\n    textShape = select(g).maybeAppend('text', 'text').style('zIndex', 0).style('text', text).call(applyStyle, Object.assign({\n      textBaseline: 'middle',\n      transform: labelTransform,\n      transformOrigin: labelTransformOrigin\n    }, rest)).node();\n  }\n  const rect = select(g).maybeAppend('background', 'rect').style('zIndex', -1).call(applyStyle, inferBackgroundBounds(textShape, padding)).call(applyStyle, background ? backgroundStyle : {}).node();\n  const left = +x0 < coordCenter[0];\n  const top = +y0 < coordCenter[1];\n  const end = [+x0 - +x, +y0 - +y];\n  const connectorPath = inferConnectorPath(rect, end, controlPoints, coordCenter, left, top);\n  const markerStart = startMarker && new Marker({\n    id: 'startMarker',\n    style: Object.assign({\n      x: 0,\n      y: 0\n    }, subObject(rest, 'startMarker'))\n  });\n  const markerEnd = endMarker && new Marker({\n    id: 'endMarker',\n    style: Object.assign({\n      x: 0,\n      y: 0\n    }, subObject(rest, 'endMarker'))\n  });\n  select(g).maybeAppend('connector', 'path').style('zIndex', 0).style('d', connectorPath).style('markerStart', markerStart).style('markerEnd', markerEnd).call(applyStyle, connector ? connectorStyle : {});\n});","map":{"version":3,"names":["isNumber","Marker","line","createElement","applyStyle","subObject","select","dist","getConnectorPoint","shape","min","x0","y0","max","x1","y1","getLocalBounds","x","y","inferBackgroundBounds","textShape","padding","top","right","bottom","left","container","parentNode","angle","getEulerAngles","setEulerAngles","halfExtents","hw","hh","width","height","cos","p0","p1","p2","a","b","c","Math","pow","inferConnectorPath","end","control","coordCenter","path","points","length","inflection","start","offset","Advance","g","_a","attributes","className","class","_c","transform","rotate","labelTransform","labelTransformOrigin","text","background","connector","startMarker","endMarker","innerHTML","rest","__rest","style","some","v","children","forEach","d","remove","_b","backgroundStyle","_d","controlPoints","connectorStyle","maybeAppend","call","Object","assign","transformOrigin","node","textBaseline","rect","connectorPath","markerStart","id","markerEnd"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/text/advance.ts"],"sourcesContent":["import { Vector2 } from '@antv/coord';\nimport {\n  DisplayObject,\n  Text as GText,\n  Rect,\n  TextStyleProps,\n  RectStyleProps,\n  PathStyleProps,\n} from '@antv/g';\nimport { isNumber } from '@antv/util';\nimport { Marker } from '@antv/component';\nimport { line } from '@antv/vendor/d3-shape';\nimport { WithPrefix } from '../../runtime';\nimport { createElement } from '../../utils/createElement';\nimport { applyStyle } from '../utils';\nimport { subObject } from '../../utils/helper';\nimport { select } from '../../utils/selection';\nimport { dist } from '../../utils/vector';\n\ntype BackgroundStyleProps = WithPrefix<\n  RectStyleProps & { padding?: number[]; radius?: number },\n  'background'\n>;\n\ntype ConnectorStyleProps = WithPrefix<\n  PathStyleProps & { points?: Vector2[] },\n  'connector'\n>;\n\ntype MarkerStyleProps<P extends string> = WithPrefix<Record<string, any>, P>;\n\ntype TextShapeStyleProps = Omit<TextStyleProps, 'text'> &\n  ConnectorStyleProps &\n  BackgroundStyleProps &\n  MarkerStyleProps<'startMarker'> &\n  MarkerStyleProps<'endMarker'> & {\n    id: string;\n    className?: string;\n    x0?: number; // x0 represents the x position of relative point, default is equal to x\n    y0?: number;\n    coordCenter?: Vector2; // center of coordinate\n    background?: boolean;\n    connector?: boolean;\n    startMarker?: boolean;\n    endMarker?: boolean;\n    labelTransform?: string;\n    labelTransformOrigin?: string;\n    rotate?: number;\n    innerHTML?: string | HTMLElement;\n    text?: string;\n  };\n\nfunction getConnectorPoint(shape: GText | Rect): [number, number] {\n  const {\n    min: [x0, y0],\n    max: [x1, y1],\n  } = shape.getLocalBounds();\n  let x = 0;\n  let y = 0;\n  if (x0 > 0) x = x0;\n  if (x1 < 0) x = x1;\n  if (y0 > 0) y = y0;\n  if (y1 < 0) y = y1;\n  return [x, y];\n}\n\nfunction inferBackgroundBounds(textShape: DisplayObject, padding = []) {\n  const [top = 0, right = 0, bottom = top, left = right] = padding;\n  const container = textShape.parentNode as DisplayObject;\n\n  const angle = container.getEulerAngles();\n  container.setEulerAngles(0);\n  const { min, halfExtents } = textShape.getLocalBounds();\n  const [x, y] = min;\n  const [hw, hh] = halfExtents;\n  container.setEulerAngles(angle);\n\n  return {\n    x: x - left,\n    y: y - top,\n    width: hw * 2 + left + right,\n    height: hh * 2 + top + bottom,\n  };\n}\n\nconst cos = (p0: Vector2, p1: Vector2, p2: Vector2) => {\n  const a = dist(p0, p1);\n  const b = dist(p1, p2);\n  const c = dist(p2, p0);\n  return (a ** 2 + b ** 2 - c ** 2) / (2 * a * b);\n};\n\n// A path from element to label.\n// Adapted drawLabelLine from https://github.com/antvis/G2/blob/master/src/geometry/label/layout/pie/spider.ts\nfunction inferConnectorPath(\n  shape: DisplayObject,\n  end: Vector2,\n  control: Vector2[],\n  coordCenter: Vector2,\n  left = true,\n  top = true,\n) {\n  const path = (points) => line()(points);\n\n  if (!end[0] && !end[1]) return path([getConnectorPoint(shape), end]);\n  if (!control.length) return path([[0, 0], end]);\n\n  const [inflection, start] = control;\n  const p1 = [...start];\n  const p2 = [...inflection];\n\n  // Label has been adjusted, so add offset to the label.\n  if (start[0] !== inflection[0]) {\n    const offset = left ? -4 : 4;\n    p1[1] = start[1];\n\n    // For the label in the first quadrant.\n    if (top && !left) {\n      p1[0] = Math.max(inflection[0], start[0] - offset);\n      if (start[1] < inflection[1]) {\n        p2[1] = p1[1];\n      } else {\n        p2[1] = inflection[1];\n        p2[0] = Math.max(p2[0], p1[0] - offset);\n      }\n    }\n\n    // For the label in the second quadrant.\n    if (!top && !left) {\n      p1[0] = Math.max(inflection[0], start[0] - offset);\n      if (start[1] > inflection[1]) {\n        p2[1] = p1[1];\n      } else {\n        p2[1] = inflection[1];\n        p2[0] = Math.max(p2[0], p1[0] - offset);\n      }\n    }\n\n    // For the label in the third quadrant.\n    if (!top && left) {\n      p1[0] = Math.min(inflection[0], start[0] - offset);\n      if (start[1] > inflection[1]) {\n        p2[1] = p1[1];\n      } else {\n        p2[1] = inflection[1];\n        p2[0] = Math.min(p2[0], p1[0] - offset);\n      }\n    }\n\n    // For the label in the fourth quadrant.\n    if (top && left) {\n      p1[0] = Math.min(inflection[0], start[0] - offset);\n      if (start[1] < inflection[1]) {\n        p2[1] = p1[1];\n      } else {\n        p2[1] = inflection[1];\n        p2[0] = Math.min(p2[0], p1[0] - offset);\n      }\n    }\n  }\n\n  return path([start, p1, p2, inflection, end]);\n}\n\nexport const Advance = createElement((g) => {\n  const {\n    className,\n    // Do not pass className\n    class: _c,\n    transform,\n    rotate,\n    labelTransform,\n    labelTransformOrigin,\n    x,\n    y,\n    x0 = x,\n    y0 = y,\n    text,\n    background,\n    connector,\n    startMarker,\n    endMarker,\n    coordCenter,\n    innerHTML,\n    ...rest\n  } = g.attributes as TextShapeStyleProps;\n\n  g.style.transform = `translate(${x}, ${y})`;\n\n  // Position is invalid, do not render the UI,\n  // or clear previous elements.\n  if ([x, y, x0, y0].some((v) => !isNumber(v))) {\n    g.children.forEach((d) => d.remove());\n    return;\n  }\n\n  const { padding, ...backgroundStyle } = subObject(rest, 'background');\n  const { points: controlPoints = [], ...connectorStyle } = subObject(\n    rest,\n    'connector',\n  );\n\n  let textShape;\n  if (innerHTML) {\n    textShape = select(g)\n      .maybeAppend('html', 'html', className)\n      .style('zIndex', 0)\n      .style('innerHTML', innerHTML)\n      .call(applyStyle, {\n        transform: labelTransform,\n        transformOrigin: labelTransformOrigin,\n        ...rest,\n      })\n      .node();\n  } else {\n    textShape = select(g)\n      .maybeAppend('text', 'text')\n      .style('zIndex', 0)\n      .style('text', text)\n      .call(applyStyle, {\n        textBaseline: 'middle',\n        transform: labelTransform,\n        transformOrigin: labelTransformOrigin,\n        ...rest,\n      })\n      .node();\n  }\n\n  const rect = select(g)\n    .maybeAppend('background', 'rect')\n    .style('zIndex', -1)\n    .call(applyStyle, inferBackgroundBounds(textShape, padding))\n    .call(applyStyle, background ? backgroundStyle : {})\n    .node();\n\n  const left = +x0 < coordCenter[0];\n  const top = +y0 < coordCenter[1];\n  const end: [number, number] = [+x0 - +x, +y0 - +y];\n  const connectorPath = inferConnectorPath(\n    rect,\n    end,\n    controlPoints,\n    coordCenter,\n    left,\n    top,\n  );\n\n  const markerStart =\n    startMarker &&\n    new Marker({\n      id: 'startMarker',\n      style: { x: 0, y: 0, ...(subObject(rest, 'startMarker') as any) },\n    });\n  const markerEnd =\n    endMarker &&\n    new Marker({\n      id: 'endMarker',\n      style: { x: 0, y: 0, ...(subObject(rest, 'endMarker') as any) },\n    });\n  select(g)\n    .maybeAppend('connector', 'path')\n    .style('zIndex', 0)\n    .style('d', connectorPath)\n    .style('markerStart', markerStart)\n    .style('markerEnd', markerEnd)\n    .call(applyStyle, connector ? connectorStyle : {});\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}