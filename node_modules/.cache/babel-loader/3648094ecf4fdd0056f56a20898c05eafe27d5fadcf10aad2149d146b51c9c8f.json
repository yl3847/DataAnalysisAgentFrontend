{"ast":null,"code":"import { ElementEvent, Image as GImage, Rect as GRect } from '@antv/g';\nimport { getAncestorShapes } from '../../utils/shape';\nexport class Image extends GImage {\n  constructor(options) {\n    super(options);\n    this.onMounted = () => {\n      this.handleRadius();\n    };\n    this.onAttrModified = () => {\n      this.handleRadius();\n    };\n    current = this;\n    this.isMutationObserved = true;\n    this.addEventListener(ElementEvent.MOUNTED, this.onMounted);\n    this.addEventListener(ElementEvent.ATTR_MODIFIED, this.onAttrModified);\n  }\n  handleRadius() {\n    const {\n      radius,\n      clipPath,\n      width = 0,\n      height = 0\n    } = this.attributes;\n    if (radius && width && height) {\n      const [x, y] = this.getBounds().min;\n      const clipPathStyle = {\n        x,\n        y,\n        radius,\n        width,\n        height\n      };\n      if (clipPath) {\n        Object.assign(this.parsedStyle.clipPath.style, clipPathStyle);\n      } else {\n        const rect = new GRect({\n          style: clipPathStyle\n        });\n        this.style.clipPath = rect;\n      }\n    } else {\n      if (clipPath) this.style.clipPath = null;\n    }\n  }\n}\nconst ImagesWeakMap = new WeakMap();\nlet current = null;\n/**\n * <zh/> 由于 g clipPath 不支持相对位置，因此当作用的元素发生位置变化时，需要通知 Image 更新 clipPath。\n *\n * 通过 connectImage 创建图形与图片的关联，并结合 dispatchPositionChange 方法触发更新\n *\n * ⚠️ 这是一种临时的、黑盒的解决方案，如果后续 g 支持相对位置，会移除该方法。\n *\n * <en/> Since g clipPath does not support relative positions, when the position of the affected element changes, the Image needs to be notified to update the clipPath.\n *\n * Use connectImage to create an association between the shape and the image, and combine it with the dispatchPositionChange method to trigger the update.\n *\n * ⚠️ This is a temporary, black-box solution, and if g supports relative positions in the future, this method will be removed.\n * @param target - <zh/> 目标元素 <en/> Target element\n */\nexport const connectImage = target => {\n  if (current && getAncestorShapes(current).includes(target)) {\n    const images = ImagesWeakMap.get(target);\n    if (images) {\n      if (!images.includes(current)) images.push(current);\n    } else ImagesWeakMap.set(target, [current]);\n  }\n};\n/**\n * <zh/> 触发关联的图片更新位置\n *\n * <en/> Trigger the associated image to update its position\n * @param target - <zh/> 目标元素 <en/> Target element\n */\nexport const dispatchPositionChange = target => {\n  const image = ImagesWeakMap.get(target);\n  if (image) {\n    image.forEach(i => i.handleRadius());\n  }\n};","map":{"version":3,"names":["ElementEvent","Image","GImage","Rect","GRect","getAncestorShapes","constructor","options","onMounted","handleRadius","onAttrModified","current","isMutationObserved","addEventListener","MOUNTED","ATTR_MODIFIED","radius","clipPath","width","height","attributes","x","y","getBounds","min","clipPathStyle","Object","assign","parsedStyle","style","rect","ImagesWeakMap","WeakMap","connectImage","target","includes","images","get","push","set","dispatchPositionChange","image","forEach","i"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/elements/shapes/image.ts"],"sourcesContent":["import type { DisplayObject, DisplayObjectConfig, ImageStyleProps as GImageStyleProps } from '@antv/g';\nimport { ElementEvent, Image as GImage, Rect as GRect } from '@antv/g';\nimport { getAncestorShapes } from '../../utils/shape';\n\nexport interface ImageStyleProps extends GImageStyleProps {\n  /**\n   * <zh/> 圆角半径\n   *\n   * <en/> Radius of the rounded corner\n   */\n  radius?: number | number[];\n}\n\nexport class Image extends GImage {\n  constructor(options: DisplayObjectConfig<ImageStyleProps>) {\n    super(options);\n    current = this;\n    this.isMutationObserved = true;\n    this.addEventListener(ElementEvent.MOUNTED, this.onMounted);\n    this.addEventListener(ElementEvent.ATTR_MODIFIED, this.onAttrModified);\n  }\n\n  private onMounted = () => {\n    this.handleRadius();\n  };\n\n  private onAttrModified = () => {\n    this.handleRadius();\n  };\n\n  public handleRadius() {\n    const { radius, clipPath, width = 0, height = 0 } = this.attributes as ImageStyleProps;\n\n    if (radius && width && height) {\n      const [x, y] = this.getBounds().min;\n      const clipPathStyle = { x, y, radius, width, height };\n\n      if (clipPath) {\n        Object.assign(this.parsedStyle.clipPath!.style, clipPathStyle);\n      } else {\n        const rect = new GRect({ style: clipPathStyle });\n        this.style.clipPath = rect;\n      }\n    } else {\n      if (clipPath) this.style.clipPath = null;\n    }\n  }\n}\n\nconst ImagesWeakMap = new WeakMap<DisplayObject, Image[]>();\n\nlet current: Image | null = null;\n\n/**\n * <zh/> 由于 g clipPath 不支持相对位置，因此当作用的元素发生位置变化时，需要通知 Image 更新 clipPath。\n *\n * 通过 connectImage 创建图形与图片的关联，并结合 dispatchPositionChange 方法触发更新\n *\n * ⚠️ 这是一种临时的、黑盒的解决方案，如果后续 g 支持相对位置，会移除该方法。\n *\n * <en/> Since g clipPath does not support relative positions, when the position of the affected element changes, the Image needs to be notified to update the clipPath.\n *\n * Use connectImage to create an association between the shape and the image, and combine it with the dispatchPositionChange method to trigger the update.\n *\n * ⚠️ This is a temporary, black-box solution, and if g supports relative positions in the future, this method will be removed.\n * @param target - <zh/> 目标元素 <en/> Target element\n */\nexport const connectImage = (target: DisplayObject) => {\n  if (current && getAncestorShapes(current).includes(target)) {\n    const images = ImagesWeakMap.get(target);\n    if (images) {\n      if (!images.includes(current)) images.push(current);\n    } else ImagesWeakMap.set(target, [current]);\n  }\n};\n\n/**\n * <zh/> 触发关联的图片更新位置\n *\n * <en/> Trigger the associated image to update its position\n * @param target - <zh/> 目标元素 <en/> Target element\n */\nexport const dispatchPositionChange = (target: DisplayObject) => {\n  const image = ImagesWeakMap.get(target);\n  if (image) {\n    image.forEach((i) => i.handleRadius());\n  }\n};\n"],"mappings":"AACA,SAASA,YAAY,EAAEC,KAAK,IAAIC,MAAM,EAAEC,IAAI,IAAIC,KAAK,QAAQ,SAAS;AACtE,SAASC,iBAAiB,QAAQ,mBAAmB;AAWrD,OAAM,MAAOJ,KAAM,SAAQC,MAAM;EAC/BI,YAAYC,OAA6C;IACvD,KAAK,CAACA,OAAO,CAAC;IAOR,KAAAC,SAAS,GAAG,MAAK;MACvB,IAAI,CAACC,YAAY,EAAE;IACrB,CAAC;IAEO,KAAAC,cAAc,GAAG,MAAK;MAC5B,IAAI,CAACD,YAAY,EAAE;IACrB,CAAC;IAZCE,OAAO,GAAG,IAAI;IACd,IAAI,CAACC,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACC,gBAAgB,CAACb,YAAY,CAACc,OAAO,EAAE,IAAI,CAACN,SAAS,CAAC;IAC3D,IAAI,CAACK,gBAAgB,CAACb,YAAY,CAACe,aAAa,EAAE,IAAI,CAACL,cAAc,CAAC;EACxE;EAUOD,YAAYA,CAAA;IACjB,MAAM;MAAEO,MAAM;MAAEC,QAAQ;MAAEC,KAAK,GAAG,CAAC;MAAEC,MAAM,GAAG;IAAC,CAAE,GAAG,IAAI,CAACC,UAA6B;IAEtF,IAAIJ,MAAM,IAAIE,KAAK,IAAIC,MAAM,EAAE;MAC7B,MAAM,CAACE,CAAC,EAAEC,CAAC,CAAC,GAAG,IAAI,CAACC,SAAS,EAAE,CAACC,GAAG;MACnC,MAAMC,aAAa,GAAG;QAAEJ,CAAC;QAAEC,CAAC;QAAEN,MAAM;QAAEE,KAAK;QAAEC;MAAM,CAAE;MAErD,IAAIF,QAAQ,EAAE;QACZS,MAAM,CAACC,MAAM,CAAC,IAAI,CAACC,WAAW,CAACX,QAAS,CAACY,KAAK,EAAEJ,aAAa,CAAC;MAChE,CAAC,MAAM;QACL,MAAMK,IAAI,GAAG,IAAI1B,KAAK,CAAC;UAAEyB,KAAK,EAAEJ;QAAa,CAAE,CAAC;QAChD,IAAI,CAACI,KAAK,CAACZ,QAAQ,GAAGa,IAAI;MAC5B;IACF,CAAC,MAAM;MACL,IAAIb,QAAQ,EAAE,IAAI,CAACY,KAAK,CAACZ,QAAQ,GAAG,IAAI;IAC1C;EACF;;AAGF,MAAMc,aAAa,GAAG,IAAIC,OAAO,EAA0B;AAE3D,IAAIrB,OAAO,GAAiB,IAAI;AAEhC;;;;;;;;;;;;;;AAcA,OAAO,MAAMsB,YAAY,GAAIC,MAAqB,IAAI;EACpD,IAAIvB,OAAO,IAAIN,iBAAiB,CAACM,OAAO,CAAC,CAACwB,QAAQ,CAACD,MAAM,CAAC,EAAE;IAC1D,MAAME,MAAM,GAAGL,aAAa,CAACM,GAAG,CAACH,MAAM,CAAC;IACxC,IAAIE,MAAM,EAAE;MACV,IAAI,CAACA,MAAM,CAACD,QAAQ,CAACxB,OAAO,CAAC,EAAEyB,MAAM,CAACE,IAAI,CAAC3B,OAAO,CAAC;IACrD,CAAC,MAAMoB,aAAa,CAACQ,GAAG,CAACL,MAAM,EAAE,CAACvB,OAAO,CAAC,CAAC;EAC7C;AACF,CAAC;AAED;;;;;;AAMA,OAAO,MAAM6B,sBAAsB,GAAIN,MAAqB,IAAI;EAC9D,MAAMO,KAAK,GAAGV,aAAa,CAACM,GAAG,CAACH,MAAM,CAAC;EACvC,IAAIO,KAAK,EAAE;IACTA,KAAK,CAACC,OAAO,CAAEC,CAAC,IAAKA,CAAC,CAAClC,YAAY,EAAE,CAAC;EACxC;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}