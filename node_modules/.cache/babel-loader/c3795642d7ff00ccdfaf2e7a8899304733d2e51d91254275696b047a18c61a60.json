{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { parseColor } from '@antv/g';\nimport { Continuous } from '@antv/component';\nimport { Constant, Quantile, Quantize, Threshold } from '@antv/scale';\nimport { format } from '@antv/vendor/d3-format';\nimport { lastOf } from '../utils/array';\nimport { G2Layout, adaptor, inferComponentLayout, inferComponentShape, isHorizontal, scaleOf, titleContent } from './utils';\nfunction updateShapeDimensions(shape, finalSize, orientation) {\n  shape.size = finalSize;\n  if (isHorizontal(orientation)) {\n    shape.height = finalSize;\n  } else {\n    shape.width = finalSize;\n  }\n  return shape;\n}\nfunction inferContinuousShape(value, options, component) {\n  const {\n    size\n  } = options;\n  const shape = inferComponentShape(value, options, component);\n  return updateShapeDimensions(shape, size, shape.orientation);\n}\nfunction getFormatter(max) {\n  return value => ({\n    value: value / max,\n    label: String(value)\n  });\n}\nfunction getQuantizeOrQuantileConfig(shape, colorScale, min, max, range) {\n  const thresholds = colorScale.thresholds;\n  const formatter = getFormatter(max);\n  return Object.assign(Object.assign({}, shape), {\n    color: range,\n    data: [min, ...thresholds, max].map(formatter)\n  });\n}\nfunction getThresholdConfig(shape, colorScale, range) {\n  const thresholds = colorScale.thresholds;\n  const data = [-Infinity, ...thresholds, Infinity].map((value, index) => ({\n    value: index,\n    label: value\n  }));\n  return Object.assign(Object.assign({}, shape), {\n    data,\n    color: range,\n    labelFilter: (datum, index) => {\n      return index > 0 && index < data.length - 1;\n    }\n  });\n}\nfunction rangeOf(scale) {\n  const {\n    domain\n  } = scale.getOptions();\n  const [min, max] = [domain[0], lastOf(domain)];\n  return [min, max];\n}\n/**\n * if color scale is not defined, create a constant color scale based on default color\n * @param scale\n * @param theme\n */\nfunction createColorScale(scale, defaultColor) {\n  const options = scale.getOptions();\n  const newScale = scale.clone();\n  newScale.update(Object.assign(Object.assign({}, options), {\n    range: [parseColor(defaultColor).toString()]\n  }));\n  return newScale;\n}\nfunction getLinearConfig(shape, colorScale, sizeScale, opacityScale, scales, theme) {\n  const {\n    length\n  } = shape;\n  const definedScale = sizeScale || opacityScale;\n  // Only use defaultColor when there is no color scale\n  // in this view.\n  const defaultColor = scales.color ? theme.legendContinuous.ribbonFill || 'black' : theme.color;\n  const scale = colorScale || createColorScale(definedScale, defaultColor);\n  const [min, max] = rangeOf(scale);\n  const [domainMin, domainMax] = rangeOf([colorScale, sizeScale, opacityScale].filter(d => d !== undefined).find(d => !(d instanceof Constant)));\n  return Object.assign(Object.assign({}, shape), {\n    domain: [domainMin, domainMax],\n    data: scale.getTicks().map(value => ({\n      value\n    })),\n    color: new Array(Math.floor(length)).fill(0).map((d, i) => {\n      const value = (max - min) / (length - 1) * i + min;\n      const color = scale.map(value) || defaultColor;\n      const opacity = opacityScale ? opacityScale.map(value) : 1;\n      return color.replace(/rgb[a]*\\(([\\d]{1,3}) *, *([\\d]{1,3}) *, *([\\d]{1,3})[\\S\\s]*\\)/, (match, p1, p2, p3) => `rgba(${p1}, ${p2}, ${p3}, ${opacity})`);\n    })\n  });\n}\nfunction inferContinuousConfig(scales, scale, value, options, component, theme) {\n  const colorScale = scaleOf(scales, 'color');\n  const shape = inferContinuousShape(value, options, component);\n  if (colorScale instanceof Threshold) {\n    const {\n      range\n    } = colorScale.getOptions();\n    const [min, max] = rangeOf(colorScale);\n    // for quantize, quantile scale\n    if (colorScale instanceof Quantize || colorScale instanceof Quantile) {\n      return getQuantizeOrQuantileConfig(shape, colorScale, min, max, range);\n    }\n    // for threshold\n    return getThresholdConfig(shape, colorScale, range);\n  }\n  // for linear, pow, sqrt, log, time, utc scale\n  const sizeScale = scaleOf(scales, 'size');\n  const opacityScale = scaleOf(scales, 'opacity');\n  return getLinearConfig(shape, colorScale, sizeScale, opacityScale, scale, theme);\n}\n/**\n * Guide Component for continuous color scale.\n * @todo Custom style.\n */\nexport const LegendContinuous = options => {\n  const {\n      labelFormatter,\n      layout,\n      order,\n      orientation,\n      position,\n      size,\n      title,\n      style,\n      crossPadding,\n      padding\n    } = options,\n    rest = __rest(options, [\"labelFormatter\", \"layout\", \"order\", \"orientation\", \"position\", \"size\", \"title\", \"style\", \"crossPadding\", \"padding\"]);\n  return ({\n    scales,\n    value,\n    theme,\n    scale\n  }) => {\n    const {\n      bbox\n    } = value;\n    const {\n      x,\n      y,\n      width,\n      height\n    } = bbox;\n    const finalLayout = inferComponentLayout(position, layout);\n    const {\n      legendContinuous: legendTheme = {}\n    } = theme;\n    const finalStyle = adaptor(Object.assign({}, legendTheme, Object.assign(Object.assign({\n      titleText: titleContent(title),\n      labelAlign: 'value',\n      labelFormatter: typeof labelFormatter === 'string' ? d => format(labelFormatter)(d.label) : labelFormatter\n    }, inferContinuousConfig(scales, scale, value, options, LegendContinuous, theme)), style), rest));\n    const layoutWrapper = new G2Layout({\n      style: Object.assign(Object.assign({\n        x,\n        y,\n        width,\n        height\n      }, finalLayout), {\n        // @ts-ignore\n        subOptions: finalStyle\n      })\n    });\n    layoutWrapper.appendChild(new Continuous({\n      className: 'legend-continuous',\n      style: finalStyle\n    }));\n    return layoutWrapper;\n  };\n};\nLegendContinuous.props = {\n  defaultPosition: 'top',\n  defaultOrientation: 'vertical',\n  defaultOrder: 1,\n  defaultSize: 60,\n  defaultLength: 200,\n  defaultLegendSize: 60,\n  defaultPadding: [20, 10],\n  defaultCrossPadding: [12, 12] // [horizontal, vertical]\n};","map":{"version":3,"names":["parseColor","Continuous","Constant","Quantile","Quantize","Threshold","format","lastOf","G2Layout","adaptor","inferComponentLayout","inferComponentShape","isHorizontal","scaleOf","titleContent","updateShapeDimensions","shape","finalSize","orientation","size","height","width","inferContinuousShape","value","options","component","getFormatter","max","label","String","getQuantizeOrQuantileConfig","colorScale","min","range","thresholds","formatter","Object","assign","color","data","map","getThresholdConfig","Infinity","index","labelFilter","datum","length","rangeOf","scale","domain","getOptions","createColorScale","defaultColor","newScale","clone","update","toString","getLinearConfig","sizeScale","opacityScale","scales","theme","definedScale","legendContinuous","ribbonFill","domainMin","domainMax","filter","d","undefined","find","getTicks","Array","Math","floor","fill","i","opacity","replace","match","p1","p2","p3","inferContinuousConfig","LegendContinuous","labelFormatter","layout","order","position","title","style","crossPadding","padding","rest","__rest","bbox","x","y","finalLayout","legendTheme","finalStyle","titleText","labelAlign","layoutWrapper","subOptions","appendChild","className","props","defaultPosition","defaultOrientation","defaultOrder","defaultSize","defaultLength","defaultLegendSize","defaultPadding","defaultCrossPadding"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/component/legendContinuous.ts"],"sourcesContent":["import { DisplayObject, parseColor } from '@antv/g';\nimport { Continuous } from '@antv/component';\nimport { Constant, Quantile, Quantize, Threshold } from '@antv/scale';\nimport { format } from '@antv/vendor/d3-format';\nimport type {\n  FlexLayout,\n  G2Theme,\n  GuideComponentComponent as GCC,\n  GuideComponentOrientation as GCO,\n  GuideComponentPosition as GCP,\n  Scale,\n} from '../runtime';\nimport { lastOf } from '../utils/array';\nimport {\n  G2Layout,\n  adaptor,\n  inferComponentLayout,\n  inferComponentShape,\n  isHorizontal,\n  scaleOf,\n  titleContent,\n} from './utils';\n\nexport type LegendContinuousOptions = {\n  layout?: FlexLayout;\n  position?: GCP;\n  title?: string | string[];\n  [key: string]: any;\n};\n\ntype Shape = {\n  orientation: string;\n  width: number;\n  height: number;\n  length: number;\n  size: number;\n};\n\ntype Config = {\n  orientation: string;\n  width: number;\n  height: number;\n  color: string[];\n  data: any[];\n  labelFilter?: (datum: any, index: number) => boolean;\n  domain?: [number, number];\n};\n\nfunction updateShapeDimensions(\n  shape: Shape,\n  finalSize: number,\n  orientation: Exclude<GCO, number>,\n): Shape {\n  shape.size = finalSize;\n  if (isHorizontal(orientation)) {\n    shape.height = finalSize;\n  } else {\n    shape.width = finalSize;\n  }\n  return shape;\n}\n\nfunction inferContinuousShape(\n  value: Record<string, any>,\n  options: LegendContinuousOptions,\n  component: GCC,\n): Shape {\n  const { size } = options;\n  const shape = inferComponentShape(value, options, component);\n  return updateShapeDimensions(shape, size, shape.orientation);\n}\n\nfunction getFormatter(max: number) {\n  return (value: number) => ({\n    value: value / max,\n    label: String(value),\n  });\n}\n\nfunction getQuantizeOrQuantileConfig(\n  shape: Shape,\n  colorScale: Threshold,\n  min: number,\n  max: number,\n  range: string[],\n): Config {\n  const thresholds = (colorScale as any).thresholds as number[];\n  const formatter = getFormatter(max);\n  return {\n    ...shape,\n    color: range,\n    data: [min, ...thresholds, max].map(formatter),\n  };\n}\n\nfunction getThresholdConfig(\n  shape: Shape,\n  colorScale: Threshold,\n  range: string[],\n): Config {\n  const thresholds = (colorScale as any).thresholds as number[];\n  const data = [-Infinity, ...thresholds, Infinity].map((value, index) => ({\n    value: index,\n    label: value,\n  }));\n  return {\n    ...shape,\n    data,\n    color: range,\n    labelFilter: (datum, index) => {\n      return index > 0 && index < data.length - 1;\n    },\n  };\n}\n\nfunction rangeOf(scale: Scale) {\n  const { domain } = scale.getOptions();\n  const [min, max] = [domain[0], lastOf(domain)];\n  return [min, max];\n}\n\n/**\n * if color scale is not defined, create a constant color scale based on default color\n * @param scale\n * @param theme\n */\nfunction createColorScale(scale: Scale, defaultColor: string): Scale {\n  const options = scale.getOptions();\n  const newScale = scale.clone();\n  newScale.update({ ...options, range: [parseColor(defaultColor).toString()] });\n  return newScale;\n}\n\nfunction getLinearConfig(\n  shape: Shape,\n  colorScale: Scale,\n  sizeScale: Scale,\n  opacityScale: Scale,\n  scales: Record<string, any>,\n  theme: G2Theme,\n): Config {\n  const { length } = shape;\n  const definedScale = sizeScale || opacityScale;\n\n  // Only use defaultColor when there is no color scale\n  // in this view.\n  const defaultColor = scales.color\n    ? theme.legendContinuous.ribbonFill || 'black'\n    : theme.color;\n\n  const scale = colorScale || createColorScale(definedScale, defaultColor);\n  const [min, max] = rangeOf(scale);\n  const [domainMin, domainMax] = rangeOf(\n    [colorScale, sizeScale, opacityScale]\n      .filter((d) => d !== undefined)\n      .find((d) => !(d instanceof Constant)),\n  );\n  return {\n    ...shape,\n    domain: [domainMin, domainMax],\n    data: scale.getTicks().map((value) => ({ value })),\n    color: new Array(Math.floor(length)).fill(0).map((d, i) => {\n      const value = ((max - min) / (length - 1)) * i + min;\n      const color = scale.map(value) || defaultColor;\n      const opacity = opacityScale ? opacityScale.map(value) : 1;\n      return color.replace(\n        /rgb[a]*\\(([\\d]{1,3}) *, *([\\d]{1,3}) *, *([\\d]{1,3})[\\S\\s]*\\)/,\n        (match, p1, p2, p3) => `rgba(${p1}, ${p2}, ${p3}, ${opacity})`,\n      );\n    }),\n  };\n}\n\nfunction inferContinuousConfig(\n  scales: Scale[],\n  scale: Record<string, Scale>,\n  value: Record<string, any>,\n  options: LegendContinuousOptions,\n  component: GCC,\n  theme: G2Theme,\n): Config {\n  const colorScale = scaleOf(scales, 'color');\n  const shape = inferContinuousShape(value, options, component);\n\n  if (colorScale instanceof Threshold) {\n    const { range } = colorScale.getOptions();\n    const [min, max] = rangeOf(colorScale);\n    // for quantize, quantile scale\n    if (colorScale instanceof Quantize || colorScale instanceof Quantile) {\n      return getQuantizeOrQuantileConfig(shape, colorScale, min, max, range);\n    }\n    // for threshold\n    return getThresholdConfig(shape, colorScale, range);\n  }\n\n  // for linear, pow, sqrt, log, time, utc scale\n  const sizeScale = scaleOf(scales, 'size');\n  const opacityScale = scaleOf(scales, 'opacity');\n  return getLinearConfig(\n    shape,\n    colorScale,\n    sizeScale,\n    opacityScale,\n    scale,\n    theme,\n  );\n}\n\n/**\n * Guide Component for continuous color scale.\n * @todo Custom style.\n */\nexport const LegendContinuous: GCC<LegendContinuousOptions> = (options) => {\n  const {\n    labelFormatter,\n    layout,\n    order,\n    orientation,\n    position,\n    size,\n    title,\n    style,\n    crossPadding,\n    padding,\n    ...rest\n  } = options;\n\n  return ({ scales, value, theme, scale }) => {\n    const { bbox } = value;\n    const { x, y, width, height } = bbox;\n    const finalLayout = inferComponentLayout(position, layout);\n\n    const { legendContinuous: legendTheme = {} } = theme;\n\n    const finalStyle = adaptor(\n      Object.assign(\n        {},\n        legendTheme,\n        {\n          titleText: titleContent(title),\n          labelAlign: 'value',\n          labelFormatter:\n            typeof labelFormatter === 'string'\n              ? (d) => format(labelFormatter)(d.label)\n              : labelFormatter,\n          ...inferContinuousConfig(\n            scales,\n            scale,\n            value,\n            options,\n            LegendContinuous,\n            theme,\n          ),\n          ...style,\n        },\n        rest,\n      ),\n    );\n\n    const layoutWrapper = new G2Layout({\n      style: {\n        x,\n        y,\n        width,\n        height,\n        ...finalLayout,\n        // @ts-ignore\n        subOptions: finalStyle,\n      },\n    });\n\n    layoutWrapper.appendChild(\n      new Continuous({\n        className: 'legend-continuous',\n        style: finalStyle,\n      }),\n    );\n\n    return layoutWrapper as unknown as DisplayObject;\n  };\n};\n\nLegendContinuous.props = {\n  defaultPosition: 'top',\n  defaultOrientation: 'vertical',\n  defaultOrder: 1,\n  defaultSize: 60,\n  defaultLength: 200,\n  defaultLegendSize: 60,\n  defaultPadding: [20, 10], // [horizontal, vertical]\n  defaultCrossPadding: [12, 12], // [horizontal, vertical]\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}