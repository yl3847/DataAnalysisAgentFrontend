{"ast":null,"code":"import { ascending, group, max, min, sum } from '@antv/vendor/d3-array';\nimport { deepMix } from '@antv/util';\nimport { isParallel, isPolar, isRadar, radiusOf } from '../utils/coordinate';\nimport { capitalizeFirst, defined } from '../utils/helper';\nimport { divide } from '../utils/array';\nimport { camelCase } from '../utils/string';\nimport { computeComponentSize, computeLabelsBBox, computeTitleBBox, createScale, groupComponents, styleOf } from './component';\nimport { isPolar as isPolarOptions, isRadial as isRadarOptions } from './coordinate';\nexport function processAxisZ(components) {\n  const axisX = components.find(({\n    type\n  }) => type === 'axisX');\n  const axisY = components.find(({\n    type\n  }) => type === 'axisY');\n  const axisZ = components.find(({\n    type\n  }) => type === 'axisZ');\n  if (axisX && axisY && axisZ) {\n    axisX.plane = 'xy';\n    axisY.plane = 'xy';\n    axisZ.plane = 'yz';\n    axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];\n    axisZ.eulerAngles = [0, -90, 0];\n    axisZ.bbox.x = axisX.bbox.x;\n    axisZ.bbox.y = axisX.bbox.y;\n    components.push(Object.assign(Object.assign({}, axisX), {\n      plane: 'xz',\n      showLabel: false,\n      showTitle: false,\n      origin: [axisX.bbox.x, axisX.bbox.y, 0],\n      eulerAngles: [-90, 0, 0]\n    }));\n    components.push(Object.assign(Object.assign({}, axisY), {\n      plane: 'yz',\n      showLabel: false,\n      showTitle: false,\n      origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0],\n      eulerAngles: [0, -90, 0]\n    }));\n    components.push(Object.assign(Object.assign({}, axisZ), {\n      plane: 'xz',\n      actualPosition: 'left',\n      showLabel: false,\n      showTitle: false,\n      eulerAngles: [90, -90, 0]\n    }));\n  }\n}\nexport function computeLayout(components, options, theme, library) {\n  var _a, _b;\n  const {\n    width,\n    height,\n    depth,\n    x = 0,\n    y = 0,\n    z = 0,\n    inset = (_a = theme.inset) !== null && _a !== void 0 ? _a : 0,\n    insetLeft = inset,\n    insetTop = inset,\n    insetBottom = inset,\n    insetRight = inset,\n    margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0,\n    marginLeft = margin,\n    marginBottom = margin,\n    marginTop = margin,\n    marginRight = margin,\n    padding = theme.padding,\n    paddingBottom = padding,\n    paddingLeft = padding,\n    paddingRight = padding,\n    paddingTop = padding\n  } = computeInset(components, options, theme, library);\n  const MIN_CONTENT_RATIO = 1 / 4;\n  const maybeClamp = (viewWidth, paddingLeft, paddingRight, pl0, pr0) => {\n    // Only clamp when has marks.\n    const {\n      marks\n    } = options;\n    if (marks.length === 0) return [pl0, pr0];\n    // If size of content is enough, skip.\n    const contentSize = viewWidth - pl0 - pr0;\n    const diff = contentSize - viewWidth * MIN_CONTENT_RATIO;\n    if (diff > 0) return [pl0, pr0];\n    // Shrink start and end size equally.\n    const shrinkSize = viewWidth * (1 - MIN_CONTENT_RATIO);\n    return [paddingLeft === 'auto' ? shrinkSize * pl0 / (pl0 + pr0) : pl0, paddingRight === 'auto' ? shrinkSize * pr0 / (pl0 + pr0) : pr0];\n  };\n  const roughPadding = padding => padding === 'auto' ? 20 : padding !== null && padding !== void 0 ? padding : 20;\n  const rpt = roughPadding(paddingTop);\n  const rpb = roughPadding(paddingBottom);\n  // Compute paddingLeft and paddingRight first to get innerWidth.\n  const horizontalPadding = computePadding(components, height - rpt - rpb, [rpt + marginTop, rpb + marginBottom], ['left', 'right'], options, theme, library);\n  const {\n    paddingLeft: pl0,\n    paddingRight: pr0\n  } = horizontalPadding;\n  const viewWidth = width - marginLeft - marginRight;\n  const [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);\n  const iw = viewWidth - pl - pr;\n  // Compute paddingBottom and paddingTop based on innerWidth.\n  const verticalPadding = computePadding(components, iw, [pl + marginLeft, pr + marginRight], ['bottom', 'top'], options, theme, library);\n  const {\n    paddingTop: pt0,\n    paddingBottom: pb0\n  } = verticalPadding;\n  const viewHeight = height - marginBottom - marginTop;\n  const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);\n  const ih = viewHeight - pb - pt;\n  return {\n    width,\n    height,\n    depth,\n    insetLeft,\n    insetTop,\n    insetBottom,\n    insetRight,\n    innerWidth: iw,\n    innerHeight: ih,\n    paddingLeft: pl,\n    paddingRight: pr,\n    paddingTop: pt,\n    paddingBottom: pb,\n    marginLeft,\n    marginBottom,\n    marginTop,\n    marginRight,\n    x,\n    y,\n    z\n  };\n}\n// For composite mark with a layout algorithm and without axis,\n// such as worldcloud, circlepack.\nexport function computeRoughPlotSize(options) {\n  const {\n    height,\n    width,\n    padding = 0,\n    paddingLeft = padding,\n    paddingRight = padding,\n    paddingTop = padding,\n    paddingBottom = padding,\n    margin = 16,\n    marginLeft = margin,\n    marginRight = margin,\n    marginTop = margin,\n    marginBottom = margin,\n    inset = 0,\n    insetLeft = inset,\n    insetRight = inset,\n    insetTop = inset,\n    insetBottom = inset\n  } = options;\n  // @todo Add this padding to theme.\n  // 30 is default size for padding, which defined in runtime.\n  const maybeAuto = padding => padding === 'auto' ? 20 : padding;\n  const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;\n  const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;\n  return {\n    width: finalWidth,\n    height: finalHeight\n  };\n}\nfunction computeInset(components, options, theme, library) {\n  const {\n    coordinates\n  } = options;\n  if (!isPolarOptions(coordinates) && !isRadarOptions(coordinates)) {\n    return options;\n  }\n  // Filter axis.\n  const axes = components.filter(d => typeof d.type === 'string' && d.type.startsWith('axis'));\n  if (axes.length === 0) return options;\n  const styles = axes.map(component => {\n    const key = component.type === 'axisArc' ? 'arc' : 'linear';\n    return styleOf(component, key, theme);\n  });\n  // Compute max labelSpacing.\n  const maxLabelSpacing = max(styles, d => {\n    var _a;\n    return (_a = d.labelSpacing) !== null && _a !== void 0 ? _a : 0;\n  });\n  // Compute labelBBoxes.\n  const labelBBoxes = axes.flatMap((component, i) => {\n    const style = styles[i];\n    const scale = createScale(component, library);\n    const labels = computeLabelsBBox(style, scale);\n    return labels;\n  }).filter(defined);\n  const size = max(labelBBoxes, d => d.height) + maxLabelSpacing;\n  // Compute titles.\n  const titleBBoxes = axes.flatMap((_, i) => {\n    const style = styles[i];\n    return computeTitleBBox(style);\n  }).filter(d => d !== null);\n  const titleSize = titleBBoxes.length === 0 ? 0 : max(titleBBoxes, d => d.height);\n  // Update inset.\n  const {\n    inset = size,\n    insetLeft = inset,\n    insetBottom = inset,\n    insetTop = inset + titleSize,\n    insetRight = inset\n  } = options;\n  return Object.assign(Object.assign({}, options), {\n    insetLeft,\n    insetBottom,\n    insetTop,\n    insetRight\n  });\n}\n/**\n * @todo Support percentage size(e.g. 50%)\n */\nfunction computePadding(components, crossSize, crossPadding, positions, options, theme, library) {\n  const positionComponents = group(components, d => d.position);\n  const {\n    padding = theme.padding,\n    paddingLeft = padding,\n    paddingRight = padding,\n    paddingBottom = padding,\n    paddingTop = padding\n  } = options;\n  const layout = {\n    paddingBottom,\n    paddingLeft,\n    paddingTop,\n    paddingRight\n  };\n  for (const position of positions) {\n    const key = `padding${capitalizeFirst(camelCase(position))}`;\n    const components = positionComponents.get(position) || [];\n    const value = layout[key];\n    const defaultSizeOf = d => {\n      if (d.size === undefined) d.size = d.defaultSize;\n    };\n    const sizeOf = d => {\n      if (d.type === 'group') {\n        d.children.forEach(defaultSizeOf);\n        d.size = max(d.children, d => d.size);\n      } else {\n        d.size = d.defaultSize;\n      }\n    };\n    const autoSizeOf = d => {\n      if (d.size) return;\n      if (value !== 'auto') sizeOf(d);else {\n        // Compute component size dynamically.\n        computeComponentSize(d, crossSize, crossPadding, position, theme, library);\n        defaultSizeOf(d);\n      }\n    };\n    const maybeHide = d => {\n      if (!d.type.startsWith('axis')) return;\n      if (d.labelAutoHide === undefined) d.labelAutoHide = true;\n    };\n    const isHorizontal = position === 'bottom' || position === 'top';\n    // !!!Note\n    // Mute axis component padding.\n    // The first axis do not has padding.\n    const minOrder = min(components, d => d.order);\n    const axes = components.filter(d => d.type.startsWith('axis') && d.order == minOrder);\n    if (axes.length) axes[0].crossPadding = 0;\n    // Specified padding.\n    if (typeof value === 'number') {\n      components.forEach(defaultSizeOf);\n      components.forEach(maybeHide);\n    } else {\n      // Compute padding dynamically.\n      if (components.length === 0) {\n        layout[key] = 0;\n      } else {\n        const size = isHorizontal ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;\n        const grouped = groupComponents(components, size);\n        grouped.forEach(autoSizeOf);\n        const totalSize = grouped.reduce((sum, {\n          size,\n          crossPadding = 12\n        }) => sum + size + crossPadding, 0);\n        layout[key] = totalSize;\n      }\n    }\n  }\n  return layout;\n}\nexport function placeComponents(components, coordinate, layout) {\n  // Group components by plane & position.\n  const positionComponents = group(components, d => `${d.plane || 'xy'}-${d.position}`);\n  const {\n    paddingLeft,\n    paddingRight,\n    paddingTop,\n    paddingBottom,\n    marginLeft,\n    marginTop,\n    marginBottom,\n    marginRight,\n    innerHeight,\n    innerWidth,\n    insetBottom,\n    insetLeft,\n    insetRight,\n    insetTop,\n    height,\n    width,\n    depth\n  } = layout;\n  const planes = {\n    xy: createSection({\n      width,\n      height,\n      paddingLeft,\n      paddingRight,\n      paddingTop,\n      paddingBottom,\n      marginLeft,\n      marginTop,\n      marginBottom,\n      marginRight,\n      innerHeight,\n      innerWidth,\n      insetBottom,\n      insetLeft,\n      insetRight,\n      insetTop\n    }),\n    yz: createSection({\n      width: depth,\n      height: height,\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      marginLeft: 0,\n      marginTop: 0,\n      marginBottom: 0,\n      marginRight: 0,\n      innerWidth: depth,\n      innerHeight: height,\n      insetBottom: 0,\n      insetLeft: 0,\n      insetRight: 0,\n      insetTop: 0\n    }),\n    xz: createSection({\n      width,\n      height: depth,\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      marginLeft: 0,\n      marginTop: 0,\n      marginBottom: 0,\n      marginRight: 0,\n      innerWidth: width,\n      innerHeight: depth,\n      insetBottom: 0,\n      insetLeft: 0,\n      insetRight: 0,\n      insetTop: 0\n    })\n  };\n  for (const [key, components] of positionComponents.entries()) {\n    const [plane, position] = key.split('-');\n    const area = planes[plane][position];\n    /**\n     * @description non-entity components: axis in the center, inner, outer, component in the center\n     * @description entity components: other components\n     * @description no volume components take up no extra space\n     */\n    const [nonEntityComponents, entityComponents] = divide(components, component => {\n      if (typeof component.type !== 'string') return false;\n      if (position === 'center') return true;\n      if (component.type.startsWith('axis') && ['inner', 'outer'].includes(position)) {\n        return true;\n      }\n      return false;\n    });\n    if (nonEntityComponents.length) {\n      placeNonEntityComponents(nonEntityComponents, coordinate, area, position);\n    }\n    if (entityComponents.length) {\n      placePaddingArea(components, coordinate, area);\n    }\n  }\n}\nfunction createSection({\n  width,\n  height,\n  paddingLeft,\n  paddingRight,\n  paddingTop,\n  paddingBottom,\n  marginLeft,\n  marginTop,\n  marginBottom,\n  marginRight,\n  innerHeight,\n  innerWidth,\n  insetBottom,\n  insetLeft,\n  insetRight,\n  insetTop\n}) {\n  const pl = paddingLeft + marginLeft;\n  const pt = paddingTop + marginTop;\n  const pr = paddingRight + marginRight;\n  const pb = paddingBottom + marginBottom;\n  const plotWidth = width - marginLeft - marginRight;\n  const centerSection = [pl + insetLeft, pt + insetTop, innerWidth - insetLeft - insetRight, innerHeight - insetTop - insetBottom, 'center', null, null];\n  const xySection = {\n    top: [pl, 0, innerWidth, pt, 'vertical', true, ascending, marginLeft, plotWidth],\n    right: [width - pr, pt, pr, innerHeight, 'horizontal', false, ascending],\n    bottom: [pl, height - pb, innerWidth, pb, 'vertical', false, ascending, marginLeft, plotWidth],\n    left: [0, pt, pl, innerHeight, 'horizontal', true, ascending],\n    'top-left': [pl, 0, innerWidth, pt, 'vertical', true, ascending],\n    'top-right': [pl, 0, innerWidth, pt, 'vertical', true, ascending],\n    'bottom-left': [pl, height - pb, innerWidth, pb, 'vertical', false, ascending],\n    'bottom-right': [pl, height - pb, innerWidth, pb, 'vertical', false, ascending],\n    center: centerSection,\n    inner: centerSection,\n    outer: centerSection\n  };\n  return xySection;\n}\nfunction placeNonEntityComponents(components, coordinate, area, position) {\n  const [axisComponents, nonAxisComponents] = divide(components, component => {\n    if (typeof component.type === 'string' && component.type.startsWith('axis')) {\n      return true;\n    }\n    return false;\n  });\n  placeNonEntityAxis(axisComponents, coordinate, area, position);\n  // in current stage, only legend component which located in the center can be placed\n  placeCenter(nonAxisComponents, coordinate, area);\n}\nfunction placeNonEntityAxis(components, coordinate, area, position) {\n  if (position === 'center') {\n    if (isRadar(coordinate)) {\n      placeAxisRadar(components, coordinate, area, position);\n    } else if (isPolar(coordinate)) {\n      placeArcLinear(components, coordinate, area);\n    } else if (isParallel(coordinate)) {\n      placeAxisParallel(components, coordinate, area, components[0].orientation);\n    }\n  } else if (position === 'inner') {\n    placeAxisArcInner(components, coordinate, area);\n  } else if (position === 'outer') {\n    placeAxisArcOuter(components, coordinate, area);\n  }\n}\nfunction placeAxisArcInner(components, coordinate, area) {\n  const [x, y,, height] = area;\n  const [cx, cy] = coordinate.getCenter();\n  const [innerRadius] = radiusOf(coordinate);\n  const r = height / 2;\n  const size = innerRadius * r;\n  const x0 = cx - size;\n  const y0 = cy - size;\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    component.bbox = {\n      x: x + x0,\n      y: y + y0,\n      width: size * 2,\n      height: size * 2\n    };\n  }\n}\nfunction placeAxisArcOuter(components, coordinate, area) {\n  const [x, y, width, height] = area;\n  for (const component of components) {\n    component.bbox = {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n}\n/**\n * @example arcX, arcY, axisLinear with angle\n */\nfunction placeArcLinear(components, coordinate, area) {\n  const [x, y, width, height] = area;\n  for (const component of components) {\n    component.bbox = {\n      x: x,\n      y,\n      width,\n      height\n    };\n  }\n}\nfunction placeAxisParallel(components, coordinate, area, orientation) {\n  if (orientation === 'horizontal') {\n    placeAxisParallelHorizontal(components, coordinate, area);\n  } else if (orientation === 'vertical') {\n    placeAxisParallelVertical(components, coordinate, area);\n  }\n}\nfunction placeAxisParallelVertical(components, coordinate, area) {\n  const [x, y,, height] = area;\n  // Create a high dimension vector and map to a list of two-dimension points.\n  // [0, 0, 0] -> [x0, 0, x1, 0, x2, 0]\n  const vector = new Array(components.length).fill(0);\n  const points = coordinate.map(vector);\n  // Extract x of each points.\n  // [x0, 0, x1, 0, x2, 0] -> [x0, x1, x2]\n  const X = points.filter((_, i) => i % 2 === 0).map(d => d + x);\n  // Place each axis by coordinate in parallel coordinate.\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    const x = X[i];\n    const width = X[i + 1] - x;\n    component.bbox = {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n}\nfunction placeAxisParallelHorizontal(components, coordinate, area) {\n  const [x, y, width] = area;\n  // Create a high dimension vector and map to a list of two-dimension points.\n  // [0, 0, 0] -> [height, y0, height, y1, height, y2]\n  const vector = new Array(components.length).fill(0);\n  const points = coordinate.map(vector);\n  // Extract y of each points.\n  // [x0, 0, x1, 0, x2, 0] -> [x0, x1, x2]\n  const Y = points.filter((_, i) => i % 2 === 1).map(d => d + y);\n  // Place each axis by coordinate in parallel coordinate.\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    const y = Y[i];\n    const height = Y[i + 1] - y;\n    component.bbox = {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n}\nfunction placeAxisRadar(components, coordinate, area, position) {\n  const [x, y, width, height] = area;\n  for (const component of components) {\n    component.bbox = {\n      x,\n      y,\n      width,\n      height\n    };\n    component.radar = {\n      index: components.indexOf(component),\n      count: components.length\n    };\n  }\n}\nfunction placePaddingArea(components, coordinate, area) {\n  const [x, y, width, height, direction, reverse, comparator, minX, totalSize] = area;\n  const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction === 'vertical' ? ['y', y, 'x', x, 'height', height, 'width', width] : ['x', x, 'y', y, 'width', width, 'height', height];\n  // Sort components by order.\n  // The smaller the order, the closer to center.\n  components.sort((a, b) => comparator === null || comparator === void 0 ? void 0 : comparator(a.order, b.order));\n  const isLarge = type => type === 'title' || type === 'group' || type.startsWith('legend');\n  const crossSizeOf = (type, small, bigger) => {\n    if (bigger === undefined) return small;\n    if (isLarge(type)) return bigger;\n    return small;\n  };\n  const crossStartOf = (type, x, minX) => {\n    if (minX === undefined) return x;\n    if (isLarge(type)) return minX;\n    return x;\n  };\n  const startValue = reverse ? mainStartValue + mainSizeValue : mainStartValue;\n  for (let i = 0, start = startValue; i < components.length; i++) {\n    const component = components[i];\n    const {\n      crossPadding = 0,\n      type\n    } = component;\n    const {\n      size\n    } = component;\n    component.bbox = {\n      [mainStartKey]: reverse ? start - size - crossPadding : start + crossPadding,\n      [crossStartKey]: crossStartOf(type, crossStartValue, minX),\n      [mainSizeKey]: size,\n      [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)\n    };\n    start += (size + crossPadding) * (reverse ? -1 : 1);\n  }\n  // Place group components.\n  const groupComponents = components.filter(d => d.type === 'group');\n  for (const group of groupComponents) {\n    const {\n      bbox,\n      children\n    } = group;\n    const size = bbox[crossSizeKey];\n    const step = size / children.length;\n    const justifyContent = children.reduce((j, child) => {\n      var _a;\n      const j0 = (_a = child.layout) === null || _a === void 0 ? void 0 : _a.justifyContent;\n      return j0 ? j0 : j;\n    }, 'flex-start');\n    const L = children.map((d, i) => {\n      const {\n        length = step,\n        padding = 0\n      } = d;\n      return length + (i === children.length - 1 ? 0 : padding);\n    });\n    const totalLength = sum(L);\n    const diff = size - totalLength;\n    const offset = justifyContent === 'flex-start' ? 0 : justifyContent === 'center' ? diff / 2 : diff;\n    for (let i = 0, start = bbox[crossStartKey] + offset; i < children.length; i++) {\n      const component = children[i];\n      const {\n        padding = 0\n      } = component;\n      const interval = i === children.length - 1 ? 0 : padding;\n      component.bbox = {\n        [mainSizeKey]: bbox[mainSizeKey],\n        [mainStartKey]: bbox[mainStartKey],\n        [crossStartKey]: start,\n        [crossSizeKey]: L[i] - interval\n      };\n      deepMix(component, {\n        layout: {\n          justifyContent\n        }\n      });\n      start += L[i];\n    }\n  }\n}\n/**\n * @example legend in the center of radial or polar system\n */\nfunction placeCenter(components, coordinate, area) {\n  if (components.length === 0) return;\n  const [x, y, width, height] = area;\n  const [innerRadius] = radiusOf(coordinate);\n  const r = height / 2 * innerRadius / Math.sqrt(2);\n  const cx = x + width / 2;\n  const cy = y + height / 2;\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    component.bbox = {\n      x: cx - r,\n      y: cy - r,\n      width: r * 2,\n      height: r * 2\n    };\n  }\n}","map":{"version":3,"names":["ascending","group","max","min","sum","deepMix","isParallel","isPolar","isRadar","radiusOf","capitalizeFirst","defined","divide","camelCase","computeComponentSize","computeLabelsBBox","computeTitleBBox","createScale","groupComponents","styleOf","isPolarOptions","isRadial","isRadarOptions","processAxisZ","components","axisX","find","type","axisY","axisZ","plane","origin","bbox","x","y","eulerAngles","push","Object","assign","showLabel","showTitle","width","actualPosition","computeLayout","options","theme","library","height","depth","z","inset","_a","insetLeft","insetTop","insetBottom","insetRight","margin","_b","marginLeft","marginBottom","marginTop","marginRight","padding","paddingBottom","paddingLeft","paddingRight","paddingTop","computeInset","MIN_CONTENT_RATIO","maybeClamp","viewWidth","pl0","pr0","marks","length","contentSize","diff","shrinkSize","roughPadding","rpt","rpb","horizontalPadding","computePadding","pl","pr","iw","verticalPadding","pt0","pb0","viewHeight","pb","pt","ih","innerWidth","innerHeight","computeRoughPlotSize","maybeAuto","finalWidth","finalHeight","coordinates","axes","filter","d","startsWith","styles","map","component","key","maxLabelSpacing","labelSpacing","labelBBoxes","flatMap","i","style","scale","labels","size","titleBBoxes","_","titleSize","crossSize","crossPadding","positions","positionComponents","position","layout","get","value","defaultSizeOf","undefined","defaultSize","sizeOf","children","forEach","autoSizeOf","maybeHide","labelAutoHide","isHorizontal","minOrder","order","grouped","totalSize","reduce","placeComponents","coordinate","planes","xy","createSection","yz","xz","entries","split","area","nonEntityComponents","entityComponents","includes","placeNonEntityComponents","placePaddingArea","plotWidth","centerSection","xySection","top","right","bottom","left","center","inner","outer","axisComponents","nonAxisComponents","placeNonEntityAxis","placeCenter","placeAxisRadar","placeArcLinear","placeAxisParallel","orientation","placeAxisArcInner","placeAxisArcOuter","cx","cy","getCenter","innerRadius","r","x0","y0","placeAxisParallelHorizontal","placeAxisParallelVertical","vector","Array","fill","points","X","Y","radar","index","indexOf","count","direction","reverse","comparator","minX","mainStartKey","mainStartValue","crossStartKey","crossStartValue","mainSizeKey","mainSizeValue","crossSizeKey","crossSizeValue","sort","a","b","isLarge","crossSizeOf","small","bigger","crossStartOf","startValue","start","step","justifyContent","j","child","j0","L","totalLength","offset","interval","Math","sqrt"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/runtime/layout.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport {\n  NestedInternMap,\n  ascending,\n  group,\n  max,\n  min,\n  sum,\n} from '@antv/vendor/d3-array';\nimport { deepMix } from '@antv/util';\nimport { isParallel, isPolar, isRadar, radiusOf } from '../utils/coordinate';\nimport { capitalizeFirst, defined } from '../utils/helper';\nimport { divide } from '../utils/array';\nimport { camelCase } from '../utils/string';\nimport {\n  GuideComponentPosition as GCP,\n  GuideComponentOrientation as GCO,\n  Layout,\n  Section,\n  SectionArea,\n  G2Theme,\n  GuideComponentPlane,\n} from './types/common';\nimport {\n  computeComponentSize,\n  computeLabelsBBox,\n  computeTitleBBox,\n  createScale,\n  groupComponents,\n  styleOf,\n} from './component';\nimport { G2GuideComponentOptions, G2Library, G2View } from './types/options';\nimport {\n  isPolar as isPolarOptions,\n  isRadial as isRadarOptions,\n} from './coordinate';\n\nexport function processAxisZ(components: G2GuideComponentOptions[]) {\n  const axisX = components.find(({ type }) => type === 'axisX');\n  const axisY = components.find(({ type }) => type === 'axisY');\n  const axisZ = components.find(({ type }) => type === 'axisZ');\n  if (axisX && axisY && axisZ) {\n    axisX.plane = 'xy';\n    axisY.plane = 'xy';\n    axisZ.plane = 'yz';\n    axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];\n    axisZ.eulerAngles = [0, -90, 0];\n    axisZ.bbox.x = axisX.bbox.x;\n    axisZ.bbox.y = axisX.bbox.y;\n    components.push({\n      ...axisX,\n      plane: 'xz',\n      showLabel: false,\n      showTitle: false,\n      origin: [axisX.bbox.x, axisX.bbox.y, 0],\n      eulerAngles: [-90, 0, 0],\n    });\n    components.push({\n      ...axisY,\n      plane: 'yz',\n      showLabel: false,\n      showTitle: false,\n      origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0],\n      eulerAngles: [0, -90, 0],\n    });\n    components.push({\n      ...axisZ,\n      plane: 'xz',\n      actualPosition: 'left',\n      showLabel: false,\n      showTitle: false,\n      eulerAngles: [90, -90, 0],\n    });\n  }\n}\n\nexport function computeLayout(\n  components: G2GuideComponentOptions[],\n  options: G2View,\n  theme: G2Theme,\n  library: G2Library,\n): Layout {\n  const {\n    width,\n    height,\n    depth,\n    x = 0,\n    y = 0,\n    z = 0,\n    inset = theme.inset ?? 0,\n    insetLeft = inset,\n    insetTop = inset,\n    insetBottom = inset,\n    insetRight = inset,\n    margin = theme.margin ?? 0,\n    marginLeft = margin,\n    marginBottom = margin,\n    marginTop = margin,\n    marginRight = margin,\n    padding = theme.padding,\n    paddingBottom = padding,\n    paddingLeft = padding,\n    paddingRight = padding,\n    paddingTop = padding,\n  } = computeInset(components, options, theme, library);\n\n  const MIN_CONTENT_RATIO = 1 / 4;\n\n  const maybeClamp = (viewWidth, paddingLeft, paddingRight, pl0, pr0) => {\n    // Only clamp when has marks.\n    const { marks } = options;\n    if (marks.length === 0) return [pl0, pr0];\n\n    // If size of content is enough, skip.\n    const contentSize = viewWidth - pl0 - pr0;\n    const diff = contentSize - viewWidth * MIN_CONTENT_RATIO;\n    if (diff > 0) return [pl0, pr0];\n\n    // Shrink start and end size equally.\n    const shrinkSize = viewWidth * (1 - MIN_CONTENT_RATIO);\n    return [\n      paddingLeft === 'auto' ? (shrinkSize * pl0) / (pl0 + pr0) : pl0,\n      paddingRight === 'auto' ? (shrinkSize * pr0) / (pl0 + pr0) : pr0,\n    ];\n  };\n\n  const roughPadding = (padding) => (padding === 'auto' ? 20 : padding ?? 20);\n  const rpt = roughPadding(paddingTop);\n  const rpb = roughPadding(paddingBottom);\n\n  // Compute paddingLeft and paddingRight first to get innerWidth.\n  const horizontalPadding = computePadding(\n    components,\n    height - rpt - rpb,\n    [rpt + marginTop, rpb + marginBottom],\n    ['left', 'right'],\n    options,\n    theme,\n    library,\n  );\n  const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;\n  const viewWidth = width - marginLeft - marginRight;\n  const [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);\n  const iw = viewWidth - pl - pr;\n\n  // Compute paddingBottom and paddingTop based on innerWidth.\n  const verticalPadding = computePadding(\n    components,\n    iw,\n    [pl + marginLeft, pr + marginRight],\n    ['bottom', 'top'],\n    options,\n    theme,\n    library,\n  );\n  const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;\n  const viewHeight = height - marginBottom - marginTop;\n  const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);\n  const ih = viewHeight - pb - pt;\n\n  return {\n    width,\n    height,\n    depth,\n    insetLeft,\n    insetTop,\n    insetBottom,\n    insetRight,\n    innerWidth: iw,\n    innerHeight: ih,\n    paddingLeft: pl,\n    paddingRight: pr,\n    paddingTop: pt,\n    paddingBottom: pb,\n    marginLeft,\n    marginBottom,\n    marginTop,\n    marginRight,\n    x,\n    y,\n    z,\n  };\n}\n\n// For composite mark with a layout algorithm and without axis,\n// such as worldcloud, circlepack.\nexport function computeRoughPlotSize(options: G2View) {\n  const {\n    height,\n    width,\n    padding = 0,\n    paddingLeft = padding,\n    paddingRight = padding,\n    paddingTop = padding,\n    paddingBottom = padding,\n    margin = 16,\n    marginLeft = margin,\n    marginRight = margin,\n    marginTop = margin,\n    marginBottom = margin,\n    inset = 0,\n    insetLeft = inset,\n    insetRight = inset,\n    insetTop = inset,\n    insetBottom = inset,\n  } = options;\n\n  // @todo Add this padding to theme.\n  // 30 is default size for padding, which defined in runtime.\n  const maybeAuto = (padding) => (padding === 'auto' ? 20 : padding);\n\n  const finalWidth =\n    width -\n    maybeAuto(paddingLeft) -\n    maybeAuto(paddingRight) -\n    marginLeft -\n    marginRight -\n    insetLeft -\n    insetRight;\n\n  const finalHeight =\n    height -\n    maybeAuto(paddingTop) -\n    maybeAuto(paddingBottom) -\n    marginTop -\n    marginBottom -\n    insetTop -\n    insetBottom;\n\n  return { width: finalWidth, height: finalHeight };\n}\n\nfunction computeInset(\n  components: G2GuideComponentOptions[],\n  options: G2View,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const { coordinates } = options;\n  if (!isPolarOptions(coordinates) && !isRadarOptions(coordinates)) {\n    return options;\n  }\n\n  // Filter axis.\n  const axes = components.filter(\n    (d) => typeof d.type === 'string' && d.type.startsWith('axis'),\n  );\n\n  if (axes.length === 0) return options;\n\n  const styles = axes.map((component) => {\n    const key = component.type === 'axisArc' ? 'arc' : 'linear';\n    return styleOf(component, key as any, theme);\n  });\n\n  // Compute max labelSpacing.\n  const maxLabelSpacing = max(styles, (d) => d.labelSpacing ?? 0);\n\n  // Compute labelBBoxes.\n  const labelBBoxes = axes\n    .flatMap((component, i) => {\n      const style = styles[i];\n      const scale = createScale(component, library);\n      const labels = computeLabelsBBox(style, scale);\n      return labels;\n    })\n    .filter(defined);\n\n  const size = max(labelBBoxes, (d) => d.height) + maxLabelSpacing;\n\n  // Compute titles.\n  const titleBBoxes = axes\n    .flatMap((_, i) => {\n      const style = styles[i];\n      return computeTitleBBox(style);\n    })\n    .filter((d) => d !== null);\n  const titleSize =\n    titleBBoxes.length === 0 ? 0 : max(titleBBoxes, (d) => d.height);\n\n  // Update inset.\n  const {\n    inset = size,\n    insetLeft = inset,\n    insetBottom = inset,\n    insetTop = inset + titleSize,\n    insetRight = inset,\n  } = options;\n  return { ...options, insetLeft, insetBottom, insetTop, insetRight };\n}\n\n/**\n * @todo Support percentage size(e.g. 50%)\n */\nfunction computePadding(\n  components: G2GuideComponentOptions[],\n  crossSize: number,\n  crossPadding: [number, number],\n  positions: GCP[],\n  options: G2View,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const positionComponents = group(components, (d) => d.position);\n  const {\n    padding = theme.padding,\n    paddingLeft = padding,\n    paddingRight = padding,\n    paddingBottom = padding,\n    paddingTop = padding,\n  } = options;\n  const layout = {\n    paddingBottom,\n    paddingLeft,\n    paddingTop,\n    paddingRight,\n  };\n\n  for (const position of positions) {\n    const key = `padding${capitalizeFirst(camelCase(position))}`;\n    const components = positionComponents.get(position) || [];\n    const value = layout[key];\n    const defaultSizeOf = (d) => {\n      if (d.size === undefined) d.size = d.defaultSize;\n    };\n    const sizeOf = (d) => {\n      if (d.type === 'group') {\n        d.children.forEach(defaultSizeOf);\n        d.size = max(d.children, (d) => (d as any).size);\n      } else {\n        d.size = d.defaultSize;\n      }\n    };\n    const autoSizeOf = (d) => {\n      if (d.size) return;\n      if (value !== 'auto') sizeOf(d);\n      else {\n        // Compute component size dynamically.\n        computeComponentSize(\n          d,\n          crossSize,\n          crossPadding,\n          position,\n          theme,\n          library,\n        );\n        defaultSizeOf(d);\n      }\n    };\n\n    const maybeHide = (d) => {\n      if (!d.type.startsWith('axis')) return;\n      if (d.labelAutoHide === undefined) d.labelAutoHide = true;\n    };\n\n    const isHorizontal = position === 'bottom' || position === 'top';\n\n    // !!!Note\n    // Mute axis component padding.\n    // The first axis do not has padding.\n    const minOrder = min(components, (d) => d.order);\n    const axes = components.filter(\n      (d) => (d.type as string).startsWith('axis') && d.order == minOrder,\n    );\n    if (axes.length) axes[0].crossPadding = 0;\n\n    // Specified padding.\n    if (typeof value === 'number') {\n      components.forEach(defaultSizeOf);\n      components.forEach(maybeHide);\n    } else {\n      // Compute padding dynamically.\n      if (components.length === 0) {\n        layout[key] = 0;\n      } else {\n        const size = isHorizontal\n          ? crossSize + crossPadding[0] + crossPadding[1]\n          : crossSize;\n        const grouped = groupComponents(components, size);\n        grouped.forEach(autoSizeOf);\n        const totalSize = grouped.reduce(\n          (sum, { size, crossPadding = 12 }) => sum + size + crossPadding,\n          0,\n        );\n        layout[key] = totalSize;\n      }\n    }\n  }\n\n  return layout;\n}\n\nexport function placeComponents(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  layout: Layout,\n): void {\n  // Group components by plane & position.\n\n  const positionComponents: NestedInternMap<\n    G2GuideComponentOptions,\n    G2GuideComponentOptions[],\n    [string]\n  > = group<G2GuideComponentOptions, [string]>(\n    components,\n    (d) => `${d.plane || 'xy'}-${d.position}`,\n  );\n\n  const {\n    paddingLeft,\n    paddingRight,\n    paddingTop,\n    paddingBottom,\n    marginLeft,\n    marginTop,\n    marginBottom,\n    marginRight,\n    innerHeight,\n    innerWidth,\n    insetBottom,\n    insetLeft,\n    insetRight,\n    insetTop,\n    height,\n    width,\n    depth,\n  } = layout;\n\n  const planes = {\n    xy: createSection({\n      width,\n      height,\n      paddingLeft,\n      paddingRight,\n      paddingTop,\n      paddingBottom,\n      marginLeft,\n      marginTop,\n      marginBottom,\n      marginRight,\n      innerHeight,\n      innerWidth,\n      insetBottom,\n      insetLeft,\n      insetRight,\n      insetTop,\n    }),\n    yz: createSection({\n      width: depth,\n      height: height,\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      marginLeft: 0,\n      marginTop: 0,\n      marginBottom: 0,\n      marginRight: 0,\n      innerWidth: depth,\n      innerHeight: height,\n      insetBottom: 0,\n      insetLeft: 0,\n      insetRight: 0,\n      insetTop: 0,\n    }),\n    xz: createSection({\n      width,\n      height: depth,\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      marginLeft: 0,\n      marginTop: 0,\n      marginBottom: 0,\n      marginRight: 0,\n      innerWidth: width,\n      innerHeight: depth,\n      insetBottom: 0,\n      insetLeft: 0,\n      insetRight: 0,\n      insetTop: 0,\n    }),\n  };\n\n  for (const [key, components] of positionComponents.entries()) {\n    const [plane, position] = key.split('-') as [GuideComponentPlane, GCP];\n    const area = planes[plane][position];\n\n    /**\n     * @description non-entity components: axis in the center, inner, outer, component in the center\n     * @description entity components: other components\n     * @description no volume components take up no extra space\n     */\n\n    const [nonEntityComponents, entityComponents] = divide(\n      components,\n      (component) => {\n        if (typeof component.type !== 'string') return false;\n        if (position === 'center') return true;\n        if (\n          component.type.startsWith('axis') &&\n          ['inner', 'outer'].includes(position)\n        ) {\n          return true;\n        }\n        return false;\n      },\n    );\n\n    if (nonEntityComponents.length) {\n      placeNonEntityComponents(nonEntityComponents, coordinate, area, position);\n    }\n    if (entityComponents.length) {\n      placePaddingArea(components, coordinate, area);\n    }\n  }\n}\n\nfunction createSection({\n  width,\n  height,\n  paddingLeft,\n  paddingRight,\n  paddingTop,\n  paddingBottom,\n  marginLeft,\n  marginTop,\n  marginBottom,\n  marginRight,\n  innerHeight,\n  innerWidth,\n  insetBottom,\n  insetLeft,\n  insetRight,\n  insetTop,\n}: {\n  width: number;\n  height: number;\n  paddingLeft: number;\n  paddingRight: number;\n  paddingTop: number;\n  paddingBottom: number;\n  marginLeft: number;\n  marginTop: number;\n  marginBottom: number;\n  marginRight: number;\n  innerHeight: number;\n  innerWidth: number;\n  insetBottom: number;\n  insetLeft: number;\n  insetRight: number;\n  insetTop: number;\n}): Section {\n  const pl = paddingLeft + marginLeft;\n  const pt = paddingTop + marginTop;\n  const pr = paddingRight + marginRight;\n  const pb = paddingBottom + marginBottom;\n  const plotWidth = width - marginLeft - marginRight;\n\n  const centerSection: SectionArea = [\n    pl + insetLeft,\n    pt + insetTop,\n    innerWidth - insetLeft - insetRight,\n    innerHeight - insetTop - insetBottom,\n    'center',\n    null,\n    null,\n  ];\n\n  const xySection: Section = {\n    top: [\n      pl,\n      0,\n      innerWidth,\n      pt,\n      'vertical',\n      true,\n      ascending,\n      marginLeft,\n      plotWidth,\n    ],\n    right: [width - pr, pt, pr, innerHeight, 'horizontal', false, ascending],\n    bottom: [\n      pl,\n      height - pb,\n      innerWidth,\n      pb,\n      'vertical',\n      false,\n      ascending,\n      marginLeft,\n      plotWidth,\n    ],\n    left: [0, pt, pl, innerHeight, 'horizontal', true, ascending],\n    'top-left': [pl, 0, innerWidth, pt, 'vertical', true, ascending],\n    'top-right': [pl, 0, innerWidth, pt, 'vertical', true, ascending],\n    'bottom-left': [\n      pl,\n      height - pb,\n      innerWidth,\n      pb,\n      'vertical',\n      false,\n      ascending,\n    ],\n    'bottom-right': [\n      pl,\n      height - pb,\n      innerWidth,\n      pb,\n      'vertical',\n      false,\n      ascending,\n    ],\n    center: centerSection,\n    inner: centerSection,\n    outer: centerSection,\n  };\n\n  return xySection;\n}\n\nfunction placeNonEntityComponents(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n  position: GCP,\n) {\n  const [axisComponents, nonAxisComponents] = divide(\n    components,\n    (component) => {\n      if (\n        typeof component.type === 'string' &&\n        component.type.startsWith('axis')\n      ) {\n        return true;\n      }\n      return false;\n    },\n  );\n\n  placeNonEntityAxis(axisComponents, coordinate, area, position);\n  // in current stage, only legend component which located in the center can be placed\n  placeCenter(nonAxisComponents, coordinate, area);\n}\n\nfunction placeNonEntityAxis(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n  position: GCP,\n) {\n  if (position === 'center') {\n    if (isRadar(coordinate)) {\n      placeAxisRadar(components, coordinate, area, position);\n    } else if (isPolar(coordinate)) {\n      placeArcLinear(components, coordinate, area);\n    } else if (isParallel(coordinate)) {\n      placeAxisParallel(\n        components,\n        coordinate,\n        area,\n        components[0].orientation, // assume that all components have the same orientation\n      );\n    }\n  } else if (position === 'inner') {\n    placeAxisArcInner(components, coordinate, area);\n  } else if (position === 'outer') {\n    placeAxisArcOuter(components, coordinate, area);\n  }\n}\n\nfunction placeAxisArcInner(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n) {\n  const [x, y, , height] = area;\n  const [cx, cy] = coordinate.getCenter();\n  const [innerRadius] = radiusOf(coordinate);\n  const r = height / 2;\n  const size = innerRadius * r;\n  const x0 = cx - size;\n  const y0 = cy - size;\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    component.bbox = {\n      x: x + x0,\n      y: y + y0,\n      width: size * 2,\n      height: size * 2,\n    };\n  }\n}\n\nfunction placeAxisArcOuter(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n) {\n  const [x, y, width, height] = area;\n  for (const component of components) {\n    component.bbox = { x, y, width, height };\n  }\n}\n\n/**\n * @example arcX, arcY, axisLinear with angle\n */\nfunction placeArcLinear(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n) {\n  const [x, y, width, height] = area;\n  for (const component of components) {\n    component.bbox = { x: x, y, width, height };\n  }\n}\n\nfunction placeAxisParallel(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n  orientation: GCO,\n) {\n  if (orientation === 'horizontal') {\n    placeAxisParallelHorizontal(components, coordinate, area);\n  } else if (orientation === 'vertical') {\n    placeAxisParallelVertical(components, coordinate, area);\n  }\n}\n\nfunction placeAxisParallelVertical(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n): void {\n  const [x, y, , height] = area;\n\n  // Create a high dimension vector and map to a list of two-dimension points.\n  // [0, 0, 0] -> [x0, 0, x1, 0, x2, 0]\n  const vector = new Array(components.length).fill(0);\n  const points = coordinate.map(vector);\n\n  // Extract x of each points.\n  // [x0, 0, x1, 0, x2, 0] -> [x0, x1, x2]\n  const X = points.filter((_, i) => i % 2 === 0).map((d) => d + x);\n\n  // Place each axis by coordinate in parallel coordinate.\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    const x = X[i];\n    const width = X[i + 1] - x;\n    component.bbox = { x, y, width, height };\n  }\n}\n\nfunction placeAxisParallelHorizontal(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n): void {\n  const [x, y, width] = area;\n\n  // Create a high dimension vector and map to a list of two-dimension points.\n  // [0, 0, 0] -> [height, y0, height, y1, height, y2]\n  const vector = new Array(components.length).fill(0);\n  const points = coordinate.map(vector);\n\n  // Extract y of each points.\n  // [x0, 0, x1, 0, x2, 0] -> [x0, x1, x2]\n  const Y = points.filter((_, i) => i % 2 === 1).map((d) => d + y);\n\n  // Place each axis by coordinate in parallel coordinate.\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    const y = Y[i];\n    const height = Y[i + 1] - y;\n    component.bbox = { x, y, width, height };\n  }\n}\n\nfunction placeAxisRadar(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n  position: GCP,\n) {\n  const [x, y, width, height] = area;\n  for (const component of components) {\n    component.bbox = { x, y, width, height };\n    component.radar = {\n      index: components.indexOf(component),\n      count: components.length,\n    };\n  }\n}\n\nfunction placePaddingArea(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n) {\n  const [x, y, width, height, direction, reverse, comparator, minX, totalSize] =\n    area;\n  const [\n    mainStartKey,\n    mainStartValue,\n    crossStartKey,\n    crossStartValue,\n    mainSizeKey,\n    mainSizeValue,\n    crossSizeKey,\n    crossSizeValue,\n  ] =\n    direction === 'vertical'\n      ? ['y', y, 'x', x, 'height', height, 'width', width]\n      : ['x', x, 'y', y, 'width', width, 'height', height];\n\n  // Sort components by order.\n  // The smaller the order, the closer to center.\n  components.sort((a, b) => comparator?.(a.order, b.order));\n\n  const isLarge = (type) =>\n    type === 'title' || type === 'group' || type.startsWith('legend');\n\n  const crossSizeOf = (type, small, bigger) => {\n    if (bigger === undefined) return small;\n    if (isLarge(type)) return bigger;\n    return small;\n  };\n\n  const crossStartOf = (type, x, minX) => {\n    if (minX === undefined) return x;\n    if (isLarge(type)) return minX;\n    return x;\n  };\n\n  const startValue = reverse ? mainStartValue + mainSizeValue : mainStartValue;\n  for (let i = 0, start = startValue; i < components.length; i++) {\n    const component = components[i];\n    const { crossPadding = 0, type } = component;\n    const { size } = component;\n    component.bbox = {\n      [mainStartKey]: reverse\n        ? start - size - crossPadding\n        : start + crossPadding,\n      [crossStartKey]: crossStartOf(type, crossStartValue, minX),\n      [mainSizeKey]: size,\n      [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize),\n    };\n    start += (size + crossPadding) * (reverse ? -1 : 1);\n  }\n\n  // Place group components.\n  const groupComponents = components.filter((d) => d.type === 'group');\n  for (const group of groupComponents) {\n    const { bbox, children } = group;\n    const size = bbox[crossSizeKey];\n    const step = size / children.length;\n    const justifyContent = children.reduce((j, child) => {\n      const j0 = child.layout?.justifyContent;\n      return j0 ? j0 : j;\n    }, 'flex-start');\n    const L = children.map((d, i) => {\n      const { length = step, padding = 0 } = d;\n      return length + (i === children.length - 1 ? 0 : padding);\n    });\n    const totalLength = sum(L);\n    const diff = size - totalLength;\n    const offset =\n      justifyContent === 'flex-start'\n        ? 0\n        : justifyContent === 'center'\n        ? diff / 2\n        : diff;\n\n    for (\n      let i = 0, start = bbox[crossStartKey] + offset;\n      i < children.length;\n      i++\n    ) {\n      const component = children[i];\n      const { padding = 0 } = component;\n      const interval = i === children.length - 1 ? 0 : padding;\n      component.bbox = {\n        [mainSizeKey]: bbox[mainSizeKey],\n        [mainStartKey]: bbox[mainStartKey],\n        [crossStartKey]: start,\n        [crossSizeKey]: L[i] - interval,\n      };\n      deepMix(component, { layout: { justifyContent } });\n      start += L[i];\n    }\n  }\n}\n\n/**\n * @example legend in the center of radial or polar system\n */\nfunction placeCenter(\n  components: G2GuideComponentOptions[],\n  coordinate: Coordinate,\n  area: SectionArea,\n) {\n  if (components.length === 0) return;\n  const [x, y, width, height] = area;\n  const [innerRadius] = radiusOf(coordinate);\n  const r = ((height / 2) * innerRadius) / Math.sqrt(2);\n  const cx = x + width / 2;\n  const cy = y + height / 2;\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    component.bbox = { x: cx - r, y: cy - r, width: r * 2, height: r * 2 };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}