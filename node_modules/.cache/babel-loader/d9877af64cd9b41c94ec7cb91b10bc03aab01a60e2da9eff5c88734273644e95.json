{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Axis as AxisComponent } from '@antv/component';\nimport { Linear as LinearScale } from '@antv/scale';\nimport { deepMix, omit, upperFirst } from '@antv/util';\nimport { extent } from '@antv/vendor/d3-array';\nimport { format } from '@antv/vendor/d3-format';\nimport { angleOf, isFisheye, isParallel, isPolar, isRadial, isTheta, isTranspose, radiusOf } from '../utils/coordinate';\nimport { prettyNumber } from '../utils/number';\nimport { capitalizeFirst } from '../utils/helper';\nimport { adaptor, isVertical, titleContent } from './utils';\nexport function rotateAxis(axis, options) {\n  const {\n    eulerAngles,\n    origin\n  } = options;\n  if (origin) {\n    axis.setOrigin(origin);\n  }\n  if (eulerAngles) {\n    axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);\n  }\n}\nfunction sizeOf(coordinate) {\n  // @ts-ignore\n  const {\n    innerWidth,\n    innerHeight,\n    depth\n  } = coordinate.getOptions();\n  return [innerWidth, innerHeight, depth];\n}\nfunction createFisheye(position, coordinate) {\n  const {\n    width,\n    height\n  } = coordinate.getOptions();\n  return tick => {\n    if (!isFisheye(coordinate)) return tick;\n    const tickPoint = position === 'bottom' ? [tick, 1] : [0, tick];\n    const vector = coordinate.map(tickPoint);\n    if (position === 'bottom') {\n      const v = vector[0];\n      const x = new LinearScale({\n        domain: [0, width],\n        range: [0, 1]\n      });\n      return x.map(v);\n    } else if (position === 'left') {\n      const v = vector[1];\n      const x = new LinearScale({\n        domain: [0, height],\n        range: [0, 1]\n      });\n      return x.map(v);\n    }\n    return tick;\n  };\n}\nfunction ticksOf(scale, domain, tickMethod) {\n  if (scale.getTicks) return scale.getTicks();\n  if (!tickMethod) return domain;\n  const [min, max] = extent(domain, d => +d);\n  const {\n    tickCount\n  } = scale.getOptions();\n  return tickMethod(min, max, tickCount);\n}\n// Set inset for axis.\nfunction createInset(position, coordinate) {\n  if (isPolar(coordinate)) return d => d;\n  const options = coordinate.getOptions();\n  const {\n    innerWidth,\n    innerHeight,\n    insetTop,\n    insetBottom,\n    insetLeft,\n    insetRight\n  } = options;\n  const [start, end, size] = position === 'left' || position === 'right' ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];\n  const x = new LinearScale({\n    domain: [0, 1],\n    range: [start / size, 1 - end / size]\n  });\n  return i => x.map(i);\n}\n/**\n * Calc ticks based on scale and coordinate.\n */\nfunction getData(scale, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate) {\n  var _a;\n  if (tickCount !== undefined || tickMethod !== undefined) {\n    scale.update(Object.assign(Object.assign({}, tickCount && {\n      tickCount\n    }), tickMethod && {\n      tickMethod\n    }));\n  }\n  const ticks = ticksOf(scale, domain, tickMethod);\n  const filteredTicks = tickFilter ? ticks.filter(tickFilter) : ticks;\n  const toString = d => d instanceof Date ? String(d) : typeof d === 'object' && !!d ? d : String(d);\n  const labelFormatter = defaultTickFormatter || ((_a = scale.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale)) || toString;\n  const applyInset = createInset(position, coordinate);\n  const applyFisheye = createFisheye(position, coordinate);\n  const isHorizontal = position => ['top', 'bottom', 'center', 'outer'].includes(position);\n  const isVertical = position => ['left', 'right'].includes(position);\n  // @todo GUI should consider the overlap problem for the first\n  // and label of arc axis.\n  if (isPolar(coordinate) || isTranspose(coordinate)) {\n    return filteredTicks.map((d, i, array) => {\n      var _a, _b;\n      const offset = ((_a = scale.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale, d)) / 2 || 0;\n      const tick = applyInset(scale.map(d) + offset);\n      const shouldReverse = isRadial(coordinate) && position === 'center' || isTranspose(coordinate) && ((_b = scale.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale)) && isHorizontal(position) || isTranspose(coordinate) && isVertical(position);\n      return {\n        value: shouldReverse ? 1 - tick : tick,\n        label: toString(labelFormatter(prettyNumber(d), i, array)),\n        id: String(i)\n      };\n    });\n  }\n  return filteredTicks.map((d, i, array) => {\n    var _a;\n    const offset = ((_a = scale.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale, d)) / 2 || 0;\n    const tick = applyFisheye(applyInset(scale.map(d) + offset));\n    const shouldReverse = isVertical(position);\n    return {\n      value: shouldReverse ? 1 - tick : tick,\n      label: toString(labelFormatter(prettyNumber(d), i, array)),\n      id: String(i)\n    };\n  });\n}\nfunction inferGridLength(position, coordinate, plane = 'xy') {\n  const [width, height, depth] = sizeOf(coordinate);\n  if (plane === 'xy') {\n    if (position.includes('bottom') || position.includes('top')) return height;\n    return width;\n  } else if (plane === 'xz') {\n    if (position.includes('bottom') || position.includes('top')) return depth;\n    return width;\n  } else {\n    if (position.includes('bottom') || position.includes('top')) return height;\n    return depth;\n  }\n}\nfunction inferLabelOverlap(transform = [], style) {\n  if (transform.length > 0) return transform;\n  const {\n    labelAutoRotate,\n    labelAutoHide,\n    labelAutoEllipsis,\n    labelAutoWrap\n  } = style;\n  const finalTransforms = [];\n  const addToTransforms = (overlap, state) => {\n    if (state) {\n      finalTransforms.push(Object.assign(Object.assign({}, overlap), state));\n    }\n  };\n  addToTransforms({\n    type: 'rotate',\n    optionalAngles: [0, 15, 30, 45, 60, 90]\n  }, labelAutoRotate);\n  addToTransforms({\n    type: 'ellipsis',\n    minLength: 20\n  }, labelAutoEllipsis);\n  addToTransforms({\n    type: 'hide'\n  }, labelAutoHide);\n  addToTransforms({\n    type: 'wrap',\n    wordWrapWidth: 100,\n    maxLines: 3,\n    recoveryWhenFail: true\n  }, labelAutoWrap);\n  return finalTransforms;\n}\nfunction inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bbox;\n  const center = [x + width / 2, y + height / 2];\n  const radius = Math.min(width, height) / 2;\n  const [startAngle, endAngle] = angleOf(coordinate);\n  const [w, h] = sizeOf(coordinate);\n  const r = Math.min(w, h) / 2;\n  const common = {\n    center,\n    radius,\n    startAngle,\n    endAngle,\n    gridLength: (outerRadius - innerRadius) * r\n  };\n  if (position === 'inner') {\n    // @ts-ignore\n    const {\n      insetLeft,\n      insetTop\n    } = coordinate.getOptions();\n    return Object.assign(Object.assign({}, common), {\n      center: [center[0] - insetLeft, center[1] - insetTop],\n      labelAlign: 'perpendicular',\n      labelDirection: 'positive',\n      tickDirection: 'positive',\n      gridDirection: 'negative'\n    });\n  }\n  // arc outer\n  return Object.assign(Object.assign({}, common), {\n    labelAlign: 'parallel',\n    labelDirection: 'negative',\n    tickDirection: 'negative',\n    gridDirection: 'positive'\n  });\n}\nfunction inferGrid(value, coordinate, scale) {\n  if (isTheta(coordinate) || isParallel(coordinate)) return false;\n  // Display axis grid for non-discrete values.\n  return value === undefined ? !!scale.getTicks : value;\n}\nfunction infer3DAxisLinearOverrideStyle(coordinate) {\n  // @ts-ignore\n  const {\n    depth\n  } = coordinate.getOptions();\n  return depth ? {\n    tickIsBillboard: true,\n    lineIsBillboard: true,\n    labelIsBillboard: true,\n    titleIsBillboard: true,\n    gridIsBillboard: true\n  } : {};\n}\nfunction inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bbox;\n  if (position === 'bottom') {\n    return {\n      startPos: [x, y],\n      endPos: [x + width, y]\n    };\n  }\n  if (position === 'left') {\n    return {\n      startPos: [x + width, y + height],\n      endPos: [x + width, y]\n    };\n  }\n  if (position === 'right') {\n    return {\n      startPos: [x, y + height],\n      endPos: [x, y]\n    };\n  }\n  if (position === 'top') {\n    return {\n      startPos: [x, y + height],\n      endPos: [x + width, y + height]\n    };\n  }\n  // linear axis, maybe in parallel, polar, radial or radar systems.\n  if (position === 'center') {\n    // axisY\n    if (orientation === 'vertical') {\n      return {\n        startPos: [x, y],\n        endPos: [x, y + height]\n      };\n    }\n    // axisX\n    else if (orientation === 'horizontal') {\n      return {\n        startPos: [x, y],\n        endPos: [x + width, y]\n      };\n    }\n    // axis with rotate\n    else if (typeof orientation === 'number') {\n      const [cx, cy] = coordinate.getCenter();\n      const [innerRadius, outerRadius] = radiusOf(coordinate);\n      const [startAngle, endAngle] = angleOf(coordinate);\n      const r = Math.min(width, height) / 2;\n      // @ts-ignore\n      const {\n        insetLeft,\n        insetTop\n      } = coordinate.getOptions();\n      const innerR = innerRadius * r;\n      const outerR = outerRadius * r;\n      const [actualCx, actualCy] = [cx + x - insetLeft, cy + y - insetTop];\n      const [cos, sin] = [Math.cos(orientation), Math.sin(orientation)];\n      const startPos = [actualCx + outerR * cos, actualCy + outerR * sin];\n      const endPos = [actualCx + innerR * cos, actualCy + innerR * sin];\n      const getAxisXDomainLength = () => {\n        const {\n          domain\n        } = xScale.getOptions();\n        return domain.length;\n      };\n      const controllAngleCount = isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;\n      return {\n        startPos,\n        endPos,\n        gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,\n        gridCenter: [actualCx, actualCy],\n        gridControlAngles: new Array(controllAngleCount).fill(0).map((d, i, arr) => (endAngle - startAngle) / controllAngleCount * i)\n      };\n    }\n  }\n  // position is inner or outer for arc axis won't be here\n  return {};\n}\nconst ArcAxisComponent = options => {\n  const {\n      order,\n      size,\n      position,\n      orientation,\n      labelFormatter,\n      tickFilter,\n      tickCount,\n      tickMethod,\n      important = {},\n      style = {},\n      indexBBox,\n      title,\n      grid = false\n    } = options,\n    rest = __rest(options, [\"order\", \"size\", \"position\", \"orientation\", \"labelFormatter\", \"tickFilter\", \"tickCount\", \"tickMethod\", \"important\", \"style\", \"indexBBox\", \"title\", \"grid\"]);\n  return ({\n    scales: [scale],\n    value,\n    coordinate,\n    theme\n  }) => {\n    const {\n      bbox\n    } = value;\n    const {\n      domain\n    } = scale.getOptions();\n    const data = getData(scale, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);\n    // Bind computed bbox if exists.\n    const labels = indexBBox ? data.map((d, i) => {\n      const bbox = indexBBox.get(i);\n      if (!bbox) return d;\n      // bbox: [label, bbox]\n      // Make than indexBBox can match current label.\n      if (bbox[0] !== d.label) return d;\n      return Object.assign(Object.assign({}, d), {\n        bbox: bbox[1]\n      });\n    }) : data;\n    const [innerRadius, outerRadius] = radiusOf(coordinate);\n    const defaultStyle = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate);\n    const {\n      axis: axisTheme,\n      axisArc = {}\n    } = theme;\n    const finalStyle = adaptor(deepMix({}, axisTheme, axisArc, defaultStyle, Object.assign(Object.assign({\n      type: 'arc',\n      data: labels,\n      titleText: titleContent(title),\n      grid\n    }, rest), important)));\n    return new AxisComponent({\n      // @fixme transform is not valid for arcAxis.\n      // @ts-ignore\n      style: omit(finalStyle, ['transform'])\n    });\n  };\n};\nfunction inferThemeStyle(scale, coordinate, theme, direction, position, orientation) {\n  const baseStyle = theme.axis;\n  const positionStyle = ['top', 'right', 'bottom', 'left'].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;\n  const channel = scale.getOptions().name;\n  const channelStyle = theme[`axis${upperFirst(channel)}`] || {};\n  return Object.assign({}, baseStyle, positionStyle, channelStyle);\n}\nfunction inferDefaultStyle(scale, coordinate, theme, direction, position, orientation) {\n  const themeStyle = inferThemeStyle(scale, coordinate, theme, direction, position, orientation);\n  if (position === 'center') {\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), {\n      labelDirection: direction === 'right' ? 'negative' : 'positive'\n    }), direction === 'center' ? {\n      labelTransform: 'translate(50%,0)'\n    } : null), {\n      tickDirection: direction === 'right' ? 'negative' : 'positive',\n      labelSpacing: direction === 'center' ? 0 : 4,\n      titleSpacing: isVertical(orientation) ? 10 : 0,\n      tick: direction === 'center' ? false : undefined\n    });\n  }\n  return themeStyle;\n}\nconst LinearAxisComponent = options => {\n  const {\n      direction = 'left',\n      important = {},\n      labelFormatter,\n      order,\n      orientation,\n      actualPosition,\n      position,\n      size,\n      style = {},\n      title,\n      tickCount,\n      tickFilter,\n      tickMethod,\n      transform,\n      indexBBox\n    } = options,\n    userDefinitions = __rest(options, [\"direction\", \"important\", \"labelFormatter\", \"order\", \"orientation\", \"actualPosition\", \"position\", \"size\", \"style\", \"title\", \"tickCount\", \"tickFilter\", \"tickMethod\", \"transform\", \"indexBBox\"]);\n  return ({\n    scales,\n    value,\n    coordinate,\n    theme\n  }) => {\n    const {\n      bbox\n    } = value;\n    const [scale] = scales;\n    const {\n      domain,\n      xScale\n    } = scale.getOptions();\n    const defaultStyle = inferDefaultStyle(scale, coordinate, theme, direction, position, orientation);\n    const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle), style), userDefinitions);\n    const gridLength = inferGridLength(actualPosition || position, coordinate, options.plane);\n    const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale);\n    const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);\n    const data = getData(scale, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);\n    // Bind computed bbox if exists.\n    const labels = indexBBox ? data.map((d, i) => {\n      const bbox = indexBBox.get(i);\n      if (!bbox) return d;\n      // bbox: [label, bbox]\n      // Make than indexBBox can match current label.\n      if (bbox[0] !== d.label) return d;\n      return Object.assign(Object.assign({}, d), {\n        bbox: bbox[1]\n      });\n    }) : data;\n    const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {\n      type: 'linear',\n      data: labels,\n      crossSize: size,\n      titleText: titleContent(title),\n      labelOverlap: inferLabelOverlap(transform, internalAxisStyle),\n      grid: inferGrid(internalAxisStyle.grid, coordinate, scale),\n      gridLength,\n      // Always showLine, make title could align the end of axis.\n      line: true,\n      indexBBox\n    }), !internalAxisStyle.line ? {\n      lineOpacity: 0\n    } : null), overrideStyle), threeDOverrideStyle), important);\n    // For hide overlap, do not set crossSize.\n    const hasHide = finalAxisStyle.labelOverlap.find(d => d.type === 'hide');\n    if (hasHide) finalAxisStyle.crossSize = false;\n    return new AxisComponent({\n      className: 'axis',\n      style: adaptor(finalAxisStyle)\n    });\n  };\n};\nconst axisFactor = axis => {\n  return options => {\n    const {\n      labelFormatter: useDefinedLabelFormatter,\n      labelFilter: userDefinedLabelFilter = () => true\n    } = options;\n    return context => {\n      var _a;\n      const {\n        scales: [scale]\n      } = context;\n      const ticks = ((_a = scale.getTicks) === null || _a === void 0 ? void 0 : _a.call(scale)) || scale.getOptions().domain;\n      const labelFormatter = typeof useDefinedLabelFormatter === 'string' ? format(useDefinedLabelFormatter) : useDefinedLabelFormatter;\n      const labelFilter = (datum, index, array) => userDefinedLabelFilter(ticks[index], index, ticks);\n      const normalizedOptions = Object.assign(Object.assign({}, options), {\n        labelFormatter,\n        labelFilter,\n        scale\n      });\n      return axis(normalizedOptions)(context);\n    };\n  };\n};\nexport const LinearAxis = axisFactor(LinearAxisComponent);\nexport const ArcAxis = axisFactor(ArcAxisComponent);\nLinearAxis.props = {\n  defaultPosition: 'center',\n  defaultSize: 45,\n  defaultOrder: 0,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12]\n};\nArcAxis.props = {\n  defaultPosition: 'outer',\n  defaultOrientation: 'vertical',\n  defaultSize: 45,\n  defaultOrder: 0,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12]\n};","map":{"version":3,"names":["Axis","AxisComponent","Linear","LinearScale","deepMix","omit","upperFirst","extent","format","angleOf","isFisheye","isParallel","isPolar","isRadial","isTheta","isTranspose","radiusOf","prettyNumber","capitalizeFirst","adaptor","isVertical","titleContent","rotateAxis","axis","options","eulerAngles","origin","setOrigin","rotate","sizeOf","coordinate","innerWidth","innerHeight","depth","getOptions","createFisheye","position","width","height","tick","tickPoint","vector","map","v","x","domain","range","ticksOf","scale","tickMethod","getTicks","min","max","d","tickCount","createInset","insetTop","insetBottom","insetLeft","insetRight","start","end","size","i","getData","defaultTickFormatter","tickFilter","undefined","update","Object","assign","ticks","filteredTicks","filter","toString","Date","String","labelFormatter","_a","getFormatter","call","applyInset","applyFisheye","isHorizontal","includes","array","offset","getBandWidth","shouldReverse","_b","value","label","id","inferGridLength","plane","inferLabelOverlap","transform","style","length","labelAutoRotate","labelAutoHide","labelAutoEllipsis","labelAutoWrap","finalTransforms","addToTransforms","overlap","state","push","type","optionalAngles","minLength","wordWrapWidth","maxLines","recoveryWhenFail","inferArcStyle","bbox","innerRadius","outerRadius","y","center","radius","Math","startAngle","endAngle","w","h","r","common","gridLength","labelAlign","labelDirection","tickDirection","gridDirection","inferGrid","infer3DAxisLinearOverrideStyle","tickIsBillboard","lineIsBillboard","labelIsBillboard","titleIsBillboard","gridIsBillboard","inferAxisLinearOverrideStyle","orientation","xScale","startPos","endPos","cx","cy","getCenter","innerR","outerR","actualCx","actualCy","cos","sin","getAxisXDomainLength","controllAngleCount","gridClosed","abs","gridCenter","gridControlAngles","Array","fill","arr","ArcAxisComponent","order","important","indexBBox","title","grid","rest","__rest","scales","theme","data","labels","get","defaultStyle","axisTheme","axisArc","finalStyle","titleText","inferThemeStyle","direction","baseStyle","positionStyle","axisLinear","channel","name","channelStyle","inferDefaultStyle","themeStyle","labelTransform","labelSpacing","titleSpacing","LinearAxisComponent","actualPosition","userDefinitions","internalAxisStyle","overrideStyle","threeDOverrideStyle","finalAxisStyle","crossSize","labelOverlap","line","lineOpacity","hasHide","find","className","axisFactor","useDefinedLabelFormatter","labelFilter","userDefinedLabelFilter","context","datum","index","normalizedOptions","LinearAxis","ArcAxis","props","defaultPosition","defaultSize","defaultOrder","defaultCrossPadding","defaultPadding","defaultOrientation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/component/axis.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport type { DisplayObject } from '@antv/g';\nimport { Axis as AxisComponent } from '@antv/component';\nimport { Linear as LinearScale } from '@antv/scale';\nimport { deepMix, omit, upperFirst } from '@antv/util';\nimport { extent } from '@antv/vendor/d3-array';\nimport { format } from '@antv/vendor/d3-format';\nimport {\n  BBox,\n  G2Theme,\n  GuideComponentComponent as GCC,\n  GuideComponentOrientation as GCO,\n  GuideComponentPosition as GCP,\n  GuideComponentPlane,\n  Scale,\n  Vector3,\n} from '../runtime';\nimport {\n  angleOf,\n  isFisheye,\n  isParallel,\n  isPolar,\n  isRadial,\n  isTheta,\n  isTranspose,\n  radiusOf,\n} from '../utils/coordinate';\nimport { prettyNumber } from '../utils/number';\nimport { capitalizeFirst } from '../utils/helper';\nimport { adaptor, isVertical, titleContent } from './utils';\n\nexport type AxisOptions = {\n  position?: GCP;\n  plane?: GuideComponentPlane;\n  zIndex?: number;\n  title?: string | string[];\n  direction?: 'left' | 'center' | 'right';\n  labelFormatter?: (datum: any, index: number, array: any[]) => string;\n  labelFilter?: (datum: any, index: number, array: any[]) => boolean;\n  tickFormatter?: (\n    datum: any,\n    index: number,\n    array: any[],\n    vector: [number, number],\n  ) => DisplayObject;\n  tickFilter?: (datum: any, index: number, array: any[]) => boolean;\n  tickMethod?: (\n    start: number | Date,\n    end: number | Date,\n    tickCount: number,\n  ) => number[];\n  tickCount?: number;\n  grid: any;\n  // options won't be overridden\n  important: Record<string, any>;\n  /**\n   * Rotation origin.\n   */\n  origin?: Vector3;\n  /**\n   * EulerAngles of rotation.\n   */\n  eulerAngles?: Vector3;\n  [key: string]: any;\n};\n\nexport function rotateAxis(axis: DisplayObject, options: AxisOptions) {\n  const { eulerAngles, origin } = options;\n  if (origin) {\n    axis.setOrigin(origin);\n  }\n  if (eulerAngles) {\n    axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);\n  }\n}\n\nfunction sizeOf(coordinate: Coordinate): [number, number, number] {\n  // @ts-ignore\n  const { innerWidth, innerHeight, depth } = coordinate.getOptions();\n  return [innerWidth, innerHeight, depth];\n}\n\nfunction createFisheye(position, coordinate) {\n  const { width, height } = coordinate.getOptions();\n  return (tick) => {\n    if (!isFisheye(coordinate)) return tick;\n    const tickPoint = position === 'bottom' ? [tick, 1] : [0, tick];\n    const vector = coordinate.map(tickPoint);\n    if (position === 'bottom') {\n      const v = vector[0];\n      const x = new LinearScale({\n        domain: [0, width],\n        range: [0, 1],\n      });\n      return x.map(v);\n    } else if (position === 'left') {\n      const v = vector[1];\n      const x = new LinearScale({\n        domain: [0, height],\n        range: [0, 1],\n      });\n      return x.map(v);\n    }\n    return tick;\n  };\n}\n\nfunction ticksOf(\n  scale: Scale,\n  domain: any[],\n  tickMethod: AxisOptions['tickMethod'],\n) {\n  if (scale.getTicks) return scale.getTicks();\n  if (!tickMethod) return domain;\n  const [min, max] = extent(domain, (d) => +d);\n  const { tickCount } = scale.getOptions();\n  return tickMethod(min, max, tickCount);\n}\n\n// Set inset for axis.\nfunction createInset(position, coordinate) {\n  if (isPolar(coordinate)) return (d) => d;\n  const options = coordinate.getOptions();\n  const {\n    innerWidth,\n    innerHeight,\n    insetTop,\n    insetBottom,\n    insetLeft,\n    insetRight,\n  } = options;\n  const [start, end, size] =\n    position === 'left' || position === 'right'\n      ? [insetTop, insetBottom, innerHeight]\n      : [insetLeft, insetRight, innerWidth];\n  const x = new LinearScale({\n    domain: [0, 1],\n    range: [start / size, 1 - end / size],\n  });\n  return (i) => x.map(i);\n}\n\n/**\n * Calc ticks based on scale and coordinate.\n */\nfunction getData(\n  scale: Scale,\n  domain: any[],\n  tickCount: number,\n  defaultTickFormatter: AxisOptions['labelFormatter'],\n  tickFilter: AxisOptions['tickFilter'],\n  tickMethod: AxisOptions['tickMethod'],\n  position: GCP,\n  coordinate: Coordinate,\n) {\n  if (tickCount !== undefined || tickMethod !== undefined) {\n    scale.update({\n      ...(tickCount && { tickCount }),\n      ...(tickMethod && { tickMethod }),\n    });\n  }\n\n  const ticks = ticksOf(scale, domain, tickMethod);\n  const filteredTicks = tickFilter ? ticks.filter(tickFilter) : ticks;\n  const toString = (d) =>\n    d instanceof Date\n      ? String(d)\n      : typeof d === 'object' && !!d\n      ? d\n      : String(d);\n  const labelFormatter =\n    defaultTickFormatter || scale.getFormatter?.() || toString;\n  const applyInset = createInset(position, coordinate);\n  const applyFisheye = createFisheye(position, coordinate);\n  const isHorizontal = (position) =>\n    ['top', 'bottom', 'center', 'outer'].includes(position);\n  const isVertical = (position) => ['left', 'right'].includes(position);\n\n  // @todo GUI should consider the overlap problem for the first\n  // and label of arc axis.\n  if (isPolar(coordinate) || isTranspose(coordinate)) {\n    return filteredTicks.map((d, i, array) => {\n      const offset = scale.getBandWidth?.(d) / 2 || 0;\n      const tick = applyInset(scale.map(d) + offset);\n      const shouldReverse =\n        (isRadial(coordinate) && position === 'center') ||\n        (isTranspose(coordinate) &&\n          scale.getTicks?.() &&\n          isHorizontal(position)) ||\n        (isTranspose(coordinate) && isVertical(position));\n\n      return {\n        value: shouldReverse ? 1 - tick : tick,\n        label: toString(labelFormatter(prettyNumber(d), i, array)),\n        id: String(i),\n      };\n    });\n  }\n\n  return filteredTicks.map((d, i, array) => {\n    const offset = scale.getBandWidth?.(d) / 2 || 0;\n    const tick = applyFisheye(applyInset(scale.map(d) + offset));\n    const shouldReverse = isVertical(position);\n    return {\n      value: shouldReverse ? 1 - tick : tick,\n      label: toString(labelFormatter(prettyNumber(d), i, array)),\n      id: String(i),\n    };\n  });\n}\n\nfunction inferGridLength(\n  position: GCP,\n  coordinate: Coordinate,\n  plane: GuideComponentPlane = 'xy',\n) {\n  const [width, height, depth] = sizeOf(coordinate);\n\n  if (plane === 'xy') {\n    if (position.includes('bottom') || position.includes('top')) return height;\n    return width;\n  } else if (plane === 'xz') {\n    if (position.includes('bottom') || position.includes('top')) return depth;\n    return width;\n  } else {\n    if (position.includes('bottom') || position.includes('top')) return height;\n    return depth;\n  }\n}\n\nfunction inferLabelOverlap(transform = [], style: Record<string, any>) {\n  if (transform.length > 0) return transform;\n  const { labelAutoRotate, labelAutoHide, labelAutoEllipsis, labelAutoWrap } =\n    style;\n\n  const finalTransforms = [];\n\n  const addToTransforms = (overlap, state) => {\n    if (state) {\n      finalTransforms.push({ ...overlap, ...state });\n    }\n  };\n\n  addToTransforms(\n    {\n      type: 'rotate',\n      optionalAngles: [0, 15, 30, 45, 60, 90],\n    },\n    labelAutoRotate,\n  );\n  addToTransforms({ type: 'ellipsis', minLength: 20 }, labelAutoEllipsis);\n  addToTransforms({ type: 'hide' }, labelAutoHide);\n  addToTransforms(\n    { type: 'wrap', wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: true },\n    labelAutoWrap,\n  );\n  return finalTransforms;\n}\n\nfunction inferArcStyle(\n  position: GCP,\n  bbox: BBox,\n  innerRadius: number,\n  outerRadius: number,\n  coordinate: Coordinate,\n) {\n  const { x, y, width, height } = bbox;\n  const center: [number, number] = [x + width / 2, y + height / 2];\n  const radius = Math.min(width, height) / 2;\n  const [startAngle, endAngle] = angleOf(coordinate);\n\n  const [w, h] = sizeOf(coordinate);\n  const r = Math.min(w, h) / 2;\n\n  const common = {\n    center,\n    radius,\n    startAngle,\n    endAngle,\n    gridLength: (outerRadius - innerRadius) * r,\n  };\n\n  if (position === 'inner') {\n    // @ts-ignore\n    const { insetLeft, insetTop } = coordinate.getOptions();\n    return {\n      ...common,\n      center: [center[0] - insetLeft, center[1] - insetTop],\n      labelAlign: 'perpendicular',\n      labelDirection: 'positive',\n      tickDirection: 'positive',\n      gridDirection: 'negative',\n    };\n  }\n\n  // arc outer\n  return {\n    ...common,\n    labelAlign: 'parallel',\n    labelDirection: 'negative',\n    tickDirection: 'negative',\n    gridDirection: 'positive',\n  };\n}\n\nfunction inferGrid(value: boolean, coordinate: Coordinate, scale: Scale) {\n  if (isTheta(coordinate) || isParallel(coordinate)) return false;\n  // Display axis grid for non-discrete values.\n  return value === undefined ? !!scale.getTicks : value;\n}\n\nfunction infer3DAxisLinearOverrideStyle(coordinate: Coordinate) {\n  // @ts-ignore\n  const { depth } = coordinate.getOptions();\n  return depth\n    ? {\n        tickIsBillboard: true,\n        lineIsBillboard: true,\n        labelIsBillboard: true,\n        titleIsBillboard: true,\n        gridIsBillboard: true,\n      }\n    : {};\n}\n\nfunction inferAxisLinearOverrideStyle(\n  position: GCP,\n  orientation: GCO,\n  bbox: BBox,\n  coordinate: Coordinate,\n  xScale: Scale,\n): {\n  startPos?: [number, number];\n  endPos?: [number, number];\n  [k: string]: any;\n} {\n  const { x, y, width, height } = bbox;\n\n  if (position === 'bottom') {\n    return { startPos: [x, y], endPos: [x + width, y] };\n  }\n  if (position === 'left') {\n    return { startPos: [x + width, y + height], endPos: [x + width, y] };\n  }\n  if (position === 'right') {\n    return { startPos: [x, y + height], endPos: [x, y] };\n  }\n  if (position === 'top') {\n    return { startPos: [x, y + height], endPos: [x + width, y + height] };\n  }\n  // linear axis, maybe in parallel, polar, radial or radar systems.\n  if (position === 'center') {\n    // axisY\n    if (orientation === 'vertical') {\n      return {\n        startPos: [x, y],\n        endPos: [x, y + height],\n      };\n    }\n    // axisX\n    else if (orientation === 'horizontal') {\n      return {\n        startPos: [x, y],\n        endPos: [x + width, y],\n      };\n    }\n    // axis with rotate\n    else if (typeof orientation === 'number') {\n      const [cx, cy] = coordinate.getCenter();\n      const [innerRadius, outerRadius] = radiusOf(coordinate);\n      const [startAngle, endAngle] = angleOf(coordinate);\n      const r = Math.min(width, height) / 2;\n      // @ts-ignore\n      const { insetLeft, insetTop } = coordinate.getOptions();\n\n      const innerR = innerRadius * r;\n      const outerR = outerRadius * r;\n\n      const [actualCx, actualCy] = [cx + x - insetLeft, cy + y - insetTop];\n      const [cos, sin] = [Math.cos(orientation), Math.sin(orientation)];\n\n      const startPos: [number, number] = [\n        actualCx + outerR * cos,\n        actualCy + outerR * sin,\n      ];\n      const endPos: [number, number] = [\n        actualCx + innerR * cos,\n        actualCy + innerR * sin,\n      ];\n\n      const getAxisXDomainLength = () => {\n        const { domain } = xScale.getOptions();\n        return domain.length;\n      };\n      const controllAngleCount =\n        isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;\n\n      return {\n        startPos,\n        endPos,\n        gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,\n        gridCenter: [actualCx, actualCy],\n        gridControlAngles: new Array(controllAngleCount)\n          .fill(0)\n          .map(\n            (d, i, arr) => ((endAngle - startAngle) / controllAngleCount) * i,\n          ),\n      };\n    }\n  }\n\n  // position is inner or outer for arc axis won't be here\n\n  return {};\n}\n\nconst ArcAxisComponent: GCC<AxisOptions> = (options) => {\n  const {\n    order,\n    size,\n    position,\n    orientation,\n    labelFormatter,\n    tickFilter,\n    tickCount,\n    tickMethod,\n    important = {},\n    style = {},\n    indexBBox,\n    title,\n    grid = false,\n    ...rest\n  } = options;\n\n  return ({ scales: [scale], value, coordinate, theme }) => {\n    const { bbox } = value;\n    const { domain } = scale.getOptions();\n    const data = getData(\n      scale,\n      domain,\n      tickCount,\n      labelFormatter,\n      tickFilter,\n      tickMethod,\n      position,\n      coordinate,\n    );\n\n    // Bind computed bbox if exists.\n    const labels = indexBBox\n      ? data.map((d, i) => {\n          const bbox = indexBBox.get(i);\n          if (!bbox) return d;\n          // bbox: [label, bbox]\n          // Make than indexBBox can match current label.\n          if (bbox[0] !== d.label) return d;\n          return { ...d, bbox: bbox[1] };\n        })\n      : data;\n\n    const [innerRadius, outerRadius] = radiusOf(coordinate);\n\n    const defaultStyle = inferArcStyle(\n      position,\n      bbox,\n      innerRadius,\n      outerRadius,\n      coordinate,\n    );\n\n    const { axis: axisTheme, axisArc = {} } = theme;\n    const finalStyle = adaptor(\n      deepMix({}, axisTheme, axisArc, defaultStyle, {\n        type: 'arc',\n        data: labels,\n        titleText: titleContent(title),\n        grid,\n        ...rest,\n        ...important,\n      }),\n    );\n\n    return new AxisComponent({\n      // @fixme transform is not valid for arcAxis.\n      // @ts-ignore\n      style: omit(finalStyle, ['transform']),\n    }) as unknown as DisplayObject;\n  };\n};\n\nfunction inferThemeStyle(\n  scale: Scale,\n  coordinate: Coordinate,\n  theme: G2Theme,\n  direction,\n  position: GCP,\n  orientation: GCO,\n) {\n  const baseStyle = theme.axis;\n  const positionStyle = ['top', 'right', 'bottom', 'left'].includes(position)\n    ? theme[`axis${capitalizeFirst(position)}`]\n    : theme.axisLinear;\n  const channel = scale.getOptions().name;\n  const channelStyle = theme[`axis${upperFirst(channel)}`] || {};\n  return Object.assign({}, baseStyle, positionStyle, channelStyle);\n}\n\nfunction inferDefaultStyle(\n  scale: Scale,\n  coordinate: Coordinate,\n  theme: G2Theme,\n  direction,\n  position: GCP,\n  orientation: GCO,\n) {\n  const themeStyle = inferThemeStyle(\n    scale,\n    coordinate,\n    theme,\n    direction,\n    position,\n    orientation,\n  );\n\n  if (position === 'center') {\n    return {\n      ...themeStyle,\n      labelDirection: direction === 'right' ? 'negative' : 'positive',\n      ...(direction === 'center'\n        ? { labelTransform: 'translate(50%,0)' }\n        : null),\n      tickDirection: direction === 'right' ? 'negative' : 'positive',\n      labelSpacing: direction === 'center' ? 0 : 4,\n      titleSpacing: isVertical(orientation) ? 10 : 0,\n      tick: direction === 'center' ? false : undefined,\n    };\n  }\n  return themeStyle;\n}\n\nconst LinearAxisComponent: GCC<AxisOptions> = (options) => {\n  const {\n    direction = 'left',\n    important = {},\n    labelFormatter,\n    order,\n    orientation,\n    actualPosition,\n    position,\n    size,\n    style = {},\n    title,\n    tickCount,\n    tickFilter,\n    tickMethod,\n    transform,\n    indexBBox,\n    ...userDefinitions\n  } = options;\n  return ({ scales, value, coordinate, theme }) => {\n    const { bbox } = value;\n    const [scale] = scales;\n    const { domain, xScale } = scale.getOptions();\n    const defaultStyle = inferDefaultStyle(\n      scale,\n      coordinate,\n      theme,\n      direction,\n      position,\n      orientation,\n    );\n    const internalAxisStyle = {\n      ...defaultStyle,\n      ...style,\n      ...userDefinitions,\n    };\n\n    const gridLength = inferGridLength(\n      actualPosition || position,\n      coordinate,\n      options.plane,\n    );\n\n    const overrideStyle = inferAxisLinearOverrideStyle(\n      position,\n      orientation,\n      bbox,\n      coordinate,\n      xScale,\n    );\n\n    const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);\n\n    const data = getData(\n      scale,\n      domain,\n      tickCount,\n      labelFormatter,\n      tickFilter,\n      tickMethod,\n      position,\n      coordinate,\n    );\n\n    // Bind computed bbox if exists.\n    const labels = indexBBox\n      ? data.map((d, i) => {\n          const bbox = indexBBox.get(i);\n          if (!bbox) return d;\n          // bbox: [label, bbox]\n          // Make than indexBBox can match current label.\n          if (bbox[0] !== d.label) return d;\n          return { ...d, bbox: bbox[1] };\n        })\n      : data;\n    const finalAxisStyle = {\n      ...internalAxisStyle,\n      type: 'linear' as const,\n      data: labels,\n      crossSize: size,\n      titleText: titleContent(title),\n      labelOverlap: inferLabelOverlap(transform, internalAxisStyle),\n      grid: inferGrid(internalAxisStyle.grid, coordinate, scale),\n      gridLength,\n      // Always showLine, make title could align the end of axis.\n      line: true,\n      indexBBox,\n      ...(!internalAxisStyle.line ? { lineOpacity: 0 } : null),\n      ...overrideStyle,\n      ...threeDOverrideStyle,\n      ...important,\n    };\n\n    // For hide overlap, do not set crossSize.\n    const hasHide = finalAxisStyle.labelOverlap.find((d) => d.type === 'hide');\n    if (hasHide) finalAxisStyle.crossSize = false;\n\n    return new AxisComponent({\n      className: 'axis',\n      style: adaptor(finalAxisStyle),\n    }) as unknown as DisplayObject;\n  };\n};\n\nconst axisFactor: (\n  axis: typeof ArcAxisComponent | typeof LinearAxisComponent,\n) => GCC<AxisOptions> = (axis) => {\n  return (options) => {\n    const {\n      labelFormatter: useDefinedLabelFormatter,\n      labelFilter: userDefinedLabelFilter = () => true,\n    } = options;\n\n    return (context) => {\n      const {\n        scales: [scale],\n      } = context;\n      const ticks = scale.getTicks?.() || scale.getOptions().domain;\n      const labelFormatter =\n        typeof useDefinedLabelFormatter === 'string'\n          ? format(useDefinedLabelFormatter)\n          : useDefinedLabelFormatter;\n      const labelFilter = (datum: any, index: number, array: any[]) =>\n        userDefinedLabelFilter(ticks[index], index, ticks);\n      const normalizedOptions = {\n        ...options,\n        labelFormatter,\n        labelFilter,\n        scale,\n      };\n      return axis(normalizedOptions)(context);\n    };\n  };\n};\n\nexport const LinearAxis = axisFactor(LinearAxisComponent);\n\nexport const ArcAxis = axisFactor(ArcAxisComponent);\n\nLinearAxis.props = {\n  defaultPosition: 'center',\n  defaultSize: 45,\n  defaultOrder: 0,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12],\n};\n\nArcAxis.props = {\n  defaultPosition: 'outer',\n  defaultOrientation: 'vertical',\n  defaultSize: 45,\n  defaultOrder: 0,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12],\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}