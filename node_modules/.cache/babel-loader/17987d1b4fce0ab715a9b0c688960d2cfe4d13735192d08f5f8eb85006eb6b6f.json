{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Group } from '@antv/g';\nimport { groupBy } from '@antv/util';\nimport { AnimationType, COMBO_KEY, GraphEvent } from '../constants';\nimport { ELEMENT_TYPES } from '../constants/element';\nimport { getExtension } from '../registry/get';\nimport { cacheStyle, hasCachedStyle } from '../utils/cache';\nimport { reduceDataChanges } from '../utils/change';\nimport { isCollapsed } from '../utils/collapsibility';\nimport { markToBeDestroyed, updateStyle } from '../utils/element';\nimport { AnimateEvent, ElementLifeCycleEvent, GraphLifeCycleEvent, emit } from '../utils/event';\nimport { idOf } from '../utils/id';\nimport { assignColorByPalette, parsePalette } from '../utils/palette';\nimport { positionOf } from '../utils/position';\nimport { print } from '../utils/print';\nimport { computeElementCallbackStyle } from '../utils/style';\nimport { themeOf } from '../utils/theme';\nimport { subtract } from '../utils/vector';\nimport { setVisibility } from '../utils/visibility';\nexport class ElementController {\n  constructor(context) {\n    this.elementMap = {};\n    this.shapeTypeMap = {};\n    this.paletteStyle = {};\n    this.defaultStyle = {};\n    this.stateStyle = {};\n    this.visibilityCache = new WeakMap();\n    this.context = context;\n  }\n  init() {\n    this.initContainer();\n  }\n  initContainer() {\n    if (!this.container || this.container.destroyed) {\n      const {\n        canvas\n      } = this.context;\n      this.container = canvas.appendChild(new Group({\n        className: 'elements'\n      }));\n    }\n  }\n  emit(event, context) {\n    if (context.silence) return;\n    emit(this.context.graph, event);\n  }\n  forEachElementData(callback) {\n    ELEMENT_TYPES.forEach(elementType => {\n      const elementData = this.context.model.getElementsDataByType(elementType);\n      callback(elementType, elementData);\n    });\n  }\n  getElementType(elementType, datum) {\n    var _a;\n    const {\n      options,\n      graph\n    } = this.context;\n    const userDefinedType = ((_a = options[elementType]) === null || _a === void 0 ? void 0 : _a.type) || datum.type;\n    if (!userDefinedType) {\n      if (elementType === 'edge') return 'line';\n      // node / combo\n      else return 'circle';\n    }\n    if (typeof userDefinedType === 'string') return userDefinedType;\n    // @ts-expect-error skip type check\n    return userDefinedType.call(graph, datum);\n  }\n  getTheme(elementType) {\n    return themeOf(this.context.options)[elementType] || {};\n  }\n  getThemeStyle(elementType) {\n    return this.getTheme(elementType).style || {};\n  }\n  getThemeStateStyle(elementType, states) {\n    const {\n      state = {}\n    } = this.getTheme(elementType);\n    return Object.assign({}, ...states.map(name => state[name] || {}));\n  }\n  computePaletteStyle() {\n    const {\n      options\n    } = this.context;\n    this.paletteStyle = {};\n    this.forEachElementData((elementType, elementData) => {\n      var _a, _b;\n      const palette = Object.assign({}, parsePalette((_a = this.getTheme(elementType)) === null || _a === void 0 ? void 0 : _a.palette), parsePalette((_b = options[elementType]) === null || _b === void 0 ? void 0 : _b.palette));\n      if (palette === null || palette === void 0 ? void 0 : palette.field) {\n        Object.assign(this.paletteStyle, assignColorByPalette(elementData, palette));\n      }\n    });\n  }\n  getPaletteStyle(elementType, id) {\n    const color = this.paletteStyle[id];\n    if (!color) return {};\n    if (elementType === 'edge') return {\n      stroke: color\n    };\n    return {\n      fill: color\n    };\n  }\n  /**\n   * <zh/> 计算单个元素的默认样式\n   *\n   * <en/> compute default style of single element\n   */\n  computeElementDefaultStyle(elementType, context) {\n    var _a;\n    const {\n      options\n    } = this.context;\n    const defaultStyle = ((_a = options[elementType]) === null || _a === void 0 ? void 0 : _a.style) || {};\n    if ('transform' in defaultStyle && Array.isArray(defaultStyle.transform)) {\n      defaultStyle.transform = [...defaultStyle.transform];\n    }\n    this.defaultStyle[idOf(context.datum)] = computeElementCallbackStyle(defaultStyle, context);\n  }\n  computeElementsDefaultStyle(ids) {\n    const {\n      graph\n    } = this.context;\n    this.forEachElementData((elementType, elementData) => {\n      const length = elementData.length;\n      for (let i = 0; i < length; i++) {\n        const datum = elementData[i];\n        if (ids === undefined || ids.includes(idOf(datum))) {\n          this.computeElementDefaultStyle(elementType, {\n            datum,\n            graph\n          });\n        }\n      }\n    });\n  }\n  getDefaultStyle(id) {\n    return this.defaultStyle[id] || {};\n  }\n  getElementState(id) {\n    try {\n      const {\n        model\n      } = this.context;\n      return model.getElementState(id);\n    } catch (_a) {\n      return [];\n    }\n  }\n  /**\n   * <zh/> 获取单个元素的单个状态的样式\n   *\n   * <en/> get single state style of single element\n   */\n  getElementStateStyle(elementType, state, context) {\n    var _a, _b;\n    const {\n      options\n    } = this.context;\n    const stateStyle = ((_b = (_a = options[elementType]) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b[state]) || {};\n    return computeElementCallbackStyle(stateStyle, context);\n  }\n  /**\n   * <zh/> 计算单个元素的合并状态样式\n   *\n   * <en/> compute merged state style of single element\n   */\n  computeElementStatesStyle(elementType, states, context) {\n    this.stateStyle[idOf(context.datum)] = Object.assign({}, ...states.map(state => this.getElementStateStyle(elementType, state, context)));\n  }\n  /**\n   * <zh/> 计算全部元素的状态样式\n   *\n   * <en/> compute state style of all elements\n   * @param ids - <zh/> 计算指定元素的状态样式 | <en/> compute state style of specified elements\n   */\n  computeElementsStatesStyle(ids) {\n    const {\n      graph\n    } = this.context;\n    this.forEachElementData((elementType, elementData) => {\n      const length = elementData.length;\n      for (let i = 0; i < length; i++) {\n        const datum = elementData[i];\n        if (ids === undefined || ids.includes(idOf(datum))) {\n          const states = this.getElementState(idOf(datum));\n          this.computeElementStatesStyle(elementType, states, {\n            datum,\n            graph\n          });\n        }\n      }\n    });\n  }\n  getStateStyle(id) {\n    return this.stateStyle[id] || {};\n  }\n  computeStyle(stage, ids) {\n    const skip = ['translate', 'zIndex'];\n    if (stage && skip.includes(stage)) return;\n    this.computePaletteStyle();\n    this.computeElementsDefaultStyle(ids);\n    this.computeElementsStatesStyle(ids);\n  }\n  getElement(id) {\n    return this.elementMap[id];\n  }\n  getNodes() {\n    return this.context.model.getNodeData().map(({\n      id\n    }) => this.elementMap[id]);\n  }\n  getEdges() {\n    return this.context.model.getEdgeData().map(edge => this.elementMap[idOf(edge)]);\n  }\n  getCombos() {\n    return this.context.model.getComboData().map(({\n      id\n    }) => this.elementMap[id]);\n  }\n  getElementComputedStyle(elementType, datum) {\n    const id = idOf(datum);\n    // 优先级(从低到高) Priority (from low to high):\n    const themeStyle = this.getThemeStyle(elementType);\n    const paletteStyle = this.getPaletteStyle(elementType, id);\n    const dataStyle = datum.style || {};\n    const defaultStyle = this.getDefaultStyle(id);\n    const themeStateStyle = this.getThemeStateStyle(elementType, this.getElementState(id));\n    const stateStyle = this.getStateStyle(id);\n    const style = Object.assign({}, themeStyle, paletteStyle, dataStyle, defaultStyle, themeStateStyle, stateStyle);\n    if (elementType === 'combo') {\n      const childrenData = this.context.model.getChildrenData(id);\n      const isCollapsed = !!style.collapsed;\n      const childrenNode = isCollapsed ? [] : childrenData.map(idOf).filter(id => this.getElement(id));\n      Object.assign(style, {\n        childrenNode,\n        childrenData\n      });\n    }\n    return style;\n  }\n  getDrawData(context) {\n    this.init();\n    const data = this.computeChangesAndDrawData(context);\n    if (!data) return null;\n    const {\n      type = 'draw',\n      stage = type\n    } = context;\n    this.markDestroyElement(data.drawData);\n    // 计算样式 / Calculate style\n    this.computeStyle(stage);\n    return {\n      type,\n      stage,\n      data\n    };\n  }\n  /**\n   * <zh/> 开始绘制流程\n   *\n   * <en/> start render process\n   */\n  draw(context = {\n    animation: true\n  }) {\n    const drawData = this.getDrawData(context);\n    if (!drawData) return;\n    const {\n      data: {\n        drawData: {\n          add,\n          update,\n          remove\n        }\n      }\n    } = drawData;\n    this.destroyElements(remove, context);\n    this.createElements(add, context);\n    this.updateElements(update, context);\n    return this.setAnimationTask(context, drawData);\n  }\n  preLayoutDraw() {\n    return __awaiter(this, arguments, void 0, function* (context = {\n      animation: true\n    }) {\n      var _a, _b;\n      const preResult = this.getDrawData(context);\n      if (!preResult) return;\n      const {\n        data: {\n          drawData\n        }\n      } = preResult;\n      yield (_b = (_a = this.context.layout) === null || _a === void 0 ? void 0 : _a.preLayout) === null || _b === void 0 ? void 0 : _b.call(_a, drawData);\n      const {\n        add,\n        update,\n        remove\n      } = drawData;\n      this.destroyElements(remove, context);\n      this.createElements(add, context);\n      this.updateElements(update, context);\n      return this.setAnimationTask(context, preResult);\n    });\n  }\n  setAnimationTask(context, data) {\n    const {\n      animation,\n      silence\n    } = context;\n    const {\n      data: {\n        dataChanges,\n        drawData\n      },\n      stage,\n      type\n    } = data;\n    return this.context.animation.animate(animation, silence ? {} : {\n      before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, {\n        dataChanges,\n        animation,\n        stage,\n        render: type === 'render'\n      }), context),\n      beforeAnimate: animation => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.DRAW, animation, drawData), context),\n      afterAnimate: animation => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.DRAW, animation, drawData), context),\n      after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, {\n        dataChanges,\n        animation,\n        stage,\n        render: type === 'render',\n        firstRender: this.context.graph.rendered === false\n      }), context)\n    });\n  }\n  computeChangesAndDrawData(context) {\n    const {\n      model\n    } = this.context;\n    const dataChanges = model.getChanges();\n    const tasks = reduceDataChanges(dataChanges);\n    if (tasks.length === 0) return null;\n    const {\n      NodeAdded = [],\n      NodeUpdated = [],\n      NodeRemoved = [],\n      EdgeAdded = [],\n      EdgeUpdated = [],\n      EdgeRemoved = [],\n      ComboAdded = [],\n      ComboUpdated = [],\n      ComboRemoved = []\n    } = groupBy(tasks, change => change.type);\n    const dataOf = data => new Map(data.map(datum => {\n      const data = datum.value;\n      return [idOf(data), data];\n    }));\n    const input = {\n      add: {\n        nodes: dataOf(NodeAdded),\n        edges: dataOf(EdgeAdded),\n        combos: dataOf(ComboAdded)\n      },\n      update: {\n        nodes: dataOf(NodeUpdated),\n        edges: dataOf(EdgeUpdated),\n        combos: dataOf(ComboUpdated)\n      },\n      remove: {\n        nodes: dataOf(NodeRemoved),\n        edges: dataOf(EdgeRemoved),\n        combos: dataOf(ComboRemoved)\n      }\n    };\n    const drawData = this.transformData(input, context);\n    // 清空变更 / Clear changes\n    model.clearChanges();\n    return {\n      dataChanges,\n      drawData\n    };\n  }\n  transformData(input, context) {\n    const transforms = this.context.transform.getTransformInstance();\n    return Object.values(transforms).reduce((data, transform) => transform.beforeDraw(data, context), input);\n  }\n  createElement(elementType, datum, context) {\n    var _a;\n    const id = idOf(datum);\n    const currentElement = this.getElement(id);\n    if (currentElement) return;\n    const type = this.getElementType(elementType, datum);\n    const style = this.getElementComputedStyle(elementType, datum);\n    // get shape constructor\n    const Ctor = getExtension(elementType, type);\n    if (!Ctor) return print.warn(`The element ${type} of ${elementType} is not registered.`);\n    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_CREATE, elementType, datum), context);\n    const element = this.container.appendChild(new Ctor({\n      id,\n      context: this.context,\n      style\n    }));\n    this.shapeTypeMap[id] = type;\n    this.elementMap[id] = element;\n    const {\n      stage = 'enter'\n    } = context;\n    (_a = this.context.animation) === null || _a === void 0 ? void 0 : _a.add({\n      element,\n      elementType,\n      stage,\n      originalStyle: Object.assign({}, element.attributes),\n      updatedStyle: style\n    }, {\n      after: () => {\n        var _a;\n        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_CREATE, elementType, datum), context);\n        (_a = element.onCreate) === null || _a === void 0 ? void 0 : _a.call(element);\n      }\n    });\n  }\n  createElements(data, context) {\n    const {\n      nodes,\n      edges,\n      combos\n    } = data;\n    const iteration = [['node', nodes], ['combo', combos], ['edge', edges]];\n    iteration.forEach(([elementType, elementData]) => {\n      elementData.forEach(datum => this.createElement(elementType, datum, context));\n    });\n  }\n  getUpdateStageStyle(elementType, datum, context) {\n    const {\n      stage = 'update'\n    } = context;\n    // 优化 translate 阶段，直接返回 x, y, z，避免计算样式\n    // Optimize the translate stage, return x, y, z directly to avoid calculating style\n    if (stage === 'translate') {\n      if (elementType === 'node' || elementType === 'combo') {\n        const {\n          style: {\n            x = 0,\n            y = 0,\n            z = 0\n          } = {}\n        } = datum;\n        return {\n          x,\n          y,\n          z\n        };\n      } else return {};\n    }\n    return this.getElementComputedStyle(elementType, datum);\n  }\n  updateElement(elementType, datum, context) {\n    var _a;\n    const id = idOf(datum);\n    const {\n      stage = 'update'\n    } = context;\n    const element = this.getElement(id);\n    if (!element) return () => null;\n    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_UPDATE, elementType, datum), context);\n    const type = this.getElementType(elementType, datum);\n    const style = this.getUpdateStageStyle(elementType, datum, context);\n    // 如果类型不同，需要先销毁原有元素，再创建新元素\n    // If the type is different, you need to destroy the original element first, and then create a new element\n    if (this.shapeTypeMap[id] !== type) {\n      element.destroy();\n      delete this.shapeTypeMap[id];\n      delete this.elementMap[id];\n      this.createElement(elementType, datum, {\n        animation: false,\n        silence: true\n      });\n    }\n    const exactStage = stage !== 'visibility' ? stage : style.visibility === 'hidden' ? 'hide' : 'show';\n    // 避免立即将 visibility 设置为 hidden，导致元素不可见，而是在 after 阶段再设置\n    // Avoid setting visibility to hidden immediately, causing the element to be invisible, but set it in the after phase\n    if (exactStage === 'hide') delete style['visibility'];\n    (_a = this.context.animation) === null || _a === void 0 ? void 0 : _a.add({\n      element,\n      elementType,\n      stage: exactStage,\n      originalStyle: Object.assign({}, element.attributes),\n      updatedStyle: style\n    }, {\n      before: () => {\n        // 通过 elementMap[id] 访问最新的 element，防止 type 不同导致的 element 丢失\n        // Access the latest element through elementMap[id] to prevent the loss of element caused by different types\n        const element = this.elementMap[id];\n        if (stage !== 'collapse') updateStyle(element, style);\n        if (stage === 'visibility') {\n          // 缓存原始透明度 / Cache original opacity\n          // 会在 animation controller 中访问该缓存值 / The cached value will be accessed in the animation controller\n          if (!hasCachedStyle(element, 'opacity')) cacheStyle(element, 'opacity');\n          this.visibilityCache.set(element, exactStage === 'show' ? 'visible' : 'hidden');\n          if (exactStage === 'show') setVisibility(element, 'visible');\n        }\n      },\n      after: () => {\n        var _a;\n        const element = this.elementMap[id];\n        if (stage === 'collapse') updateStyle(element, style);\n        if (exactStage === 'hide') setVisibility(element, this.visibilityCache.get(element));\n        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_UPDATE, elementType, datum), context);\n        (_a = element.onUpdate) === null || _a === void 0 ? void 0 : _a.call(element);\n      }\n    });\n  }\n  updateElements(data, context) {\n    const {\n      nodes,\n      edges,\n      combos\n    } = data;\n    const iteration = [['node', nodes], ['combo', combos], ['edge', edges]];\n    iteration.forEach(([elementType, elementData]) => {\n      elementData.forEach(datum => this.updateElement(elementType, datum, context));\n    });\n  }\n  /**\n   * <zh/> 标记销毁元素\n   *\n   * <en/> mark destroy element\n   * @param data - <zh/> 绘制数据 | <en/> draw data\n   */\n  markDestroyElement(data) {\n    Object.values(data.remove).forEach(elementData => {\n      elementData.forEach(datum => {\n        const id = idOf(datum);\n        const element = this.getElement(id);\n        if (element) markToBeDestroyed(element);\n      });\n    });\n  }\n  destroyElement(elementType, datum, context) {\n    var _a;\n    const {\n      stage = 'exit'\n    } = context;\n    const id = idOf(datum);\n    const element = this.elementMap[id];\n    if (!element) return () => null;\n    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_DESTROY, elementType, datum), context);\n    (_a = this.context.animation) === null || _a === void 0 ? void 0 : _a.add({\n      element,\n      elementType,\n      stage,\n      originalStyle: Object.assign({}, element.attributes),\n      updatedStyle: {}\n    }, {\n      after: () => {\n        var _a;\n        this.clearElement(id);\n        element.destroy();\n        (_a = element.onDestroy) === null || _a === void 0 ? void 0 : _a.call(element);\n        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_DESTROY, elementType, datum), context);\n      }\n    });\n  }\n  destroyElements(data, context) {\n    const {\n      nodes,\n      edges,\n      combos\n    } = data;\n    const iteration = [['combo', combos], ['edge', edges], ['node', nodes]];\n    iteration.forEach(([elementType, elementData]) => {\n      elementData.forEach(datum => this.destroyElement(elementType, datum, context));\n    });\n    // TODO 重新计算色板样式，如果是分组色板，则不需要重新计算\n  }\n  clearElement(id) {\n    delete this.paletteStyle[id];\n    delete this.defaultStyle[id];\n    delete this.stateStyle[id];\n    delete this.elementMap[id];\n    delete this.shapeTypeMap[id];\n  }\n  /**\n   * <zh/> 将布局结果对齐到元素，避免视图偏移。会修改布局结果\n   *\n   * <en/> Align the layout result to the element to avoid view offset. Will modify the layout result\n   * @param layoutResult - <zh/> 布局结果 | <en/> layout result\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   */\n  alignLayoutResultToElement(layoutResult, id) {\n    var _a, _b;\n    const target = (_a = layoutResult.nodes) === null || _a === void 0 ? void 0 : _a.find(node => idOf(node) === id);\n    if (target) {\n      const originalPosition = positionOf(this.context.model.getNodeLikeDatum(id));\n      const modifiedPosition = positionOf(target);\n      const delta = subtract(originalPosition, modifiedPosition);\n      (_b = layoutResult.nodes) === null || _b === void 0 ? void 0 : _b.forEach(node => {\n        var _a, _b, _c;\n        if ((_a = node.style) === null || _a === void 0 ? void 0 : _a.x) node.style.x += delta[0];\n        if ((_b = node.style) === null || _b === void 0 ? void 0 : _b.y) node.style.y += delta[1];\n        if ((_c = node.style) === null || _c === void 0 ? void 0 : _c.z) node.style.z += delta[2] || 0;\n      });\n    }\n  }\n  /**\n   * <zh/> 收起节点\n   *\n   * <en/> collapse node\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param options - <zh/> 选项 | <en/> options\n   */\n  collapseNode(id, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const {\n        animation\n      } = options;\n      const {\n        model\n      } = this.context;\n      // 重新计算数据 / Recalculate data\n      const data = this.computeChangesAndDrawData({\n        stage: 'collapse',\n        animation\n      });\n      if (!data) return;\n      const {\n        drawData\n      } = data;\n      const {\n        add,\n        remove,\n        update\n      } = drawData;\n      this.markDestroyElement(drawData);\n      const context = {\n        animation,\n        stage: 'collapse',\n        data: drawData\n      };\n      this.destroyElements(remove, context);\n      this.createElements(add, context);\n      this.updateElements(update, context);\n      yield (_a = this.context.animation.animate(animation, {\n        beforeAnimate: animation => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation, drawData), context),\n        afterAnimate: animation => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation, drawData), context)\n      }, {\n        collapse: {\n          target: id,\n          descendants: Array.from(remove.nodes).map(([, node]) => idOf(node)),\n          position: positionOf(update.nodes.get(id))\n        }\n      })) === null || _a === void 0 ? void 0 : _a.finished;\n    });\n  }\n  /**\n   * <zh/> 展开节点\n   *\n   * <en/> expand node\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 是否使用动画，默认为 true | <en/> Whether to use animation, default is true\n   */\n  expandNode(id, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const {\n        model,\n        layout\n      } = this.context;\n      const {\n        animation,\n        align\n      } = options;\n      const position = positionOf(model.getNodeData([id])[0]);\n      // 重新计算数据 / Recalculate data\n      const data = this.computeChangesAndDrawData({\n        stage: 'expand',\n        animation\n      });\n      this.createElements(data.drawData.add, {\n        animation: false,\n        stage: 'expand',\n        target: id\n      });\n      // 重置动画 / Reset animation\n      this.context.animation.clear();\n      this.computeStyle('expand');\n      if (!data) return;\n      const {\n        drawData\n      } = data;\n      const {\n        update,\n        add\n      } = drawData;\n      const context = {\n        animation,\n        stage: 'expand',\n        data: drawData\n      };\n      // 将新增节点/边添加到更新列表 / Add new nodes/edges to the update list\n      add.edges.forEach(edge => update.edges.set(idOf(edge), edge));\n      add.nodes.forEach(node => update.nodes.set(idOf(node), node));\n      this.updateElements(update, context);\n      yield (_a = this.context.animation.animate(animation, {\n        beforeAnimate: animation => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation, drawData), context),\n        afterAnimate: animation => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation, drawData), context)\n      }, {\n        expand: {\n          target: id,\n          descendants: Array.from(add.nodes).map(([, node]) => idOf(node)),\n          position\n        }\n      })) === null || _a === void 0 ? void 0 : _a.finished;\n    });\n  }\n  collapseCombo(id, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const {\n        model,\n        element\n      } = this.context;\n      if (model.getAncestorsData(id, COMBO_KEY).some(datum => isCollapsed(datum))) return;\n      const combo = element.getElement(id);\n      const position = combo.getComboPosition(Object.assign(Object.assign({}, combo.attributes), {\n        collapsed: true\n      }));\n      const data = this.computeChangesAndDrawData({\n        stage: 'collapse',\n        animation\n      });\n      if (!data) return;\n      const {\n        dataChanges,\n        drawData\n      } = data;\n      this.markDestroyElement(drawData);\n      const {\n        update,\n        remove\n      } = drawData;\n      const context = {\n        animation,\n        stage: 'collapse',\n        data: drawData\n      };\n      this.destroyElements(remove, context);\n      this.updateElements(update, context);\n      const idsOf = data => Array.from(data).map(([, node]) => idOf(node));\n      yield (_a = this.context.animation.animate(animation, {\n        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, {\n          dataChanges,\n          animation\n        }), context),\n        beforeAnimate: animation => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation, drawData), context),\n        afterAnimate: animation => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation, drawData), context),\n        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, {\n          dataChanges,\n          animation\n        }), context)\n      }, {\n        collapse: {\n          target: id,\n          descendants: [...idsOf(remove.nodes), ...idsOf(remove.combos)],\n          position\n        }\n      })) === null || _a === void 0 ? void 0 : _a.finished;\n    });\n  }\n  expandCombo(id, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const {\n        model\n      } = this.context;\n      const position = positionOf(model.getComboData([id])[0]);\n      // 重新计算数据 / Recalculate data\n      this.computeStyle('expand');\n      const data = this.computeChangesAndDrawData({\n        stage: 'expand',\n        animation\n      });\n      if (!data) return;\n      const {\n        dataChanges,\n        drawData\n      } = data;\n      const {\n        add,\n        update\n      } = drawData;\n      const context = {\n        animation,\n        stage: 'expand',\n        data: drawData,\n        target: id\n      };\n      this.createElements(add, context);\n      this.updateElements(update, context);\n      const idsOf = data => Array.from(data).map(([, node]) => idOf(node));\n      yield (_a = this.context.animation.animate(animation, {\n        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, {\n          dataChanges,\n          animation\n        }), context),\n        beforeAnimate: animation => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation, drawData), context),\n        afterAnimate: animation => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation, drawData), context),\n        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, {\n          dataChanges,\n          animation\n        }), context)\n      }, {\n        expand: {\n          target: id,\n          descendants: [...idsOf(add.nodes), ...idsOf(add.combos)],\n          position\n        }\n      })) === null || _a === void 0 ? void 0 : _a.finished;\n    });\n  }\n  /**\n   * <zh/> 清空所有元素\n   *\n   * <en/> clear all elements\n   */\n  clear() {\n    this.container.destroy();\n    this.initContainer();\n    this.elementMap = {};\n    this.shapeTypeMap = {};\n    this.defaultStyle = {};\n    this.stateStyle = {};\n    this.paletteStyle = {};\n  }\n  destroy() {\n    this.clear();\n    this.container.destroy();\n    // @ts-expect-error force delete\n    this.context = {};\n  }\n}","map":{"version":3,"names":["Group","groupBy","AnimationType","COMBO_KEY","GraphEvent","ELEMENT_TYPES","getExtension","cacheStyle","hasCachedStyle","reduceDataChanges","isCollapsed","markToBeDestroyed","updateStyle","AnimateEvent","ElementLifeCycleEvent","GraphLifeCycleEvent","emit","idOf","assignColorByPalette","parsePalette","positionOf","print","computeElementCallbackStyle","themeOf","subtract","setVisibility","ElementController","constructor","context","elementMap","shapeTypeMap","paletteStyle","defaultStyle","stateStyle","visibilityCache","WeakMap","init","initContainer","container","destroyed","canvas","appendChild","className","event","silence","graph","forEachElementData","callback","forEach","elementType","elementData","model","getElementsDataByType","getElementType","datum","options","userDefinedType","_a","type","call","getTheme","getThemeStyle","style","getThemeStateStyle","states","state","Object","assign","map","name","computePaletteStyle","palette","_b","field","getPaletteStyle","id","color","stroke","fill","computeElementDefaultStyle","Array","isArray","transform","computeElementsDefaultStyle","ids","length","i","undefined","includes","getDefaultStyle","getElementState","getElementStateStyle","computeElementStatesStyle","computeElementsStatesStyle","getStateStyle","computeStyle","stage","skip","getElement","getNodes","getNodeData","getEdges","getEdgeData","edge","getCombos","getComboData","getElementComputedStyle","themeStyle","dataStyle","themeStateStyle","childrenData","getChildrenData","collapsed","childrenNode","filter","getDrawData","data","computeChangesAndDrawData","markDestroyElement","drawData","draw","animation","add","update","remove","destroyElements","createElements","updateElements","setAnimationTask","preLayoutDraw","preResult","layout","preLayout","dataChanges","animate","before","BEFORE_DRAW","render","beforeAnimate","BEFORE_ANIMATE","DRAW","afterAnimate","AFTER_ANIMATE","after","AFTER_DRAW","firstRender","rendered","getChanges","tasks","NodeAdded","NodeUpdated","NodeRemoved","EdgeAdded","EdgeUpdated","EdgeRemoved","ComboAdded","ComboUpdated","ComboRemoved","change","dataOf","Map","value","input","nodes","edges","combos","transformData","clearChanges","transforms","getTransformInstance","values","reduce","beforeDraw","createElement","currentElement","Ctor","warn","BEFORE_ELEMENT_CREATE","element","originalStyle","attributes","updatedStyle","AFTER_ELEMENT_CREATE","onCreate","iteration","getUpdateStageStyle","x","y","z","updateElement","BEFORE_ELEMENT_UPDATE","destroy","exactStage","visibility","set","get","AFTER_ELEMENT_UPDATE","onUpdate","destroyElement","BEFORE_ELEMENT_DESTROY","clearElement","onDestroy","AFTER_ELEMENT_DESTROY","alignLayoutResultToElement","layoutResult","target","find","node","originalPosition","getNodeLikeDatum","modifiedPosition","delta","_c","collapseNode","COLLAPSE","collapse","descendants","from","position","finished","expandNode","align","clear","EXPAND","expand","collapseCombo","getAncestorsData","some","combo","getComboPosition","idsOf","expandCombo"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/runtime/element.ts"],"sourcesContent":["/* eslint-disable jsdoc/require-returns */\n/* eslint-disable jsdoc/require-param */\nimport type { BaseStyleProps } from '@antv/g';\nimport { Group } from '@antv/g';\nimport { groupBy } from '@antv/util';\nimport { AnimationType, COMBO_KEY, ChangeType, GraphEvent } from '../constants';\nimport { ELEMENT_TYPES } from '../constants/element';\nimport { getExtension } from '../registry/get';\nimport type { ComboData, EdgeData, GraphData, NodeData } from '../spec';\nimport type { AnimationStage } from '../spec/element/animation';\nimport type { DrawData, ProcedureData } from '../transforms/types';\nimport type {\n  Combo,\n  DataChange,\n  Edge,\n  Element,\n  ElementData,\n  ElementDatum,\n  ElementType,\n  ID,\n  Node,\n  NodeLikeData,\n  State,\n  StyleIterationContext,\n} from '../types';\nimport { cacheStyle, hasCachedStyle } from '../utils/cache';\nimport { reduceDataChanges } from '../utils/change';\nimport { isCollapsed } from '../utils/collapsibility';\nimport { markToBeDestroyed, updateStyle } from '../utils/element';\nimport type { BaseEvent } from '../utils/event';\nimport { AnimateEvent, ElementLifeCycleEvent, GraphLifeCycleEvent, emit } from '../utils/event';\nimport { idOf } from '../utils/id';\nimport { assignColorByPalette, parsePalette } from '../utils/palette';\nimport { positionOf } from '../utils/position';\nimport { print } from '../utils/print';\nimport { computeElementCallbackStyle } from '../utils/style';\nimport { themeOf } from '../utils/theme';\nimport { subtract } from '../utils/vector';\nimport { setVisibility } from '../utils/visibility';\nimport type { RuntimeContext } from './types';\n\nexport class ElementController {\n  private context: RuntimeContext;\n\n  private container!: Group;\n\n  private elementMap: Record<ID, Element> = {};\n\n  private shapeTypeMap: Record<ID, string> = {};\n\n  constructor(context: RuntimeContext) {\n    this.context = context;\n  }\n\n  public init() {\n    this.initContainer();\n  }\n\n  private initContainer() {\n    if (!this.container || this.container.destroyed) {\n      const { canvas } = this.context;\n      this.container = canvas.appendChild(new Group({ className: 'elements' }));\n    }\n  }\n\n  private emit(event: BaseEvent, context: DrawContext) {\n    if (context.silence) return;\n    emit(this.context.graph, event);\n  }\n\n  private forEachElementData(callback: (elementType: ElementType, elementData: ElementData) => void) {\n    ELEMENT_TYPES.forEach((elementType) => {\n      const elementData = this.context.model.getElementsDataByType(elementType);\n      callback(elementType, elementData);\n    });\n  }\n\n  public getElementType(elementType: ElementType, datum: ElementDatum) {\n    const { options, graph } = this.context;\n    const userDefinedType = options[elementType]?.type || datum.type;\n\n    if (!userDefinedType) {\n      if (elementType === 'edge') return 'line';\n      // node / combo\n      else return 'circle';\n    }\n    if (typeof userDefinedType === 'string') return userDefinedType;\n    // @ts-expect-error skip type check\n    return userDefinedType.call(graph, datum);\n  }\n\n  private getTheme(elementType: ElementType) {\n    return themeOf(this.context.options)[elementType] || {};\n  }\n\n  public getThemeStyle(elementType: ElementType) {\n    return this.getTheme(elementType).style || {};\n  }\n\n  public getThemeStateStyle(elementType: ElementType, states: State[]) {\n    const { state = {} } = this.getTheme(elementType);\n    return Object.assign({}, ...states.map((name) => state[name] || {}));\n  }\n\n  private paletteStyle: Record<ID, string> = {};\n\n  private computePaletteStyle() {\n    const { options } = this.context;\n\n    this.paletteStyle = {};\n\n    this.forEachElementData((elementType, elementData) => {\n      const palette = Object.assign(\n        {},\n        parsePalette(this.getTheme(elementType)?.palette),\n        parsePalette(options[elementType]?.palette),\n      );\n      if (palette?.field) {\n        Object.assign(this.paletteStyle, assignColorByPalette(elementData, palette));\n      }\n    });\n  }\n\n  public getPaletteStyle(elementType: ElementType, id: ID): BaseStyleProps {\n    const color = this.paletteStyle[id];\n    if (!color) return {};\n\n    if (elementType === 'edge') return { stroke: color };\n    return { fill: color };\n  }\n\n  private defaultStyle: Record<ID, Record<string, unknown>> = {};\n\n  /**\n   * <zh/> 计算单个元素的默认样式\n   *\n   * <en/> compute default style of single element\n   */\n  private computeElementDefaultStyle(elementType: ElementType, context: StyleIterationContext) {\n    const { options } = this.context;\n    const defaultStyle = options[elementType]?.style || {};\n    if ('transform' in defaultStyle && Array.isArray(defaultStyle.transform)) {\n      defaultStyle.transform = [...defaultStyle.transform];\n    }\n    this.defaultStyle[idOf(context.datum)] = computeElementCallbackStyle(defaultStyle as any, context);\n  }\n\n  private computeElementsDefaultStyle(ids?: ID[]) {\n    const { graph } = this.context;\n    this.forEachElementData((elementType, elementData) => {\n      const length = elementData.length;\n      for (let i = 0; i < length; i++) {\n        const datum = elementData[i];\n        if (ids === undefined || ids.includes(idOf(datum))) {\n          this.computeElementDefaultStyle(elementType, { datum, graph });\n        }\n      }\n    });\n  }\n\n  public getDefaultStyle(id: ID) {\n    return this.defaultStyle[id] || {};\n  }\n\n  private getElementState(id: ID) {\n    try {\n      const { model } = this.context;\n      return model.getElementState(id);\n    } catch {\n      return [];\n    }\n  }\n\n  private stateStyle: Record<ID, Record<string, unknown>> = {};\n\n  /**\n   * <zh/> 获取单个元素的单个状态的样式\n   *\n   * <en/> get single state style of single element\n   */\n  private getElementStateStyle(elementType: ElementType, state: State, context: StyleIterationContext) {\n    const { options } = this.context;\n    const stateStyle = options[elementType]?.state?.[state] || {};\n    return computeElementCallbackStyle(stateStyle as any, context);\n  }\n\n  /**\n   * <zh/> 计算单个元素的合并状态样式\n   *\n   * <en/> compute merged state style of single element\n   */\n  private computeElementStatesStyle(elementType: ElementType, states: State[], context: StyleIterationContext) {\n    this.stateStyle[idOf(context.datum)] = Object.assign(\n      {},\n      ...states.map((state) => this.getElementStateStyle(elementType, state, context)),\n    );\n  }\n\n  /**\n   * <zh/> 计算全部元素的状态样式\n   *\n   * <en/> compute state style of all elements\n   * @param ids - <zh/> 计算指定元素的状态样式 | <en/> compute state style of specified elements\n   */\n  private computeElementsStatesStyle(ids?: ID[]) {\n    const { graph } = this.context;\n    this.forEachElementData((elementType, elementData) => {\n      const length = elementData.length;\n      for (let i = 0; i < length; i++) {\n        const datum = elementData[i];\n        if (ids === undefined || ids.includes(idOf(datum))) {\n          const states = this.getElementState(idOf(datum));\n          this.computeElementStatesStyle(elementType, states, { datum, graph });\n        }\n      }\n    });\n  }\n\n  public getStateStyle(id: ID) {\n    return this.stateStyle[id] || {};\n  }\n\n  private computeStyle(stage?: string, ids?: ID[]) {\n    const skip = ['translate', 'zIndex'];\n    if (stage && skip.includes(stage)) return;\n\n    this.computePaletteStyle();\n    this.computeElementsDefaultStyle(ids);\n    this.computeElementsStatesStyle(ids);\n  }\n\n  public getElement<T extends Element>(id: ID): T | undefined {\n    return this.elementMap[id] as T;\n  }\n\n  public getNodes() {\n    return this.context.model.getNodeData().map(({ id }) => this.elementMap[id]) as Node[];\n  }\n\n  public getEdges() {\n    return this.context.model.getEdgeData().map((edge) => this.elementMap[idOf(edge)]) as Edge[];\n  }\n\n  public getCombos() {\n    return this.context.model.getComboData().map(({ id }) => this.elementMap[id]) as Combo[];\n  }\n\n  public getElementComputedStyle(elementType: ElementType, datum: ElementDatum) {\n    const id = idOf(datum);\n    // 优先级(从低到高) Priority (from low to high):\n    const themeStyle = this.getThemeStyle(elementType);\n    const paletteStyle = this.getPaletteStyle(elementType, id);\n    const dataStyle = datum.style || {};\n    const defaultStyle = this.getDefaultStyle(id);\n    const themeStateStyle = this.getThemeStateStyle(elementType, this.getElementState(id));\n    const stateStyle = this.getStateStyle(id);\n\n    const style = Object.assign({}, themeStyle, paletteStyle, dataStyle, defaultStyle, themeStateStyle, stateStyle);\n\n    if (elementType === 'combo') {\n      const childrenData = this.context.model.getChildrenData(id);\n      const isCollapsed = !!style.collapsed;\n      const childrenNode = isCollapsed ? [] : childrenData.map(idOf).filter((id) => this.getElement(id));\n      Object.assign(style, { childrenNode, childrenData });\n    }\n    return style;\n  }\n\n  private getDrawData(context: DrawContext): DrawPayload | null {\n    this.init();\n\n    const data = this.computeChangesAndDrawData(context);\n    if (!data) return null;\n\n    const { type = 'draw', stage = type } = context;\n    this.markDestroyElement(data.drawData);\n    // 计算样式 / Calculate style\n    this.computeStyle(stage);\n\n    return { type, stage, data };\n  }\n\n  /**\n   * <zh/> 开始绘制流程\n   *\n   * <en/> start render process\n   */\n  public draw(context: DrawContext = { animation: true }) {\n    const drawData = this.getDrawData(context);\n    if (!drawData) return;\n\n    const {\n      data: {\n        drawData: { add, update, remove },\n      },\n    } = drawData;\n\n    this.destroyElements(remove, context);\n    this.createElements(add, context);\n    this.updateElements(update, context);\n\n    return this.setAnimationTask(context, drawData);\n  }\n\n  public async preLayoutDraw(context: DrawContext = { animation: true }) {\n    const preResult = this.getDrawData(context);\n    if (!preResult) return;\n\n    const {\n      data: { drawData },\n    } = preResult;\n\n    await this.context.layout?.preLayout?.(drawData);\n\n    const { add, update, remove } = drawData;\n    this.destroyElements(remove, context);\n    this.createElements(add, context);\n    this.updateElements(update, context);\n\n    return this.setAnimationTask(context, preResult);\n  }\n\n  private setAnimationTask(context: DrawContext, data: DrawPayload) {\n    const { animation, silence } = context;\n    const {\n      data: { dataChanges, drawData },\n      stage,\n      type,\n    } = data;\n\n    return this.context.animation!.animate(\n      animation,\n      silence\n        ? {}\n        : {\n            before: () =>\n              this.emit(\n                new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, {\n                  dataChanges,\n                  animation,\n                  stage,\n                  render: type === 'render',\n                }),\n                context,\n              ),\n            beforeAnimate: (animation) =>\n              this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.DRAW, animation, drawData), context),\n            afterAnimate: (animation) =>\n              this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.DRAW, animation, drawData), context),\n            after: () =>\n              this.emit(\n                new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, {\n                  dataChanges,\n                  animation,\n                  stage,\n                  render: type === 'render',\n                  firstRender: this.context.graph.rendered === false,\n                }),\n                context,\n              ),\n          },\n    );\n  }\n\n  private computeChangesAndDrawData(context: DrawContext) {\n    const { model } = this.context;\n    const dataChanges = model.getChanges();\n    const tasks = reduceDataChanges(dataChanges);\n    if (tasks.length === 0) return null;\n\n    const {\n      NodeAdded = [],\n      NodeUpdated = [],\n      NodeRemoved = [],\n      EdgeAdded = [],\n      EdgeUpdated = [],\n      EdgeRemoved = [],\n      ComboAdded = [],\n      ComboUpdated = [],\n      ComboRemoved = [],\n    } = groupBy(tasks, (change) => change.type) as unknown as Record<`${ChangeType}`, DataChange[]>;\n\n    const dataOf = <T extends DataChange['value']>(data: DataChange[]) =>\n      new Map(\n        data.map((datum) => {\n          const data = datum.value;\n          return [idOf(data), data] as [ID, T];\n        }),\n      );\n\n    const input: DrawData = {\n      add: {\n        nodes: dataOf<NodeData>(NodeAdded),\n        edges: dataOf<EdgeData>(EdgeAdded),\n        combos: dataOf<ComboData>(ComboAdded),\n      },\n      update: {\n        nodes: dataOf<NodeData>(NodeUpdated),\n        edges: dataOf<EdgeData>(EdgeUpdated),\n        combos: dataOf<ComboData>(ComboUpdated),\n      },\n      remove: {\n        nodes: dataOf<NodeData>(NodeRemoved),\n        edges: dataOf<EdgeData>(EdgeRemoved),\n        combos: dataOf<ComboData>(ComboRemoved),\n      },\n    };\n    const drawData = this.transformData(input, context);\n\n    // 清空变更 / Clear changes\n    model.clearChanges();\n\n    return { dataChanges, drawData };\n  }\n\n  private transformData(input: DrawData, context: DrawContext): DrawData {\n    const transforms = this.context.transform.getTransformInstance();\n\n    return Object.values(transforms).reduce((data, transform) => transform.beforeDraw(data, context), input);\n  }\n\n  private createElement(elementType: ElementType, datum: ElementDatum, context: DrawContext) {\n    const id = idOf(datum);\n    const currentElement = this.getElement(id);\n    if (currentElement) return;\n    const type = this.getElementType(elementType, datum);\n    const style = this.getElementComputedStyle(elementType, datum);\n\n    // get shape constructor\n    const Ctor = getExtension(elementType, type);\n    if (!Ctor) return print.warn(`The element ${type} of ${elementType} is not registered.`);\n\n    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_CREATE, elementType, datum), context);\n\n    const element = this.container.appendChild(\n      new Ctor({\n        id,\n        context: this.context,\n        style,\n      }),\n    ) as Element;\n\n    this.shapeTypeMap[id] = type;\n    this.elementMap[id] = element;\n\n    const { stage = 'enter' } = context;\n\n    this.context.animation?.add(\n      {\n        element,\n        elementType,\n        stage,\n        originalStyle: { ...element.attributes },\n        updatedStyle: style,\n      },\n      {\n        after: () => {\n          this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_CREATE, elementType, datum), context);\n          element.onCreate?.();\n        },\n      },\n    );\n  }\n\n  private createElements(data: ProcedureData, context: DrawContext) {\n    const { nodes, edges, combos } = data;\n    const iteration: [ElementType, Map<ID, ElementDatum>][] = [\n      ['node', nodes],\n      ['combo', combos],\n      ['edge', edges],\n    ];\n\n    iteration.forEach(([elementType, elementData]) => {\n      elementData.forEach((datum) => this.createElement(elementType, datum, context));\n    });\n  }\n\n  private getUpdateStageStyle(elementType: ElementType, datum: ElementDatum, context: DrawContext) {\n    const { stage = 'update' } = context;\n\n    // 优化 translate 阶段，直接返回 x, y, z，避免计算样式\n    // Optimize the translate stage, return x, y, z directly to avoid calculating style\n    if (stage === 'translate') {\n      if (elementType === 'node' || elementType === 'combo') {\n        const { style: { x = 0, y = 0, z = 0 } = {} } = datum as NodeLikeData;\n        return { x, y, z };\n      } else return {};\n    }\n\n    return this.getElementComputedStyle(elementType, datum);\n  }\n\n  private updateElement(elementType: ElementType, datum: ElementDatum, context: DrawContext) {\n    const id = idOf(datum);\n    const { stage = 'update' } = context;\n\n    const element = this.getElement(id);\n    if (!element) return () => null;\n\n    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_UPDATE, elementType, datum), context);\n\n    const type = this.getElementType(elementType, datum);\n    const style = this.getUpdateStageStyle(elementType, datum, context);\n\n    // 如果类型不同，需要先销毁原有元素，再创建新元素\n    // If the type is different, you need to destroy the original element first, and then create a new element\n    if (this.shapeTypeMap[id] !== type) {\n      element.destroy();\n      delete this.shapeTypeMap[id];\n      delete this.elementMap[id];\n\n      this.createElement(elementType, datum, { animation: false, silence: true });\n    }\n\n    const exactStage = stage !== 'visibility' ? stage : style.visibility === 'hidden' ? 'hide' : 'show';\n\n    // 避免立即将 visibility 设置为 hidden，导致元素不可见，而是在 after 阶段再设置\n    // Avoid setting visibility to hidden immediately, causing the element to be invisible, but set it in the after phase\n    if (exactStage === 'hide') delete style['visibility'];\n\n    this.context.animation?.add(\n      {\n        element,\n        elementType,\n        stage: exactStage,\n        originalStyle: { ...element.attributes },\n        updatedStyle: style,\n      },\n      {\n        before: () => {\n          // 通过 elementMap[id] 访问最新的 element，防止 type 不同导致的 element 丢失\n          // Access the latest element through elementMap[id] to prevent the loss of element caused by different types\n          const element = this.elementMap[id];\n          if (stage !== 'collapse') updateStyle(element, style);\n\n          if (stage === 'visibility') {\n            // 缓存原始透明度 / Cache original opacity\n            // 会在 animation controller 中访问该缓存值 / The cached value will be accessed in the animation controller\n            if (!hasCachedStyle(element, 'opacity')) cacheStyle(element, 'opacity');\n            this.visibilityCache.set(element, exactStage === 'show' ? 'visible' : 'hidden');\n            if (exactStage === 'show') setVisibility(element, 'visible');\n          }\n        },\n        after: () => {\n          const element = this.elementMap[id];\n          if (stage === 'collapse') updateStyle(element, style);\n          if (exactStage === 'hide') setVisibility(element, this.visibilityCache.get(element));\n          this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_UPDATE, elementType, datum), context);\n          element.onUpdate?.();\n        },\n      },\n    );\n  }\n\n  private updateElements(data: ProcedureData, context: DrawContext) {\n    const { nodes, edges, combos } = data;\n    const iteration: [ElementType, Map<ID, ElementDatum>][] = [\n      ['node', nodes],\n      ['combo', combos],\n      ['edge', edges],\n    ];\n\n    iteration.forEach(([elementType, elementData]) => {\n      elementData.forEach((datum) => this.updateElement(elementType, datum, context));\n    });\n  }\n\n  private visibilityCache = new WeakMap<Element, BaseStyleProps['visibility']>();\n\n  /**\n   * <zh/> 标记销毁元素\n   *\n   * <en/> mark destroy element\n   * @param data - <zh/> 绘制数据 | <en/> draw data\n   */\n  private markDestroyElement(data: DrawData) {\n    Object.values(data.remove).forEach((elementData) => {\n      elementData.forEach((datum) => {\n        const id = idOf(datum);\n        const element = this.getElement(id);\n        if (element) markToBeDestroyed(element);\n      });\n    });\n  }\n\n  private destroyElement(elementType: ElementType, datum: ElementDatum, context: DrawContext) {\n    const { stage = 'exit' } = context;\n    const id = idOf(datum);\n    const element = this.elementMap[id];\n    if (!element) return () => null;\n\n    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_DESTROY, elementType, datum), context);\n\n    this.context.animation?.add(\n      {\n        element,\n        elementType,\n        stage,\n        originalStyle: { ...element.attributes },\n        updatedStyle: {},\n      },\n      {\n        after: () => {\n          this.clearElement(id);\n          element.destroy();\n          element.onDestroy?.();\n          this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_DESTROY, elementType, datum), context);\n        },\n      },\n    );\n  }\n\n  private destroyElements(data: ProcedureData, context: DrawContext) {\n    const { nodes, edges, combos } = data;\n    const iteration: [ElementType, Map<ID, ElementDatum>][] = [\n      ['combo', combos],\n      ['edge', edges],\n      ['node', nodes],\n    ];\n\n    iteration.forEach(([elementType, elementData]) => {\n      elementData.forEach((datum) => this.destroyElement(elementType, datum, context));\n    });\n\n    // TODO 重新计算色板样式，如果是分组色板，则不需要重新计算\n  }\n\n  private clearElement(id: ID) {\n    delete this.paletteStyle[id];\n    delete this.defaultStyle[id];\n    delete this.stateStyle[id];\n    delete this.elementMap[id];\n    delete this.shapeTypeMap[id];\n  }\n\n  /**\n   * <zh/> 将布局结果对齐到元素，避免视图偏移。会修改布局结果\n   *\n   * <en/> Align the layout result to the element to avoid view offset. Will modify the layout result\n   * @param layoutResult - <zh/> 布局结果 | <en/> layout result\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   */\n  private alignLayoutResultToElement(layoutResult: GraphData, id: ID) {\n    const target = layoutResult.nodes?.find((node) => idOf(node) === id);\n\n    if (target) {\n      const originalPosition = positionOf(this.context.model.getNodeLikeDatum(id));\n      const modifiedPosition = positionOf(target);\n      const delta = subtract(originalPosition, modifiedPosition);\n      layoutResult.nodes?.forEach((node) => {\n        if (node.style?.x) node.style.x += delta[0];\n        if (node.style?.y) node.style.y += delta[1];\n        if (node.style?.z) node.style.z += delta[2] || 0;\n      });\n    }\n  }\n\n  /**\n   * <zh/> 收起节点\n   *\n   * <en/> collapse node\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param options - <zh/> 选项 | <en/> options\n   */\n  public async collapseNode(id: ID, options: CollapseExpandNodeOptions): Promise<void> {\n    const { animation } = options;\n    const { model } = this.context;\n\n    // 重新计算数据 / Recalculate data\n    const data = this.computeChangesAndDrawData({ stage: 'collapse', animation });\n    if (!data) return;\n    const { drawData } = data;\n    const { add, remove, update } = drawData;\n    this.markDestroyElement(drawData);\n    const context = { animation, stage: 'collapse', data: drawData } as const;\n\n    this.destroyElements(remove, context);\n    this.createElements(add, context);\n    this.updateElements(update, context);\n\n    await this.context.animation!.animate(\n      animation,\n      {\n        beforeAnimate: (animation) =>\n          this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation, drawData), context),\n        afterAnimate: (animation) =>\n          this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation, drawData), context),\n      },\n      {\n        collapse: {\n          target: id,\n          descendants: Array.from(remove.nodes).map(([, node]) => idOf(node)),\n          position: positionOf(update.nodes.get(id)!),\n        },\n      },\n    )?.finished;\n  }\n\n  /**\n   * <zh/> 展开节点\n   *\n   * <en/> expand node\n   * @param id - <zh/> 元素 ID | <en/> element ID\n   * @param animation - <zh/> 是否使用动画，默认为 true | <en/> Whether to use animation, default is true\n   */\n  public async expandNode(id: ID, options: CollapseExpandNodeOptions): Promise<void> {\n    const { model, layout } = this.context;\n    const { animation, align } = options;\n    const position = positionOf(model.getNodeData([id])[0]);\n\n    // 重新计算数据 / Recalculate data\n    const data = this.computeChangesAndDrawData({ stage: 'expand', animation });\n    this.createElements(data!.drawData.add, { animation: false, stage: 'expand', target: id });\n    // 重置动画 / Reset animation\n    this.context.animation!.clear();\n    this.computeStyle('expand');\n    if (!data) return;\n    const { drawData } = data;\n    const { update, add } = drawData;\n\n    const context = { animation, stage: 'expand', data: drawData } as const;\n\n    // 将新增节点/边添加到更新列表 / Add new nodes/edges to the update list\n    add.edges.forEach((edge) => update.edges.set(idOf(edge), edge));\n    add.nodes.forEach((node) => update.nodes.set(idOf(node), node));\n\n    this.updateElements(update, context);\n\n    await this.context.animation!.animate(\n      animation,\n      {\n        beforeAnimate: (animation) =>\n          this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation, drawData), context),\n        afterAnimate: (animation) =>\n          this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation, drawData), context),\n      },\n      {\n        expand: {\n          target: id,\n          descendants: Array.from(add.nodes).map(([, node]) => idOf(node)),\n          position,\n        },\n      },\n    )?.finished;\n  }\n\n  public async collapseCombo(id: ID, animation: boolean): Promise<void> {\n    const { model, element } = this.context;\n    if (model.getAncestorsData(id, COMBO_KEY).some((datum) => isCollapsed(datum))) return;\n\n    const combo = element!.getElement<Combo>(id)!;\n\n    const position = combo.getComboPosition({\n      ...combo.attributes,\n      collapsed: true,\n    });\n\n    const data = this.computeChangesAndDrawData({ stage: 'collapse', animation });\n    if (!data) return;\n\n    const { dataChanges, drawData } = data;\n    this.markDestroyElement(drawData);\n    const { update, remove } = drawData;\n    const context = { animation, stage: 'collapse', data: drawData } as const;\n\n    this.destroyElements(remove, context);\n    this.updateElements(update, context);\n\n    const idsOf = (data: Map<ID, ElementDatum>) => Array.from(data).map(([, node]) => idOf(node));\n\n    await this.context.animation!.animate(\n      animation,\n      {\n        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),\n        beforeAnimate: (animation) =>\n          this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation, drawData), context),\n        afterAnimate: (animation) =>\n          this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation, drawData), context),\n        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, { dataChanges, animation }), context),\n      },\n      {\n        collapse: {\n          target: id,\n          descendants: [...idsOf(remove.nodes), ...idsOf(remove.combos)],\n          position,\n        },\n      },\n    )?.finished;\n  }\n\n  public async expandCombo(id: ID, animation: boolean): Promise<void> {\n    const { model } = this.context;\n    const position = positionOf(model.getComboData([id])[0]);\n\n    // 重新计算数据 / Recalculate data\n    this.computeStyle('expand');\n    const data = this.computeChangesAndDrawData({ stage: 'expand', animation });\n    if (!data) return;\n\n    const { dataChanges, drawData } = data;\n    const { add, update } = drawData;\n    const context = { animation, stage: 'expand', data: drawData, target: id } as const;\n\n    this.createElements(add, context);\n    this.updateElements(update, context);\n\n    const idsOf = (data: Map<ID, ElementDatum>) => Array.from(data).map(([, node]) => idOf(node));\n\n    await this.context.animation!.animate(\n      animation,\n      {\n        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),\n        beforeAnimate: (animation) =>\n          this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation, drawData), context),\n        afterAnimate: (animation) =>\n          this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation, drawData), context),\n        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, { dataChanges, animation }), context),\n      },\n      {\n        expand: {\n          target: id,\n          descendants: [...idsOf(add.nodes), ...idsOf(add.combos)],\n          position,\n        },\n      },\n    )?.finished;\n  }\n\n  /**\n   * <zh/> 清空所有元素\n   *\n   * <en/> clear all elements\n   */\n  public clear() {\n    this.container.destroy();\n    this.initContainer();\n    this.elementMap = {};\n    this.shapeTypeMap = {};\n    this.defaultStyle = {};\n    this.stateStyle = {};\n    this.paletteStyle = {};\n  }\n\n  public destroy() {\n    this.clear();\n    this.container.destroy();\n    // @ts-expect-error force delete\n    this.context = {};\n  }\n}\n\nexport interface DrawContext {\n  /** <zh/> 是否使用动画，默认为 true | <en/> Whether to use animation, default is true */\n  animation?: boolean;\n  /** <zh/> 当前绘制阶段 | <en/> Current draw stage */\n  stage?: AnimationStage;\n  /** <zh/> 是否不抛出事件 | <en/> Whether not to dispatch events */\n  silence?: boolean;\n  /** <zh/> 收起/展开的对象 ID | <en/> ID of the object to collapse/expand */\n  collapseExpandTarget?: ID;\n  /** <zh/> 绘制类型 | <en/> Draw type */\n  type?: 'render' | 'draw';\n  /** <zh/> 展开阶段的目标元素 id | <en/> ID of the target element in the expand stage */\n  target?: ID;\n}\n\ninterface DrawPayload {\n  data: {\n    dataChanges: DataChange[];\n    drawData: DrawData;\n  };\n  stage: AnimationStage;\n  type: 'render' | 'draw';\n}\n\n/**\n * <zh/> 展开/收起节点选项\n *\n * <en/> Expand / collapse node options\n */\nexport interface CollapseExpandNodeOptions {\n  /**\n   * <zh/> 是否使用动画\n   *\n   * <en/> Whether to use animation\n   */\n  animation?: boolean;\n  /**\n   * <zh/> 保证展开/收起的节点位置不变\n   *\n   * <en/> Ensure that the position of the expanded/collapsed node remains unchanged\n   */\n  align?: boolean;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}