{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Circle, Line } from '@antv/g';\nimport { sort, group, mean, bisector, minIndex } from '@antv/vendor/d3-array';\nimport { deepMix, lowerFirst, set, throttle, last } from '@antv/util';\nimport { Tooltip as TooltipComponent } from '@antv/component';\nimport { defined, groupNameOf, subObject, dataOf, isHeatmap } from '../utils/helper';\nimport { isTranspose, isPolar } from '../utils/coordinate';\nimport { angle, sub, dist } from '../utils/vector';\nimport { invert } from '../utils/scale';\nimport { CALLBACK_ITEM_SYMBOL } from '../runtime/transform';\nimport { selectG2Elements, createXKey, selectPlotArea, mousePosition, selectFacetG2Elements, createDatumof, selectElementByData, bboxOf, maybeRoot } from './utils';\nfunction getContainer(group, mount) {\n  var _a;\n  if (mount) {\n    return typeof mount === 'string' ? document.querySelector(mount) : mount;\n  }\n  const view = (_a = group.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n  if (!view) return;\n  const canvas = view.getContextService().getDomElement();\n  return canvas.parentElement;\n}\nfunction getBounding(root) {\n  const bbox = root.getRenderBounds();\n  const {\n    min: [x1, y1],\n    max: [x2, y2]\n  } = bbox;\n  return {\n    x: x1,\n    y: y1,\n    width: x2 - x1,\n    height: y2 - y1\n  };\n}\nfunction getContainerOffset(container1, container2) {\n  const r1 = container1.getBoundingClientRect();\n  const r2 = container2.getBoundingClientRect();\n  return {\n    x: r1.x - r2.x,\n    y: r1.y - r2.y\n  };\n}\nfunction createTooltip(container, x0, y0, position, enterable, bounding, containerOffset, css = {}, offset = [10, 10]) {\n  const defaults = {\n    '.g2-tooltip': {},\n    '.g2-tooltip-title': {\n      overflow: 'hidden',\n      'white-space': 'nowrap',\n      'text-overflow': 'ellipsis'\n    }\n  };\n  const tooltipElement = new TooltipComponent({\n    className: 'tooltip',\n    style: {\n      x: x0,\n      y: y0,\n      container: containerOffset,\n      data: [],\n      bounding,\n      position,\n      enterable,\n      title: '',\n      offset,\n      template: {\n        prefixCls: 'g2-'\n      },\n      style: deepMix(defaults, css)\n    }\n  });\n  container.appendChild(tooltipElement.HTMLTooltipElement);\n  return tooltipElement;\n}\nfunction showTooltip({\n  root,\n  data,\n  x,\n  y,\n  render,\n  event,\n  single,\n  position = 'right-bottom',\n  enterable = false,\n  css,\n  mount,\n  bounding,\n  offset\n}) {\n  const container = getContainer(root, mount);\n  const canvasContainer = getContainer(root);\n  // All the views share the same tooltip.\n  const parent = single ? canvasContainer : root;\n  const b = bounding || getBounding(root);\n  const containerOffset = getContainerOffset(canvasContainer, container);\n  const {\n    tooltipElement = createTooltip(container, x, y, position, enterable, b, containerOffset, css, offset)\n  } = parent;\n  const {\n    items,\n    title = ''\n  } = data;\n  tooltipElement.update(Object.assign({\n    x,\n    y,\n    data: items,\n    title,\n    position,\n    enterable,\n    container: containerOffset\n  }, render !== undefined && {\n    content: render(event, {\n      items,\n      title\n    })\n  }));\n  parent.tooltipElement = tooltipElement;\n}\nfunction hideTooltip({\n  root,\n  single,\n  emitter,\n  nativeEvent = true,\n  event = null\n}) {\n  if (nativeEvent) {\n    emitter.emit('tooltip:hide', {\n      nativeEvent\n    });\n  }\n  const container = getContainer(root);\n  const parent = single ? container : root;\n  const {\n    tooltipElement\n  } = parent;\n  if (tooltipElement) {\n    // Must be clientX, clientY.\n    tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);\n  }\n  hideRuleY(root);\n  hideRuleX(root);\n  hideMarker(root);\n}\nfunction destroyTooltip({\n  root,\n  single\n}) {\n  const container = getContainer(root);\n  const parent = single ? container : root;\n  if (!parent) return;\n  const {\n    tooltipElement\n  } = parent;\n  if (tooltipElement) {\n    tooltipElement.destroy();\n    parent.tooltipElement = undefined;\n  }\n  hideRuleY(root);\n  hideRuleX(root);\n  hideMarker(root);\n}\nfunction showUndefined(item) {\n  const {\n    value\n  } = item;\n  return Object.assign(Object.assign({}, item), {\n    value: value === undefined ? 'undefined' : value\n  });\n}\nfunction heatmapItem(element) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const datum = element.__data__;\n  const normalizedX = (_b = (_a = datum === null || datum === void 0 ? void 0 : datum.normalized) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;\n  const originalDatum = (_c = element.parentNode) === null || _c === void 0 ? void 0 : _c.__data__;\n  const encode = (_d = originalDatum === null || originalDatum === void 0 ? void 0 : originalDatum.encode) !== null && _d !== void 0 ? _d : {};\n  const {\n    x = {},\n    y = {},\n    color = {}\n  } = encode;\n  const {\n    value: vx = []\n  } = x;\n  const {\n    value: vy = []\n  } = y;\n  const {\n    value: vc = []\n  } = color;\n  const index = Math.min(Math.round(vx.length * normalizedX), vx.length - 1);\n  return {\n    title: `${vx[index]}, ${vy[index]}`,\n    items: [{\n      name: (_e = color.field) !== null && _e !== void 0 ? _e : 'value',\n      value: vc[index],\n      color: ((_f = element.style) === null || _f === void 0 ? void 0 : _f.fill) || ((_g = element.getAttribute) === null || _g === void 0 ? void 0 : _g.call(element, 'color')) || '#000'\n    }]\n  };\n}\nfunction singleItem(element) {\n  const {\n    __data__: datum\n  } = element;\n  if (isHeatmap(element)) return heatmapItem(element);\n  const {\n    title,\n    items = []\n  } = datum;\n  const newItems = items.filter(defined).map(_a => {\n    var {\n        color = itemColorOf(element)\n      } = _a,\n      item = __rest(_a, [\"color\"]);\n    return Object.assign(Object.assign({}, item), {\n      color\n    });\n  }).map(showUndefined);\n  return Object.assign(Object.assign({}, title && {\n    title\n  }), {\n    items: newItems\n  });\n}\nfunction itemColorOf(element) {\n  const fill = element.getAttribute('fill');\n  const stroke = element.getAttribute('stroke');\n  const {\n    __data__: datum\n  } = element;\n  const {\n    color = fill && fill !== 'transparent' ? fill : stroke\n  } = datum;\n  return color;\n}\nfunction unique(items, key = d => d) {\n  const valueName = new Map(items.map(d => [key(d), d]));\n  return Array.from(valueName.values());\n}\nfunction groupItems(elements, scale, groupName, data = elements.map(d => d['__data__']), theme = {}) {\n  const key = d => d instanceof Date ? +d : d;\n  const T = unique(data.map(d => d.title), key).filter(defined);\n  const newItems = data.flatMap((datum, i) => {\n    // Fix: Get the corresponding element from datum instead of using index i\n    // When data and elements don't correspond one-to-one, using index will cause color errors\n    const element = datum.element || elements[i];\n    const {\n      items = [],\n      title\n    } = datum;\n    const definedItems = items.filter(defined);\n    // If there is only one item, use groupName as title by default.\n    const useGroupName = groupName !== undefined ? groupName : items.length <= 1 ? true : false;\n    return definedItems.map(_a => {\n      var {\n          color = itemColorOf(element) || theme.color,\n          name\n        } = _a,\n        item = __rest(_a, [\"color\", \"name\"]);\n      const groupName = groupNameOf(scale, datum);\n      // callback's priority is higher than groupName.\n      const name1 = useGroupName && !(CALLBACK_ITEM_SYMBOL in item) ? groupName || name : name || groupName;\n      return Object.assign(Object.assign({}, item), {\n        color,\n        name: name1 || title\n      });\n    });\n  }).map(showUndefined);\n  return Object.assign(Object.assign({}, T.length > 0 && {\n    title: T.join(',')\n  }), {\n    items: unique(newItems, d => `(${key(d.name)}, ${key(d.value)}, ${key(d.color)})`)\n  });\n}\nfunction updateRuleX(root, points, mouse, _a) {\n  var {\n      plotWidth,\n      plotHeight,\n      mainWidth,\n      mainHeight,\n      startX,\n      startY,\n      transposed,\n      polar,\n      insetLeft,\n      insetTop\n    } = _a,\n    rest = __rest(_a, [\"plotWidth\", \"plotHeight\", \"mainWidth\", \"mainHeight\", \"startX\", \"startY\", \"transposed\", \"polar\", \"insetLeft\", \"insetTop\"]);\n  const defaults = Object.assign({\n    lineWidth: 1,\n    stroke: '#1b1e23',\n    strokeOpacity: 0.5\n  }, rest);\n  const createCircle = (cx, cy, r) => {\n    const circle = new Circle({\n      style: Object.assign({\n        cx,\n        cy,\n        r\n      }, defaults)\n    });\n    root.appendChild(circle);\n    return circle;\n  };\n  const createLine = (x1, x2, y1, y2) => {\n    const line = new Line({\n      style: Object.assign({\n        x1,\n        x2,\n        y1,\n        y2\n      }, defaults)\n    });\n    root.appendChild(line);\n    return line;\n  };\n  const minDistPoint = (mouse, points) => {\n    // only one point do not need compute\n    if (points.length === 1) {\n      return points[0];\n    }\n    const dists = points.map(p => dist(p, mouse));\n    const minDistIndex = minIndex(dists, d => d);\n    return points[minDistIndex];\n  };\n  const target = minDistPoint(mouse, points);\n  const pointsOf = () => {\n    if (transposed) return [startX + target[0], startX + target[0], startY, startY + plotHeight];\n    return [startX, startX + plotWidth, target[1] + startY, target[1] + startY];\n  };\n  const pointsOfPolar = () => {\n    const cx = startX + insetLeft + mainWidth / 2;\n    const cy = startY + insetTop + mainHeight / 2;\n    const cdist = dist([cx, cy], target);\n    return [cx, cy, cdist];\n  };\n  if (polar) {\n    const [cx, cy, r] = pointsOfPolar();\n    const ruleX = root.ruleX || createCircle(cx, cy, r);\n    ruleX.style.cx = cx;\n    ruleX.style.cy = cy;\n    ruleX.style.r = r;\n    root.ruleX = ruleX;\n  } else {\n    const [x1, x2, y1, y2] = pointsOf();\n    const ruleX = root.ruleX || createLine(x1, x2, y1, y2);\n    ruleX.style.x1 = x1;\n    ruleX.style.x2 = x2;\n    ruleX.style.y1 = y1;\n    ruleX.style.y2 = y2;\n    root.ruleX = ruleX;\n  }\n}\nfunction updateRuleY(root, points, _a) {\n  var {\n      plotWidth,\n      plotHeight,\n      mainWidth,\n      mainHeight,\n      startX,\n      startY,\n      transposed,\n      polar,\n      insetLeft,\n      insetTop\n    } = _a,\n    rest = __rest(_a, [\"plotWidth\", \"plotHeight\", \"mainWidth\", \"mainHeight\", \"startX\", \"startY\", \"transposed\", \"polar\", \"insetLeft\", \"insetTop\"]);\n  const defaults = Object.assign({\n    lineWidth: 1,\n    stroke: '#1b1e23',\n    strokeOpacity: 0.5\n  }, rest);\n  const Y = points.map(p => p[1]);\n  const X = points.map(p => p[0]);\n  const y = mean(Y);\n  const x = mean(X);\n  const pointsOf = () => {\n    if (polar) {\n      const r = Math.min(mainWidth, mainHeight) / 2;\n      const cx = startX + insetLeft + mainWidth / 2;\n      const cy = startY + insetTop + mainHeight / 2;\n      const a = angle(sub([x, y], [cx, cy]));\n      const x0 = cx + r * Math.cos(a);\n      const y0 = cy + r * Math.sin(a);\n      return [cx, x0, cy, y0];\n    }\n    if (transposed) return [startX, startX + plotWidth, y + startY, y + startY];\n    return [x + startX, x + startX, startY, startY + plotHeight];\n  };\n  const [x1, x2, y1, y2] = pointsOf();\n  const createLine = () => {\n    const line = new Line({\n      style: Object.assign({\n        x1,\n        x2,\n        y1,\n        y2\n      }, defaults)\n    });\n    root.appendChild(line);\n    return line;\n  };\n  // Only update rule with defined series elements.\n  if (X.length > 0) {\n    const ruleY = root.ruleY || createLine();\n    ruleY.style.x1 = x1;\n    ruleY.style.x2 = x2;\n    ruleY.style.y1 = y1;\n    ruleY.style.y2 = y2;\n    root.ruleY = ruleY;\n  }\n}\nfunction hideRuleY(root) {\n  if (root.ruleY) {\n    root.ruleY.remove();\n    root.ruleY = undefined;\n  }\n}\nfunction hideRuleX(root) {\n  if (root.ruleX) {\n    root.ruleX.remove();\n    root.ruleX = undefined;\n  }\n}\nfunction updateMarker(root, {\n  data,\n  style,\n  theme\n}) {\n  if (root.markers) root.markers.forEach(d => d.remove());\n  const {\n    type = ''\n  } = style;\n  const markers = data.filter(d => {\n    const [{\n      x,\n      y\n    }] = d;\n    return defined(x) && defined(y);\n  }).map(d => {\n    const [{\n      color,\n      element\n    }, point] = d;\n    const originColor = color ||\n    // encode value\n    element.style.fill || element.style.stroke || theme.color;\n    const fill = type === 'hollow' ? 'transparent' : originColor;\n    const stroke = type === 'hollow' ? originColor : '#fff';\n    const shape = new Circle({\n      className: 'g2-tooltip-marker',\n      style: Object.assign({\n        cx: point[0],\n        cy: point[1],\n        fill,\n        r: 4,\n        stroke,\n        lineWidth: 2,\n        // Prevents blocking clicks on elements behind.\n        pointerEvents: 'none'\n      }, style)\n    });\n    return shape;\n  });\n  for (const marker of markers) root.appendChild(marker);\n  root.markers = markers;\n}\nfunction hideMarker(root) {\n  if (root.markers) {\n    root.markers.forEach(d => d.remove());\n    root.markers = [];\n  }\n}\nfunction interactionKeyof(markState, key) {\n  return Array.from(markState.values()).some(\n  // @ts-ignore\n  d => {\n    var _a;\n    return (_a = d.interaction) === null || _a === void 0 ? void 0 : _a[key];\n  });\n}\nexport function maybeValue(specified, defaults) {\n  return specified === undefined ? defaults : specified;\n}\nfunction isEmptyTooltipData(data) {\n  const {\n    title,\n    items\n  } = data;\n  if (items.length === 0 && title === undefined) return true;\n  return false;\n}\nfunction hasSeries(markState) {\n  return Array.from(markState.values()).some(\n  // @ts-ignore\n  d => {\n    var _a;\n    return ((_a = d.interaction) === null || _a === void 0 ? void 0 : _a.seriesTooltip) && d.tooltip;\n  });\n}\nfunction normalizedPosition(coordinate, position) {\n  const {\n    innerWidth,\n    innerHeight,\n    marginLeft,\n    paddingLeft,\n    insetLeft,\n    marginTop,\n    paddingTop,\n    insetTop\n  } = coordinate.getOptions();\n  return {\n    x: (position.x - marginLeft - paddingLeft - insetLeft) / innerWidth,\n    y: (position.y - marginTop - paddingTop - insetTop) / innerHeight\n  };\n}\n/**\n * Finds a single element based on the mouse event in a non-series context (e.g., single item tooltip).\n * @param root - The root display object of the chart.\n * @param event - The mouse event object (e.g., pointermove, pointerdown).\n * @param elements - Array of chart elements to search within.\n * @param coordinate - The coordinate system of the chart (e.g., Cartesian, polar).\n * @param scale - The scale configurations (e.g., x, series scales).\n * @param shared - Whether the tooltip is shared among multiple elements (e.g., grouped bars).\n * @returns The matched display object or `undefined` if no element is found.\n * @description\n * - Handles bar charts by sorting elements and using bisector search for efficient lookup.\n * - For non-bar charts, directly finds the target element from the event's target.\n * - Adjusts for bar spacing in grouped charts when `shared` is false.\n */\nexport function findSingleElement({\n  root,\n  event,\n  elements = [],\n  coordinate,\n  scale,\n  shared\n}) {\n  var _a, _b;\n  const inInterval = d => d.markType === 'interval';\n  const isBar = elements.every(inInterval) && !isPolar(coordinate);\n  const scaleX = scale.x;\n  const scaleSeries = scale.series;\n  const bandWidth = (_b = (_a = scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX)) !== null && _b !== void 0 ? _b : 0;\n  const xof = scaleSeries ? d => {\n    const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);\n    return d.__data__.x + d.__data__.series * bandWidth + bandWidth / (seriesCount * 2);\n  } : d => d.__data__.x + bandWidth / 2;\n  // Sort for bisector search.\n  if (isBar) elements.sort((a, b) => xof(a) - xof(b));\n  const findElementByTarget = event => {\n    const {\n      target = last(elements)\n    } = event;\n    return maybeRoot(target, node => {\n      if (!node.classList) return false;\n      if (isHeatmap(node)) {\n        set(node, '__data__.normalized', normalizedPosition(coordinate, {\n          x: event.offsetX,\n          y: event.offsetY\n        }));\n      }\n      return node.classList.includes('element');\n    });\n  };\n  const element = isBar ? event => {\n    const mouse = mousePosition(root, event);\n    if (!mouse) return;\n    const [abstractX] = coordinate.invert(mouse);\n    const search = bisector(xof).center;\n    const i = search(elements, abstractX);\n    const target = elements[i];\n    if (!shared) {\n      // For grouped bar chart without shared options.\n      const isGrouped = elements.find(d => d !== target && xof(d) === xof(target));\n      if (isGrouped) return findElementByTarget(event);\n    }\n    return target;\n  } : findElementByTarget;\n  return element(event);\n}\n/**\n * Finds series-related elements and data based on the mouse event for series tooltips.\n * @param root - The root display object of the chart.\n * @param event - The mouse event object (e.g., pointermove, pointerdown).\n * @param elements - Array of chart elements to search within.\n * @param coordinate - The coordinate system of the chart (e.g., Cartesian, polar).\n * @param scale - The scale configurations (e.g., x, series scales).\n * @param startX - The starting X position of the plot area.\n * @param startY - The starting Y position of the plot area.\n * @returns An object containing:\n * - `selectedElements`: Matched display objects (series and item elements).\n * - `selectedData`: Corresponding data records of the selected elements.\n * - `filteredSeriesData`: Filtered series data closest to the mouse focus.\n * - `abstractX`: A function to convert mouse coordinates to abstract X values.\n * @description\n * - Splits elements into series and item elements for targeted searching.\n * - Handles bar charts and band scales using bisector search and coordinate inversion.\n * - Sorts elements to ensure correct visual ordering (top-to-bottom or right-to-left in transposed mode).\n * - Filters and groups data to provide accurate tooltip information for series.\n */\nexport function findSeriesElement({\n  root,\n  event,\n  elements,\n  coordinate,\n  scale,\n  startX,\n  startY\n}) {\n  const transposed = isTranspose(coordinate);\n  // Split elements into series elements and item elements.\n  const seriesElements = [];\n  const itemElements = [];\n  for (const element of elements) {\n    const {\n      __data__: data\n    } = element;\n    const {\n      seriesX,\n      title,\n      items\n    } = data;\n    if (seriesX) seriesElements.push(element);else if (title || items) itemElements.push(element);\n  }\n  const inInterval = d => d.markType === 'interval';\n  const isBar = itemElements.length && itemElements.every(inInterval) && !isPolar(coordinate);\n  const xof = d => d.__data__.x;\n  // For band scale x, find the closest series element to focus,\n  // useful for interval + line mark.\n  const isBandScale = !!scale.x.getBandWidth;\n  const closest = isBandScale && itemElements.length > 0;\n  // Sorted elements from top to bottom visually,\n  // or from right to left in transpose coordinate.\n  seriesElements.sort((a, b) => {\n    const index = transposed ? 0 : 1;\n    const minY = d => d.getBounds().min[index];\n    return transposed ? minY(b) - minY(a) : minY(a) - minY(b);\n  });\n  const extent = d => {\n    const index = transposed ? 1 : 0;\n    const {\n      min,\n      max\n    } = d.getLocalBounds();\n    return sort([min[index], max[index]]);\n  };\n  // Sort itemElements for bisector search.\n  if (isBar) elements.sort((a, b) => xof(a) - xof(b));else {\n    itemElements.sort((a, b) => {\n      const [minA, maxA] = extent(a);\n      const [minB, maxB] = extent(b);\n      const midA = (minA + maxA) / 2;\n      const midB = (minB + maxB) / 2;\n      return transposed ? midB - midA : midA - midB;\n    });\n  }\n  // Get sortedIndex and X for each series elements\n  const elementSortedX = new Map(seriesElements.map(element => {\n    const {\n      __data__: data\n    } = element;\n    const {\n      seriesX\n    } = data;\n    const seriesIndex = seriesX.map((_, i) => i);\n    const sortedIndex = sort(seriesIndex, i => seriesX[+i]);\n    return [element, [sortedIndex, seriesX]];\n  }));\n  const {\n    x: scaleX\n  } = scale;\n  // Apply offset for band scale x.\n  const offsetX = (scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) ? scaleX.getBandWidth() / 2 : 0;\n  const abstractX = focus => {\n    const [normalizedX] = coordinate.invert(focus);\n    return normalizedX - offsetX;\n  };\n  const indexByFocus = (event, focus, I, X) => {\n    // _x is from emit event, to find the right element.\n    const {\n      _x\n    } = event;\n    const finalX = _x !== undefined ? scaleX.map(_x) : abstractX(focus);\n    const DX = X.filter(defined);\n    const [minX, maxX] = sort([DX[0], DX[DX.length - 1]]);\n    // If only has one element(minX == maxX), show tooltip when hover whole chart\n    const isOnlyOneElement = minX === maxX;\n    // If closest is true, always find at least one element.\n    // Otherwise, skip element out of plot area.\n    if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement) return null;\n    const search = bisector(i => X[+i]).center;\n    const i = search(I, finalX);\n    return I[i];\n  };\n  const elementsByFocus = isBar ? (focus, elements) => {\n    const search = bisector(xof).center;\n    const i = search(elements, abstractX(focus));\n    const find = elements[i];\n    const groups = group(elements, xof);\n    const selected = groups.get(xof(find));\n    return selected;\n  } : (focus, elements) => {\n    const index = transposed ? 1 : 0;\n    const x = focus[index];\n    const filtered = elements.filter(element => {\n      const [min, max] = extent(element);\n      return x >= min && x <= max;\n    });\n    // If closet is true, always find at least one element.\n    if (!closest || filtered.length > 0) return filtered;\n    // Search the closet element to the focus.\n    const search = bisector(element => {\n      const [min, max] = extent(element);\n      return (min + max) / 2;\n    }).center;\n    const i = search(elements, x);\n    return [elements[i]].filter(defined);\n  };\n  const seriesData = (element, index) => {\n    const {\n      __data__: data\n    } = element;\n    return Object.fromEntries(Object.entries(data).filter(([key]) => key.startsWith('series') && key !== 'series').map(([key, V]) => {\n      const d = V[index];\n      return [lowerFirst(key.replace('series', '')), d];\n    }));\n  };\n  const mouse = mousePosition(root, event);\n  if (!mouse) return;\n  const focus = [mouse[0] - startX, mouse[1] - startY];\n  if (!focus) return;\n  // Get selected item element.\n  const selectedItems = elementsByFocus(focus, itemElements);\n  // Get selected data item from both series element and item element.\n  const selectedSeriesElements = [];\n  const selectedSeriesData = [];\n  for (const element of seriesElements) {\n    const [sortedIndex, X] = elementSortedX.get(element);\n    const index = indexByFocus(event, focus, sortedIndex, X);\n    if (index !== null) {\n      selectedSeriesElements.push(element);\n      const d = seriesData(element, index);\n      const {\n        x,\n        y\n      } = d;\n      const p = coordinate.map([(x || 0) + offsetX, y || 0]);\n      selectedSeriesData.push([Object.assign(Object.assign({}, d), {\n        element\n      }), p]);\n    }\n  }\n  // Filter selectedSeriesData with different x,\n  // make sure there is only one x closest to focusX.\n  const SX = Array.from(new Set(selectedSeriesData.map(d => d[0].x)));\n  const closestX = SX[minIndex(SX, x => Math.abs(x - abstractX(focus)))];\n  const filteredSeriesData = selectedSeriesData.filter(d => d[0].x === closestX);\n  const selectedData = [...filteredSeriesData.map(d => d[0]), ...selectedItems.map(d => d.__data__)];\n  // Get the displayed tooltip data.\n  const selectedElements = [...selectedSeriesElements, ...selectedItems];\n  return {\n    selectedElements,\n    selectedData,\n    filteredSeriesData,\n    abstractX\n  };\n}\n/**\n * Show tooltip for series item.\n */\nexport function seriesTooltip(root, _a) {\n  var {\n      elements: elementsof,\n      sort: sortFunction,\n      filter: filterFunction,\n      scale,\n      coordinate,\n      crosshairs,\n      crosshairsX,\n      crosshairsY,\n      render,\n      groupName,\n      emitter,\n      wait = 50,\n      leading = true,\n      trailing = false,\n      startX = 0,\n      startY = 0,\n      body = true,\n      single = true,\n      position,\n      enterable,\n      mount,\n      bounding,\n      theme,\n      offset,\n      disableNative = false,\n      marker = true,\n      preserve = false,\n      style: _style = {},\n      css = {}\n    } = _a,\n    rest = __rest(_a, [\"elements\", \"sort\", \"filter\", \"scale\", \"coordinate\", \"crosshairs\", \"crosshairsX\", \"crosshairsY\", \"render\", \"groupName\", \"emitter\", \"wait\", \"leading\", \"trailing\", \"startX\", \"startY\", \"body\", \"single\", \"position\", \"enterable\", \"mount\", \"bounding\", \"theme\", \"offset\", \"disableNative\", \"marker\", \"preserve\", \"style\", \"css\"]);\n  const elements = elementsof(root);\n  const style = deepMix(_style, rest);\n  const polar = isPolar(coordinate);\n  const transposed = isTranspose(coordinate);\n  const {\n    innerWidth: plotWidth,\n    innerHeight: plotHeight,\n    width: mainWidth,\n    height: mainHeight,\n    insetLeft,\n    insetTop\n  } = coordinate.getOptions();\n  const update = throttle(event => {\n    var _a;\n    const mouse = mousePosition(root, event);\n    if (!mouse) return;\n    const bbox = bboxOf(root);\n    const x = bbox.min[0];\n    const y = bbox.min[1];\n    const {\n      selectedElements,\n      selectedData,\n      filteredSeriesData,\n      abstractX\n    } = findSeriesElement({\n      root,\n      event,\n      elements,\n      coordinate,\n      scale,\n      startX,\n      startY\n    });\n    const tooltipData = groupItems(selectedElements, scale, groupName, selectedData, theme);\n    // Sort items and filter items.\n    if (sortFunction) {\n      tooltipData.items.sort((a, b) => sortFunction(a) - sortFunction(b));\n    }\n    if (filterFunction) {\n      tooltipData.items = tooltipData.items.filter(filterFunction);\n    }\n    // Hide tooltip with no selected tooltip.\n    if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {\n      hide(event);\n      return;\n    }\n    if (body) {\n      showTooltip({\n        root,\n        data: tooltipData,\n        x: mouse[0] + x,\n        y: mouse[1] + y,\n        render,\n        event,\n        single,\n        position,\n        enterable,\n        mount,\n        bounding,\n        css,\n        offset\n      });\n    }\n    if (crosshairs || crosshairsX || crosshairsY) {\n      const ruleStyle = subObject(style, 'crosshairs');\n      const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), subObject(style, 'crosshairsX'));\n      const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), subObject(style, 'crosshairsY'));\n      const points = filteredSeriesData.map(d => d[1]);\n      if (crosshairsX) {\n        updateRuleX(root, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {\n          plotWidth,\n          plotHeight,\n          mainWidth,\n          mainHeight,\n          insetLeft,\n          insetTop,\n          startX,\n          startY,\n          transposed,\n          polar\n        }));\n      }\n      if (crosshairsY) {\n        updateRuleY(root, points, Object.assign(Object.assign({}, ruleStyleY), {\n          plotWidth,\n          plotHeight,\n          mainWidth,\n          mainHeight,\n          insetLeft,\n          insetTop,\n          startX,\n          startY,\n          transposed,\n          polar\n        }));\n      }\n    }\n    if (marker) {\n      const markerStyles = subObject(style, 'marker');\n      updateMarker(root, {\n        data: filteredSeriesData,\n        style: markerStyles,\n        theme\n      });\n    }\n    // X in focus may related multiple points when dataset is large,\n    // so we need to find the first x to show tooltip.\n    const firstX = (_a = filteredSeriesData[0]) === null || _a === void 0 ? void 0 : _a[0].x;\n    const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);\n    emitter.emit('tooltip:show', Object.assign(Object.assign({}, event), {\n      nativeEvent: true,\n      data: Object.assign(Object.assign({}, tooltipData), {\n        data: {\n          x: invert(scale.x, transformedX, true)\n        }\n      })\n    }));\n  }, wait, {\n    leading,\n    trailing\n  });\n  const hide = event => {\n    hideTooltip({\n      root,\n      single,\n      emitter,\n      event\n    });\n  };\n  const destroy = () => {\n    destroyTooltip({\n      root,\n      single\n    });\n  };\n  const onTooltipShow = _a => {\n    var _b;\n    var {\n        nativeEvent,\n        data,\n        offsetX,\n        offsetY\n      } = _a,\n      rest = __rest(_a, [\"nativeEvent\", \"data\", \"offsetX\", \"offsetY\"]);\n    if (nativeEvent) return;\n    const x = (_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b.x;\n    const scaleX = scale.x;\n    const x1 = scaleX.map(x);\n    const [x2, y2] = coordinate.map([x1, 0.5]);\n    const rootBounds = root.getRenderBounds();\n    const minX = rootBounds.min[0];\n    const minY = rootBounds.min[1];\n    update(Object.assign(Object.assign({}, rest), {\n      offsetX: offsetX !== undefined ? offsetX : minX + x2,\n      offsetY: offsetY !== undefined ? offsetY : minY + y2,\n      _x: x\n    }));\n  };\n  const onTooltipHide = () => {\n    hideTooltip({\n      root,\n      single,\n      emitter,\n      nativeEvent: false\n    });\n  };\n  const onTooltipDisable = () => {\n    removeEventListeners();\n    destroy();\n  };\n  const onTooltipEnable = () => {\n    addEventListeners();\n  };\n  const addEventListeners = () => {\n    if (!disableNative) {\n      root.addEventListener('pointerdown', update);\n      root.addEventListener('pointerenter', update);\n      root.addEventListener('pointermove', update);\n      // Only emit pointerleave event when the pointer is not in the root area.\n      root.addEventListener('pointerleave', e => {\n        if (mousePosition(root, e)) return;\n        hide(e);\n      });\n      root.addEventListener('pointerup', hide);\n    }\n  };\n  const removeEventListeners = () => {\n    if (!disableNative) {\n      root.removeEventListener('pointerdown', update);\n      root.removeEventListener('pointerenter', update);\n      root.removeEventListener('pointermove', update);\n      root.removeEventListener('pointerleave', hide);\n      root.removeEventListener('pointerup', hide);\n    }\n  };\n  addEventListeners();\n  emitter.on('tooltip:show', onTooltipShow);\n  emitter.on('tooltip:hide', onTooltipHide);\n  emitter.on('tooltip:disable', onTooltipDisable);\n  emitter.on('tooltip:enable', onTooltipEnable);\n  return () => {\n    removeEventListeners();\n    emitter.off('tooltip:show', onTooltipShow);\n    emitter.off('tooltip:hide', onTooltipHide);\n    emitter.off('tooltip:disable', onTooltipDisable);\n    emitter.off('tooltip:enable', onTooltipEnable);\n    if (preserve) {\n      hideTooltip({\n        root,\n        single,\n        emitter,\n        nativeEvent: false\n      });\n    } else {\n      destroy();\n    }\n  };\n}\n/**\n * Show tooltip for non-series item.\n */\nexport function tooltip(root, {\n  elements: elementsof,\n  coordinate,\n  scale,\n  render,\n  groupName,\n  sort: sortFunction,\n  filter: filterFunction,\n  emitter,\n  wait = 50,\n  leading = true,\n  trailing = false,\n  groupKey = d => d,\n  // group elements by specified key\n  single = true,\n  position,\n  enterable,\n  datum,\n  view,\n  mount,\n  bounding,\n  theme,\n  offset,\n  shared = false,\n  body = true,\n  disableNative = false,\n  preserve = false,\n  css = {}\n}) {\n  const elements = elementsof(root);\n  const keyGroup = group(elements, groupKey);\n  const pointermove = throttle(event => {\n    const element = findSingleElement({\n      root,\n      event,\n      elements,\n      coordinate,\n      scale,\n      shared\n    });\n    if (!element) {\n      hideTooltip({\n        root,\n        single,\n        emitter,\n        event\n      });\n      return;\n    }\n    const k = groupKey(element);\n    const group = keyGroup.get(k);\n    if (!group) {\n      return;\n    }\n    const data = group.length === 1 && !shared ? singleItem(group[0]) : groupItems(group, scale, groupName, undefined, theme);\n    // Sort items and sort.\n    if (sortFunction) {\n      data.items.sort((a, b) => sortFunction(a) - sortFunction(b));\n    }\n    if (filterFunction) {\n      data.items = data.items.filter(filterFunction);\n    }\n    if (isEmptyTooltipData(data)) {\n      hideTooltip({\n        root,\n        single,\n        emitter,\n        event\n      });\n      return;\n    }\n    const {\n      offsetX,\n      offsetY\n    } = event;\n    if (body) {\n      showTooltip({\n        root,\n        data,\n        x: offsetX,\n        y: offsetY,\n        render,\n        event,\n        single,\n        position,\n        enterable,\n        mount,\n        bounding,\n        css,\n        offset\n      });\n    }\n    emitter.emit('tooltip:show', Object.assign(Object.assign({}, event), {\n      nativeEvent: true,\n      data: Object.assign(Object.assign({}, data), {\n        data: dataOf(element, view)\n      })\n    }));\n  }, wait, {\n    leading,\n    trailing\n  });\n  const pointerleave = event => {\n    hideTooltip({\n      root,\n      single,\n      emitter,\n      event\n    });\n  };\n  const addEventListeners = () => {\n    if (!disableNative) {\n      root.addEventListener('pointerdown', pointermove);\n      root.addEventListener('pointermove', pointermove);\n      // Only emit pointerleave event when the pointer is not in the root area.\n      // !!!DO NOT USE pointerout event, it will emit when the pointer is in the child area.\n      root.addEventListener('pointerleave', pointerleave);\n      root.addEventListener('pointerup', pointerleave);\n    }\n  };\n  const removeEventListeners = () => {\n    if (!disableNative) {\n      root.removeEventListener('pointerdown', pointermove);\n      root.removeEventListener('pointermove', pointermove);\n      root.removeEventListener('pointerleave', pointerleave);\n      root.removeEventListener('pointerup', pointerleave);\n    }\n  };\n  const onTooltipShow = ({\n    nativeEvent,\n    offsetX,\n    offsetY,\n    data: raw\n  }) => {\n    if (nativeEvent) return;\n    const {\n      data\n    } = raw;\n    const element = selectElementByData(elements, data, datum);\n    if (!element) return;\n    const bbox = element.getBBox();\n    const {\n      x,\n      y,\n      width,\n      height\n    } = bbox;\n    const rootBBox = root.getBBox();\n    pointermove({\n      target: element,\n      offsetX: offsetX !== undefined ? offsetX + rootBBox.x : x + width / 2,\n      offsetY: offsetY !== undefined ? offsetY + rootBBox.y : y + height / 2\n    });\n  };\n  const onTooltipHide = ({\n    nativeEvent\n  } = {}) => {\n    if (nativeEvent) return;\n    hideTooltip({\n      root,\n      single,\n      emitter,\n      nativeEvent: false\n    });\n  };\n  const onTooltipDisable = () => {\n    removeEventListeners();\n    destroyTooltip({\n      root,\n      single\n    });\n  };\n  const onTooltipEnable = () => {\n    addEventListeners();\n  };\n  emitter.on('tooltip:show', onTooltipShow);\n  emitter.on('tooltip:hide', onTooltipHide);\n  emitter.on('tooltip:enable', onTooltipEnable);\n  emitter.on('tooltip:disable', onTooltipDisable);\n  addEventListeners();\n  return () => {\n    removeEventListeners();\n    emitter.off('tooltip:show', onTooltipShow);\n    emitter.off('tooltip:hide', onTooltipHide);\n    emitter.off('tooltip:enable', onTooltipEnable);\n    emitter.off('tooltip:disable', onTooltipDisable);\n    if (preserve) {\n      hideTooltip({\n        root,\n        single,\n        emitter,\n        nativeEvent: false\n      });\n    } else {\n      destroyTooltip({\n        root,\n        single\n      });\n    }\n  };\n}\nexport function Tooltip(options) {\n  const {\n      shared,\n      crosshairs,\n      crosshairsX,\n      crosshairsY,\n      series,\n      name,\n      item = () => ({}),\n      facet = false\n    } = options,\n    rest = __rest(options, [\"shared\", \"crosshairs\", \"crosshairsX\", \"crosshairsY\", \"series\", \"name\", \"item\", \"facet\"]);\n  return (target, viewInstances, emitter) => {\n    const {\n      container,\n      view\n    } = target;\n    const {\n      scale,\n      markState,\n      coordinate,\n      theme\n    } = view;\n    // Get default value from mark states.\n    const defaultSeries = interactionKeyof(markState, 'seriesTooltip');\n    const defaultShowCrosshairs = interactionKeyof(markState, 'crosshairs');\n    const plotArea = selectPlotArea(container);\n    const isSeries = maybeValue(series, defaultSeries);\n    const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);\n    // For non-facet and series tooltip.\n    if (isSeries && hasSeries(markState) && !facet) {\n      return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {\n        theme,\n        elements: selectG2Elements,\n        scale,\n        coordinate,\n        crosshairs: crosshairsSetting,\n        // the crosshairsX settings level: crosshairsX > crosshairs > false\n        // it means crosshairsX default is false\n        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),\n        // crosshairsY default depend on the crossharisSettings\n        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),\n        item,\n        emitter\n      }));\n    }\n    // For facet and series tooltip.\n    if (isSeries && facet) {\n      // Get sub view instances for this view.\n      const facetInstances = viewInstances.filter(d => d !== target && d.options.parentKey === target.options.key);\n      const elements = selectFacetG2Elements(target, viewInstances);\n      // Use the scale of the first view.\n      const scale = facetInstances[0].view.scale;\n      const bbox = plotArea.getBounds();\n      const startX = bbox.min[0];\n      const startY = bbox.min[1];\n      Object.assign(scale, {\n        facet: true\n      });\n      // @todo Nested structure rather than flat structure for facet?\n      // Add listener to the root area.\n      // @ts-ignore\n      return seriesTooltip(plotArea.parentNode.parentNode, Object.assign(Object.assign({}, rest), {\n        theme,\n        elements: () => elements,\n        scale,\n        coordinate,\n        crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),\n        // the crosshairsX settings level: crosshairsX > crosshairs > false\n        // it means crosshairsX default is false\n        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),\n        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),\n        item,\n        startX,\n        startY,\n        emitter\n      }));\n    }\n    return tooltip(plotArea, Object.assign(Object.assign({}, rest), {\n      datum: createDatumof(view),\n      elements: selectG2Elements,\n      scale,\n      coordinate,\n      groupKey: shared ? createXKey(view) : undefined,\n      item,\n      emitter,\n      view,\n      theme,\n      shared\n    }));\n  };\n}\nTooltip.props = {\n  reapplyWhenUpdate: true\n};","map":{"version":3,"names":["Circle","Line","sort","group","mean","bisector","minIndex","deepMix","lowerFirst","set","throttle","last","Tooltip","TooltipComponent","defined","groupNameOf","subObject","dataOf","isHeatmap","isTranspose","isPolar","angle","sub","dist","invert","CALLBACK_ITEM_SYMBOL","selectG2Elements","createXKey","selectPlotArea","mousePosition","selectFacetG2Elements","createDatumof","selectElementByData","bboxOf","maybeRoot","getContainer","mount","document","querySelector","view","_a","ownerDocument","defaultView","canvas","getContextService","getDomElement","parentElement","getBounding","root","bbox","getRenderBounds","min","x1","y1","max","x2","y2","x","y","width","height","getContainerOffset","container1","container2","r1","getBoundingClientRect","r2","createTooltip","container","x0","y0","position","enterable","bounding","containerOffset","css","offset","defaults","overflow","tooltipElement","className","style","data","title","template","prefixCls","appendChild","HTMLTooltipElement","showTooltip","render","event","single","canvasContainer","parent","b","items","update","Object","assign","undefined","content","hideTooltip","emitter","nativeEvent","emit","hide","clientX","clientY","hideRuleY","hideRuleX","hideMarker","destroyTooltip","destroy","showUndefined","item","value","heatmapItem","element","datum","__data__","normalizedX","_b","normalized","originalDatum","_c","parentNode","encode","_d","color","vx","vy","vc","index","Math","round","length","name","_e","field","_f","fill","_g","getAttribute","call","singleItem","newItems","filter","map","itemColorOf","__rest","stroke","unique","key","d","valueName","Map","Array","from","values","groupItems","elements","scale","groupName","theme","Date","T","flatMap","i","definedItems","useGroupName","name1","join","updateRuleX","points","mouse","plotWidth","plotHeight","mainWidth","mainHeight","startX","startY","transposed","polar","insetLeft","insetTop","rest","lineWidth","strokeOpacity","createCircle","cx","cy","r","circle","createLine","line","minDistPoint","dists","p","minDistIndex","target","pointsOf","pointsOfPolar","cdist","ruleX","updateRuleY","Y","X","a","cos","sin","ruleY","remove","updateMarker","markers","forEach","type","point","originColor","shape","pointerEvents","marker","interactionKeyof","markState","some","interaction","maybeValue","specified","isEmptyTooltipData","hasSeries","seriesTooltip","tooltip","normalizedPosition","coordinate","innerWidth","innerHeight","marginLeft","paddingLeft","marginTop","paddingTop","getOptions","findSingleElement","shared","inInterval","markType","isBar","every","scaleX","scaleSeries","series","bandWidth","getBandWidth","xof","seriesCount","valueBandWidth","findElementByTarget","node","classList","offsetX","offsetY","includes","abstractX","search","center","isGrouped","find","findSeriesElement","seriesElements","itemElements","seriesX","push","isBandScale","closest","minY","getBounds","extent","getLocalBounds","minA","maxA","minB","maxB","midA","midB","elementSortedX","seriesIndex","_","sortedIndex","focus","indexByFocus","I","_x","finalX","DX","minX","maxX","isOnlyOneElement","elementsByFocus","groups","selected","get","filtered","seriesData","fromEntries","entries","startsWith","V","replace","selectedItems","selectedSeriesElements","selectedSeriesData","SX","Set","closestX","abs","filteredSeriesData","selectedData","selectedElements","elementsof","sortFunction","filterFunction","crosshairs","crosshairsX","crosshairsY","wait","leading","trailing","body","disableNative","preserve","_style","tooltipData","ruleStyle","ruleStyleX","ruleStyleY","markerStyles","firstX","transformedX","onTooltipShow","rootBounds","onTooltipHide","onTooltipDisable","removeEventListeners","onTooltipEnable","addEventListeners","addEventListener","e","removeEventListener","on","off","groupKey","keyGroup","pointermove","k","pointerleave","raw","getBBox","rootBBox","options","facet","viewInstances","defaultSeries","defaultShowCrosshairs","plotArea","isSeries","crosshairsSetting","facetInstances","parentKey","props","reapplyWhenUpdate"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/tooltip.ts"],"sourcesContent":["import { Circle, DisplayObject, IElement, Line } from '@antv/g';\nimport { sort, group, mean, bisector, minIndex } from '@antv/vendor/d3-array';\nimport { deepMix, lowerFirst, set, throttle, last } from '@antv/util';\nimport { Tooltip as TooltipComponent } from '@antv/component';\nimport {\n  defined,\n  groupNameOf,\n  subObject,\n  dataOf,\n  isHeatmap,\n} from '../utils/helper';\nimport { isTranspose, isPolar } from '../utils/coordinate';\nimport { angle, sub, dist } from '../utils/vector';\nimport { invert } from '../utils/scale';\nimport { BBox } from '../runtime';\nimport { CALLBACK_ITEM_SYMBOL } from '../runtime/transform';\nimport {\n  selectG2Elements,\n  createXKey,\n  selectPlotArea,\n  mousePosition,\n  selectFacetG2Elements,\n  createDatumof,\n  selectElementByData,\n  bboxOf,\n  maybeRoot,\n} from './utils';\n\nfunction getContainer(\n  group: IElement,\n  mount?: string | HTMLElement,\n): HTMLElement {\n  if (mount) {\n    return typeof mount === 'string' ? document.querySelector(mount) : mount;\n  }\n  const view = group.ownerDocument?.defaultView;\n  if (!view) return;\n  const canvas: any = view.getContextService().getDomElement();\n  return canvas.parentElement as unknown as HTMLElement;\n}\n\nfunction getBounding(root: DisplayObject): BBox {\n  const bbox = root.getRenderBounds();\n  const {\n    min: [x1, y1],\n    max: [x2, y2],\n  } = bbox;\n  return {\n    x: x1,\n    y: y1,\n    width: x2 - x1,\n    height: y2 - y1,\n  };\n}\n\nfunction getContainerOffset(\n  container1: HTMLElement,\n  container2: HTMLElement,\n): { x: number; y: number } {\n  const r1 = container1.getBoundingClientRect();\n  const r2 = container2.getBoundingClientRect();\n  return {\n    x: r1.x - r2.x,\n    y: r1.y - r2.y,\n  };\n}\n\nfunction createTooltip(\n  container: HTMLElement,\n  x0,\n  y0,\n  position,\n  enterable,\n  bounding,\n  containerOffset,\n  css = {},\n  offset: [number, number] = [10, 10],\n) {\n  const defaults = {\n    '.g2-tooltip': {},\n    '.g2-tooltip-title': {\n      overflow: 'hidden',\n      'white-space': 'nowrap',\n      'text-overflow': 'ellipsis',\n    },\n  };\n  const tooltipElement = new TooltipComponent({\n    className: 'tooltip',\n    style: {\n      x: x0,\n      y: y0,\n      container: containerOffset,\n      data: [],\n      bounding,\n      position,\n      enterable,\n      title: '',\n      offset,\n      template: {\n        prefixCls: 'g2-',\n      },\n      style: deepMix(defaults, css),\n    },\n  });\n  container.appendChild(tooltipElement.HTMLTooltipElement);\n  return tooltipElement;\n}\n\nfunction showTooltip({\n  root,\n  data,\n  x,\n  y,\n  render,\n  event,\n  single,\n  position = 'right-bottom',\n  enterable = false,\n  css,\n  mount,\n  bounding,\n  offset,\n}) {\n  const container = getContainer(root, mount);\n  const canvasContainer = getContainer(root);\n  // All the views share the same tooltip.\n  const parent = single ? canvasContainer : root;\n  const b = bounding || getBounding(root);\n  const containerOffset = getContainerOffset(canvasContainer, container);\n  const {\n    tooltipElement = createTooltip(\n      container,\n      x,\n      y,\n      position,\n      enterable,\n      b,\n      containerOffset,\n      css,\n      offset,\n    ),\n  } = parent as any;\n  const { items, title = '' } = data;\n  tooltipElement.update({\n    x,\n    y,\n    data: items,\n    title,\n    position,\n    enterable,\n    container: containerOffset,\n    ...(render !== undefined && {\n      content: render(event, { items, title }),\n    }),\n  });\n  parent.tooltipElement = tooltipElement;\n}\n\nfunction hideTooltip({\n  root,\n  single,\n  emitter,\n  nativeEvent = true,\n  event = null,\n}) {\n  if (nativeEvent) {\n    emitter.emit('tooltip:hide', { nativeEvent });\n  }\n  const container = getContainer(root);\n  const parent = single ? container : root;\n  const { tooltipElement } = parent;\n  if (tooltipElement) {\n    // Must be clientX, clientY.\n    tooltipElement.hide(event?.clientX, event?.clientY);\n  }\n  hideRuleY(root);\n  hideRuleX(root);\n  hideMarker(root);\n}\n\nfunction destroyTooltip({ root, single }) {\n  const container = getContainer(root);\n  const parent = single ? container : root;\n  if (!parent) return;\n  const { tooltipElement } = parent;\n  if (tooltipElement) {\n    tooltipElement.destroy();\n    parent.tooltipElement = undefined;\n  }\n  hideRuleY(root);\n  hideRuleX(root);\n  hideMarker(root);\n}\n\nfunction showUndefined(item) {\n  const { value } = item;\n  return { ...item, value: value === undefined ? 'undefined' : value };\n}\n\nfunction heatmapItem(element) {\n  const datum = element.__data__;\n  const normalizedX = datum?.normalized?.x ?? 0;\n\n  const originalDatum = element.parentNode?.__data__;\n  const encode = originalDatum?.encode ?? {};\n  const { x = {}, y = {}, color = {} } = encode;\n  const { value: vx = [] } = x;\n  const { value: vy = [] } = y;\n  const { value: vc = [] } = color;\n  const index = Math.min(Math.round(vx.length * normalizedX), vx.length - 1);\n\n  return {\n    title: `${vx[index]}, ${vy[index]}`,\n    items: [\n      {\n        name: color.field ?? 'value',\n        value: vc[index],\n        color: element.style?.fill || element.getAttribute?.('color') || '#000',\n      },\n    ],\n  };\n}\n\nfunction singleItem(element) {\n  const { __data__: datum } = element;\n  if (isHeatmap(element)) return heatmapItem(element);\n  const { title, items = [] } = datum;\n  const newItems = items\n    .filter(defined)\n    .map(({ color = itemColorOf(element), ...item }) => ({\n      ...item,\n      color,\n    }))\n    .map(showUndefined);\n  return {\n    ...(title && { title }),\n    items: newItems,\n  };\n}\n\nfunction itemColorOf(element) {\n  const fill = element.getAttribute('fill');\n  const stroke = element.getAttribute('stroke');\n  const { __data__: datum } = element;\n  const { color = fill && fill !== 'transparent' ? fill : stroke } = datum;\n  return color;\n}\n\nfunction unique(items, key = (d) => d) {\n  const valueName = new Map(items.map((d) => [key(d), d]));\n  return Array.from(valueName.values());\n}\n\nfunction groupItems(\n  elements,\n  scale,\n  groupName,\n  data = elements.map((d) => d['__data__']),\n  theme: Record<string, any> = {},\n) {\n  const key = (d) => (d instanceof Date ? +d : d);\n  const T = unique(\n    data.map((d) => d.title),\n    key,\n  ).filter(defined);\n  const newItems = data\n    .flatMap((datum, i) => {\n      // Fix: Get the corresponding element from datum instead of using index i\n      // When data and elements don't correspond one-to-one, using index will cause color errors\n      const element = datum.element || elements[i];\n      const { items = [], title } = datum;\n      const definedItems = items.filter(defined);\n\n      // If there is only one item, use groupName as title by default.\n      const useGroupName =\n        groupName !== undefined ? groupName : items.length <= 1 ? true : false;\n\n      return definedItems.map(\n        ({ color = itemColorOf(element) || theme.color, name, ...item }) => {\n          const groupName = groupNameOf(scale, datum);\n          // callback's priority is higher than groupName.\n          const name1 =\n            useGroupName && !(CALLBACK_ITEM_SYMBOL in item)\n              ? groupName || name\n              : name || groupName;\n\n          return {\n            ...item,\n            color,\n            name: name1 || title,\n          };\n        },\n      );\n    })\n    .map(showUndefined);\n  return {\n    ...(T.length > 0 && { title: T.join(',') }),\n    items: unique(\n      newItems,\n      (d) => `(${key(d.name)}, ${key(d.value)}, ${key(d.color)})`,\n    ),\n  };\n}\n\nfunction updateRuleX(\n  root,\n  points,\n  mouse,\n  {\n    plotWidth,\n    plotHeight,\n    mainWidth,\n    mainHeight,\n    startX,\n    startY,\n    transposed,\n    polar,\n    insetLeft,\n    insetTop,\n    ...rest\n  },\n) {\n  const defaults = {\n    lineWidth: 1,\n    stroke: '#1b1e23',\n    strokeOpacity: 0.5,\n    ...rest,\n  };\n\n  const createCircle = (cx, cy, r) => {\n    const circle = new Circle({\n      style: {\n        cx,\n        cy,\n        r,\n        ...defaults,\n      },\n    });\n    root.appendChild(circle);\n    return circle;\n  };\n\n  const createLine = (x1, x2, y1, y2) => {\n    const line = new Line({\n      style: {\n        x1,\n        x2,\n        y1,\n        y2,\n        ...defaults,\n      },\n    });\n    root.appendChild(line);\n    return line;\n  };\n\n  const minDistPoint = (mouse, points) => {\n    // only one point do not need compute\n    if (points.length === 1) {\n      return points[0];\n    }\n    const dists = points.map((p) => dist(p, mouse));\n    const minDistIndex = minIndex(dists, (d) => d);\n    return points[minDistIndex];\n  };\n\n  const target = minDistPoint(mouse, points);\n\n  const pointsOf = () => {\n    if (transposed)\n      return [\n        startX + target[0],\n        startX + target[0],\n        startY,\n        startY + plotHeight,\n      ];\n    return [startX, startX + plotWidth, target[1] + startY, target[1] + startY];\n  };\n\n  const pointsOfPolar = () => {\n    const cx = startX + insetLeft + mainWidth / 2;\n    const cy = startY + insetTop + mainHeight / 2;\n    const cdist = dist([cx, cy], target);\n    return [cx, cy, cdist];\n  };\n\n  if (polar) {\n    const [cx, cy, r] = pointsOfPolar();\n    const ruleX = root.ruleX || createCircle(cx, cy, r);\n    ruleX.style.cx = cx;\n    ruleX.style.cy = cy;\n    ruleX.style.r = r;\n    root.ruleX = ruleX;\n  } else {\n    const [x1, x2, y1, y2] = pointsOf();\n    const ruleX = root.ruleX || createLine(x1, x2, y1, y2);\n    ruleX.style.x1 = x1;\n    ruleX.style.x2 = x2;\n    ruleX.style.y1 = y1;\n    ruleX.style.y2 = y2;\n    root.ruleX = ruleX;\n  }\n}\n\nfunction updateRuleY(\n  root,\n  points,\n  {\n    plotWidth,\n    plotHeight,\n    mainWidth,\n    mainHeight,\n    startX,\n    startY,\n    transposed,\n    polar,\n    insetLeft,\n    insetTop,\n    ...rest\n  },\n) {\n  const defaults = {\n    lineWidth: 1,\n    stroke: '#1b1e23',\n    strokeOpacity: 0.5,\n    ...rest,\n  };\n\n  const Y = points.map((p) => p[1]);\n  const X = points.map((p) => p[0]);\n  const y = mean(Y);\n  const x = mean(X);\n\n  const pointsOf = () => {\n    if (polar) {\n      const r = Math.min(mainWidth, mainHeight) / 2;\n      const cx = startX + insetLeft + mainWidth / 2;\n      const cy = startY + insetTop + mainHeight / 2;\n      const a = angle(sub([x, y], [cx, cy]));\n      const x0 = cx + r * Math.cos(a);\n      const y0 = cy + r * Math.sin(a);\n      return [cx, x0, cy, y0];\n    }\n    if (transposed) return [startX, startX + plotWidth, y + startY, y + startY];\n    return [x + startX, x + startX, startY, startY + plotHeight];\n  };\n\n  const [x1, x2, y1, y2] = pointsOf();\n  const createLine = () => {\n    const line = new Line({\n      style: {\n        x1,\n        x2,\n        y1,\n        y2,\n        ...defaults,\n      },\n    });\n\n    root.appendChild(line);\n    return line;\n  };\n  // Only update rule with defined series elements.\n  if (X.length > 0) {\n    const ruleY = root.ruleY || createLine();\n    ruleY.style.x1 = x1;\n    ruleY.style.x2 = x2;\n    ruleY.style.y1 = y1;\n    ruleY.style.y2 = y2;\n    root.ruleY = ruleY;\n  }\n}\n\nfunction hideRuleY(root) {\n  if (root.ruleY) {\n    root.ruleY.remove();\n    root.ruleY = undefined;\n  }\n}\n\nfunction hideRuleX(root) {\n  if (root.ruleX) {\n    root.ruleX.remove();\n    root.ruleX = undefined;\n  }\n}\n\nfunction updateMarker(root, { data, style, theme }) {\n  if (root.markers) root.markers.forEach((d) => d.remove());\n  const { type = '' } = style;\n\n  const markers = data\n    .filter((d) => {\n      const [{ x, y }] = d;\n      return defined(x) && defined(y);\n    })\n    .map((d) => {\n      const [{ color, element }, point] = d;\n      const originColor =\n        color || // encode value\n        element.style.fill ||\n        element.style.stroke ||\n        theme.color;\n      const fill = type === 'hollow' ? 'transparent' : originColor;\n      const stroke = type === 'hollow' ? originColor : '#fff';\n      const shape = new Circle({\n        className: 'g2-tooltip-marker',\n        style: {\n          cx: point[0],\n          cy: point[1],\n          fill,\n          r: 4,\n          stroke,\n          lineWidth: 2,\n          // Prevents blocking clicks on elements behind.\n          pointerEvents: 'none',\n          ...style,\n        },\n      });\n      return shape;\n    });\n  for (const marker of markers) root.appendChild(marker);\n  root.markers = markers;\n}\n\nfunction hideMarker(root) {\n  if (root.markers) {\n    root.markers.forEach((d) => d.remove());\n    root.markers = [];\n  }\n}\n\nfunction interactionKeyof(markState, key) {\n  return Array.from(markState.values()).some(\n    // @ts-ignore\n    (d) => d.interaction?.[key],\n  );\n}\n\nexport function maybeValue(specified, defaults) {\n  return specified === undefined ? defaults : specified;\n}\n\nfunction isEmptyTooltipData(data) {\n  const { title, items } = data;\n  if (items.length === 0 && title === undefined) return true;\n  return false;\n}\n\nfunction hasSeries(markState): boolean {\n  return Array.from(markState.values()).some(\n    // @ts-ignore\n    (d) => d.interaction?.seriesTooltip && d.tooltip,\n  );\n}\n\nfunction normalizedPosition(coordinate, position) {\n  const {\n    innerWidth,\n    innerHeight,\n    marginLeft,\n    paddingLeft,\n    insetLeft,\n    marginTop,\n    paddingTop,\n    insetTop,\n  } = coordinate.getOptions();\n  return {\n    x: (position.x - marginLeft - paddingLeft - insetLeft) / innerWidth,\n    y: (position.y - marginTop - paddingTop - insetTop) / innerHeight,\n  };\n}\n\n/**\n * Finds a single element based on the mouse event in a non-series context (e.g., single item tooltip).\n * @param root - The root display object of the chart.\n * @param event - The mouse event object (e.g., pointermove, pointerdown).\n * @param elements - Array of chart elements to search within.\n * @param coordinate - The coordinate system of the chart (e.g., Cartesian, polar).\n * @param scale - The scale configurations (e.g., x, series scales).\n * @param shared - Whether the tooltip is shared among multiple elements (e.g., grouped bars).\n * @returns The matched display object or `undefined` if no element is found.\n * @description\n * - Handles bar charts by sorting elements and using bisector search for efficient lookup.\n * - For non-bar charts, directly finds the target element from the event's target.\n * - Adjusts for bar spacing in grouped charts when `shared` is false.\n */\nexport function findSingleElement({\n  root,\n  event,\n  elements = [],\n  coordinate,\n  scale,\n  shared,\n}): DisplayObject | undefined {\n  const inInterval = (d) => d.markType === 'interval';\n  const isBar = elements.every(inInterval) && !isPolar(coordinate);\n  const scaleX = scale.x;\n  const scaleSeries = scale.series;\n  const bandWidth = scaleX?.getBandWidth?.() ?? 0;\n  const xof = scaleSeries\n    ? (d) => {\n        const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);\n        return (\n          d.__data__.x +\n          d.__data__.series * bandWidth +\n          bandWidth / (seriesCount * 2)\n        );\n      }\n    : (d) => d.__data__.x + bandWidth / 2;\n\n  // Sort for bisector search.\n  if (isBar) elements.sort((a, b) => xof(a) - xof(b));\n  const findElementByTarget = (event) => {\n    const { target = last(elements) } = event;\n    return maybeRoot(target, (node) => {\n      if (!node.classList) return false;\n      if (isHeatmap(node)) {\n        set(\n          node,\n          '__data__.normalized',\n          normalizedPosition(coordinate, {\n            x: event.offsetX,\n            y: event.offsetY,\n          }),\n        );\n      }\n      return node.classList.includes('element');\n    });\n  };\n\n  const element = isBar\n    ? (event) => {\n        const mouse = mousePosition(root, event);\n        if (!mouse) return;\n        const [abstractX] = coordinate.invert(mouse);\n        const search = bisector(xof).center;\n        const i = search(elements, abstractX);\n        const target = elements[i];\n\n        if (!shared) {\n          // For grouped bar chart without shared options.\n          const isGrouped = elements.find(\n            (d) => d !== target && xof(d) === xof(target),\n          );\n          if (isGrouped) return findElementByTarget(event);\n        }\n        return target;\n      }\n    : findElementByTarget;\n\n  return element(event);\n}\n\n/**\n * Finds series-related elements and data based on the mouse event for series tooltips.\n * @param root - The root display object of the chart.\n * @param event - The mouse event object (e.g., pointermove, pointerdown).\n * @param elements - Array of chart elements to search within.\n * @param coordinate - The coordinate system of the chart (e.g., Cartesian, polar).\n * @param scale - The scale configurations (e.g., x, series scales).\n * @param startX - The starting X position of the plot area.\n * @param startY - The starting Y position of the plot area.\n * @returns An object containing:\n * - `selectedElements`: Matched display objects (series and item elements).\n * - `selectedData`: Corresponding data records of the selected elements.\n * - `filteredSeriesData`: Filtered series data closest to the mouse focus.\n * - `abstractX`: A function to convert mouse coordinates to abstract X values.\n * @description\n * - Splits elements into series and item elements for targeted searching.\n * - Handles bar charts and band scales using bisector search and coordinate inversion.\n * - Sorts elements to ensure correct visual ordering (top-to-bottom or right-to-left in transposed mode).\n * - Filters and groups data to provide accurate tooltip information for series.\n */\nexport function findSeriesElement({\n  root,\n  event,\n  elements,\n  coordinate,\n  scale,\n  startX,\n  startY,\n}): {\n  selectedElements: DisplayObject[];\n  selectedData: Record<string, any>[];\n  filteredSeriesData: any[];\n  abstractX: (number) => number;\n} {\n  const transposed = isTranspose(coordinate);\n\n  // Split elements into series elements and item elements.\n  const seriesElements = [];\n  const itemElements = [];\n  for (const element of elements) {\n    const { __data__: data } = element;\n    const { seriesX, title, items } = data;\n    if (seriesX) seriesElements.push(element);\n    else if (title || items) itemElements.push(element);\n  }\n  const inInterval = (d) => d.markType === 'interval';\n  const isBar =\n    itemElements.length &&\n    itemElements.every(inInterval) &&\n    !isPolar(coordinate);\n  const xof = (d) => d.__data__.x;\n\n  // For band scale x, find the closest series element to focus,\n  // useful for interval + line mark.\n  const isBandScale = !!scale.x.getBandWidth;\n  const closest = isBandScale && itemElements.length > 0;\n\n  // Sorted elements from top to bottom visually,\n  // or from right to left in transpose coordinate.\n  seriesElements.sort((a, b) => {\n    const index = transposed ? 0 : 1;\n    const minY = (d) => d.getBounds().min[index];\n    return transposed ? minY(b) - minY(a) : minY(a) - minY(b);\n  });\n\n  const extent = (d) => {\n    const index = transposed ? 1 : 0;\n    const { min, max } = d.getLocalBounds();\n    return sort([min[index], max[index]]);\n  };\n\n  // Sort itemElements for bisector search.\n  if (isBar) elements.sort((a, b) => xof(a) - xof(b));\n  else {\n    itemElements.sort((a, b) => {\n      const [minA, maxA] = extent(a);\n      const [minB, maxB] = extent(b);\n      const midA = (minA + maxA) / 2;\n      const midB = (minB + maxB) / 2;\n      return transposed ? midB - midA : midA - midB;\n    });\n  }\n\n  // Get sortedIndex and X for each series elements\n  const elementSortedX = new Map(\n    seriesElements.map((element) => {\n      const { __data__: data } = element;\n      const { seriesX } = data;\n      const seriesIndex = seriesX.map((_, i) => i);\n      const sortedIndex = sort(seriesIndex, (i) => seriesX[+i]);\n      return [element, [sortedIndex, seriesX]];\n    }),\n  );\n\n  const { x: scaleX } = scale;\n\n  // Apply offset for band scale x.\n  const offsetX = scaleX?.getBandWidth ? scaleX.getBandWidth() / 2 : 0;\n\n  const abstractX = (focus) => {\n    const [normalizedX] = coordinate.invert(focus);\n    return normalizedX - offsetX;\n  };\n\n  const indexByFocus = (event, focus, I, X) => {\n    // _x is from emit event, to find the right element.\n    const { _x } = event;\n    const finalX = _x !== undefined ? scaleX.map(_x) : abstractX(focus);\n    const DX = X.filter(defined);\n    const [minX, maxX] = sort([DX[0], DX[DX.length - 1]]);\n    // If only has one element(minX == maxX), show tooltip when hover whole chart\n    const isOnlyOneElement = minX === maxX;\n\n    // If closest is true, always find at least one element.\n    // Otherwise, skip element out of plot area.\n    if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement)\n      return null;\n    const search = bisector((i) => X[+i]).center;\n    const i = search(I, finalX);\n    return I[i];\n  };\n\n  const elementsByFocus = isBar\n    ? (focus, elements) => {\n        const search = bisector(xof).center;\n        const i = search(elements, abstractX(focus));\n        const find = elements[i];\n        const groups = group(elements, xof);\n        const selected = groups.get(xof(find));\n        return selected;\n      }\n    : (focus, elements) => {\n        const index = transposed ? 1 : 0;\n        const x = focus[index];\n        const filtered = elements.filter((element) => {\n          const [min, max] = extent(element);\n          return x >= min && x <= max;\n        });\n        // If closet is true, always find at least one element.\n        if (!closest || filtered.length > 0) return filtered;\n\n        // Search the closet element to the focus.\n        const search = bisector((element) => {\n          const [min, max] = extent(element);\n          return (min + max) / 2;\n        }).center;\n        const i = search(elements, x);\n        return [elements[i]].filter(defined);\n      };\n\n  const seriesData = (element, index) => {\n    const { __data__: data } = element;\n    return Object.fromEntries(\n      Object.entries(data)\n        .filter(([key]) => key.startsWith('series') && key !== 'series')\n        .map(([key, V]) => {\n          const d = V[index];\n          return [lowerFirst(key.replace('series', '')), d];\n        }),\n    );\n  };\n  const mouse = mousePosition(root, event);\n  if (!mouse) return;\n  const focus = [mouse[0] - startX, mouse[1] - startY];\n  if (!focus) return;\n  // Get selected item element.\n  const selectedItems = elementsByFocus(focus, itemElements);\n\n  // Get selected data item from both series element and item element.\n  const selectedSeriesElements = [];\n  const selectedSeriesData = [];\n  for (const element of seriesElements) {\n    const [sortedIndex, X] = elementSortedX.get(element);\n    const index = indexByFocus(event, focus, sortedIndex, X);\n    if (index !== null) {\n      selectedSeriesElements.push(element);\n      const d = seriesData(element, index);\n      const { x, y } = d;\n      const p = coordinate.map([(x || 0) + offsetX, y || 0]);\n      selectedSeriesData.push([{ ...d, element }, p] as const);\n    }\n  }\n\n  // Filter selectedSeriesData with different x,\n  // make sure there is only one x closest to focusX.\n  const SX = Array.from(new Set(selectedSeriesData.map((d) => d[0].x)));\n  const closestX = SX[minIndex(SX, (x) => Math.abs(x - abstractX(focus)))];\n  const filteredSeriesData = selectedSeriesData.filter(\n    (d) => d[0].x === closestX,\n  );\n\n  const selectedData = [\n    ...filteredSeriesData.map((d) => d[0]),\n    ...selectedItems.map((d) => d.__data__),\n  ];\n\n  // Get the displayed tooltip data.\n  const selectedElements = [...selectedSeriesElements, ...selectedItems];\n\n  return { selectedElements, selectedData, filteredSeriesData, abstractX };\n}\n\n/**\n * Show tooltip for series item.\n */\nexport function seriesTooltip(\n  root: DisplayObject,\n  {\n    elements: elementsof,\n    sort: sortFunction,\n    filter: filterFunction,\n    scale,\n    coordinate,\n    crosshairs,\n    crosshairsX,\n    crosshairsY,\n    render,\n    groupName,\n    emitter,\n    wait = 50,\n    leading = true,\n    trailing = false,\n    startX = 0,\n    startY = 0,\n    body = true,\n    single = true,\n    position,\n    enterable,\n    mount,\n    bounding,\n    theme,\n    offset,\n    disableNative = false,\n    marker = true,\n    preserve = false,\n    style: _style = {},\n    css = {},\n    ...rest\n  }: Record<string, any>,\n) {\n  const elements = elementsof(root);\n  const style = deepMix(_style, rest);\n  const polar = isPolar(coordinate);\n  const transposed = isTranspose(coordinate);\n  const {\n    innerWidth: plotWidth,\n    innerHeight: plotHeight,\n    width: mainWidth,\n    height: mainHeight,\n    insetLeft,\n    insetTop,\n  } = coordinate.getOptions();\n  const update = throttle(\n    (event) => {\n      const mouse = mousePosition(root, event);\n      if (!mouse) return;\n      const bbox = bboxOf(root);\n      const x = bbox.min[0];\n      const y = bbox.min[1];\n      const { selectedElements, selectedData, filteredSeriesData, abstractX } =\n        findSeriesElement({\n          root,\n          event,\n          elements,\n          coordinate,\n          scale,\n          startX,\n          startY,\n        });\n      const tooltipData = groupItems(\n        selectedElements,\n        scale,\n        groupName,\n        selectedData,\n        theme,\n      );\n\n      // Sort items and filter items.\n      if (sortFunction) {\n        tooltipData.items.sort((a, b) => sortFunction(a) - sortFunction(b));\n      }\n      if (filterFunction) {\n        tooltipData.items = tooltipData.items.filter(filterFunction);\n      }\n\n      // Hide tooltip with no selected tooltip.\n      if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {\n        hide(event);\n        return;\n      }\n\n      if (body) {\n        showTooltip({\n          root,\n          data: tooltipData,\n          x: mouse[0] + x,\n          y: mouse[1] + y,\n          render,\n          event,\n          single,\n          position,\n          enterable,\n          mount,\n          bounding,\n          css,\n          offset,\n        });\n      }\n\n      if (crosshairs || crosshairsX || crosshairsY) {\n        const ruleStyle = subObject(style, 'crosshairs');\n\n        const ruleStyleX = {\n          ...ruleStyle,\n          ...subObject(style, 'crosshairsX'),\n        };\n        const ruleStyleY = {\n          ...ruleStyle,\n          ...subObject(style, 'crosshairsY'),\n        };\n\n        const points = filteredSeriesData.map((d) => d[1]);\n        if (crosshairsX) {\n          updateRuleX(root, points, mouse, {\n            ...ruleStyleX,\n            plotWidth,\n            plotHeight,\n            mainWidth,\n            mainHeight,\n            insetLeft,\n            insetTop,\n            startX,\n            startY,\n            transposed,\n            polar,\n          });\n        }\n\n        if (crosshairsY) {\n          updateRuleY(root, points, {\n            ...ruleStyleY,\n            plotWidth,\n            plotHeight,\n            mainWidth,\n            mainHeight,\n            insetLeft,\n            insetTop,\n            startX,\n            startY,\n            transposed,\n            polar,\n          });\n        }\n      }\n\n      if (marker) {\n        const markerStyles = subObject(style, 'marker');\n        updateMarker(root, {\n          data: filteredSeriesData,\n          style: markerStyles,\n          theme,\n        });\n      }\n\n      // X in focus may related multiple points when dataset is large,\n      // so we need to find the first x to show tooltip.\n      const firstX = filteredSeriesData[0]?.[0].x;\n      const transformedX = firstX ?? abstractX(focus);\n\n      emitter.emit('tooltip:show', {\n        ...event,\n        nativeEvent: true,\n        data: {\n          ...tooltipData,\n          data: { x: invert(scale.x, transformedX, true) },\n        },\n      });\n    },\n    wait,\n    { leading, trailing },\n  ) as (...args: any[]) => void;\n\n  const hide = (event: MouseEvent) => {\n    hideTooltip({ root, single, emitter, event });\n  };\n\n  const destroy = () => {\n    destroyTooltip({ root, single });\n  };\n\n  const onTooltipShow = ({ nativeEvent, data, offsetX, offsetY, ...rest }) => {\n    if (nativeEvent) return;\n    const x = data?.data?.x;\n    const scaleX = scale.x;\n    const x1 = scaleX.map(x);\n    const [x2, y2] = coordinate.map([x1, 0.5]);\n    const rootBounds = root.getRenderBounds();\n    const minX = rootBounds.min[0];\n    const minY = rootBounds.min[1];\n    update({\n      ...rest,\n      offsetX: offsetX !== undefined ? offsetX : minX + x2,\n      offsetY: offsetY !== undefined ? offsetY : minY + y2,\n      _x: x, // a hint, to lookup for the right element if multiple element in the same abstractX.\n    });\n  };\n\n  const onTooltipHide = () => {\n    hideTooltip({ root, single, emitter, nativeEvent: false });\n  };\n\n  const onTooltipDisable = () => {\n    removeEventListeners();\n    destroy();\n  };\n\n  const onTooltipEnable = () => {\n    addEventListeners();\n  };\n\n  const addEventListeners = () => {\n    if (!disableNative) {\n      root.addEventListener('pointerdown', update);\n      root.addEventListener('pointerenter', update);\n      root.addEventListener('pointermove', update);\n      // Only emit pointerleave event when the pointer is not in the root area.\n      root.addEventListener('pointerleave', (e) => {\n        if (mousePosition(root, e)) return;\n        hide(e);\n      });\n      root.addEventListener('pointerup', hide);\n    }\n  };\n\n  const removeEventListeners = () => {\n    if (!disableNative) {\n      root.removeEventListener('pointerdown', update);\n      root.removeEventListener('pointerenter', update);\n      root.removeEventListener('pointermove', update);\n      root.removeEventListener('pointerleave', hide);\n      root.removeEventListener('pointerup', hide);\n    }\n  };\n\n  addEventListeners();\n\n  emitter.on('tooltip:show', onTooltipShow);\n  emitter.on('tooltip:hide', onTooltipHide);\n  emitter.on('tooltip:disable', onTooltipDisable);\n  emitter.on('tooltip:enable', onTooltipEnable);\n\n  return () => {\n    removeEventListeners();\n    emitter.off('tooltip:show', onTooltipShow);\n    emitter.off('tooltip:hide', onTooltipHide);\n    emitter.off('tooltip:disable', onTooltipDisable);\n    emitter.off('tooltip:enable', onTooltipEnable);\n    if (preserve) {\n      hideTooltip({ root, single, emitter, nativeEvent: false });\n    } else {\n      destroy();\n    }\n  };\n}\n\n/**\n * Show tooltip for non-series item.\n */\nexport function tooltip(\n  root: DisplayObject,\n  {\n    elements: elementsof,\n    coordinate,\n    scale,\n    render,\n    groupName,\n    sort: sortFunction,\n    filter: filterFunction,\n    emitter,\n    wait = 50,\n    leading = true,\n    trailing = false,\n    groupKey = (d) => d, // group elements by specified key\n    single = true,\n    position,\n    enterable,\n    datum,\n    view,\n    mount,\n    bounding,\n    theme,\n    offset,\n    shared = false,\n    body = true,\n    disableNative = false,\n    preserve = false,\n    css = {},\n  }: Record<string, any>,\n) {\n  const elements = elementsof(root);\n  const keyGroup = group(elements, groupKey);\n  const pointermove = throttle(\n    (event) => {\n      const element = findSingleElement({\n        root,\n        event,\n        elements,\n        coordinate,\n        scale,\n        shared,\n      });\n      if (!element) {\n        hideTooltip({ root, single, emitter, event });\n        return;\n      }\n      const k = groupKey(element);\n      const group = keyGroup.get(k);\n      if (!group) {\n        return;\n      }\n      const data =\n        group.length === 1 && !shared\n          ? singleItem(group[0])\n          : groupItems(group, scale, groupName, undefined, theme);\n\n      // Sort items and sort.\n      if (sortFunction) {\n        data.items.sort((a, b) => sortFunction(a) - sortFunction(b));\n      }\n      if (filterFunction) {\n        data.items = data.items.filter(filterFunction);\n      }\n\n      if (isEmptyTooltipData(data)) {\n        hideTooltip({ root, single, emitter, event });\n        return;\n      }\n\n      const { offsetX, offsetY } = event;\n      if (body) {\n        showTooltip({\n          root,\n          data,\n          x: offsetX,\n          y: offsetY,\n          render,\n          event,\n          single,\n          position,\n          enterable,\n          mount,\n          bounding,\n          css,\n          offset,\n        });\n      }\n\n      emitter.emit('tooltip:show', {\n        ...event,\n        nativeEvent: true,\n        data: {\n          ...data,\n          data: dataOf(element, view),\n        },\n      });\n    },\n    wait,\n    { leading, trailing },\n  ) as (...args: any[]) => void;\n\n  const pointerleave = (event) => {\n    hideTooltip({ root, single, emitter, event });\n  };\n\n  const addEventListeners = () => {\n    if (!disableNative) {\n      root.addEventListener('pointerdown', pointermove);\n      root.addEventListener('pointermove', pointermove);\n      // Only emit pointerleave event when the pointer is not in the root area.\n      // !!!DO NOT USE pointerout event, it will emit when the pointer is in the child area.\n      root.addEventListener('pointerleave', pointerleave);\n      root.addEventListener('pointerup', pointerleave);\n    }\n  };\n\n  const removeEventListeners = () => {\n    if (!disableNative) {\n      root.removeEventListener('pointerdown', pointermove);\n      root.removeEventListener('pointermove', pointermove);\n      root.removeEventListener('pointerleave', pointerleave);\n      root.removeEventListener('pointerup', pointerleave);\n    }\n  };\n\n  const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw }) => {\n    if (nativeEvent) return;\n    const { data } = raw;\n    const element = selectElementByData(elements, data, datum);\n    if (!element) return;\n    const bbox = element.getBBox();\n    const { x, y, width, height } = bbox;\n    const rootBBox = root.getBBox();\n    pointermove({\n      target: element,\n      offsetX: offsetX !== undefined ? offsetX + rootBBox.x : x + width / 2,\n      offsetY: offsetY !== undefined ? offsetY + rootBBox.y : y + height / 2,\n    });\n  };\n\n  const onTooltipHide = ({ nativeEvent }: any = {}) => {\n    if (nativeEvent) return;\n    hideTooltip({ root, single, emitter, nativeEvent: false });\n  };\n\n  const onTooltipDisable = () => {\n    removeEventListeners();\n    destroyTooltip({ root, single });\n  };\n\n  const onTooltipEnable = () => {\n    addEventListeners();\n  };\n\n  emitter.on('tooltip:show', onTooltipShow);\n  emitter.on('tooltip:hide', onTooltipHide);\n  emitter.on('tooltip:enable', onTooltipEnable);\n  emitter.on('tooltip:disable', onTooltipDisable);\n\n  addEventListeners();\n\n  return () => {\n    removeEventListeners();\n    emitter.off('tooltip:show', onTooltipShow);\n    emitter.off('tooltip:hide', onTooltipHide);\n    emitter.off('tooltip:enable', onTooltipEnable);\n    emitter.off('tooltip:disable', onTooltipDisable);\n    if (preserve) {\n      hideTooltip({ root, single, emitter, nativeEvent: false });\n    } else {\n      destroyTooltip({ root, single });\n    }\n  };\n}\n\nexport function Tooltip(options) {\n  const {\n    shared,\n    crosshairs,\n    crosshairsX,\n    crosshairsY,\n    series,\n    name,\n    item = () => ({}),\n    facet = false,\n    ...rest\n  } = options;\n\n  return (target, viewInstances, emitter) => {\n    const { container, view } = target;\n    const { scale, markState, coordinate, theme } = view;\n    // Get default value from mark states.\n    const defaultSeries = interactionKeyof(markState, 'seriesTooltip');\n    const defaultShowCrosshairs = interactionKeyof(markState, 'crosshairs');\n    const plotArea = selectPlotArea(container);\n    const isSeries = maybeValue(series, defaultSeries);\n    const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);\n\n    // For non-facet and series tooltip.\n    if (isSeries && hasSeries(markState) && !facet) {\n      return seriesTooltip(plotArea, {\n        ...rest,\n        theme,\n        elements: selectG2Elements,\n        scale,\n        coordinate,\n        crosshairs: crosshairsSetting,\n        // the crosshairsX settings level: crosshairsX > crosshairs > false\n        // it means crosshairsX default is false\n        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),\n        // crosshairsY default depend on the crossharisSettings\n        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),\n        item,\n        emitter,\n      });\n    }\n\n    // For facet and series tooltip.\n    if (isSeries && facet) {\n      // Get sub view instances for this view.\n      const facetInstances = viewInstances.filter(\n        (d) => d !== target && d.options.parentKey === target.options.key,\n      );\n      const elements = selectFacetG2Elements(target, viewInstances);\n      // Use the scale of the first view.\n      const scale = facetInstances[0].view.scale;\n      const bbox = plotArea.getBounds();\n      const startX = bbox.min[0];\n      const startY = bbox.min[1];\n      Object.assign(scale, { facet: true });\n\n      // @todo Nested structure rather than flat structure for facet?\n      // Add listener to the root area.\n      // @ts-ignore\n      return seriesTooltip(plotArea.parentNode.parentNode, {\n        ...rest,\n        theme,\n        elements: () => elements,\n        scale,\n        coordinate,\n        crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),\n        // the crosshairsX settings level: crosshairsX > crosshairs > false\n        // it means crosshairsX default is false\n        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),\n        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),\n        item,\n        startX,\n        startY,\n        emitter,\n      });\n    }\n\n    return tooltip(plotArea, {\n      ...rest,\n      datum: createDatumof(view),\n      elements: selectG2Elements,\n      scale,\n      coordinate,\n      groupKey: shared ? createXKey(view) : undefined,\n      item,\n      emitter,\n      view,\n      theme,\n      shared,\n    });\n  };\n}\n\nTooltip.props = {\n  reapplyWhenUpdate: true,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}