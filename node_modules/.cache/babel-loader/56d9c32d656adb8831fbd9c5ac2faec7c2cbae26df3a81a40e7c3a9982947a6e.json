{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { line, curveLinearClosed } from '@antv/vendor/d3-shape';\nimport { isTranspose } from '../../utils/coordinate';\nimport { select } from '../../utils/selection';\nimport { applyStyle, reorder } from '../utils';\n/**\n * Adjust and return the new `points`.\n */\nfunction getFunnelPoints(points, nextPoints, coordinate) {\n  const [p0, p1, p2, p3] = points;\n  if (isTranspose(coordinate)) {\n    const newP1 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];\n    const newP2 = [nextPoints ? nextPoints[3][0] : p2[0], p2[1]];\n    return [p0, newP1, newP2, p3];\n  }\n  const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];\n  const newP2 = [p2[0], nextPoints ? nextPoints[3][1] : p2[1]];\n  return [p0, newP1, newP2, p3];\n}\n/**\n * Render funnel in different coordinate and using color channel for stroke and fill attribute.\n */\nexport const Funnel = (options, context) => {\n  const {\n      adjustPoints = getFunnelPoints\n    } = options,\n    style = __rest(options, [\"adjustPoints\"]);\n  const {\n    coordinate,\n    document\n  } = context;\n  return (points, value, defaults, point2d) => {\n    const {\n      index\n    } = value;\n    const {\n        color: defaultColor\n      } = defaults,\n      rest = __rest(defaults, [\"color\"]);\n    const nextPoints = point2d[index + 1];\n    const funnelPoints = adjustPoints(points, nextPoints, coordinate);\n    const tpShape = !!isTranspose(coordinate);\n    const [p0, p1, p2, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;\n    const {\n      color = defaultColor,\n      opacity\n    } = value;\n    const b = line().curve(curveLinearClosed)([p0, p1, p2, p3]);\n    return select(document.createElement('path', {})).call(applyStyle, rest).style('d', b).style('fill', color).style('fillOpacity', opacity).call(applyStyle, style).node();\n  };\n};\nFunnel.props = {\n  defaultMarker: 'square'\n};","map":{"version":3,"names":["line","curveLinearClosed","isTranspose","select","applyStyle","reorder","getFunnelPoints","points","nextPoints","coordinate","p0","p1","p2","p3","newP1","newP2","Funnel","options","context","adjustPoints","style","__rest","document","value","defaults","point2d","index","color","defaultColor","rest","funnelPoints","tpShape","opacity","b","curve","createElement","call","node","props","defaultMarker"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/interval/funnel.ts"],"sourcesContent":["import { line, curveLinearClosed } from '@antv/vendor/d3-shape';\nimport { Coordinate } from '@antv/coord';\nimport { isTranspose } from '../../utils/coordinate';\nimport { ShapeComponent as SC, Vector2 } from '../../runtime';\nimport { select } from '../../utils/selection';\nimport { applyStyle, reorder } from '../utils';\n\nexport type FunnelOptions = {\n  adjustPoints?: (\n    points: Vector2[],\n    nextPoints: Vector2[],\n    coordinate: Coordinate,\n  ) => Vector2[];\n  [key: string]: any;\n};\n\n/**\n * Adjust and return the new `points`.\n */\nfunction getFunnelPoints(\n  points: Vector2[],\n  nextPoints: Vector2[],\n  coordinate: Coordinate,\n) {\n  const [p0, p1, p2, p3] = points;\n\n  if (isTranspose(coordinate)) {\n    const newP1: Vector2 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];\n    const newP2: Vector2 = [nextPoints ? nextPoints[3][0] : p2[0], p2[1]];\n    return [p0, newP1, newP2, p3];\n  }\n  const newP1: Vector2 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];\n  const newP2: Vector2 = [p2[0], nextPoints ? nextPoints[3][1] : p2[1]];\n  return [p0, newP1, newP2, p3];\n}\n\n/**\n * Render funnel in different coordinate and using color channel for stroke and fill attribute.\n */\nexport const Funnel: SC<FunnelOptions> = (options, context) => {\n  const { adjustPoints = getFunnelPoints, ...style } = options;\n  const { coordinate, document } = context;\n  return (points, value, defaults, point2d) => {\n    const { index } = value;\n    const { color: defaultColor, ...rest } = defaults;\n    const nextPoints = point2d[index + 1];\n    const funnelPoints = adjustPoints(points, nextPoints, coordinate);\n    const tpShape = !!isTranspose(coordinate);\n    const [p0, p1, p2, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;\n    const { color = defaultColor, opacity } = value;\n    const b = line().curve(curveLinearClosed)([p0, p1, p2, p3]);\n    return select(document.createElement('path', {}))\n      .call(applyStyle, rest)\n      .style('d', b)\n      .style('fill', color)\n      .style('fillOpacity', opacity)\n      .call(applyStyle, style)\n      .node();\n  };\n};\n\nFunnel.props = {\n  defaultMarker: 'square',\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}