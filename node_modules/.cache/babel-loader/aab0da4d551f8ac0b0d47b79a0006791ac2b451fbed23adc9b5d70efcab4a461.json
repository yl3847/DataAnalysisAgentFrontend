{"ast":null,"code":"import getAdjMatrix from './adjacent-matrix';\nimport { uniqueId } from './util';\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  }\n  // the origin data\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach(function (node, i) {\n    var cid = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  });\n  // the adjacent matrix of calNodes inside clusters\n  var adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      });\n      // find the cluster with max weight\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true;\n        // remove from origin cluster\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // move the node to the best cluster\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n    if (state_1 === \"break\") break;\n  }\n  // delete the empty clusters\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n  // get the cluster edges\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n      target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\nexport default labelPropagation;","map":{"version":3,"names":["getAdjMatrix","uniqueId","labelPropagation","graphData","directed","weightPropertyName","maxIteration","_a","nodes","_b","edges","clusters","nodeMap","forEach","node","i","cid","clusterId","id","idx","adjMatrix","ks","neighbors","row","k","iid","entry","j","jid","push","iter","_loop_1","changed","neighborClusters","Object","keys","neighborId","neighborWeight","neighborNode","neighborClusterId","maxWeight","Infinity","bestClusterIds","length","selfClusterIdx","indexOf","splice","selfCluster","nodeInSelfClusterIdx","randomIdx","Math","floor","random","bestCluster","state_1","cluster","clusterEdges","clusterEdgeMap","edge","source","target","weight","sourceClusterId","targetClusterId","newEdgeId","concat","count","newEdge","clustersArray"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/algorithm/es/label-propagation.js"],"sourcesContent":["import getAdjMatrix from './adjacent-matrix';\nimport { uniqueId } from './util';\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  }\n  // the origin data\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach(function (node, i) {\n    var cid = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  });\n  // the adjacent matrix of calNodes inside clusters\n  var adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      });\n      // find the cluster with max weight\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true;\n        // remove from origin cluster\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // move the node to the best cluster\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n    if (state_1 === \"break\") break;\n  }\n  // delete the empty clusters\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n  // get the cluster edges\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n      target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\nexport default labelPropagation;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}