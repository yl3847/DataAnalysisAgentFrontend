{"ast":null,"code":"/*!\n * @antv/g-dom-mutation-observer-api\n * @description A simple implementation of DOM MutationObserver API.\n * @version 2.0.38\n * @date 7/30/2025, 1:34:51 PM\n * @author AntVis\n * @docs https://g.antv.antgroup.com/\n */\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport { ElementEvent, MutationEvent, runtime } from '@antv/g-lite';\nvar MutationRecord = /*#__PURE__*/function () {\n  function MutationRecord(type, target) {\n    _classCallCheck(this, MutationRecord);\n    this.addedNodes = [];\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.nextSibling = null;\n    this.oldValue = null;\n    this.previousSibling = null;\n    this.removedNodes = [];\n    this.type = type;\n    this.target = target;\n  }\n  return _createClass(MutationRecord, null, [{\n    key: \"copy\",\n    value: function copy(original) {\n      var record = new MutationRecord(original.type, original.target);\n      record.addedNodes = original.addedNodes.slice();\n      record.removedNodes = original.removedNodes.slice();\n      record.previousSibling = original.previousSibling;\n      record.nextSibling = original.nextSibling;\n      record.attributeName = original.attributeName;\n      record.attributeNamespace = original.attributeNamespace;\n      record.oldValue = original.oldValue;\n      return record;\n    }\n  }]);\n}();\nvar uidCounter = 0;\nvar registrationsTable = new WeakMap();\nvar Registration = /*#__PURE__*/function () {\n  function Registration(observer, target, options) {\n    _classCallCheck(this, Registration);\n    this.transientObservedNodes = [];\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n  }\n  return _createClass(Registration, [{\n    key: \"enqueue\",\n    value: function enqueue(record) {\n      var records = this.observer.records;\n      var length = records.length;\n\n      // There are cases where we replace the last record with the new record.\n      // For example if the record represents the same mutation we need to use\n      // the one with the oldValue. If we get same record (this can happen as we\n      // walk up the tree) we ignore the new record.\n      if (records.length > 0) {\n        var lastRecord = records[length - 1];\n        var recordToReplaceLast = selectRecord(lastRecord, record);\n        if (recordToReplaceLast) {\n          records[length - 1] = recordToReplaceLast;\n          return;\n        }\n      } else {\n        scheduleCallback(this.observer);\n      }\n      records[length] = record;\n    }\n  }, {\n    key: \"addListeners\",\n    value: function addListeners() {\n      this.addListeners_(this.target);\n    }\n  }, {\n    key: \"addListeners_\",\n    value: function addListeners_(node) {\n      var options = this.options;\n      if (options.attributes) node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n\n      // if (options.characterData) node.addEventListener('DOMCharacterDataModified', this, true);\n\n      if (options.childList) node.addEventListener(ElementEvent.INSERTED, this, true);\n      if (options.childList || options.subtree) node.addEventListener(ElementEvent.REMOVED, this, true);\n    }\n  }, {\n    key: \"removeListeners\",\n    value: function removeListeners() {\n      this.removeListeners_(this.target);\n    }\n  }, {\n    key: \"removeListeners_\",\n    value: function removeListeners_(node) {\n      var options = this.options;\n      if (options.attributes) node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n\n      // if (options.characterData) node.removeEventListener('DOMCharacterDataModified', this, true);\n\n      if (options.childList) node.removeEventListener(ElementEvent.INSERTED, this, true);\n      if (options.childList || options.subtree) node.removeEventListener(ElementEvent.REMOVED, this, true);\n    }\n\n    /**\n     * Adds a transient observer on node. The transient observer gets removed\n     * next time we deliver the change records.\n     */\n    // addTransientObserver(node: IElement) {\n    //   // Don't add transient observers on the target itself. We already have all\n    //   // the required listeners set up on the target.\n    //   if (node === this.target) return;\n\n    //   this.addListeners_(node);\n    //   this.transientObservedNodes.push(node);\n    //   let registrations = registrationsTable.get(node);\n    //   if (!registrations) registrationsTable.set(node, (registrations = []));\n\n    //   // We know that registrations does not contain this because we already\n    //   // checked if node === this.target.\n    //   registrations.push(this);\n    // }\n  }, {\n    key: \"removeTransientObservers\",\n    value: function removeTransientObservers() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n      transientObservedNodes.forEach(function (node) {\n        // Transient observers are never added to the target.\n        this.removeListeners_(node);\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i] === this) {\n            registrations.splice(i, 1);\n            // Each node can only have one registered observer associated with\n            // this observer.\n            break;\n          }\n        }\n      }, this);\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(e) {\n      // Stop propagation since we are managing the propagation manually.\n      // This means that other mutation events on the page will not work\n      // correctly but that is by design.\n      e.stopImmediatePropagation();\n      var record;\n      var target;\n      switch (e.type) {\n        case ElementEvent.ATTR_MODIFIED:\n          // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\n          var name = e.attrName;\n          // @ts-ignore\n          var namespace = e.relatedNode.namespaceURI;\n          target = e.target;\n\n          // 1.\n          record = getRecord('attributes', target);\n          record.attributeName = name;\n          record.attributeNamespace = namespace;\n\n          // 2.\n          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n          forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n            // 3.1, 4.2\n            if (!options.attributes) return;\n\n            // 3.2, 4.3\n            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\n              return;\n            }\n            // 3.3, 4.4\n            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n\n            // 3.4, 4.5\n            return record;\n          });\n          break;\n\n        // case 'DOMCharacterDataModified':\n        //   // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n        //   var target = e.target;\n\n        //   // 1.\n        //   var record = getRecord('characterData', target);\n\n        //   // 2.\n        //   var oldValue = e.prevValue;\n\n        //   forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n        //     // 3.1, 4.2\n        //     if (!options.characterData)\n        //       return;\n\n        //     // 3.2, 4.3\n        //     if (options.characterDataOldValue)\n        //       return getRecordWithOldValue(oldValue);\n\n        //     // 3.3, 4.4\n        //     return record;\n        //   });\n\n        //   break;\n\n        case ElementEvent.REMOVED:\n        // this.addTransientObserver(e.target as IElement);\n        // Fall through.\n        case ElementEvent.INSERTED:\n          // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n          target = e.relatedNode;\n          var changedNode = e.target;\n          var addedNodes;\n          var removedNodes;\n          if (e.type === ElementEvent.INSERTED) {\n            addedNodes = [changedNode];\n            removedNodes = [];\n          } else {\n            addedNodes = [];\n            removedNodes = [changedNode];\n          }\n          var previousSibling = changedNode.previousSibling;\n          var nextSibling = changedNode.nextSibling;\n\n          // 1.\n          record = getRecord('childList', target);\n          record.addedNodes = addedNodes;\n          record.removedNodes = removedNodes;\n          record.previousSibling = previousSibling;\n          record.nextSibling = nextSibling;\n          forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n            // 2.1, 3.2\n            if (!options.childList) return;\n\n            // 2.2, 3.3\n            return record;\n          });\n      }\n      clearRecords();\n    }\n  }]);\n}();\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n * @see https://github.com/googlearchive/MutationObservers/blob/master/MutationObserver.js\n */\nvar MutationObserver = /*#__PURE__*/function () {\n  function MutationObserver(callback) {\n    _classCallCheck(this, MutationObserver);\n    this.nodes = [];\n    this.records = [];\n    this.uid = uidCounter++;\n    this.callback = callback;\n  }\n  return _createClass(MutationObserver, [{\n    key: \"observe\",\n    value: function observe(target, options) {\n      // 1.1\n      if (!options.childList && !options.attributes && !options.characterData ||\n      // 1.2\n      options.attributeOldValue && !options.attributes ||\n      // 1.3\n      options.attributeFilter && options.attributeFilter.length && !options.attributes ||\n      // 1.4\n      options.characterDataOldValue && !options.characterData) {\n        throw new SyntaxError();\n      }\n      var registrations = registrationsTable.get(target);\n      if (!registrations) registrationsTable.set(target, registrations = []);\n\n      // 2\n      // If target's list of registered observers already includes a registered\n      // observer associated with the context object, replace that registered\n      // observer's options with options.\n      var registration;\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          registration.removeListeners();\n          registration.options = options;\n          break;\n        }\n      }\n\n      // 3.\n      // Otherwise, add a new registered observer to target's list of registered\n      // observers with the context object as the observer and options as the\n      // options, and add target to context object's list of nodes on which it\n      // is registered.\n      if (!registration) {\n        registration = new Registration(this, target, options);\n        registrations.push(registration);\n        this.nodes.push(target);\n      }\n      registration.addListeners();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this = this;\n      this.nodes.forEach(function (node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === _this) {\n            registration.removeListeners();\n            registrations.splice(i, 1);\n            // Each node can only have one registered observer associated with\n            // this observer.\n            break;\n          }\n        }\n      }, this);\n      this.records = [];\n    }\n  }, {\n    key: \"takeRecords\",\n    value: function takeRecords() {\n      var copyOfRecords = this.records;\n      this.records = [];\n      return copyOfRecords;\n    }\n  }]);\n}();\n\n// We keep track of the two (possibly one) records used in a single mutation.\nvar currentRecord;\nvar recordWithOldValue;\n\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n */\nfunction getRecord(type, target) {\n  return currentRecord = new MutationRecord(type, target);\n}\n\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n */\nfunction getRecordWithOldValue(oldValue) {\n  if (recordWithOldValue) return recordWithOldValue;\n  recordWithOldValue = MutationRecord.copy(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n\n/**\n * Whether the record represents a record from the current\n * mutation event.\n */\nfunction recordRepresentsCurrentMutation(record) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n */\nfunction selectRecord(lastRecord, newRecord) {\n  if (lastRecord === newRecord) return lastRecord;\n\n  // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n  return null;\n}\nfunction removeTransientObserversFor(observer) {\n  observer.nodes.forEach(function (node) {\n    var registrations = registrationsTable.get(node);\n    if (!registrations) return;\n    registrations.forEach(function (registration) {\n      if (registration.observer === observer) registration.removeTransientObservers();\n    });\n  });\n}\n\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n  for (var node = target; node; node = node.parentNode) {\n    var registrations = registrationsTable.get(node);\n    if (registrations) {\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var _options = registration.options;\n\n        // Only target ignores subtree.\n        if (node !== target && !_options.subtree) continue;\n        var record = callback(_options);\n        if (record) registration.enqueue(record);\n      }\n    }\n  }\n}\n\n// This is used to ensure that we never schedule 2 callas to setImmediate\nvar isScheduled = false;\n\n// Keep track of observers that needs to be notified next time.\nvar scheduledObservers = [];\n\n/**\n * Schedules |dispatchCallback| to be called in the future.\n */\nfunction scheduleCallback(observer) {\n  scheduledObservers.push(observer);\n  if (!isScheduled) {\n    isScheduled = true;\n    // setImmediate(dispatchCallbacks);\n    if (typeof runtime.globalThis !== 'undefined') {\n      runtime.globalThis.setTimeout(dispatchCallbacks);\n    } else {\n      dispatchCallbacks();\n    }\n  }\n}\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  var observers = scheduledObservers;\n  scheduledObservers = [];\n  // Sort observers based on their creation UID (incremental).\n  observers.sort(function (o1, o2) {\n    return o1.uid - o2.uid;\n  });\n  var anyNonEmpty = false;\n  observers.forEach(function (observer) {\n    // 2.1, 2.2\n    var queue = observer.takeRecords();\n    // 2.3. Remove all transient registered observers whose observer is mo.\n    removeTransientObserversFor(observer);\n\n    // 2.4\n    if (queue.length) {\n      // @ts-ignore\n      observer.callback(queue, observer);\n      anyNonEmpty = true;\n    }\n  });\n\n  // 3.\n  if (anyNonEmpty) dispatchCallbacks();\n}\nexport { MutationObserver, MutationRecord, Registration };","map":{"version":3,"names":["MutationRecord","type","target","_classCallCheck","addedNodes","attributeName","attributeNamespace","nextSibling","oldValue","previousSibling","removedNodes","_createClass","key","value","copy","original","record","slice","uidCounter","registrationsTable","WeakMap","Registration","observer","options","transientObservedNodes","enqueue","records","length","lastRecord","recordToReplaceLast","selectRecord","scheduleCallback","addListeners","addListeners_","node","attributes","addEventListener","ElementEvent","ATTR_MODIFIED","childList","INSERTED","subtree","REMOVED","removeListeners","removeListeners_","removeEventListener","removeTransientObservers","forEach","registrations","get","i","splice","handleEvent","e","stopImmediatePropagation","name","attrName","namespace","relatedNode","namespaceURI","getRecord","attrChange","MutationEvent","ADDITION","prevValue","forEachAncestorAndObserverEnqueueRecord","attributeFilter","indexOf","attributeOldValue","getRecordWithOldValue","changedNode","clearRecords","MutationObserver","callback","nodes","uid","observe","characterData","characterDataOldValue","SyntaxError","set","registration","push","disconnect","_this","takeRecords","copyOfRecords","currentRecord","recordWithOldValue","undefined","recordRepresentsCurrentMutation","newRecord","removeTransientObserversFor","parentNode","j","_options","isScheduled","scheduledObservers","runtime","globalThis","setTimeout","dispatchCallbacks","observers","sort","o1","o2","anyNonEmpty","queue"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-dom-mutation-observer-api/src/dom/MutationRecord.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-dom-mutation-observer-api/src/dom/MutationObserver.ts"],"sourcesContent":["import type { IElement } from '@antv/g-lite';\n\nexport class MutationRecord {\n  static copy(original: MutationRecord) {\n    const record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  }\n\n  addedNodes: IElement[] = [];\n  attributeName: string = null;\n  attributeNamespace: string = null;\n  nextSibling: IElement = null;\n  oldValue: string = null;\n  previousSibling: IElement = null;\n  removedNodes: IElement[] = [];\n  constructor(\n    public type: MutationRecordType,\n    public target: IElement,\n  ) {}\n}\n","/* eslint-disable max-classes-per-file */\nimport type { DisplayObject, IElement } from '@antv/g-lite';\nimport { ElementEvent, MutationEvent, runtime } from '@antv/g-lite';\nimport { MutationRecord } from './MutationRecord';\n\nlet uidCounter = 0;\nconst registrationsTable = new WeakMap<IElement, Registration[]>();\n\nexport class Registration {\n  private transientObservedNodes = [];\n\n  constructor(\n    public observer: MutationObserver,\n    public target: IElement,\n    public options?: MutationObserverInit,\n  ) {}\n\n  enqueue(record: MutationRecord) {\n    const { records } = this.observer;\n    const { length } = records;\n\n    // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n    if (records.length > 0) {\n      const lastRecord = records[length - 1];\n      const recordToReplaceLast = selectRecord(lastRecord, record);\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n\n    records[length] = record;\n  }\n\n  addListeners() {\n    this.addListeners_(this.target);\n  }\n\n  private addListeners_(node: IElement) {\n    const { options } = this;\n    if (options.attributes)\n      node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n\n    // if (options.characterData) node.addEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.addEventListener(ElementEvent.INSERTED, this, true);\n\n    if (options.childList || options.subtree)\n      node.addEventListener(ElementEvent.REMOVED, this, true);\n  }\n\n  removeListeners() {\n    this.removeListeners_(this.target);\n  }\n\n  removeListeners_(node: IElement) {\n    const { options } = this;\n    if (options.attributes)\n      node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n\n    // if (options.characterData) node.removeEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.removeEventListener(ElementEvent.INSERTED, this, true);\n\n    if (options.childList || options.subtree)\n      node.removeEventListener(ElementEvent.REMOVED, this, true);\n  }\n\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   */\n  // addTransientObserver(node: IElement) {\n  //   // Don't add transient observers on the target itself. We already have all\n  //   // the required listeners set up on the target.\n  //   if (node === this.target) return;\n\n  //   this.addListeners_(node);\n  //   this.transientObservedNodes.push(node);\n  //   let registrations = registrationsTable.get(node);\n  //   if (!registrations) registrationsTable.set(node, (registrations = []));\n\n  //   // We know that registrations does not contain this because we already\n  //   // checked if node === this.target.\n  //   registrations.push(this);\n  // }\n\n  removeTransientObservers() {\n    const { transientObservedNodes } = this;\n    this.transientObservedNodes = [];\n\n    transientObservedNodes.forEach(function (node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n\n      const registrations = registrationsTable.get(node);\n      for (let i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n  }\n\n  handleEvent(e: MutationEvent) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n\n    let record: MutationRecord;\n    let target: IElement;\n\n    switch (e.type) {\n      case ElementEvent.ATTR_MODIFIED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\n        const name = e.attrName;\n        // @ts-ignore\n        const namespace = e.relatedNode.namespaceURI;\n        target = e.target as IElement;\n\n        // 1.\n        record = getRecord('attributes', target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n\n        // 2.\n        const oldValue =\n          e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n\n        forEachAncestorAndObserverEnqueueRecord(target, (options) => {\n          // 3.1, 4.2\n          if (!options.attributes) return;\n\n          // 3.2, 4.3\n          if (\n            options.attributeFilter &&\n            options.attributeFilter.length &&\n            options.attributeFilter.indexOf(name) === -1 &&\n            options.attributeFilter.indexOf(namespace) === -1\n          ) {\n            return;\n          }\n          // 3.3, 4.4\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n\n          // 3.4, 4.5\n          return record;\n        });\n\n        break;\n\n      // case 'DOMCharacterDataModified':\n      //   // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n      //   var target = e.target;\n\n      //   // 1.\n      //   var record = getRecord('characterData', target);\n\n      //   // 2.\n      //   var oldValue = e.prevValue;\n\n      //   forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n      //     // 3.1, 4.2\n      //     if (!options.characterData)\n      //       return;\n\n      //     // 3.2, 4.3\n      //     if (options.characterDataOldValue)\n      //       return getRecordWithOldValue(oldValue);\n\n      //     // 3.3, 4.4\n      //     return record;\n      //   });\n\n      //   break;\n\n      case ElementEvent.REMOVED:\n      // this.addTransientObserver(e.target as IElement);\n      // Fall through.\n      case ElementEvent.INSERTED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        target = e.relatedNode;\n        const changedNode = e.target as IElement;\n        let addedNodes: IElement[];\n        let removedNodes: IElement[];\n        if (e.type === ElementEvent.INSERTED) {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n        const { previousSibling } = changedNode;\n        const { nextSibling } = changedNode;\n\n        // 1.\n        record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling as IElement;\n        record.nextSibling = nextSibling as IElement;\n\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 2.1, 3.2\n          if (!options.childList) return;\n\n          // 2.2, 3.3\n          return record;\n        });\n    }\n\n    clearRecords();\n  }\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n * @see https://github.com/googlearchive/MutationObservers/blob/master/MutationObserver.js\n */\nexport class MutationObserver {\n  nodes: IElement[] = [];\n  records: MutationRecord[] = [];\n  uid = uidCounter++;\n\n  constructor(public callback: MutationCallback) {}\n\n  observe(target: DisplayObject, options?: MutationObserverInit) {\n    // 1.1\n    if (\n      (!options.childList && !options.attributes && !options.characterData) ||\n      // 1.2\n      (options.attributeOldValue && !options.attributes) ||\n      // 1.3\n      (options.attributeFilter &&\n        options.attributeFilter.length &&\n        !options.attributes) ||\n      // 1.4\n      (options.characterDataOldValue && !options.characterData)\n    ) {\n      throw new SyntaxError();\n    }\n\n    let registrations = registrationsTable.get(target);\n    if (!registrations) registrationsTable.set(target, (registrations = []));\n\n    // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n    let registration: Registration;\n    for (let i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    }\n\n    // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes.push(target);\n    }\n\n    registration.addListeners();\n  }\n\n  disconnect() {\n    this.nodes.forEach((node) => {\n      const registrations = registrationsTable.get(node);\n      for (let i = 0; i < registrations.length; i++) {\n        const registration = registrations[i];\n        if (registration.observer === this) {\n          registration.removeListeners();\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n    this.records = [];\n  }\n\n  takeRecords() {\n    const copyOfRecords = this.records;\n    this.records = [];\n    return copyOfRecords;\n  }\n}\n\n// We keep track of the two (possibly one) records used in a single mutation.\nlet currentRecord: MutationRecord;\nlet recordWithOldValue;\n\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n */\nfunction getRecord(type: MutationRecordType, target: IElement) {\n  return (currentRecord = new MutationRecord(type, target));\n}\n\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n */\nfunction getRecordWithOldValue(oldValue: any) {\n  if (recordWithOldValue) return recordWithOldValue;\n  recordWithOldValue = MutationRecord.copy(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\n\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n\n/**\n * Whether the record represents a record from the current\n * mutation event.\n */\nfunction recordRepresentsCurrentMutation(record: MutationRecord) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n */\nfunction selectRecord(lastRecord: MutationRecord, newRecord: MutationRecord) {\n  if (lastRecord === newRecord) return lastRecord;\n\n  // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n    return recordWithOldValue;\n\n  return null;\n}\n\nfunction removeTransientObserversFor(observer: MutationObserver) {\n  observer.nodes.forEach((node) => {\n    const registrations = registrationsTable.get(node);\n    if (!registrations) return;\n    registrations.forEach(function (registration) {\n      if (registration.observer === observer)\n        registration.removeTransientObservers();\n    });\n  });\n}\n\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\nfunction forEachAncestorAndObserverEnqueueRecord(target: IElement, callback) {\n  for (let node = target; node; node = node.parentNode as IElement) {\n    const registrations = registrationsTable.get(node);\n\n    if (registrations) {\n      for (let j = 0; j < registrations.length; j++) {\n        const registration = registrations[j];\n        const { options } = registration;\n\n        // Only target ignores subtree.\n        if (node !== target && !options.subtree) continue;\n\n        const record = callback(options);\n        if (record) registration.enqueue(record);\n      }\n    }\n  }\n}\n\n// This is used to ensure that we never schedule 2 callas to setImmediate\nlet isScheduled = false;\n\n// Keep track of observers that needs to be notified next time.\nlet scheduledObservers: MutationObserver[] = [];\n\n/**\n * Schedules |dispatchCallback| to be called in the future.\n */\nfunction scheduleCallback(observer: MutationObserver) {\n  scheduledObservers.push(observer);\n  if (!isScheduled) {\n    isScheduled = true;\n    // setImmediate(dispatchCallbacks);\n    if (typeof runtime.globalThis !== 'undefined') {\n      runtime.globalThis.setTimeout(dispatchCallbacks);\n    } else {\n      dispatchCallbacks();\n    }\n  }\n}\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  const observers = scheduledObservers;\n  scheduledObservers = [];\n  // Sort observers based on their creation UID (incremental).\n  observers.sort((o1, o2) => {\n    return o1.uid - o2.uid;\n  });\n\n  let anyNonEmpty = false;\n  observers.forEach(function (observer) {\n    // 2.1, 2.2\n    const queue = observer.takeRecords();\n    // 2.3. Remove all transient registered observers whose observer is mo.\n    removeTransientObserversFor(observer);\n\n    // 2.4\n    if (queue.length) {\n      // @ts-ignore\n      observer.callback(queue, observer);\n      anyNonEmpty = true;\n    }\n  });\n\n  // 3.\n  if (anyNonEmpty) dispatchCallbacks();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}