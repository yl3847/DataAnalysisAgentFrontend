{"ast":null,"code":"/*!\n * @antv/g-plugin-canvas-picker\n * @description A G plugin for picking in canvas\n * @version 2.1.27\n * @date 7/30/2025, 1:37:32 PM\n * @author AntVis\n * @docs https://g.antv.antgroup.com/\n */\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _callSuper from '@babel/runtime/helpers/callSuper';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport { findClosestClipPathTarget, Point, isFillOrStrokeAffected, getOrCalculatePathTotalLength, Shape, AbstractRendererPlugin } from '@antv/g-lite';\nimport _createForOfIteratorHelper from '@babel/runtime/helpers/createForOfIteratorHelper';\nimport _regeneratorRuntime from '@babel/runtime/helpers/regeneratorRuntime';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport { vec3, mat4 } from 'gl-matrix';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { distance, linePointToLine, cubicPointDistance, quadPointDistance } from '@antv/g-math';\nimport { arcToCubic, clamp } from '@antv/util';\nimport _objectSpread from '@babel/runtime/helpers/objectSpread2';\nvar tmpVec3a = vec3.create();\nvar tmpVec3b = vec3.create();\nvar tmpVec3c = vec3.create();\nvar tmpMat4 = mat4.create();\n/**\n * pick shape(s) with Mouse/Touch event\n *\n * 1. find AABB with r-tree\n * 2. do math calculation with geometry in an accurate way\n */\nvar CanvasPickerPlugin = /*#__PURE__*/function () {\n  function CanvasPickerPlugin() {\n    var _this = this;\n    _classCallCheck(this, CanvasPickerPlugin);\n    this.isHit = function (displayObject, position, worldTransform, isClipPath) {\n      // use picker for current shape's type\n      var pick = _this.context.pointInPathPickerFactory[displayObject.nodeName];\n      if (pick) {\n        // invert with world matrix\n        var invertWorldMat = mat4.invert(tmpMat4, worldTransform);\n\n        // transform client position to local space, do picking in local space\n        var localPosition = vec3.transformMat4(tmpVec3b, vec3.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);\n        if (pick(displayObject, new Point(localPosition[0], localPosition[1]), isClipPath, _this.isPointInPath, _this.context, _this.runtime)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    /**\n     * use native picking method\n     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInPath\n     */\n    this.isPointInPath = function (displayObject, position) {\n      var context = _this.runtime.offscreenCanvasCreator.getOrCreateContext(_this.context.config.offscreenCanvas);\n      var generatePath = _this.context.pathGeneratorFactory[displayObject.nodeName];\n      if (generatePath) {\n        context.beginPath();\n        generatePath(context, displayObject.parsedStyle);\n        context.closePath();\n      }\n      return context.isPointInPath(position.x, position.y);\n    };\n  }\n  return _createClass(CanvasPickerPlugin, [{\n    key: \"apply\",\n    value: function apply(context, runtime) {\n      var _renderingContext$roo,\n        _this2 = this;\n      var renderingService = context.renderingService,\n        renderingContext = context.renderingContext;\n      this.context = context;\n      this.runtime = runtime;\n      var document = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;\n      renderingService.hooks.pick.tapPromise(CanvasPickerPlugin.tag, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(result) {\n          return _regeneratorRuntime().wrap(function (_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", _this2.pick(document, result));\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      renderingService.hooks.pickSync.tap(CanvasPickerPlugin.tag, function (result) {\n        return _this2.pick(document, result);\n      });\n    }\n  }, {\n    key: \"pick\",\n    value: function pick(document, result) {\n      var topmost = result.topmost,\n        _result$position = result.position,\n        x = _result$position.x,\n        y = _result$position.y;\n\n      // position in world space\n      var position = vec3.set(tmpVec3a, x, y, 0);\n\n      // query by AABB first with spatial index(r-tree)\n      var hitTestList = document.elementsFromBBox(position[0], position[1], position[0], position[1]);\n\n      // test with clip path & origin shape\n      // @see https://github.com/antvis/g/issues/1064\n      var pickedDisplayObjects = [];\n      var _iterator = _createForOfIteratorHelper(hitTestList),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _displayObject = _step.value;\n          var worldTransform = _displayObject.getWorldTransform();\n          var isHitOriginShape = this.isHit(_displayObject, position, worldTransform, false);\n          if (isHitOriginShape) {\n            // should look up in the ancestor node\n            var clipped = findClosestClipPathTarget(_displayObject);\n            if (clipped) {\n              var clipPath = clipped.parsedStyle.clipPath;\n              var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);\n              if (isHitClipPath) {\n                if (topmost) {\n                  result.picked = [_displayObject];\n                  return result;\n                }\n                pickedDisplayObjects.push(_displayObject);\n              }\n            } else {\n              if (topmost) {\n                result.picked = [_displayObject];\n                return result;\n              }\n              pickedDisplayObjects.push(_displayObject);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      result.picked = pickedDisplayObjects;\n      return result;\n    }\n  }]);\n}();\nCanvasPickerPlugin.tag = 'CanvasPicker';\nfunction isPointInPath$8(displayObject, position, isClipPath) {\n  var _ref = displayObject.parsedStyle,\n    _ref$cx = _ref.cx,\n    cx = _ref$cx === void 0 ? 0 : _ref$cx,\n    _ref$cy = _ref.cy,\n    cy = _ref$cy === void 0 ? 0 : _ref$cy,\n    r = _ref.r,\n    fill = _ref.fill,\n    stroke = _ref.stroke,\n    _ref$lineWidth = _ref.lineWidth,\n    lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,\n    _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting,\n    increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid,\n    _ref$pointerEvents = _ref.pointerEvents,\n    pointerEvents = _ref$pointerEvents === void 0 ? 'auto' : _ref$pointerEvents;\n  var halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;\n  var absDistance = distance(cx, cy, position.x, position.y);\n  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),\n    _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2),\n    hasFill = _isFillOrStrokeAffect2[0],\n    hasStroke = _isFillOrStrokeAffect2[1];\n  if (hasFill && hasStroke || isClipPath) {\n    return absDistance <= r + halfLineWidth;\n  }\n  if (hasFill) {\n    return absDistance <= r;\n  }\n  if (hasStroke) {\n    return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\n  }\n  return false;\n}\nfunction ellipseDistance(squareX, squareY, rx, ry) {\n  return squareX / (rx * rx) + squareY / (ry * ry);\n}\nfunction isPointInPath$7(displayObject, position, isClipPath) {\n  var _ref = displayObject.parsedStyle,\n    _ref$cx = _ref.cx,\n    cx = _ref$cx === void 0 ? 0 : _ref$cx,\n    _ref$cy = _ref.cy,\n    cy = _ref$cy === void 0 ? 0 : _ref$cy,\n    rx = _ref.rx,\n    ry = _ref.ry,\n    fill = _ref.fill,\n    stroke = _ref.stroke,\n    _ref$lineWidth = _ref.lineWidth,\n    lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,\n    _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting,\n    increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid,\n    _ref$pointerEvents = _ref.pointerEvents,\n    pointerEvents = _ref$pointerEvents === void 0 ? 'auto' : _ref$pointerEvents;\n  var x = position.x,\n    y = position.y;\n  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),\n    _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2),\n    hasFill = _isFillOrStrokeAffect2[0],\n    hasStroke = _isFillOrStrokeAffect2[1];\n  var halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;\n  var squareX = (x - cx) * (x - cx);\n  var squareY = (y - cy) * (y - cy);\n  // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n  if (hasFill && hasStroke || isClipPath) {\n    return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n  }\n  if (hasFill) {\n    return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n  }\n  if (hasStroke) {\n    return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n  }\n  return false;\n}\nfunction inBox(minX, minY, width, height, x, y) {\n  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;\n}\nfunction inRect(minX, minY, width, height, lineWidth, x, y) {\n  var halfWidth = lineWidth / 2;\n  // 将四个边看做矩形来检测，比边的检测算法要快\n  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) ||\n  // 上边\n  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) ||\n  // 右边\n  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) ||\n  // 下边\n  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y); // 左边\n}\nfunction inArc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {\n  var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // 转换到 0 - 2 * Math.PI 之间\n  // if (angle < startAngle || angle > endAngle) {\n  //   return false;\n  // }\n  var point = {\n    x: cx + r * Math.cos(angle),\n    y: cy + r * Math.sin(angle)\n  };\n  return distance(point.x, point.y, x, y) <= lineWidth / 2;\n}\nfunction inLine(x1, y1, x2, y2, lineWidth, x, y) {\n  var minX = Math.min(x1, x2);\n  var maxX = Math.max(x1, x2);\n  var minY = Math.min(y1, y2);\n  var maxY = Math.max(y1, y2);\n  var halfWidth = lineWidth / 2;\n  // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\n  // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\n  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {\n    return false;\n  }\n  // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\n  return linePointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\n}\nfunction inPolyline(points, lineWidth, x, y, isClose) {\n  var count = points.length;\n  if (count < 2) {\n    return false;\n  }\n  for (var i = 0; i < count - 1; i++) {\n    var x1 = points[i][0];\n    var y1 = points[i][1];\n    var x2 = points[i + 1][0];\n    var y2 = points[i + 1][1];\n    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {\n      return true;\n    }\n  }\n\n  // 如果封闭，则计算起始点和结束点的边\n  if (isClose) {\n    var first = points[0];\n    var last = points[count - 1];\n    if (inLine(first[0], first[1], last[0], last[1], lineWidth, x, y)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nvar tolerance = 1e-6;\n// 三态函数，判断两个double在eps精度下的大小关系\nfunction dcmp(x) {\n  if (Math.abs(x) < tolerance) {\n    return 0;\n  }\n  return x < 0 ? -1 : 1;\n}\n\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n  return false;\n}\n\n// 判断点P在多边形内-射线法\nfunction inPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length;\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    }\n    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n  return isHit;\n}\nfunction inPolygons(polygons, x, y) {\n  var isHit = false;\n  for (var i = 0; i < polygons.length; i++) {\n    var points = polygons[i];\n    isHit = inPolygon(points, x, y);\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\nfunction isPointInPath$6(displayObject, position, isClipPath) {\n  var _ref = displayObject.parsedStyle,\n    x1 = _ref.x1,\n    y1 = _ref.y1,\n    x2 = _ref.x2,\n    y2 = _ref.y2,\n    _ref$lineWidth = _ref.lineWidth,\n    lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,\n    _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting,\n    increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid,\n    _ref$pointerEvents = _ref.pointerEvents,\n    pointerEvents = _ref$pointerEvents === void 0 ? 'auto' : _ref$pointerEvents,\n    fill = _ref.fill,\n    stroke = _ref.stroke;\n  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),\n    _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2),\n    hasStroke = _isFillOrStrokeAffect2[1];\n  if (!hasStroke && !isClipPath || !lineWidth) {\n    return false;\n  }\n  return inLine(x1, y1, x2, y2, lineWidth + increasedLineWidthForHitTesting, position.x, position.y);\n}\n\n// TODO: replace it with method in @antv/util\nfunction isPointInStroke(segments, lineWidth, px, py, length) {\n  var isHit = false;\n  var halfWidth = lineWidth / 2;\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var currentPoint = segment.currentPoint,\n      params = segment.params,\n      prePoint = segment.prePoint,\n      box = segment.box;\n    // 如果在前面已经生成过包围盒，直接按照包围盒计算\n    if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, px, py)) {\n      continue;\n    }\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'Q':\n        var qDistance = quadPointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);\n        isHit = qDistance <= lineWidth / 2;\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'C':\n        var cDistance = cubicPointDistance(prePoint[0],\n        // 上一段结束位置, 即 C 的起始点\n        prePoint[1], params[1],\n        // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n        params[2], params[3], params[4], params[5], params[6], px, py, length);\n        isHit = cDistance <= lineWidth / 2;\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'A':\n        // cache conversion result\n        if (!segment.cubicParams) {\n          segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], undefined);\n        }\n        var args = segment.cubicParams;\n\n        // fixArc\n        var prePointInCubic = prePoint;\n        for (var _i = 0; _i < args.length; _i += 6) {\n          var _cDistance = cubicPointDistance(prePointInCubic[0],\n          // 上一段结束位置, 即 C 的起始点\n          prePointInCubic[1], args[_i], args[_i + 1], args[_i + 2], args[_i + 3], args[_i + 4], args[_i + 5], px, py, length);\n          prePointInCubic = [args[_i + 4], args[_i + 5]];\n          isHit = _cDistance <= lineWidth / 2;\n          if (isHit) {\n            return true;\n          }\n        }\n        break;\n    }\n  }\n  return isHit;\n}\nfunction isPointInPath$5(displayObject, position, isClipPath, isPointInPath, renderingPluginContext, runtime) {\n  var _ref = displayObject.parsedStyle,\n    _ref$lineWidth = _ref.lineWidth,\n    lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,\n    _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting,\n    increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid,\n    stroke = _ref.stroke,\n    fill = _ref.fill,\n    d = _ref.d,\n    _ref$pointerEvents = _ref.pointerEvents,\n    pointerEvents = _ref$pointerEvents === void 0 ? 'auto' : _ref$pointerEvents;\n  var segments = d.segments,\n    hasArc = d.hasArc,\n    polylines = d.polylines,\n    polygons = d.polygons;\n  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents,\n    // Only a closed path can be filled.\n    (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill, stroke),\n    _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2),\n    hasFill = _isFillOrStrokeAffect2[0],\n    hasStroke = _isFillOrStrokeAffect2[1];\n  var totalLength = getOrCalculatePathTotalLength(displayObject);\n  var isHit = false;\n  if (hasFill || isClipPath) {\n    if (hasArc) {\n      // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n      isHit = isPointInPath(displayObject, position);\n    } else {\n      // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n      isHit = inPolygons(polygons, position.x, position.y) || inPolygons(polylines, position.x, position.y);\n    }\n    return isHit;\n  }\n  if (hasStroke || isClipPath) {\n    isHit = isPointInStroke(segments, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, totalLength);\n  }\n  return isHit;\n}\nfunction isPointInPath$4(displayObject, position, isClipPath) {\n  var _ref = displayObject.parsedStyle,\n    stroke = _ref.stroke,\n    fill = _ref.fill,\n    _ref$lineWidth = _ref.lineWidth,\n    lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,\n    _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting,\n    increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid,\n    points = _ref.points,\n    _ref$pointerEvents = _ref.pointerEvents,\n    pointerEvents = _ref$pointerEvents === void 0 ? 'auto' : _ref$pointerEvents;\n  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),\n    _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2),\n    hasFill = _isFillOrStrokeAffect2[0],\n    hasStroke = _isFillOrStrokeAffect2[1];\n  var isHit = false;\n  if (hasStroke || isClipPath) {\n    isHit = inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, true);\n  }\n  if (!isHit && (hasFill || isClipPath)) {\n    isHit = inPolygon(points.points, position.x, position.y);\n  }\n  return isHit;\n}\nfunction isPointInPath$3(displayObject, position, isClipPath) {\n  var _ref = displayObject.parsedStyle,\n    _ref$lineWidth = _ref.lineWidth,\n    lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,\n    _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting,\n    increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid,\n    points = _ref.points,\n    _ref$pointerEvents = _ref.pointerEvents,\n    pointerEvents = _ref$pointerEvents === void 0 ? 'auto' : _ref$pointerEvents,\n    fill = _ref.fill,\n    stroke = _ref.stroke;\n  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),\n    _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2),\n    hasStroke = _isFillOrStrokeAffect2[1];\n  if (!hasStroke && !isClipPath || !lineWidth) {\n    return false;\n  }\n  return inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, false);\n}\nfunction isPointInPath$2(displayObject, position, isClipPath, isPointInPath, runtime) {\n  var _ref = displayObject.parsedStyle,\n    radius = _ref.radius,\n    fill = _ref.fill,\n    stroke = _ref.stroke,\n    _ref$lineWidth = _ref.lineWidth,\n    lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,\n    _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting,\n    increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid,\n    _ref$x = _ref.x,\n    x = _ref$x === void 0 ? 0 : _ref$x,\n    _ref$y = _ref.y,\n    y = _ref$y === void 0 ? 0 : _ref$y,\n    width = _ref.width,\n    height = _ref.height,\n    _ref$pointerEvents = _ref.pointerEvents,\n    pointerEvents = _ref$pointerEvents === void 0 ? 'auto' : _ref$pointerEvents;\n  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),\n    _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2),\n    hasFill = _isFillOrStrokeAffect2[0],\n    hasStroke = _isFillOrStrokeAffect2[1];\n  var hasRadius = radius && radius.some(function (r) {\n    return r !== 0;\n  });\n  var lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;\n\n  // 无圆角时的策略\n  if (!hasRadius) {\n    var halfWidth = lineWidthForHitTesting / 2;\n    // 同时填充和带有边框\n    if (hasFill && hasStroke || isClipPath) {\n      return inBox(x - halfWidth, y - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);\n    }\n    // 仅填充\n    if (hasFill) {\n      return inBox(x, y, width, height, position.x, position.y);\n    }\n    if (hasStroke) {\n      return inRect(x, y, width, height, lineWidthForHitTesting, position.x, position.y);\n    }\n  } else {\n    var isHit = false;\n    if (hasStroke || isClipPath) {\n      isHit = inRectWithRadius(x, y, width, height, radius.map(function (r) {\n        return clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));\n      }), lineWidthForHitTesting, position.x, position.y);\n    }\n    // 仅填充时带有圆角的矩形直接通过图形拾取\n    // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\n    if (!isHit && (hasFill || isClipPath)) {\n      isHit = isPointInPath(displayObject, position);\n    }\n    return isHit;\n  }\n  return false;\n}\nfunction inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x, y) {\n  var _radiusArray = _slicedToArray(radiusArray, 4),\n    tlr = _radiusArray[0],\n    trr = _radiusArray[1],\n    brr = _radiusArray[2],\n    blr = _radiusArray[3];\n  return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x, y) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x, y) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x, y) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x, y) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x, y) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x, y);\n}\nfunction isPointInPath$1(displayObject, position, isClipPath, isPointInPath, renderingPluginContext, runtime) {\n  var _ref = displayObject.parsedStyle,\n    _ref$pointerEvents = _ref.pointerEvents,\n    pointerEvents = _ref$pointerEvents === void 0 ? 'auto' : _ref$pointerEvents,\n    _ref$x = _ref.x,\n    x = _ref$x === void 0 ? 0 : _ref$x,\n    _ref$y = _ref.y,\n    y = _ref$y === void 0 ? 0 : _ref$y,\n    width = _ref.width,\n    height = _ref.height;\n  if (pointerEvents === 'non-transparent-pixel') {\n    var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;\n    var canvas = runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n    var context = runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {\n      willReadFrequently: true\n    });\n    canvas.width = width;\n    canvas.height = height;\n    renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, _objectSpread(_objectSpread({}, displayObject.parsedStyle), {}, {\n      x: 0,\n      y: 0\n    }), displayObject, undefined, undefined, undefined);\n    var imagedata = context.getImageData(position.x - x, position.y - y, 1, 1).data;\n    return imagedata.every(function (component) {\n      return component !== 0;\n    });\n  }\n  return true;\n}\nfunction isPointInPath(displayObject, position, isClipPath, isPointInPath) {\n  var bounds = displayObject.getGeometryBounds();\n\n  // @see https://stackoverflow.com/questions/28706989/how-do-i-check-if-a-mouse-click-is-inside-a-rotated-text-on-the-html5-canvas-in\n  return position.x >= bounds.min[0] && position.y >= bounds.min[1] && position.x <= bounds.max[0] && position.y <= bounds.max[1];\n}\nvar Plugin = /*#__PURE__*/function (_AbstractRendererPlug) {\n  function Plugin() {\n    var _this;\n    _classCallCheck(this, Plugin);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, Plugin, [].concat(args));\n    _this.name = 'canvas-picker';\n    return _this;\n  }\n  _inherits(Plugin, _AbstractRendererPlug);\n  return _createClass(Plugin, [{\n    key: \"init\",\n    value: function init() {\n      var _pointInPathPickerFac;\n      var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pointInPathPickerFac, Shape.CIRCLE, isPointInPath$8), Shape.ELLIPSE, isPointInPath$7), Shape.RECT, isPointInPath$2), Shape.LINE, isPointInPath$6), Shape.POLYLINE, isPointInPath$3), Shape.POLYGON, isPointInPath$4), Shape.PATH, isPointInPath$5), Shape.TEXT, isPointInPath), Shape.GROUP, null), Shape.IMAGE, isPointInPath$1), _defineProperty(_defineProperty(_pointInPathPickerFac, Shape.HTML, null), Shape.MESH, null));\n\n      // @ts-ignore\n      this.context.pointInPathPickerFactory = pointInPathPickerFactory;\n      this.addRenderingPlugin(new CanvasPickerPlugin());\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      // @ts-ignore\n      delete this.context.pointInPathPickerFactory;\n      this.removeAllRenderingPlugins();\n    }\n  }]);\n}(AbstractRendererPlugin);\nexport { Plugin };","map":{"version":3,"names":["tmpVec3a","vec3","create","tmpVec3b","tmpVec3c","tmpMat4","mat4","CanvasPickerPlugin","_this","_classCallCheck","isHit","displayObject","position","worldTransform","isClipPath","pick","context","pointInPathPickerFactory","nodeName","invertWorldMat","invert","localPosition","transformMat4","set","Point","isPointInPath","runtime","offscreenCanvasCreator","getOrCreateContext","config","offscreenCanvas","generatePath","pathGeneratorFactory","beginPath","parsedStyle","closePath","x","y","_createClass","key","value","apply","_renderingContext$roo","_this2","renderingService","renderingContext","document","root","ownerDocument","hooks","tapPromise","tag","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","result","wrap","_context","prev","next","abrupt","stop","_x","arguments","pickSync","tap","topmost","_result$position","hitTestList","elementsFromBBox","pickedDisplayObjects","_iterator","_createForOfIteratorHelper","_step","s","n","done","_displayObject","getWorldTransform","isHitOriginShape","clipped","findClosestClipPathTarget","clipPath","isHitClipPath","picked","push","err","e","f","isPointInPath$8","_ref$cx","cx","_ref$cy","cy","r","fill","stroke","_ref$lineWidth","lineWidth","_ref$increasedLineWid","increasedLineWidthForHitTesting","_ref$pointerEvents","pointerEvents","halfLineWidth","absDistance","distance","_isFillOrStrokeAffect","isFillOrStrokeAffected","_isFillOrStrokeAffect2","_slicedToArray","hasFill","hasStroke","ellipseDistance","squareX","squareY","rx","ry","isPointInPath$7","halfLineWith","inBox","minX","minY","width","height","inRect","halfWidth","inArc","startAngle","endAngle","angle","Math","atan2","PI","point","cos","sin","inLine","x1","y1","x2","y2","min","maxX","max","maxY","linePointToLine","inPolyline","points","isClose","count","length","i","first","last","tolerance","dcmp","abs","onSegment","p1","p2","q","inPolygon","inPolygons","polygons","isPointInPath$6","isPointInStroke","segments","px","py","segment","currentPoint","params","prePoint","box","command","qDistance","quadPointDistance","cDistance","cubicPointDistance","cubicParams","arcToCubic","undefined","args","prePointInCubic","_i","_cDistance","isPointInPath$5","renderingPluginContext","d","hasArc","polylines","totalLength","getOrCalculatePathTotalLength","isPointInPath$4","isPointInPath$3","isPointInPath$2","radius","_ref$x","_ref$y","hasRadius","some","lineWidthForHitTesting","inRectWithRadius","map","clamp","radiusArray","_radiusArray","tlr","trr","brr","blr","isPointInPath$1","canvas","getOrCreateCanvas","willReadFrequently","defaultStyleRendererFactory","Shape","IMAGE","render","_objectSpread","imagedata","getImageData","data","every","component","bounds","getGeometryBounds","Plugin","_AbstractRendererPlug","_len","Array","_key","_callSuper","concat","name","_inherits","init","_pointInPathPickerFac","_defineProperty","CIRCLE","ELLIPSE","RECT","LINE","POLYLINE","POLYGON","PATH","TEXT","GROUP","HTML","MESH","addRenderingPlugin","destroy","removeAllRenderingPlugins","AbstractRendererPlugin"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/CanvasPickerPlugin.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Circle.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Ellipse.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/utils/math.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Line.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Path.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Polygon.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Polyline.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Rect.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Image.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/Text.ts","/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g-plugin-canvas-picker/src/index.ts"],"sourcesContent":["import type {\n  BaseStyleProps,\n  DisplayObject,\n  PickingResult,\n  RenderingPlugin,\n  Shape,\n  IDocument,\n  RenderingPluginContext,\n  GlobalRuntime,\n} from '@antv/g-lite';\nimport { findClosestClipPathTarget, Point } from '@antv/g-lite';\nimport type { PathGenerator } from '@antv/g-plugin-canvas-path-generator';\nimport { mat4, vec3 } from 'gl-matrix';\n\nexport type PointInPathPicker<T extends BaseStyleProps> = (\n  displayObject: DisplayObject<T>,\n  point: Point,\n  isClipPath: boolean,\n  isPointInPath: (displayObject: DisplayObject<T>, point: Point) => boolean,\n  context: RenderingPluginContext,\n  runtime: GlobalRuntime,\n) => boolean;\n\nconst tmpVec3a = vec3.create();\nconst tmpVec3b = vec3.create();\nconst tmpVec3c = vec3.create();\nconst tmpMat4 = mat4.create();\n\ninterface Extended {\n  pathGeneratorFactory: Record<Shape, PathGenerator<any>>;\n  pointInPathPickerFactory: Record<Shape, PointInPathPicker<any>>;\n}\n\n/**\n * pick shape(s) with Mouse/Touch event\n *\n * 1. find AABB with r-tree\n * 2. do math calculation with geometry in an accurate way\n */\nexport class CanvasPickerPlugin implements RenderingPlugin {\n  static tag = 'CanvasPicker';\n\n  private context: RenderingPluginContext & Extended;\n  private runtime: GlobalRuntime;\n\n  apply(context: RenderingPluginContext, runtime: GlobalRuntime) {\n    const { renderingService, renderingContext } = context;\n    this.context = context as RenderingPluginContext & Extended;\n    this.runtime = runtime;\n\n    const document = renderingContext.root?.ownerDocument;\n\n    renderingService.hooks.pick.tapPromise(\n      CanvasPickerPlugin.tag,\n      async (result: PickingResult) => {\n        return this.pick(document, result);\n      },\n    );\n\n    renderingService.hooks.pickSync.tap(\n      CanvasPickerPlugin.tag,\n      (result: PickingResult) => {\n        return this.pick(document, result);\n      },\n    );\n  }\n\n  private pick(document: IDocument, result: PickingResult) {\n    const {\n      topmost,\n      position: { x, y },\n    } = result;\n\n    // position in world space\n    const position = vec3.set(tmpVec3a, x, y, 0);\n\n    // query by AABB first with spatial index(r-tree)\n    const hitTestList = document.elementsFromBBox(\n      position[0],\n      position[1],\n      position[0],\n      position[1],\n    );\n\n    // test with clip path & origin shape\n    // @see https://github.com/antvis/g/issues/1064\n    const pickedDisplayObjects: DisplayObject[] = [];\n    for (const displayObject of hitTestList) {\n      const worldTransform = displayObject.getWorldTransform();\n      const isHitOriginShape = this.isHit(\n        displayObject,\n        position,\n        worldTransform,\n        false,\n      );\n      if (isHitOriginShape) {\n        // should look up in the ancestor node\n        const clipped = findClosestClipPathTarget(displayObject);\n        if (clipped) {\n          const { clipPath } = clipped.parsedStyle;\n          const isHitClipPath = this.isHit(\n            clipPath,\n            position,\n            clipPath.getWorldTransform(),\n            true,\n          );\n          if (isHitClipPath) {\n            if (topmost) {\n              result.picked = [displayObject];\n              return result;\n            }\n            pickedDisplayObjects.push(displayObject);\n          }\n        } else {\n          if (topmost) {\n            result.picked = [displayObject];\n            return result;\n          }\n          pickedDisplayObjects.push(displayObject);\n        }\n      }\n    }\n\n    result.picked = pickedDisplayObjects;\n    return result;\n  }\n\n  private isHit = (\n    displayObject: DisplayObject,\n    position: vec3,\n    worldTransform: mat4,\n    isClipPath: boolean,\n  ) => {\n    // use picker for current shape's type\n    const pick =\n      this.context.pointInPathPickerFactory[displayObject.nodeName as Shape];\n    if (pick) {\n      // invert with world matrix\n      const invertWorldMat = mat4.invert(tmpMat4, worldTransform);\n\n      // transform client position to local space, do picking in local space\n      const localPosition = vec3.transformMat4(\n        tmpVec3b,\n        vec3.set(tmpVec3c, position[0], position[1], 0),\n        invertWorldMat,\n      );\n\n      if (\n        pick(\n          displayObject,\n          new Point(localPosition[0], localPosition[1]),\n          isClipPath,\n          this.isPointInPath,\n          this.context,\n          this.runtime,\n        )\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * use native picking method\n   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInPath\n   */\n  private isPointInPath = (displayObject: DisplayObject, position: Point) => {\n    const context = this.runtime.offscreenCanvasCreator.getOrCreateContext(\n      this.context.config.offscreenCanvas,\n    ) as CanvasRenderingContext2D;\n\n    const generatePath =\n      this.context.pathGeneratorFactory[displayObject.nodeName];\n    if (generatePath) {\n      context.beginPath();\n      generatePath(context, displayObject.parsedStyle);\n      context.closePath();\n    }\n\n    return context.isPointInPath(position.x, position.y);\n  };\n}\n","import type {\n  CircleStyleProps,\n  DisplayObject,\n  ParsedCircleStyleProps,\n  Point,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\nimport { distance } from '@antv/g-math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<CircleStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    cx = 0,\n    cy = 0,\n    r,\n    fill,\n    stroke,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedCircleStyleProps;\n  const halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;\n  const absDistance = distance(cx, cy, position.x, position.y);\n\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    fill,\n    stroke,\n  );\n\n  if ((hasFill && hasStroke) || isClipPath) {\n    return absDistance <= r + halfLineWidth;\n  }\n  if (hasFill) {\n    return absDistance <= r;\n  }\n  if (hasStroke) {\n    return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\n  }\n  return false;\n}\n","import type {\n  DisplayObject,\n  EllipseStyleProps,\n  ParsedEllipseStyleProps,\n  Point,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\n\nfunction ellipseDistance(\n  squareX: number,\n  squareY: number,\n  rx: number,\n  ry: number,\n) {\n  return squareX / (rx * rx) + squareY / (ry * ry);\n}\n\nexport function isPointInPath(\n  displayObject: DisplayObject<EllipseStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    cx = 0,\n    cy = 0,\n    rx,\n    ry,\n    fill,\n    stroke,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedEllipseStyleProps;\n\n  const { x, y } = position;\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    fill,\n    stroke,\n  );\n\n  const halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;\n  const squareX = (x - cx) * (x - cx);\n  const squareY = (y - cy) * (y - cy);\n  // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n  if ((hasFill && hasStroke) || isClipPath) {\n    return (\n      ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <=\n      1\n    );\n  }\n  if (hasFill) {\n    return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n  }\n  if (hasStroke) {\n    return (\n      ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >=\n        1 &&\n      ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <=\n        1\n    );\n  }\n  return false;\n}\n","import { distance, linePointToLine } from '@antv/g-math';\n\nexport function inBox(\n  minX: number,\n  minY: number,\n  width: number,\n  height: number,\n  x: number,\n  y: number,\n) {\n  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;\n}\n\nexport function inRect(\n  minX: number,\n  minY: number,\n  width: number,\n  height: number,\n  lineWidth: number,\n  x: number,\n  y: number,\n) {\n  const halfWidth = lineWidth / 2;\n  // 将四个边看做矩形来检测，比边的检测算法要快\n  return (\n    inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边\n    inBox(\n      minX + width - halfWidth,\n      minY - halfWidth,\n      lineWidth,\n      height,\n      x,\n      y,\n    ) || // 右边\n    inBox(\n      minX + halfWidth,\n      minY + height - halfWidth,\n      width,\n      lineWidth,\n      x,\n      y,\n    ) || // 下边\n    inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y)\n  ); // 左边\n}\n\nexport function inArc(\n  cx: number,\n  cy: number,\n  r: number,\n  startAngle: number,\n  endAngle: number,\n  lineWidth: number,\n  x: number,\n  y: number,\n) {\n  const angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // 转换到 0 - 2 * Math.PI 之间\n  // if (angle < startAngle || angle > endAngle) {\n  //   return false;\n  // }\n  const point = {\n    x: cx + r * Math.cos(angle),\n    y: cy + r * Math.sin(angle),\n  };\n\n  return distance(point.x, point.y, x, y) <= lineWidth / 2;\n}\n\nexport function inLine(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  lineWidth: number,\n  x: number,\n  y: number,\n) {\n  const minX = Math.min(x1, x2);\n  const maxX = Math.max(x1, x2);\n  const minY = Math.min(y1, y2);\n  const maxY = Math.max(y1, y2);\n  const halfWidth = lineWidth / 2;\n  // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\n  // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\n  if (\n    !(\n      x >= minX - halfWidth &&\n      x <= maxX + halfWidth &&\n      y >= minY - halfWidth &&\n      y <= maxY + halfWidth\n    )\n  ) {\n    return false;\n  }\n  // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\n  return linePointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\n}\n\nexport function inPolyline(\n  points: any[],\n  lineWidth: number,\n  x: number,\n  y: number,\n  isClose: boolean,\n) {\n  const count = points.length;\n  if (count < 2) {\n    return false;\n  }\n  for (let i = 0; i < count - 1; i++) {\n    const x1 = points[i][0];\n    const y1 = points[i][1];\n    const x2 = points[i + 1][0];\n    const y2 = points[i + 1][1];\n\n    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {\n      return true;\n    }\n  }\n\n  // 如果封闭，则计算起始点和结束点的边\n  if (isClose) {\n    const first = points[0];\n    const last = points[count - 1];\n    if (inLine(first[0], first[1], last[0], last[1], lineWidth, x, y)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nconst tolerance = 1e-6;\n// 三态函数，判断两个double在eps精度下的大小关系\nfunction dcmp(x: number) {\n  if (Math.abs(x) < tolerance) {\n    return 0;\n  }\n\n  return x < 0 ? -1 : 1;\n}\n\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1: any, p2: any, q: any) {\n  if (\n    (q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\n    Math.min(p1[0], p2[0]) <= q[0] &&\n    q[0] <= Math.max(p1[0], p2[0]) &&\n    Math.min(p1[1], p2[1]) <= q[1] &&\n    q[1] <= Math.max(p1[1], p2[1])\n  ) {\n    return true;\n  }\n  return false;\n}\n\n// 判断点P在多边形内-射线法\nexport function inPolygon(points: any[], x: number, y: number) {\n  let isHit = false;\n  const n = points.length;\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n  for (let i = 0; i < n; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % n];\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    }\n    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n    if (\n      dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\n      dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0\n    ) {\n      isHit = !isHit;\n    }\n  }\n  return isHit;\n}\nexport function inPolygons(polygons: any[], x: number, y: number): boolean {\n  let isHit = false;\n  for (let i = 0; i < polygons.length; i++) {\n    const points = polygons[i];\n    isHit = inPolygon(points, x, y);\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\n","import type {\n  DisplayObject,\n  LineStyleProps,\n  ParsedLineStyleProps,\n  Point,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\nimport { inLine } from './utils/math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<LineStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    x1,\n    y1,\n    x2,\n    y2,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    pointerEvents = 'auto',\n    fill,\n    stroke,\n  } = displayObject.parsedStyle as ParsedLineStyleProps;\n\n  const [, hasStroke] = isFillOrStrokeAffected(pointerEvents, fill, stroke);\n\n  if ((!hasStroke && !isClipPath) || !lineWidth) {\n    return false;\n  }\n\n  return inLine(\n    x1,\n    y1,\n    x2,\n    y2,\n    lineWidth + increasedLineWidthForHitTesting,\n    position.x,\n    position.y,\n  );\n}\n","import type {\n  DisplayObject,\n  GlobalRuntime,\n  ParsedPathStyleProps,\n  Path,\n  PathSegment,\n  PathStyleProps,\n  Point,\n  RenderingPluginContext,\n} from '@antv/g-lite';\nimport {\n  getOrCalculatePathTotalLength,\n  isFillOrStrokeAffected,\n} from '@antv/g-lite';\nimport { cubicPointDistance, quadPointDistance } from '@antv/g-math';\nimport { arcToCubic } from '@antv/util';\nimport { inBox, inLine, inPolygons } from './utils/math';\n\n// TODO: replace it with method in @antv/util\nfunction isPointInStroke(\n  segments: PathSegment[],\n  lineWidth: number,\n  px: number,\n  py: number,\n  length: number,\n) {\n  let isHit = false;\n  const halfWidth = lineWidth / 2;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const { currentPoint, params, prePoint, box } = segment;\n    // 如果在前面已经生成过包围盒，直接按照包围盒计算\n    if (\n      box &&\n      !inBox(\n        box.x - halfWidth,\n        box.y - halfWidth,\n        box.width + lineWidth,\n        box.height + lineWidth,\n        px,\n        py,\n      )\n    ) {\n      continue;\n    }\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = inLine(\n          prePoint[0],\n          prePoint[1],\n          currentPoint[0],\n          currentPoint[1],\n          lineWidth,\n          px,\n          py,\n        );\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'Q':\n        const qDistance = quadPointDistance(\n          prePoint[0],\n          prePoint[1],\n          params[1],\n          params[2],\n          params[3],\n          params[4],\n          px,\n          py,\n        );\n        isHit = qDistance <= lineWidth / 2;\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'C':\n        const cDistance = cubicPointDistance(\n          prePoint[0], // 上一段结束位置, 即 C 的起始点\n          prePoint[1],\n          params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n          params[2],\n          params[3],\n          params[4],\n          params[5],\n          params[6],\n          px,\n          py,\n          length,\n        );\n        isHit = cDistance <= lineWidth / 2;\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'A':\n        // cache conversion result\n        if (!segment.cubicParams) {\n          segment.cubicParams = arcToCubic(\n            prePoint[0],\n            prePoint[1],\n            params[1],\n            params[2],\n            params[3],\n            params[4],\n            params[5],\n            params[6],\n            params[7],\n            undefined,\n          ) as [number, number, number, number, number, number];\n        }\n\n        const args = segment.cubicParams;\n\n        // fixArc\n        let prePointInCubic = prePoint;\n        for (let i = 0; i < args.length; i += 6) {\n          const cDistance = cubicPointDistance(\n            prePointInCubic[0], // 上一段结束位置, 即 C 的起始点\n            prePointInCubic[1],\n            args[i],\n            args[i + 1],\n            args[i + 2],\n            args[i + 3],\n            args[i + 4],\n            args[i + 5],\n            px,\n            py,\n            length,\n          );\n          prePointInCubic = [args[i + 4], args[i + 5]];\n          isHit = cDistance <= lineWidth / 2;\n\n          if (isHit) {\n            return true;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  return isHit;\n}\n\nexport function isPointInPath(\n  displayObject: DisplayObject<PathStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n  isPointInPath: (\n    displayObject: DisplayObject<PathStyleProps>,\n    position: Point,\n  ) => boolean,\n  renderingPluginContext: RenderingPluginContext,\n  runtime: GlobalRuntime,\n): boolean {\n  const {\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    stroke,\n    fill,\n    d,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedPathStyleProps;\n\n  const { segments, hasArc, polylines, polygons } = d;\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    // Only a closed path can be filled.\n    polygons?.length && fill,\n    stroke,\n  );\n\n  const totalLength = getOrCalculatePathTotalLength(displayObject as Path);\n\n  let isHit = false;\n\n  if (hasFill || isClipPath) {\n    if (hasArc) {\n      // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n      isHit = isPointInPath(displayObject, position);\n    } else {\n      // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n      isHit =\n        inPolygons(polygons, position.x, position.y) ||\n        inPolygons(polylines, position.x, position.y);\n    }\n    return isHit;\n  }\n  if (hasStroke || isClipPath) {\n    isHit = isPointInStroke(\n      segments,\n      lineWidth + increasedLineWidthForHitTesting,\n      position.x,\n      position.y,\n      totalLength,\n    );\n  }\n\n  return isHit;\n}\n","import type {\n  DisplayObject,\n  ParsedPolygonStyleProps,\n  Point,\n  PolylineStyleProps,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\nimport { inPolygon, inPolyline } from './utils/math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<PolylineStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    stroke,\n    fill,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    points,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedPolygonStyleProps;\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    fill,\n    stroke,\n  );\n\n  let isHit = false;\n  if (hasStroke || isClipPath) {\n    isHit = inPolyline(\n      points.points,\n      lineWidth + increasedLineWidthForHitTesting,\n      position.x,\n      position.y,\n      true,\n    );\n  }\n  if (!isHit && (hasFill || isClipPath)) {\n    isHit = inPolygon(points.points, position.x, position.y);\n  }\n  return isHit;\n}\n","import type {\n  DisplayObject,\n  ParsedPolylineStyleProps,\n  Point,\n  PolylineStyleProps,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\nimport { inPolyline } from './utils/math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<PolylineStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    points,\n    pointerEvents = 'auto',\n    fill,\n    stroke,\n  } = displayObject.parsedStyle as ParsedPolylineStyleProps;\n  const [, hasStroke] = isFillOrStrokeAffected(pointerEvents, fill, stroke);\n\n  if ((!hasStroke && !isClipPath) || !lineWidth) {\n    return false;\n  }\n\n  return inPolyline(\n    points.points,\n    lineWidth + increasedLineWidthForHitTesting,\n    position.x,\n    position.y,\n    false,\n  );\n}\n","import type {\n  DisplayObject,\n  ParsedRectStyleProps,\n  Point,\n  RectStyleProps,\n} from '@antv/g-lite';\nimport { GlobalRuntime, isFillOrStrokeAffected } from '@antv/g-lite';\nimport { clamp } from '@antv/util';\nimport { inArc, inBox, inLine, inRect } from './utils/math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<RectStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n  isPointInPath: (\n    displayObject: DisplayObject<RectStyleProps>,\n    position: Point,\n  ) => boolean,\n  runtime: GlobalRuntime,\n): boolean {\n  const {\n    radius,\n    fill,\n    stroke,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    x = 0,\n    y = 0,\n    width,\n    height,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedRectStyleProps;\n\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    fill,\n    stroke,\n  );\n\n  const hasRadius = radius && radius.some((r) => r !== 0);\n\n  const lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;\n\n  // 无圆角时的策略\n  if (!hasRadius) {\n    const halfWidth = lineWidthForHitTesting / 2;\n    // 同时填充和带有边框\n    if ((hasFill && hasStroke) || isClipPath) {\n      return inBox(\n        x - halfWidth,\n        y - halfWidth,\n        width + halfWidth,\n        height + halfWidth,\n        position.x,\n        position.y,\n      );\n    }\n    // 仅填充\n    if (hasFill) {\n      return inBox(x, y, width, height, position.x, position.y);\n    }\n    if (hasStroke) {\n      return inRect(\n        x,\n        y,\n        width,\n        height,\n        lineWidthForHitTesting,\n        position.x,\n        position.y,\n      );\n    }\n  } else {\n    let isHit = false;\n    if (hasStroke || isClipPath) {\n      isHit = inRectWithRadius(\n        x,\n        y,\n        width,\n        height,\n        radius.map((r) =>\n          clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2)),\n        ) as [number, number, number, number],\n        lineWidthForHitTesting,\n        position.x,\n        position.y,\n      );\n    }\n    // 仅填充时带有圆角的矩形直接通过图形拾取\n    // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\n    if (!isHit && (hasFill || isClipPath)) {\n      isHit = isPointInPath(displayObject, position);\n    }\n    return isHit;\n  }\n\n  return false;\n}\n\nfunction inRectWithRadius(\n  minX: number,\n  minY: number,\n  width: number,\n  height: number,\n  radiusArray: [number, number, number, number],\n  lineWidth: number,\n  x: number,\n  y: number,\n) {\n  const [tlr, trr, brr, blr] = radiusArray;\n  return (\n    inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x, y) ||\n    inLine(\n      minX + width,\n      minY + trr,\n      minX + width,\n      minY + height - brr,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inLine(\n      minX + width - brr,\n      minY + height,\n      minX + blr,\n      minY + height,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x, y) ||\n    inArc(\n      minX + width - trr,\n      minY + trr,\n      trr,\n      1.5 * Math.PI,\n      2 * Math.PI,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inArc(\n      minX + width - brr,\n      minY + height - brr,\n      brr,\n      0,\n      0.5 * Math.PI,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inArc(\n      minX + blr,\n      minY + height - blr,\n      blr,\n      0.5 * Math.PI,\n      Math.PI,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x, y)\n  );\n}\n","import {\n  DisplayObject,\n  ParsedImageStyleProps,\n  Point,\n  ImageStyleProps,\n  Shape,\n  RenderingPluginContext,\n  GlobalRuntime,\n} from '@antv/g-lite';\nimport { StyleRenderer } from '@antv/g-plugin-canvas-renderer';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<ImageStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n  isPointInPath: (\n    displayObject: DisplayObject<ImageStyleProps>,\n    position: Point,\n  ) => boolean,\n  renderingPluginContext: RenderingPluginContext,\n  runtime: GlobalRuntime,\n): boolean {\n  const {\n    pointerEvents = 'auto',\n    x = 0,\n    y = 0,\n    width,\n    height,\n  } = displayObject.parsedStyle as ParsedImageStyleProps;\n\n  if (pointerEvents === 'non-transparent-pixel') {\n    const { offscreenCanvas } = renderingPluginContext.config;\n    const canvas =\n      runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n    const context = runtime.offscreenCanvasCreator.getOrCreateContext(\n      offscreenCanvas,\n      {\n        willReadFrequently: true,\n      },\n    ) as CanvasRenderingContext2D;\n    canvas.width = width;\n    canvas.height = height;\n\n    (\n      (renderingPluginContext as any).defaultStyleRendererFactory as Record<\n        Shape,\n        StyleRenderer\n      >\n    )[Shape.IMAGE].render(\n      context,\n      { ...displayObject.parsedStyle, x: 0, y: 0 },\n      displayObject,\n      undefined,\n      undefined,\n      undefined,\n    );\n\n    const imagedata = context.getImageData(\n      position.x - x,\n      position.y - y,\n      1,\n      1,\n    ).data;\n    return imagedata.every((component) => component !== 0);\n  }\n\n  return true;\n}\n","import type { DisplayObject, Point, TextStyleProps } from '@antv/g-lite';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<TextStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n  isPointInPath: (\n    displayObject: DisplayObject<TextStyleProps>,\n    position: Point,\n  ) => boolean,\n): boolean {\n  const bounds = displayObject.getGeometryBounds();\n\n  // @see https://stackoverflow.com/questions/28706989/how-do-i-check-if-a-mouse-click-is-inside-a-rotated-text-on-the-html5-canvas-in\n  return (\n    position.x >= bounds.min[0] &&\n    position.y >= bounds.min[1] &&\n    position.x <= bounds.max[0] &&\n    position.y <= bounds.max[1]\n  );\n}\n","import { AbstractRendererPlugin, Shape } from '@antv/g-lite';\nimport type { PointInPathPicker } from './CanvasPickerPlugin';\nimport { CanvasPickerPlugin } from './CanvasPickerPlugin';\nimport { isPointInPath as CirclePicker } from './Circle';\nimport { isPointInPath as EllipsePicker } from './Ellipse';\nimport { isPointInPath as LinePicker } from './Line';\nimport { isPointInPath as PathPicker } from './Path';\nimport { isPointInPath as PolygonPicker } from './Polygon';\nimport { isPointInPath as PolylinePicker } from './Polyline';\nimport { isPointInPath as RectPicker } from './Rect';\nimport { isPointInPath as ImagePicker } from './Image';\nimport { isPointInPath as TextPicker } from './Text';\n\nexport class Plugin extends AbstractRendererPlugin {\n  name = 'canvas-picker';\n  init(): void {\n    const pointInPathPickerFactory: Record<Shape, PointInPathPicker<any>> = {\n      [Shape.CIRCLE]: CirclePicker,\n      [Shape.ELLIPSE]: EllipsePicker,\n      [Shape.RECT]: RectPicker,\n      [Shape.LINE]: LinePicker,\n      [Shape.POLYLINE]: PolylinePicker,\n      [Shape.POLYGON]: PolygonPicker,\n      [Shape.PATH]: PathPicker,\n      [Shape.TEXT]: TextPicker,\n      [Shape.GROUP]: null,\n      [Shape.IMAGE]: ImagePicker,\n      [Shape.HTML]: null,\n      [Shape.MESH]: null,\n    };\n\n    // @ts-ignore\n    this.context.pointInPathPickerFactory = pointInPathPickerFactory;\n\n    this.addRenderingPlugin(new CanvasPickerPlugin());\n  }\n  destroy(): void {\n    // @ts-ignore\n    delete this.context.pointInPathPickerFactory;\n    this.removeAllRenderingPlugins();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}