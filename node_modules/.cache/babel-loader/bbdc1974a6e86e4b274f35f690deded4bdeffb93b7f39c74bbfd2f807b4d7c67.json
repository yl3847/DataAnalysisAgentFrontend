{"ast":null,"code":"import { ascending } from '@antv/vendor/d3-array';\nfunction isSegmentIntersect([a, b], [c, d]) {\n  return d > a && b > c;\n}\nfunction useMap() {\n  const map = new Map();\n  const get = key => map.get(key);\n  const set = (key, value) => map.set(key, value);\n  return [get, set];\n}\nfunction getBoundsWithoutConnector(shape) {\n  const node = shape.cloneNode(true);\n  const connectorShape = node.getElementById('connector');\n  connectorShape && node.removeChild(connectorShape);\n  const {\n    min,\n    max\n  } = node.getRenderBounds();\n  node.destroy();\n  return {\n    min,\n    max\n  };\n}\n/**\n * An iterative dodge method avoids label overlap. (n * log(n))\n */\nexport const OverlapDodgeY = options => {\n  const {\n    maxIterations = 10,\n    maxError = 0.1,\n    padding = 1\n  } = options;\n  return labels => {\n    const n = labels.length;\n    if (n <= 1) return labels;\n    // Index y, x0, x, height, by label.\n    const [y0, setY0] = useMap();\n    const [y, setY] = useMap();\n    const [h, setH] = useMap();\n    const [xx, setXX] = useMap();\n    for (const label of labels) {\n      const {\n        min,\n        max\n      } = getBoundsWithoutConnector(label);\n      const [x0, y0] = min;\n      const [x1, y1] = max;\n      setY0(label, y0);\n      setY(label, y0);\n      setH(label, y1 - y0);\n      setXX(label, [x0, x1]);\n    }\n    // Offsets position Y.\n    for (let iter = 0; iter < maxIterations; iter++) {\n      labels.sort((a, b) => ascending(y(a), y(b)));\n      let error = 0;\n      for (let i = 0; i < n - 1; i++) {\n        const l0 = labels[i];\n        let j = i + 1;\n        let l1;\n        // Find the next label overlapping with the current label in x direction.\n        while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1))) j += 1;\n        if (l1) {\n          const y0 = y(l0);\n          const h0 = h(l0);\n          const y1 = y(l1);\n          const delta = y1 - (y0 + h0);\n          if (delta < padding) {\n            const newDelta = (padding - delta) / 2;\n            error = Math.max(error, newDelta);\n            setY(l0, y0 - newDelta);\n            setY(l1, y1 + newDelta);\n          }\n        }\n      }\n      if (error < maxError) break;\n    }\n    for (const label of labels) {\n      label.style.y += y(label) - y0(label);\n    }\n    return labels;\n  };\n};","map":{"version":3,"names":["ascending","isSegmentIntersect","a","b","c","d","useMap","map","Map","get","key","set","value","getBoundsWithoutConnector","shape","node","cloneNode","connectorShape","getElementById","removeChild","min","max","getRenderBounds","destroy","OverlapDodgeY","options","maxIterations","maxError","padding","labels","n","length","y0","setY0","y","setY","h","setH","xx","setXX","label","x0","x1","y1","iter","sort","error","i","l0","j","l1","h0","delta","newDelta","Math","style"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/label-transform/overlapDodgeY.ts"],"sourcesContent":["import { DisplayObject } from '@antv/g';\nimport { ascending } from '@antv/vendor/d3-array';\nimport { OverlapDodgeYLabelTransform } from '../spec';\nimport { LabelTransformComponent as LLC } from '../runtime';\n\nexport type OverlapDodgeYOptions = Omit<OverlapDodgeYLabelTransform, 'type'>;\n\nfunction isSegmentIntersect([a, b], [c, d]) {\n  return d > a && b > c;\n}\n\nfunction useMap<K, V>() {\n  const map = new Map<K, V>();\n  const get = (key: K) => map.get(key);\n  const set = (key: K, value: V) => map.set(key, value);\n  return [get, set] as const;\n}\n\nfunction getBoundsWithoutConnector(shape: DisplayObject) {\n  const node = shape.cloneNode(true);\n  const connectorShape = node.getElementById('connector');\n  connectorShape && node.removeChild(connectorShape);\n  const { min, max } = node.getRenderBounds();\n  node.destroy();\n  return { min, max };\n}\n\n/**\n * An iterative dodge method avoids label overlap. (n * log(n))\n */\nexport const OverlapDodgeY: LLC<OverlapDodgeYOptions> = (options) => {\n  const { maxIterations = 10, maxError = 0.1, padding = 1 } = options;\n  return (labels: DisplayObject[]) => {\n    const n = labels.length;\n    if (n <= 1) return labels;\n\n    // Index y, x0, x, height, by label.\n    const [y0, setY0] = useMap<DisplayObject, number>();\n    const [y, setY] = useMap<DisplayObject, number>();\n    const [h, setH] = useMap<DisplayObject, number>();\n    const [xx, setXX] = useMap<DisplayObject, [number, number]>();\n    for (const label of labels) {\n      const { min, max } = getBoundsWithoutConnector(label);\n      const [x0, y0] = min;\n      const [x1, y1] = max;\n      setY0(label, y0);\n      setY(label, y0);\n      setH(label, y1 - y0);\n      setXX(label, [x0, x1]);\n    }\n\n    // Offsets position Y.\n    for (let iter = 0; iter < maxIterations; iter++) {\n      labels.sort((a, b) => ascending(y(a), y(b)));\n      let error = 0;\n      for (let i = 0; i < n - 1; i++) {\n        const l0 = labels[i];\n        let j = i + 1;\n        let l1;\n        // Find the next label overlapping with the current label in x direction.\n        while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1))) j += 1;\n        if (l1) {\n          const y0 = y(l0);\n          const h0 = h(l0);\n          const y1 = y(l1);\n          const delta = y1 - (y0 + h0);\n          if (delta < padding) {\n            const newDelta = (padding - delta) / 2;\n            error = Math.max(error, newDelta);\n            setY(l0, y0 - newDelta);\n            setY(l1, y1 + newDelta);\n          }\n        }\n      }\n      if (error < maxError) break;\n    }\n\n    for (const label of labels) {\n      label.style.y += y(label) - y0(label);\n    }\n\n    return labels;\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}