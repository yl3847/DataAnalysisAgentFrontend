{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix } from '@antv/util';\nimport { subObject } from '../utils/helper';\nimport { selectionOf } from '../utils/scale';\nimport { brush as createBrush } from './brushHighlight';\nimport { selectPlotArea } from './utils';\n// Mock dblclick events.\nfunction dblclick(interval = 300) {\n  let preTimeStamp = null;\n  return e => {\n    const {\n      timeStamp\n    } = e;\n    if (preTimeStamp !== null && timeStamp - preTimeStamp < interval) {\n      preTimeStamp = timeStamp;\n      return true;\n    }\n    preTimeStamp = timeStamp;\n    return false;\n  };\n}\nexport function brushFilter(root, _a) {\n  var {\n      filter,\n      reset,\n      brushRegion,\n      extent: optionalExtent,\n      reverse,\n      emitter,\n      scale,\n      coordinate,\n      selection,\n      series = false\n    } = _a,\n    rest = __rest(_a, [\"filter\", \"reset\", \"brushRegion\", \"extent\", \"reverse\", \"emitter\", \"scale\", \"coordinate\", \"selection\", \"series\"]);\n  const brushStyle = subObject(rest, 'mask');\n  const {\n    width: rootWidth,\n    height: rootHeight\n  } = root.getBBox();\n  const extent = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];\n  const isDblclick = dblclick();\n  const brush = createBrush(root, Object.assign(Object.assign({}, brushStyle), {\n    extent,\n    brushRegion,\n    reverse,\n    brushcreated\n  }));\n  root.addEventListener('click', click);\n  // Filter when brush created.\n  function brushcreated(x, y, x1, y1, event) {\n    if (x === x1 && y === y1) return;\n    event.nativeEvent = true;\n    filter(selection(x, y, x1, y1), event);\n    brush.remove();\n  }\n  // Reset when dblclick.\n  function click(e) {\n    if (isDblclick(e)) {\n      e.nativeEvent = true;\n      reset(e);\n    }\n  }\n  const onFilter = ({\n    nativeEvent,\n    data\n  }) => {\n    if (nativeEvent) return;\n    const {\n      selection\n    } = data;\n    filter(selection, {\n      nativeEvent: false\n    });\n  };\n  emitter.on('brush:filter', onFilter);\n  return () => {\n    brush.destroy();\n    emitter.off('brush:filter', onFilter);\n    root.removeEventListener('click', click);\n  };\n}\nexport function BrushFilter(_a) {\n  var {\n      hideX = true,\n      hideY = true\n    } = _a,\n    rest = __rest(_a, [\"hideX\", \"hideY\"]);\n  return (target, viewInstances, emitter) => {\n    const {\n      container,\n      view,\n      options: viewOptions,\n      update,\n      setState\n    } = target;\n    const plotArea = selectPlotArea(container);\n    const defaultOptions = {\n      maskFill: '#777',\n      maskFillOpacity: '0.3',\n      maskStroke: '#fff',\n      unhighlightedOpacity: 0.5,\n      reverse: false\n    };\n    let filtered = false;\n    let filtering = false;\n    let newView = view;\n    const {\n      scale,\n      coordinate\n    } = view;\n    return brushFilter(plotArea, Object.assign(Object.assign({\n      brushRegion: (x, y, x1, y1) => [x, y, x1, y1],\n      selection: (x, y, x1, y1) => {\n        const {\n          scale,\n          coordinate\n        } = newView;\n        return selectionOf(x, y, x1, y1, scale, coordinate);\n      },\n      filter: (selection, event) => __awaiter(this, void 0, void 0, function* () {\n        // Avoid redundant filter.\n        if (filtering) return;\n        filtering = true;\n        // Update the domain of x and y scale to filter data.\n        const [domainX, domainY] = selection;\n        setState('brushFilter', options => {\n          const {\n            marks\n          } = options;\n          const newMarks = marks.map(mark => deepMix({\n            // Hide label to keep smooth transition.\n            axis: Object.assign(Object.assign({}, hideX && {\n              x: {\n                transform: [{\n                  type: 'hide'\n                }]\n              }\n            }), hideY && {\n              y: {\n                transform: [{\n                  type: 'hide'\n                }]\n              }\n            })\n          }, mark, {\n            // Set nice to false to avoid modify domain.\n            scale: {\n              x: {\n                domain: domainX,\n                nice: false\n              },\n              y: {\n                domain: domainY,\n                nice: false\n              }\n            }\n          }));\n          return Object.assign(Object.assign({}, viewOptions), {\n            marks: newMarks,\n            clip: true\n          });\n        });\n        // Emit event.\n        emitter.emit('brush:filter', Object.assign(Object.assign({}, event), {\n          data: {\n            selection: [domainX, domainY]\n          }\n        }));\n        const newState = yield update();\n        newView = newState.view;\n        filtering = false;\n        filtered = true;\n      }),\n      reset: event => {\n        if (filtering || !filtered) return;\n        // Emit event.\n        const {\n          scale\n        } = view;\n        const {\n          x: scaleX,\n          y: scaleY\n        } = scale;\n        const domainX = scaleX.getOptions().domain;\n        const domainY = scaleY.getOptions().domain;\n        emitter.emit('brush:filter', Object.assign(Object.assign({}, event), {\n          data: {\n            selection: [domainX, domainY]\n          }\n        }));\n        filtered = false;\n        newView = view;\n        setState('brushFilter');\n        update();\n      },\n      extent: undefined,\n      emitter,\n      scale,\n      coordinate\n    }, defaultOptions), rest));\n  };\n}","map":{"version":3,"names":["deepMix","subObject","selectionOf","brush","createBrush","selectPlotArea","dblclick","interval","preTimeStamp","e","timeStamp","brushFilter","root","_a","filter","reset","brushRegion","extent","optionalExtent","reverse","emitter","scale","coordinate","selection","series","rest","__rest","brushStyle","width","rootWidth","height","rootHeight","getBBox","isDblclick","Object","assign","brushcreated","addEventListener","click","x","y","x1","y1","event","nativeEvent","remove","onFilter","data","on","destroy","off","removeEventListener","BrushFilter","hideX","hideY","target","viewInstances","container","view","options","viewOptions","update","setState","plotArea","defaultOptions","maskFill","maskFillOpacity","maskStroke","unhighlightedOpacity","filtered","filtering","newView","__awaiter","domainX","domainY","marks","newMarks","map","mark","axis","transform","type","domain","nice","clip","emit","newState","scaleX","scaleY","getOptions","undefined"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/brushFilter.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { subObject } from '../utils/helper';\nimport { selectionOf } from '../utils/scale';\nimport { brush as createBrush } from './brushHighlight';\nimport { selectPlotArea } from './utils';\n\n// Mock dblclick events.\nfunction dblclick(interval = 300) {\n  let preTimeStamp = null;\n  return (e) => {\n    const { timeStamp } = e;\n    if (preTimeStamp !== null && timeStamp - preTimeStamp < interval) {\n      preTimeStamp = timeStamp;\n      return true;\n    }\n    preTimeStamp = timeStamp;\n    return false;\n  };\n}\n\nexport function brushFilter(\n  root,\n  {\n    filter,\n    reset,\n    brushRegion,\n    extent: optionalExtent,\n    reverse,\n    emitter,\n    scale,\n    coordinate,\n    selection,\n    series = false,\n    ...rest\n  },\n) {\n  const brushStyle = subObject(rest, 'mask');\n  const { width: rootWidth, height: rootHeight } = root.getBBox();\n  const extent = optionalExtent\n    ? optionalExtent\n    : [0, 0, rootWidth, rootHeight];\n  const isDblclick = dblclick();\n\n  const brush = createBrush(root, {\n    ...brushStyle,\n    extent,\n    brushRegion,\n    reverse,\n    brushcreated,\n  });\n\n  root.addEventListener('click', click);\n\n  // Filter when brush created.\n  function brushcreated(x, y, x1, y1, event) {\n    if (x === x1 && y === y1) return;\n    event.nativeEvent = true;\n    filter(selection(x, y, x1, y1), event);\n    brush.remove();\n  }\n\n  // Reset when dblclick.\n  function click(e) {\n    if (isDblclick(e)) {\n      e.nativeEvent = true;\n      reset(e);\n    }\n  }\n\n  const onFilter = ({ nativeEvent, data }) => {\n    if (nativeEvent) return;\n    const { selection } = data;\n    filter(selection, { nativeEvent: false });\n  };\n  emitter.on('brush:filter', onFilter);\n\n  return () => {\n    brush.destroy();\n    emitter.off('brush:filter', onFilter);\n    root.removeEventListener('click', click);\n  };\n}\n\nexport function BrushFilter({ hideX = true, hideY = true, ...rest }) {\n  return (target, viewInstances, emitter) => {\n    const { container, view, options: viewOptions, update, setState } = target;\n    const plotArea = selectPlotArea(container);\n    const defaultOptions = {\n      maskFill: '#777',\n      maskFillOpacity: '0.3',\n      maskStroke: '#fff',\n      unhighlightedOpacity: 0.5,\n      reverse: false,\n    };\n\n    let filtered = false;\n    let filtering = false;\n    let newView = view;\n\n    const { scale, coordinate } = view;\n    return brushFilter(plotArea, {\n      brushRegion: (x, y, x1, y1) => [x, y, x1, y1],\n      selection: (x, y, x1, y1) => {\n        const { scale, coordinate } = newView;\n        return selectionOf(x, y, x1, y1, scale, coordinate);\n      },\n      filter: async (selection, event) => {\n        // Avoid redundant filter.\n        if (filtering) return;\n        filtering = true;\n\n        // Update the domain of x and y scale to filter data.\n        const [domainX, domainY] = selection;\n\n        setState('brushFilter', (options) => {\n          const { marks } = options;\n          const newMarks = marks.map((mark) =>\n            deepMix(\n              {\n                // Hide label to keep smooth transition.\n                axis: {\n                  ...(hideX && { x: { transform: [{ type: 'hide' }] } }),\n                  ...(hideY && { y: { transform: [{ type: 'hide' }] } }),\n                },\n              },\n              mark,\n              {\n                // Set nice to false to avoid modify domain.\n                scale: {\n                  x: { domain: domainX, nice: false },\n                  y: { domain: domainY, nice: false },\n                },\n              },\n            ),\n          );\n\n          return {\n            ...viewOptions,\n            marks: newMarks,\n            clip: true, // Clip shapes out of plot area.\n          };\n        });\n\n        // Emit event.\n        emitter.emit('brush:filter', {\n          ...event,\n          data: { selection: [domainX, domainY] },\n        });\n\n        const newState = await update();\n        newView = newState.view;\n        filtering = false;\n        filtered = true;\n      },\n      reset: (event) => {\n        if (filtering || !filtered) return;\n\n        // Emit event.\n        const { scale } = view;\n        const { x: scaleX, y: scaleY } = scale;\n        const domainX = scaleX.getOptions().domain;\n        const domainY = scaleY.getOptions().domain;\n        emitter.emit('brush:filter', {\n          ...event,\n          data: { selection: [domainX, domainY] },\n        });\n        filtered = false;\n        newView = view;\n        setState('brushFilter');\n        update();\n      },\n      extent: undefined,\n      emitter,\n      scale,\n      coordinate,\n      ...defaultOptions,\n      ...rest,\n    });\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}