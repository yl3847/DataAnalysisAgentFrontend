{"ast":null,"code":"import { midPoint } from './mid-point';\nimport { distanceSquareRoot } from './distance-square-root';\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a line (L,V,H,Z) segment.\n */\nexport function segmentLineFactory(x1, y1, x2, y2, distance) {\n  var length = distanceSquareRoot([x1, y1], [x2, y2]);\n  var point = {\n    x: 0,\n    y: 0\n  };\n  if (typeof distance === 'number') {\n    if (distance <= 0) {\n      point = {\n        x: x1,\n        y: y1\n      };\n    } else if (distance >= length) {\n      point = {\n        x: x2,\n        y: y2\n      };\n    } else {\n      var _a = midPoint([x1, y1], [x2, y2], distance / length),\n        x = _a[0],\n        y = _a[1];\n      point = {\n        x: x,\n        y: y\n      };\n    }\n  }\n  return {\n    length: length,\n    point: point,\n    min: {\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2)\n    },\n    max: {\n      x: Math.max(x1, x2),\n      y: Math.max(y1, y2)\n    }\n  };\n}","map":{"version":3,"names":["midPoint","distanceSquareRoot","segmentLineFactory","x1","y1","x2","y2","distance","length","point","x","y","_a","min","Math","max"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/util/src/path/util/segment-line-factory.ts"],"sourcesContent":["import type { LengthFactory } from '../types';\nimport { midPoint } from './mid-point';\nimport { distanceSquareRoot } from './distance-square-root';\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a line (L,V,H,Z) segment.\n */\nexport function segmentLineFactory(x1: number, y1: number, x2: number, y2: number, distance: number): LengthFactory {\n  const length = distanceSquareRoot([x1, y1], [x2, y2]);\n  let point = { x: 0, y: 0 };\n\n  if (typeof distance === 'number') {\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = { x, y };\n    }\n  }\n\n  return {\n    length,\n    point,\n    min: {\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n    },\n    max: {\n      x: Math.max(x1, x2),\n      y: Math.max(y1, y2),\n    },\n  };\n}\n"],"mappings":"AACA,SAASA,QAAQ,QAAQ,aAAa;AACtC,SAASC,kBAAkB,QAAQ,wBAAwB;AAE3D;;;;AAIA,OAAM,SAAUC,kBAAkBA,CAACC,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEC,QAAgB;EACjG,IAAMC,MAAM,GAAGP,kBAAkB,CAAC,CAACE,EAAE,EAAEC,EAAE,CAAC,EAAE,CAACC,EAAE,EAAEC,EAAE,CAAC,CAAC;EACrD,IAAIG,KAAK,GAAG;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAC,CAAE;EAE1B,IAAI,OAAOJ,QAAQ,KAAK,QAAQ,EAAE;IAChC,IAAIA,QAAQ,IAAI,CAAC,EAAE;MACjBE,KAAK,GAAG;QAAEC,CAAC,EAAEP,EAAE;QAAEQ,CAAC,EAAEP;MAAE,CAAE;IAC1B,CAAC,MAAM,IAAIG,QAAQ,IAAIC,MAAM,EAAE;MAC7BC,KAAK,GAAG;QAAEC,CAAC,EAAEL,EAAE;QAAEM,CAAC,EAAEL;MAAE,CAAE;IAC1B,CAAC,MAAM;MACC,IAAAM,EAAA,GAASZ,QAAQ,CAAC,CAACG,EAAE,EAAEC,EAAE,CAAC,EAAE,CAACC,EAAE,EAAEC,EAAE,CAAC,EAAEC,QAAQ,GAAGC,MAAM,CAAC;QAAvDE,CAAC,GAAAE,EAAA;QAAED,CAAC,GAAAC,EAAA,GAAmD;MAC9DH,KAAK,GAAG;QAAEC,CAAC,EAAAA,CAAA;QAAEC,CAAC,EAAAA;MAAA,CAAE;IAClB;EACF;EAEA,OAAO;IACLH,MAAM,EAAAA,MAAA;IACNC,KAAK,EAAAA,KAAA;IACLI,GAAG,EAAE;MACHH,CAAC,EAAEI,IAAI,CAACD,GAAG,CAACV,EAAE,EAAEE,EAAE,CAAC;MACnBM,CAAC,EAAEG,IAAI,CAACD,GAAG,CAACT,EAAE,EAAEE,EAAE;KACnB;IACDS,GAAG,EAAE;MACHL,CAAC,EAAEI,IAAI,CAACC,GAAG,CAACZ,EAAE,EAAEE,EAAE,CAAC;MACnBM,CAAC,EAAEG,IAAI,CAACC,GAAG,CAACX,EAAE,EAAEE,EAAE;;GAErB;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}