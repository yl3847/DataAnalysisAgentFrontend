{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { group } from '@antv/vendor/d3-array';\nimport { deepMix } from '@antv/util';\nimport { subObject } from '../utils/helper';\nimport { traverseElements } from '../utils/traverse-elements';\nimport { createValueof, createDatumof, selectG2Elements, renderLink, renderBackground, selectPlotArea, offsetTransform, mergeState, selectElementByData, createXKey, createFindElementByEvent, VALID_FIND_BY_X_MARKS, createUseState } from './utils';\n/**\n * Active a group of elements.\n */\nexport function elementSelect(root, {\n  elements: elementsof,\n  // given the root of chart returns elements to be manipulated\n  datum,\n  // given each element returns the datum of it\n  groupKey = d => d,\n  // group elements by specified key\n  regionGroupKey = d => d,\n  // how to group elements when click region\n  link = false,\n  // draw link or not\n  single = false,\n  // single select or not\n  multipleSelectHotkey,\n  // hotkey for multi-select mode\n  coordinate,\n  background = false,\n  scale,\n  emitter,\n  state = {},\n  region = false,\n  regionEleFilter = el => VALID_FIND_BY_X_MARKS.includes(el.markType)\n}) {\n  var _a;\n  const elements = elementsof(root);\n  const elementSet = new Set(elements);\n  const findElement = createFindElementByEvent({\n    elementsof,\n    root,\n    coordinate,\n    scale\n  });\n  const keyGroup = group(elements, groupKey);\n  const regionGroup = group(elements, regionGroupKey);\n  const valueof = createValueof(elements, datum);\n  const [appendLink, removeLink] = renderLink(Object.assign({\n    link,\n    elements,\n    valueof,\n    coordinate\n  }, subObject(state.selected, 'link')));\n  const [appendBackground, removeBackground] = renderBackground(Object.assign({\n    document: root.ownerDocument,\n    background,\n    coordinate,\n    scale,\n    valueof\n  }, subObject(state.selected, 'background')));\n  const elementStyle = deepMix(state, {\n    selected: Object.assign({}, ((_a = state.selected) === null || _a === void 0 ? void 0 : _a.offset) && {\n      // Apply translate to mock slice out.\n      transform: (...params) => {\n        const value = state.selected.offset(...params);\n        const [, i] = params;\n        return offsetTransform(elements[i], value, coordinate);\n      }\n    })\n  });\n  const useState = createUseState(elementStyle, elements);\n  const {\n    updateState,\n    removeState,\n    hasState\n  } = useState(valueof);\n  let isMultiSelectMode = !single; // \"single\" determines whether to multi-select by default\n  let activeHotkey = null; // Track the currently active hotkey\n  const clear = (nativeEvent = true) => {\n    for (const e of elements) {\n      removeState(e, 'selected', 'unselected');\n      removeLink(e);\n      removeBackground(e);\n    }\n    if (nativeEvent) emitter.emit('element:unselect', {\n      nativeEvent: true\n    });\n    return;\n  };\n  const singleSelect = ({\n    event,\n    element,\n    nativeEvent = true,\n    filter = el => true,\n    groupBy = groupKey,\n    groupMap = keyGroup\n  }) => {\n    const filteredElements = elements.filter(filter);\n    // Clear states if clicked selected element.\n    if (hasState(element, 'selected')) clear();else {\n      const k = groupBy(element);\n      const group = groupMap.get(k);\n      const groupSet = new Set(group);\n      for (const e of filteredElements) {\n        if (groupSet.has(e)) updateState(e, 'selected');else {\n          updateState(e, 'unselected');\n          removeLink(e);\n        }\n        if (e !== element) removeBackground(e);\n      }\n      appendLink(group);\n      appendBackground(element);\n      if (!nativeEvent) return;\n      emitter.emit('element:select', Object.assign(Object.assign({}, event), {\n        nativeEvent,\n        data: {\n          data: [datum(element), ...group.map(datum)]\n        }\n      }));\n    }\n  };\n  const multipleSelect = ({\n    event,\n    element,\n    nativeEvent = true,\n    filter = el => true,\n    groupBy = groupKey,\n    groupMap = keyGroup\n  }) => {\n    const k = groupBy(element);\n    const group = groupMap.get(k);\n    const groupSet = new Set(group);\n    const filteredElements = elements.filter(filter);\n    if (!hasState(element, 'selected')) {\n      const hasSelectedGroup = group.some(e => hasState(e, 'selected'));\n      for (const e of filteredElements) {\n        if (groupSet.has(e)) updateState(e, 'selected');else if (!hasState(e, 'selected')) updateState(e, 'unselected');\n      }\n      // Append link for each group only once.\n      if (!hasSelectedGroup && link) appendLink(group);\n      appendBackground(element);\n    } else {\n      // If there is no selected elements after resetting this group,\n      // clear the states.\n      const hasSelected = elements.some(e => !groupSet.has(e) && hasState(e, 'selected'));\n      if (!hasSelected) return clear();\n      // If there are still some selected elements after resetting this group,\n      // only remove the link.\n      for (const e of group) {\n        updateState(e, 'unselected');\n        removeLink(e);\n        removeBackground(e);\n      }\n    }\n    if (!nativeEvent) return;\n    emitter.emit('element:select', Object.assign(Object.assign({}, event), {\n      nativeEvent,\n      data: {\n        data: elements.filter(e => hasState(e, 'selected')).map(datum)\n      }\n    }));\n  };\n  const isClickElementOrGroup = element => {\n    if (elementSet.has(element)) return true;\n    for (const group of elementSet) {\n      const found = traverseElements(group, el => el === element);\n      if (found) return true;\n    }\n    return false;\n  };\n  const getRealElement = element => {\n    if (elementSet.has(element)) return element;\n    for (const group of elementSet) {\n      let match = null;\n      traverseElements(group, el => {\n        if (el === element) match = group;\n      });\n      if (match) return match;\n    }\n    return element;\n  };\n  const click = event => {\n    const {\n      target: element,\n      nativeEvent = true\n    } = event;\n    const select = !isMultiSelectMode ? singleSelect : multipleSelect;\n    let el = element;\n    const isClickElement = isClickElementOrGroup(element);\n    if (!region || isClickElement) {\n      // Click non-element shape, reset.\n      // Such as the rest of content area(background).\n      if (!isClickElement) return clear();\n      return select({\n        event,\n        element: getRealElement(el),\n        nativeEvent,\n        groupBy: groupKey\n      });\n    } else {\n      // Click background region area, select elements in the region.\n      // Get element at cursor.x position.\n      el = findElement(event);\n      if (!elementSet.has(el)) return clear();\n      return select({\n        event,\n        element: el,\n        nativeEvent,\n        filter: regionEleFilter,\n        groupBy: regionGroupKey,\n        groupMap: regionGroup\n      });\n    }\n  };\n  // Handle keyboard events for multi-select mode\n  const hotkeys = Array.isArray(multipleSelectHotkey) ? multipleSelectHotkey : [multipleSelectHotkey];\n  const handleKeyDown = event => {\n    if (hotkeys.includes(event.code) && !activeHotkey) {\n      activeHotkey = event.code;\n      isMultiSelectMode = true;\n    }\n  };\n  const handleKeyUp = event => {\n    if (event.code === activeHotkey) {\n      activeHotkey = null;\n      isMultiSelectMode = false;\n    }\n  };\n  root.addEventListener('click', click);\n  if (multipleSelectHotkey) {\n    // If a hotkey is set, the initial state should be single mode\n    isMultiSelectMode = false;\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n  }\n  const onSelect = e => {\n    const {\n      nativeEvent,\n      data\n    } = e;\n    if (nativeEvent) return;\n    const selectedData = !isMultiSelectMode ? data.data.slice(0, 1) : data.data;\n    for (const d of selectedData) {\n      const element = selectElementByData(elements, d, datum);\n      click({\n        target: element,\n        nativeEvent: false\n      });\n    }\n  };\n  const onUnSelect = () => {\n    clear(false);\n  };\n  emitter.on('element:select', onSelect);\n  emitter.on('element:unselect', onUnSelect);\n  return () => {\n    for (const e of elements) removeLink(e);\n    root.removeEventListener('click', click);\n    if (multipleSelectHotkey) {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    }\n    emitter.off('element:select', onSelect);\n    emitter.off('element:unselect', onUnSelect);\n  };\n}\nexport function ElementSelect(_a) {\n  var {\n      createGroup,\n      createRegionGroup,\n      background = false,\n      link = false\n    } = _a,\n    rest = __rest(_a, [\"createGroup\", \"createRegionGroup\", \"background\", \"link\"]);\n  return (context, _, emitter) => {\n    const {\n      container,\n      view,\n      options\n    } = context;\n    const {\n      coordinate,\n      scale\n    } = view;\n    const plotArea = selectPlotArea(container);\n    return elementSelect(plotArea, Object.assign({\n      elements: selectG2Elements,\n      datum: createDatumof(view),\n      groupKey: createGroup ? createGroup(view) : undefined,\n      regionGroupKey: createRegionGroup ? createRegionGroup(view) : createXKey(view),\n      coordinate,\n      scale,\n      state: mergeState(options, [['selected', background ? {} : {\n        lineWidth: '1',\n        stroke: '#000'\n      }], 'unselected']),\n      background,\n      link,\n      emitter\n    }, rest));\n  };\n}\nElementSelect.props = {\n  reapplyWhenUpdate: true\n};","map":{"version":3,"names":["group","deepMix","subObject","traverseElements","createValueof","createDatumof","selectG2Elements","renderLink","renderBackground","selectPlotArea","offsetTransform","mergeState","selectElementByData","createXKey","createFindElementByEvent","VALID_FIND_BY_X_MARKS","createUseState","elementSelect","root","elements","elementsof","datum","groupKey","d","regionGroupKey","link","single","multipleSelectHotkey","coordinate","background","scale","emitter","state","region","regionEleFilter","el","includes","markType","elementSet","Set","findElement","keyGroup","regionGroup","valueof","appendLink","removeLink","Object","assign","selected","appendBackground","removeBackground","document","ownerDocument","elementStyle","_a","offset","transform","params","value","i","useState","updateState","removeState","hasState","isMultiSelectMode","activeHotkey","clear","nativeEvent","e","emit","singleSelect","event","element","filter","groupBy","groupMap","filteredElements","k","get","groupSet","has","data","map","multipleSelect","hasSelectedGroup","some","hasSelected","isClickElementOrGroup","found","getRealElement","match","click","target","select","isClickElement","hotkeys","Array","isArray","handleKeyDown","code","handleKeyUp","addEventListener","onSelect","selectedData","slice","onUnSelect","on","removeEventListener","off","ElementSelect","createGroup","createRegionGroup","rest","__rest","context","_","container","view","options","plotArea","undefined","lineWidth","stroke","props","reapplyWhenUpdate"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/elementSelect.ts"],"sourcesContent":["import { DisplayObject } from '@antv/g';\nimport { group } from '@antv/vendor/d3-array';\nimport { deepMix } from '@antv/util';\nimport { subObject } from '../utils/helper';\nimport { traverseElements } from '../utils/traverse-elements';\nimport {\n  createValueof,\n  createDatumof,\n  selectG2Elements,\n  renderLink,\n  renderBackground,\n  selectPlotArea,\n  offsetTransform,\n  mergeState,\n  selectElementByData,\n  createXKey,\n  createFindElementByEvent,\n  VALID_FIND_BY_X_MARKS,\n  createUseState,\n} from './utils';\n\n/**\n * Active a group of elements.\n */\nexport function elementSelect(\n  root: DisplayObject,\n  {\n    elements: elementsof, // given the root of chart returns elements to be manipulated\n    datum, // given each element returns the datum of it\n    groupKey = (d) => d, // group elements by specified key\n    regionGroupKey = (d) => d, // how to group elements when click region\n    link = false, // draw link or not\n    single = false, // single select or not\n    multipleSelectHotkey, // hotkey for multi-select mode\n    coordinate,\n    background = false,\n    scale,\n    emitter,\n    state = {},\n    region = false,\n    regionEleFilter = (el) => VALID_FIND_BY_X_MARKS.includes(el.markType),\n  }: Record<string, any>,\n) {\n  const elements = elementsof(root);\n  const elementSet: Set<DisplayObject> = new Set(elements);\n  const findElement = createFindElementByEvent({\n    elementsof,\n    root,\n    coordinate,\n    scale,\n  });\n  const keyGroup = group(elements, groupKey);\n  const regionGroup = group(elements, regionGroupKey);\n\n  const valueof = createValueof(elements, datum);\n\n  const [appendLink, removeLink] = renderLink({\n    link,\n    elements,\n    valueof,\n    coordinate,\n    ...subObject(state.selected, 'link'),\n  });\n\n  const [appendBackground, removeBackground] = renderBackground({\n    document: root.ownerDocument,\n    background,\n    coordinate,\n    scale,\n    valueof,\n    ...subObject(state.selected, 'background'),\n  });\n\n  const elementStyle = deepMix(state, {\n    selected: {\n      ...(state.selected?.offset && {\n        // Apply translate to mock slice out.\n        transform: (...params) => {\n          const value = state.selected.offset(...params);\n          const [, i] = params;\n          return offsetTransform(elements[i], value, coordinate);\n        },\n      }),\n    },\n  });\n\n  const useState = createUseState(elementStyle, elements);\n\n  const { updateState, removeState, hasState } = useState(valueof);\n  let isMultiSelectMode = !single; // \"single\" determines whether to multi-select by default\n  let activeHotkey = null; // Track the currently active hotkey\n\n  const clear = (nativeEvent = true) => {\n    for (const e of elements) {\n      removeState(e, 'selected', 'unselected');\n      removeLink(e);\n      removeBackground(e);\n    }\n    if (nativeEvent) emitter.emit('element:unselect', { nativeEvent: true });\n    return;\n  };\n\n  const singleSelect = ({\n    event,\n    element,\n    nativeEvent = true,\n    filter = (el) => true,\n    groupBy = groupKey,\n    groupMap = keyGroup,\n  }) => {\n    const filteredElements = elements.filter(filter);\n    // Clear states if clicked selected element.\n    if (hasState(element, 'selected')) clear();\n    else {\n      const k = groupBy(element);\n      const group = groupMap.get(k);\n      const groupSet = new Set(group);\n      for (const e of filteredElements) {\n        if (groupSet.has(e)) updateState(e, 'selected');\n        else {\n          updateState(e, 'unselected');\n          removeLink(e);\n        }\n        if (e !== element) removeBackground(e);\n      }\n      appendLink(group);\n      appendBackground(element);\n\n      if (!nativeEvent) return;\n      emitter.emit('element:select', {\n        ...event,\n        nativeEvent,\n        data: {\n          data: [datum(element), ...group.map(datum)],\n        },\n      });\n    }\n  };\n\n  const multipleSelect = ({\n    event,\n    element,\n    nativeEvent = true,\n    filter = (el) => true,\n    groupBy = groupKey,\n    groupMap = keyGroup,\n  }) => {\n    const k = groupBy(element);\n    const group = groupMap.get(k);\n    const groupSet = new Set(group);\n    const filteredElements = elements.filter(filter);\n\n    if (!hasState(element, 'selected')) {\n      const hasSelectedGroup = group.some((e) => hasState(e, 'selected'));\n      for (const e of filteredElements) {\n        if (groupSet.has(e)) updateState(e, 'selected');\n        else if (!hasState(e, 'selected')) updateState(e, 'unselected');\n      }\n      // Append link for each group only once.\n      if (!hasSelectedGroup && link) appendLink(group);\n      appendBackground(element);\n    } else {\n      // If there is no selected elements after resetting this group,\n      // clear the states.\n      const hasSelected = elements.some(\n        (e) => !groupSet.has(e) && hasState(e, 'selected'),\n      );\n      if (!hasSelected) return clear();\n      // If there are still some selected elements after resetting this group,\n      // only remove the link.\n      for (const e of group) {\n        updateState(e, 'unselected');\n        removeLink(e);\n        removeBackground(e);\n      }\n    }\n    if (!nativeEvent) return;\n    emitter.emit('element:select', {\n      ...event,\n      nativeEvent,\n      data: {\n        data: elements.filter((e) => hasState(e, 'selected')).map(datum),\n      },\n    });\n  };\n\n  const isClickElementOrGroup = (element: DisplayObject): boolean => {\n    if (elementSet.has(element)) return true;\n\n    for (const group of elementSet) {\n      const found = traverseElements(group, (el) => el === element);\n      if (found) return true;\n    }\n\n    return false;\n  };\n\n  const getRealElement = (element: DisplayObject): DisplayObject => {\n    if (elementSet.has(element)) return element;\n    for (const group of elementSet) {\n      let match: DisplayObject | null = null;\n      traverseElements(group, (el) => {\n        if (el === element) match = group;\n      });\n      if (match) return match;\n    }\n    return element;\n  };\n\n  const click = (event) => {\n    const { target: element, nativeEvent = true } = event;\n\n    const select = !isMultiSelectMode ? singleSelect : multipleSelect;\n    let el = element;\n    const isClickElement = isClickElementOrGroup(element);\n\n    if (!region || isClickElement) {\n      // Click non-element shape, reset.\n      // Such as the rest of content area(background).\n      if (!isClickElement) return clear();\n      return select({\n        event,\n        element: getRealElement(el),\n        nativeEvent,\n        groupBy: groupKey,\n      });\n    } else {\n      // Click background region area, select elements in the region.\n      // Get element at cursor.x position.\n      el = findElement(event);\n\n      if (!elementSet.has(el)) return clear();\n\n      return select({\n        event,\n        element: el,\n        nativeEvent,\n        filter: regionEleFilter,\n        groupBy: regionGroupKey,\n        groupMap: regionGroup,\n      });\n    }\n  };\n\n  // Handle keyboard events for multi-select mode\n  const hotkeys = Array.isArray(multipleSelectHotkey)\n    ? multipleSelectHotkey\n    : [multipleSelectHotkey];\n  const handleKeyDown = (event) => {\n    if (hotkeys.includes(event.code) && !activeHotkey) {\n      activeHotkey = event.code;\n      isMultiSelectMode = true;\n    }\n  };\n  const handleKeyUp = (event) => {\n    if (event.code === activeHotkey) {\n      activeHotkey = null;\n      isMultiSelectMode = false;\n    }\n  };\n\n  root.addEventListener('click', click);\n  if (multipleSelectHotkey) {\n    // If a hotkey is set, the initial state should be single mode\n    isMultiSelectMode = false;\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n  }\n\n  const onSelect = (e) => {\n    const { nativeEvent, data } = e;\n    if (nativeEvent) return;\n    const selectedData = !isMultiSelectMode ? data.data.slice(0, 1) : data.data;\n    for (const d of selectedData) {\n      const element = selectElementByData(elements, d, datum);\n      click({ target: element, nativeEvent: false });\n    }\n  };\n\n  const onUnSelect = () => {\n    clear(false);\n  };\n\n  emitter.on('element:select', onSelect);\n  emitter.on('element:unselect', onUnSelect);\n\n  return () => {\n    for (const e of elements) removeLink(e);\n    root.removeEventListener('click', click);\n    if (multipleSelectHotkey) {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    }\n    emitter.off('element:select', onSelect);\n    emitter.off('element:unselect', onUnSelect);\n  };\n}\n\nexport function ElementSelect({\n  createGroup,\n  createRegionGroup,\n  background = false,\n  link = false,\n  ...rest\n}) {\n  return (context, _, emitter) => {\n    const { container, view, options } = context;\n    const { coordinate, scale } = view;\n    const plotArea = selectPlotArea(container);\n    return elementSelect(plotArea, {\n      elements: selectG2Elements,\n      datum: createDatumof(view),\n      groupKey: createGroup ? createGroup(view) : undefined,\n      regionGroupKey: createRegionGroup\n        ? createRegionGroup(view)\n        : createXKey(view),\n      coordinate,\n      scale,\n      state: mergeState(options, [\n        ['selected', background ? {} : { lineWidth: '1', stroke: '#000' }],\n        'unselected',\n      ]),\n      background,\n      link,\n      emitter,\n      ...rest,\n    });\n  };\n}\n\nElementSelect.props = {\n  reapplyWhenUpdate: true,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}