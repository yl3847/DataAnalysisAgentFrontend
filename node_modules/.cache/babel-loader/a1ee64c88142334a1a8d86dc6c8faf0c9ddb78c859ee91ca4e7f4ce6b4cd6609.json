{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix } from '@antv/util';\nimport { group } from '@antv/vendor/d3-array';\nimport { subObject } from '../utils/helper';\nimport { createDatumof, createFindElementByEvent, createUseState, createValueof, createXKey, mergeState, offsetTransform, renderBackground, renderLink, selectElementByData, selectG2Elements, selectPlotArea, VALID_FIND_BY_X_MARKS } from './utils';\n/**\n * highlight a group of elements.\n */\nexport function elementHighlight(root, {\n  elements: elementsof,\n  // given the root of chart returns elements to be manipulated\n  datum,\n  // given each element returns the datum of it\n  groupKey: eleGroupKey = d => d,\n  // group elements by specified key\n  regionGroupKey = d => d,\n  // how to group elements when hover region\n  link = false,\n  // draw link or not\n  background = false,\n  // draw background or not\n  delay = 60,\n  // delay to unhighlighted element\n  scale,\n  coordinate,\n  emitter,\n  state = {},\n  region = false,\n  regionEleFilter = el => VALID_FIND_BY_X_MARKS.includes(el.markType) // some elements can not be highlighted by region, like shapes in pie.\n}) {\n  var _a, _b;\n  const allElements = (_a = elementsof(root)) !== null && _a !== void 0 ? _a : [];\n  const elements = region ? allElements.filter(regionEleFilter) : allElements;\n  const elementSet = new Set(elements);\n  const groupKey = region ? regionGroupKey : eleGroupKey;\n  const keyGroup = group(elements, groupKey);\n  const findElement = createFindElementByEvent({\n    elementsof,\n    root,\n    coordinate,\n    scale\n  });\n  const valueof = createValueof(elements, datum);\n  const [appendLink, removeLink] = renderLink(Object.assign({\n    elements,\n    valueof,\n    link,\n    coordinate\n  }, subObject(state.active, 'link')));\n  const [appendBackground, removeBackground, isBackground] = renderBackground(Object.assign({\n    document: root.ownerDocument,\n    scale,\n    coordinate,\n    background,\n    valueof\n  }, subObject(state.active, 'background')));\n  const elementStyle = deepMix(state, {\n    active: Object.assign({}, ((_b = state.active) === null || _b === void 0 ? void 0 : _b.offset) && {\n      //Apply translate to mock slice out.\n      transform: (...params) => {\n        const value = state.active.offset(...params);\n        const [, i] = params;\n        return offsetTransform(elements[i], value, coordinate);\n      }\n    })\n  });\n  const useState = createUseState(elementStyle, elements);\n  const {\n    updateState,\n    removeState,\n    hasState\n  } = useState(valueof);\n  let out; // Timer for delaying unhighlighted.\n  const pointerover = event => {\n    const {\n      nativeEvent = true\n    } = event;\n    let element = event.target;\n    if (region) {\n      element = findElement(event);\n    }\n    if (!elementSet.has(element)) return;\n    if (out) clearTimeout(out);\n    const k = groupKey(element);\n    const group = keyGroup.get(k);\n    const groupSet = new Set(group);\n    for (const e of elements) {\n      if (groupSet.has(e)) {\n        if (!hasState(e, 'active')) updateState(e, 'active');\n      } else {\n        updateState(e, 'inactive');\n        removeLink(e);\n      }\n      if (e !== element) removeBackground(e);\n    }\n    appendBackground(element);\n    appendLink(group);\n    // Emit events.\n    if (!nativeEvent) return;\n    emitter.emit('element:highlight', {\n      nativeEvent,\n      data: {\n        data: datum(element),\n        group: group.map(datum)\n      }\n    });\n  };\n  const delayUnhighlighted = () => {\n    if (out) clearTimeout(out);\n    out = setTimeout(() => {\n      unhighlighted();\n      out = null;\n    }, delay);\n  };\n  const unhighlighted = (nativeEvent = true) => {\n    for (const e of elements) {\n      removeState(e, 'active', 'inactive');\n      removeBackground(e);\n      removeLink(e);\n    }\n    if (nativeEvent) {\n      emitter.emit('element:unhighlight', {\n        nativeEvent\n      });\n    }\n  };\n  const pointerout = event => {\n    let element = event.target;\n    if (region) {\n      element = findElement(event);\n    }\n    if (!element) {\n      if (delay > 0) delayUnhighlighted();else unhighlighted();\n      return;\n    }\n    if (background && !isBackground(element)) return;\n    if (!background && !elementSet.has(element)) return;\n    if (delay > 0) delayUnhighlighted();else unhighlighted();\n  };\n  const pointerleave = () => {\n    unhighlighted();\n  };\n  root.addEventListener('pointerover', pointerover);\n  root.addEventListener('pointermove', pointerover);\n  root.addEventListener('pointerout', pointerout);\n  root.addEventListener('pointerleave', pointerleave);\n  const onRest = e => {\n    const {\n      nativeEvent\n    } = e;\n    if (nativeEvent) return;\n    unhighlighted(false);\n  };\n  const onHighlight = e => {\n    const {\n      nativeEvent\n    } = e;\n    if (nativeEvent) return;\n    const {\n      data\n    } = e.data;\n    const element = selectElementByData(elements, data, datum);\n    if (!element) return;\n    pointerover({\n      target: element,\n      nativeEvent: false\n    });\n  };\n  emitter.on('element:highlight', onHighlight);\n  emitter.on('element:unhighlight', onRest);\n  return () => {\n    root.removeEventListener('pointerover', pointerover);\n    root.removeEventListener('pointermove', pointerover);\n    root.removeEventListener('pointerout', pointerout);\n    root.removeEventListener('pointerleave', pointerleave);\n    emitter.off('element:highlight', onHighlight);\n    emitter.off('element:unhighlight', onRest);\n    for (const e of elements) {\n      removeBackground(e);\n      removeLink(e);\n    }\n  };\n}\nexport function ElementHighlight(_a) {\n  var {\n      delay,\n      createGroup,\n      createRegionGroup,\n      background = false,\n      link = false\n    } = _a,\n    rest = __rest(_a, [\"delay\", \"createGroup\", \"createRegionGroup\", \"background\", \"link\"]);\n  return (context, _, emitter) => {\n    const {\n      container,\n      view,\n      options\n    } = context;\n    const {\n      scale,\n      coordinate\n    } = view;\n    const plotArea = selectPlotArea(container);\n    return elementHighlight(plotArea, Object.assign({\n      elements: selectG2Elements,\n      datum: createDatumof(view),\n      groupKey: createGroup ? createGroup(view) : undefined,\n      regionGroupKey: createRegionGroup ? createRegionGroup(view) : createXKey(view),\n      coordinate,\n      scale,\n      state: mergeState(options, [['active', background ? {} : {\n        lineWidth: '1',\n        stroke: '#000'\n      }], 'inactive']),\n      background,\n      link,\n      delay,\n      emitter\n    }, rest));\n  };\n}\nElementHighlight.props = {\n  reapplyWhenUpdate: true\n};","map":{"version":3,"names":["deepMix","group","subObject","createDatumof","createFindElementByEvent","createUseState","createValueof","createXKey","mergeState","offsetTransform","renderBackground","renderLink","selectElementByData","selectG2Elements","selectPlotArea","VALID_FIND_BY_X_MARKS","elementHighlight","root","elements","elementsof","datum","groupKey","eleGroupKey","d","regionGroupKey","link","background","delay","scale","coordinate","emitter","state","region","regionEleFilter","el","includes","markType","allElements","_a","filter","elementSet","Set","keyGroup","findElement","valueof","appendLink","removeLink","Object","assign","active","appendBackground","removeBackground","isBackground","document","ownerDocument","elementStyle","_b","offset","transform","params","value","i","useState","updateState","removeState","hasState","out","pointerover","event","nativeEvent","element","target","has","clearTimeout","k","get","groupSet","e","emit","data","map","delayUnhighlighted","setTimeout","unhighlighted","pointerout","pointerleave","addEventListener","onRest","onHighlight","on","removeEventListener","off","ElementHighlight","createGroup","createRegionGroup","rest","__rest","context","_","container","view","options","plotArea","undefined","lineWidth","stroke","props","reapplyWhenUpdate"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/elementHighlight.ts"],"sourcesContent":["import { DisplayObject } from '@antv/g';\nimport { deepMix } from '@antv/util';\nimport { group } from '@antv/vendor/d3-array';\nimport { subObject } from '../utils/helper';\nimport {\n  createDatumof,\n  createFindElementByEvent,\n  createUseState,\n  createValueof,\n  createXKey,\n  mergeState,\n  offsetTransform,\n  renderBackground,\n  renderLink,\n  selectElementByData,\n  selectG2Elements,\n  selectPlotArea,\n  VALID_FIND_BY_X_MARKS,\n} from './utils';\n\n/**\n * highlight a group of elements.\n */\nexport function elementHighlight(\n  root: DisplayObject,\n  {\n    elements: elementsof, // given the root of chart returns elements to be manipulated\n    datum, // given each element returns the datum of it\n    groupKey: eleGroupKey = (d) => d, // group elements by specified key\n    regionGroupKey = (d) => d, // how to group elements when hover region\n    link = false, // draw link or not\n    background = false, // draw background or not\n    delay = 60, // delay to unhighlighted element\n    scale,\n    coordinate,\n    emitter,\n    state = {},\n    region = false,\n    regionEleFilter = (el) => VALID_FIND_BY_X_MARKS.includes(el.markType), // some elements can not be highlighted by region, like shapes in pie.\n  }: Record<string, any>,\n) {\n  const allElements = elementsof(root) ?? [];\n  const elements = region ? allElements.filter(regionEleFilter) : allElements;\n  const elementSet = new Set(elements);\n  const groupKey = region ? regionGroupKey : eleGroupKey;\n  const keyGroup = group(elements, groupKey);\n  const findElement = createFindElementByEvent({\n    elementsof,\n    root,\n    coordinate,\n    scale,\n  });\n\n  const valueof = createValueof(elements, datum);\n  const [appendLink, removeLink] = renderLink({\n    elements,\n    valueof,\n    link,\n    coordinate,\n    ...subObject(state.active, 'link'),\n  });\n  const [appendBackground, removeBackground, isBackground] = renderBackground({\n    document: root.ownerDocument,\n    scale,\n    coordinate,\n    background,\n    valueof,\n    ...subObject(state.active, 'background'),\n  });\n\n  const elementStyle = deepMix(state, {\n    active: {\n      ...(state.active?.offset && {\n        //Apply translate to mock slice out.\n        transform: (...params) => {\n          const value = state.active.offset(...params);\n          const [, i] = params;\n          return offsetTransform(elements[i], value, coordinate);\n        },\n      }),\n    },\n  });\n\n  const useState = createUseState(elementStyle, elements);\n\n  const { updateState, removeState, hasState } = useState(valueof);\n\n  let out; // Timer for delaying unhighlighted.\n  const pointerover = (event) => {\n    const { nativeEvent = true } = event;\n    let element = event.target;\n    if (region) {\n      element = findElement(event);\n    }\n    if (!elementSet.has(element)) return;\n    if (out) clearTimeout(out);\n    const k = groupKey(element);\n    const group = keyGroup.get(k);\n    const groupSet = new Set(group);\n    for (const e of elements) {\n      if (groupSet.has(e)) {\n        if (!hasState(e, 'active')) updateState(e, 'active');\n      } else {\n        updateState(e, 'inactive');\n        removeLink(e);\n      }\n      if (e !== element) removeBackground(e);\n    }\n    appendBackground(element);\n    appendLink(group);\n\n    // Emit events.\n    if (!nativeEvent) return;\n    emitter.emit('element:highlight', {\n      nativeEvent,\n      data: {\n        data: datum(element),\n        group: group.map(datum),\n      },\n    });\n  };\n\n  const delayUnhighlighted = () => {\n    if (out) clearTimeout(out);\n    out = setTimeout(() => {\n      unhighlighted();\n      out = null;\n    }, delay);\n  };\n\n  const unhighlighted = (nativeEvent = true) => {\n    for (const e of elements) {\n      removeState(e, 'active', 'inactive');\n      removeBackground(e);\n      removeLink(e);\n    }\n    if (nativeEvent) {\n      emitter.emit('element:unhighlight', { nativeEvent });\n    }\n  };\n\n  const pointerout = (event) => {\n    let element = event.target;\n    if (region) {\n      element = findElement(event);\n    }\n    if (!element) {\n      if (delay > 0) delayUnhighlighted();\n      else unhighlighted();\n      return;\n    }\n    if (background && !isBackground(element)) return;\n    if (!background && !elementSet.has(element)) return;\n    if (delay > 0) delayUnhighlighted();\n    else unhighlighted();\n  };\n\n  const pointerleave = () => {\n    unhighlighted();\n  };\n\n  root.addEventListener('pointerover', pointerover);\n  root.addEventListener('pointermove', pointerover);\n  root.addEventListener('pointerout', pointerout);\n  root.addEventListener('pointerleave', pointerleave);\n\n  const onRest = (e) => {\n    const { nativeEvent } = e;\n    if (nativeEvent) return;\n    unhighlighted(false);\n  };\n\n  const onHighlight = (e) => {\n    const { nativeEvent } = e;\n    if (nativeEvent) return;\n    const { data } = e.data;\n    const element = selectElementByData(elements, data, datum);\n    if (!element) return;\n    pointerover({ target: element, nativeEvent: false });\n  };\n\n  emitter.on('element:highlight', onHighlight);\n  emitter.on('element:unhighlight', onRest);\n\n  return () => {\n    root.removeEventListener('pointerover', pointerover);\n    root.removeEventListener('pointermove', pointerover);\n    root.removeEventListener('pointerout', pointerout);\n    root.removeEventListener('pointerleave', pointerleave);\n    emitter.off('element:highlight', onHighlight);\n    emitter.off('element:unhighlight', onRest);\n    for (const e of elements) {\n      removeBackground(e);\n      removeLink(e);\n    }\n  };\n}\n\nexport function ElementHighlight({\n  delay,\n  createGroup,\n  createRegionGroup,\n  background = false,\n  link = false,\n  ...rest\n}) {\n  return (context, _, emitter) => {\n    const { container, view, options } = context;\n    const { scale, coordinate } = view;\n    const plotArea = selectPlotArea(container);\n\n    return elementHighlight(plotArea, {\n      elements: selectG2Elements,\n      datum: createDatumof(view),\n      groupKey: createGroup ? createGroup(view) : undefined,\n      regionGroupKey: createRegionGroup\n        ? createRegionGroup(view)\n        : createXKey(view),\n      coordinate,\n      scale,\n      state: mergeState(options, [\n        ['active', background ? {} : { lineWidth: '1', stroke: '#000' }],\n        'inactive',\n      ]),\n      background,\n      link,\n      delay,\n      emitter,\n      ...rest,\n    });\n  };\n}\n\nElementHighlight.props = {\n  reapplyWhenUpdate: true,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}