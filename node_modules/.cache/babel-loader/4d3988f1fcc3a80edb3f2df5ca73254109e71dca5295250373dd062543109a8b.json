{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { AABB } from '@antv/g';\nimport { isFunction } from '@antv/util';\nimport { getBBoxHeight, getBBoxWidth, getCombinedBBox, getExpandedBBox } from '../../utils/bbox';\nimport { idOf } from '../../utils/id';\nimport { parsePadding } from '../../utils/padding';\nimport { getXYByPlacement, hasPosition, positionOf } from '../../utils/position';\nimport { subStyleProps } from '../../utils/prefix';\nimport { parseSize } from '../../utils/size';\nimport { mergeOptions } from '../../utils/style';\nimport { add, divide } from '../../utils/vector';\nimport { BaseNode } from '../nodes';\nimport { Icon } from '../shapes';\nimport { connectImage, dispatchPositionChange } from '../shapes/image';\n/**\n * <zh/> 组合元素的基类\n *\n * <en/> Base class of combo\n * @remarks\n * <zh/> 自定义组合时，推荐使用这个类作为基类。这样，用户只需要专注于实现 keyShape 的绘制逻辑\n *\n * <en/> When customizing a combo, it is recommended to use this class as the base class. In this way, users only need to focus on the logic of drawing keyShape\n */\nexport class BaseCombo extends BaseNode {\n  constructor(options) {\n    super(mergeOptions({\n      style: BaseCombo.defaultStyleProps\n    }, options));\n    this.type = 'combo';\n    this.updateComboPosition(this.parsedAttributes);\n  }\n  getKeySize(attributes) {\n    const {\n      collapsed,\n      childrenNode = []\n    } = attributes;\n    if (childrenNode.length === 0) return this.getEmptyKeySize(attributes);\n    return collapsed ? this.getCollapsedKeySize(attributes) : this.getExpandedKeySize(attributes);\n  }\n  getEmptyKeySize(attributes) {\n    const {\n      padding,\n      collapsedSize\n    } = attributes;\n    const [top, right, bottom, left] = parsePadding(padding);\n    return add(parseSize(collapsedSize), [left + right, top + bottom, 0]);\n  }\n  getCollapsedKeySize(attributes) {\n    return parseSize(attributes.collapsedSize);\n  }\n  getExpandedKeySize(attributes) {\n    const contentBBox = this.getContentBBox(attributes);\n    return [getBBoxWidth(contentBBox), getBBoxHeight(contentBBox), 0];\n  }\n  getContentBBox(attributes) {\n    const {\n      childrenNode = [],\n      padding\n    } = attributes;\n    const children = childrenNode.map(id => this.context.element.getElement(id)).filter(Boolean);\n    if (children.length === 0) {\n      const bbox = new AABB();\n      const {\n        x = 0,\n        y = 0,\n        size\n      } = attributes;\n      const [width, height] = parseSize(size);\n      bbox.setMinMax([x - width / 2, y - height / 2, 0], [x + width / 2, y + height / 2, 0]);\n      return bbox;\n    }\n    const childrenBBox = getCombinedBBox(children.map(child => child.getBounds()));\n    if (!padding) return childrenBBox;\n    return getExpandedBBox(childrenBBox, padding);\n  }\n  drawCollapsedMarkerShape(attributes, container) {\n    const style = this.getCollapsedMarkerStyle(attributes);\n    this.upsert('collapsed-marker', Icon, style, container);\n    connectImage(this);\n  }\n  getCollapsedMarkerStyle(attributes) {\n    if (!attributes.collapsed || !attributes.collapsedMarker) return false;\n    const _a = subStyleProps(this.getGraphicStyle(attributes), 'collapsedMarker'),\n      {\n        type\n      } = _a,\n      collapsedMarkerStyle = __rest(_a, [\"type\"]);\n    const keyShape = this.getShape('key');\n    const [x, y] = getXYByPlacement(keyShape.getLocalBounds(), 'center');\n    const style = Object.assign(Object.assign({}, collapsedMarkerStyle), {\n      x,\n      y\n    });\n    if (type) {\n      const text = this.getCollapsedMarkerText(type, attributes);\n      Object.assign(style, {\n        text\n      });\n    }\n    return style;\n  }\n  getCollapsedMarkerText(type, attributes) {\n    const {\n      childrenData = []\n    } = attributes;\n    const {\n      model\n    } = this.context;\n    if (type === 'descendant-count') return model.getDescendantsData(this.id).length.toString();\n    if (type === 'child-count') return childrenData.length.toString();\n    if (type === 'node-count') return model.getDescendantsData(this.id).filter(datum => model.getElementType(idOf(datum)) === 'node').length.toString();\n    if (isFunction(type)) return type(childrenData);\n    return '';\n  }\n  getComboPosition(attributes) {\n    const {\n      x = 0,\n      y = 0,\n      collapsed,\n      childrenData = []\n    } = attributes;\n    if (childrenData.length === 0) return [+x, +y, 0];\n    if (collapsed) {\n      const {\n        model\n      } = this.context;\n      const descendants = model.getDescendantsData(this.id).filter(datum => !model.isCombo(idOf(datum)));\n      if (descendants.length > 0 && descendants.some(hasPosition)) {\n        // combo 被收起，返回平均中心位置 / combo is collapsed, return the average center position\n        const totalPosition = descendants.reduce((acc, datum) => add(acc, positionOf(datum)), [0, 0, 0]);\n        return divide(totalPosition, descendants.length);\n      }\n      // empty combo\n      return [+x, +y, 0];\n    }\n    return this.getContentBBox(attributes).center;\n  }\n  getComboStyle(attributes) {\n    const [x, y] = this.getComboPosition(attributes);\n    // x/y will be used to calculate position later.\n    return {\n      x,\n      y,\n      transform: [['translate', x, y]]\n    };\n  }\n  updateComboPosition(attributes) {\n    const comboStyle = this.getComboStyle(attributes);\n    Object.assign(this.style, comboStyle);\n    // Sync combo position to model\n    const {\n      x,\n      y\n    } = comboStyle;\n    this.context.model.syncNodeLikeDatum({\n      id: this.id,\n      style: {\n        x,\n        y\n      }\n    });\n    dispatchPositionChange(this);\n  }\n  render(attributes, container = this) {\n    super.render(attributes, container);\n    // collapsed marker\n    this.drawCollapsedMarkerShape(attributes, container);\n  }\n  update(attr = {}) {\n    super.update(attr);\n    this.updateComboPosition(this.parsedAttributes);\n  }\n  onframe() {\n    super.onframe();\n    // 收起状态下，通过动画来更新位置\n    // Update position through animation in collapsed state\n    if (!this.attributes.collapsed) this.updateComboPosition(this.parsedAttributes);\n    this.drawKeyShape(this.parsedAttributes, this);\n  }\n  animate(keyframes, options) {\n    const animation = super.animate(this.attributes.collapsed ? keyframes :\n    // 如果当前 combo 是展开状态，则动画不受 x, y, z, transform 影响，仅由子元素决定位置\n    // If the current combo is in the expanded state, the animation is not affected by x, y, z, transform, and the position is determined only by the child elements\n    keyframes.map(_a => {\n      var {\n          x,\n          y,\n          z,\n          transform\n        } = _a,\n        keyframe = __rest(_a, [\"x\", \"y\", \"z\", \"transform\"]);\n      return keyframe;\n    }), options);\n    if (!animation) return animation;\n    return new Proxy(animation, {\n      set: (target, propKey, value) => {\n        if (propKey === 'currentTime') Promise.resolve().then(() => this.onframe());\n        return Reflect.set(target, propKey, value);\n      }\n    });\n  }\n}\nBaseCombo.defaultStyleProps = {\n  childrenNode: [],\n  droppable: true,\n  draggable: true,\n  collapsed: false,\n  collapsedSize: 32,\n  collapsedMarker: true,\n  collapsedMarkerZIndex: 1,\n  collapsedMarkerFontSize: 12,\n  collapsedMarkerTextAlign: 'center',\n  collapsedMarkerTextBaseline: 'middle',\n  collapsedMarkerType: 'child-count'\n};","map":{"version":3,"names":["AABB","isFunction","getBBoxHeight","getBBoxWidth","getCombinedBBox","getExpandedBBox","idOf","parsePadding","getXYByPlacement","hasPosition","positionOf","subStyleProps","parseSize","mergeOptions","add","divide","BaseNode","Icon","connectImage","dispatchPositionChange","BaseCombo","constructor","options","style","defaultStyleProps","type","updateComboPosition","parsedAttributes","getKeySize","attributes","collapsed","childrenNode","length","getEmptyKeySize","getCollapsedKeySize","getExpandedKeySize","padding","collapsedSize","top","right","bottom","left","contentBBox","getContentBBox","children","map","id","context","element","getElement","filter","Boolean","bbox","x","y","size","width","height","setMinMax","childrenBBox","child","getBounds","drawCollapsedMarkerShape","container","getCollapsedMarkerStyle","upsert","collapsedMarker","_a","getGraphicStyle","collapsedMarkerStyle","__rest","keyShape","getShape","getLocalBounds","Object","assign","text","getCollapsedMarkerText","childrenData","model","getDescendantsData","toString","datum","getElementType","getComboPosition","descendants","isCombo","some","totalPosition","reduce","acc","center","getComboStyle","transform","comboStyle","syncNodeLikeDatum","render","update","attr","onframe","drawKeyShape","animate","keyframes","animation","z","keyframe","Proxy","set","target","propKey","value","Promise","resolve","then","Reflect","droppable","draggable","collapsedMarkerZIndex","collapsedMarkerFontSize","collapsedMarkerTextAlign","collapsedMarkerTextBaseline","collapsedMarkerType"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/elements/combos/base-combo.ts"],"sourcesContent":["import { AABB, BaseStyleProps, DisplayObject, DisplayObjectConfig, Group } from '@antv/g';\nimport { isFunction } from '@antv/util';\nimport type {\n  CollapsedMarkerStyleProps,\n  Combo,\n  ID,\n  NodeLikeData,\n  Padding,\n  Point,\n  Prefix,\n  STDSize,\n  Size,\n} from '../../types';\nimport { getBBoxHeight, getBBoxWidth, getCombinedBBox, getExpandedBBox } from '../../utils/bbox';\nimport { idOf } from '../../utils/id';\nimport { parsePadding } from '../../utils/padding';\nimport { getXYByPlacement, hasPosition, positionOf } from '../../utils/position';\nimport { subStyleProps } from '../../utils/prefix';\nimport { parseSize } from '../../utils/size';\nimport { mergeOptions } from '../../utils/style';\nimport { add, divide } from '../../utils/vector';\nimport type { BaseNodeStyleProps } from '../nodes';\nimport { BaseNode } from '../nodes';\nimport { Icon, IconStyleProps } from '../shapes';\nimport { connectImage, dispatchPositionChange } from '../shapes/image';\n\n/**\n * <zh/> 组合通用样式配置项\n *\n * <en/> Common style props for combo\n */\nexport interface BaseComboStyleProps\n  extends BaseNodeStyleProps,\n    Prefix<'collapsed', BaseStyleProps>,\n    Prefix<'collapsedMarker', CollapsedMarkerStyleProps> {\n  /**\n   * <zh/> 组合展开后的默认大小\n   *\n   * <en/> The default size of combo when expanded\n   */\n  size?: Size;\n  /**\n   * <zh/> 组合收起后的默认大小\n   *\n   * <en/> The default size of combo when collapsed\n   */\n  collapsedSize?: Size;\n  /**\n   * <zh/> 组合的子元素，可以是节点或者组合\n   *\n   * <en/> The children of combo, which can be nodes or combos\n   */\n  childrenNode?: ID[];\n  /**\n   * <zh/> 组合的子元素数据\n   *\n   * <en/> The data of the children of combo\n   * @remarks\n   * <zh/> 如果组合是收起状态，children 可能为空，通过 childrenData 能够获取完整的子元素数据\n   *\n   * <en/> If the combo is collapsed, children may be empty, and the complete child element data can be obtained through childrenData\n   */\n  childrenData?: NodeLikeData[];\n  /**\n   * <zh/> 组合的内边距，只在展开状态下生效\n   *\n   * <en/> The padding of combo, only effective when expanded\n   */\n  padding?: Padding;\n  /**\n   * <zh/> 组合收起时是否显示标记\n   *\n   * <en/> Whether to show the marker when the combo is collapsed\n   */\n  collapsedMarker?: boolean;\n}\n\n/**\n * <zh/> 组合元素的基类\n *\n * <en/> Base class of combo\n * @remarks\n * <zh/> 自定义组合时，推荐使用这个类作为基类。这样，用户只需要专注于实现 keyShape 的绘制逻辑\n *\n * <en/> When customizing a combo, it is recommended to use this class as the base class. In this way, users only need to focus on the logic of drawing keyShape\n */\nexport abstract class BaseCombo<S extends BaseComboStyleProps = BaseComboStyleProps>\n  extends BaseNode<S>\n  implements Combo\n{\n  public type = 'combo';\n\n  static defaultStyleProps: Partial<BaseComboStyleProps> = {\n    childrenNode: [],\n    droppable: true,\n    draggable: true,\n    collapsed: false,\n    collapsedSize: 32,\n    collapsedMarker: true,\n    collapsedMarkerZIndex: 1,\n    collapsedMarkerFontSize: 12,\n    collapsedMarkerTextAlign: 'center',\n    collapsedMarkerTextBaseline: 'middle',\n    collapsedMarkerType: 'child-count',\n  };\n  constructor(options: DisplayObjectConfig<BaseComboStyleProps>) {\n    super(mergeOptions({ style: BaseCombo.defaultStyleProps }, options));\n    this.updateComboPosition(this.parsedAttributes);\n  }\n\n  /**\n   * Draw the key shape of combo\n   */\n  protected abstract drawKeyShape(attributes: Required<S>, container: Group): DisplayObject | undefined;\n\n  protected getKeySize(attributes: Required<S>): STDSize {\n    const { collapsed, childrenNode = [] } = attributes;\n    if (childrenNode.length === 0) return this.getEmptyKeySize(attributes);\n    return collapsed ? this.getCollapsedKeySize(attributes) : this.getExpandedKeySize(attributes);\n  }\n\n  protected getEmptyKeySize(attributes: Required<S>): STDSize {\n    const { padding, collapsedSize } = attributes;\n    const [top, right, bottom, left] = parsePadding(padding);\n    return add(parseSize(collapsedSize), [left + right, top + bottom, 0]) as STDSize;\n  }\n\n  protected getCollapsedKeySize(attributes: Required<S>): STDSize {\n    return parseSize(attributes.collapsedSize);\n  }\n\n  protected getExpandedKeySize(attributes: Required<S>): STDSize {\n    const contentBBox = this.getContentBBox(attributes);\n    return [getBBoxWidth(contentBBox), getBBoxHeight(contentBBox), 0];\n  }\n\n  protected getContentBBox(attributes: Required<S>): AABB {\n    const { childrenNode = [], padding } = attributes;\n    const children = childrenNode.map((id) => this.context!.element!.getElement(id)).filter(Boolean);\n    if (children.length === 0) {\n      const bbox = new AABB();\n      const { x = 0, y = 0, size } = attributes;\n      const [width, height] = parseSize(size);\n      bbox.setMinMax([x - width / 2, y - height / 2, 0], [x + width / 2, y + height / 2, 0]);\n      return bbox;\n    }\n\n    const childrenBBox = getCombinedBBox(children.map((child) => child!.getBounds()));\n\n    if (!padding) return childrenBBox;\n\n    return getExpandedBBox(childrenBBox, padding);\n  }\n\n  protected drawCollapsedMarkerShape(attributes: Required<S>, container: Group): void {\n    const style = this.getCollapsedMarkerStyle(attributes);\n    this.upsert('collapsed-marker', Icon, style, container);\n    connectImage(this);\n  }\n\n  protected getCollapsedMarkerStyle(attributes: Required<S>): IconStyleProps | false {\n    if (!attributes.collapsed || !attributes.collapsedMarker) return false;\n\n    const { type, ...collapsedMarkerStyle } = subStyleProps<CollapsedMarkerStyleProps>(\n      this.getGraphicStyle(attributes),\n      'collapsedMarker',\n    );\n    const keyShape = this.getShape('key');\n    const [x, y] = getXYByPlacement(keyShape.getLocalBounds(), 'center');\n\n    const style = { ...collapsedMarkerStyle, x, y };\n\n    if (type) {\n      const text = this.getCollapsedMarkerText(type, attributes);\n      Object.assign(style, { text });\n    }\n\n    return style;\n  }\n\n  protected getCollapsedMarkerText(type: CollapsedMarkerStyleProps['type'], attributes: Required<S>): string {\n    const { childrenData = [] } = attributes;\n    const { model } = this.context;\n\n    if (type === 'descendant-count') return model.getDescendantsData(this.id).length.toString();\n    if (type === 'child-count') return childrenData.length.toString();\n    if (type === 'node-count')\n      return model\n        .getDescendantsData(this.id)\n        .filter((datum) => model.getElementType(idOf(datum)) === 'node')\n        .length.toString();\n    if (isFunction(type)) return type(childrenData);\n    return '';\n  }\n\n  public getComboPosition(attributes: Required<S>): Point {\n    const { x = 0, y = 0, collapsed, childrenData = [] } = attributes;\n\n    if (childrenData.length === 0) return [+x, +y, 0];\n\n    if (collapsed) {\n      const { model } = this.context;\n      const descendants = model.getDescendantsData(this.id).filter((datum) => !model.isCombo(idOf(datum)));\n\n      if (descendants.length > 0 && descendants.some(hasPosition)) {\n        // combo 被收起，返回平均中心位置 / combo is collapsed, return the average center position\n        const totalPosition = descendants.reduce((acc, datum) => add(acc, positionOf(datum)), [0, 0, 0] as Point);\n        return divide(totalPosition, descendants.length);\n      }\n      // empty combo\n      return [+x, +y, 0];\n    }\n\n    return this.getContentBBox(attributes).center;\n  }\n\n  protected getComboStyle(attributes: Required<S>) {\n    const [x, y] = this.getComboPosition(attributes);\n    // x/y will be used to calculate position later.\n    return { x, y, transform: [['translate', x, y]] };\n  }\n\n  protected updateComboPosition(attributes: Required<S>) {\n    const comboStyle = this.getComboStyle(attributes);\n    Object.assign(this.style, comboStyle);\n    // Sync combo position to model\n    const { x, y } = comboStyle;\n    this.context.model.syncNodeLikeDatum({ id: this.id, style: { x, y } });\n    dispatchPositionChange(this);\n  }\n\n  public render(attributes: Required<S>, container: Group = this) {\n    super.render(attributes, container);\n\n    // collapsed marker\n    this.drawCollapsedMarkerShape(attributes, container);\n  }\n\n  public update(attr: Partial<S> = {}): void {\n    super.update(attr);\n    this.updateComboPosition(this.parsedAttributes);\n  }\n\n  protected onframe() {\n    super.onframe();\n    // 收起状态下，通过动画来更新位置\n    // Update position through animation in collapsed state\n    if (!this.attributes.collapsed) this.updateComboPosition(this.parsedAttributes);\n    this.drawKeyShape(this.parsedAttributes, this);\n  }\n\n  public animate(keyframes: Keyframe[], options?: number | KeyframeAnimationOptions) {\n    const animation = super.animate(\n      this.attributes.collapsed\n        ? keyframes\n        : // 如果当前 combo 是展开状态，则动画不受 x, y, z, transform 影响，仅由子元素决定位置\n          // If the current combo is in the expanded state, the animation is not affected by x, y, z, transform, and the position is determined only by the child elements\n          keyframes.map(({ x, y, z, transform, ...keyframe }: any) => keyframe),\n      options,\n    );\n\n    if (!animation) return animation;\n\n    return new Proxy(animation, {\n      set: (target, propKey, value) => {\n        if (propKey === 'currentTime') Promise.resolve().then(() => this.onframe());\n        return Reflect.set(target, propKey, value);\n      },\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}