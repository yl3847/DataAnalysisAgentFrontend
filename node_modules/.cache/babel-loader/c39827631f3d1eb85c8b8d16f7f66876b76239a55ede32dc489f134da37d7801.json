{"ast":null,"code":"import { getNeighbors } from \"./util\";\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nexport var detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = getNeighbors(node.id, edges);\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n      allComponents.push(component);\n    }\n  }\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\nexport var detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true;\n    // 考虑每个邻接点\n    var neighbors = getNeighbors(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n        // tree edge\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    }\n    // If node is a root node, generate an SCC\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n  return allComponents;\n};\nexport default function getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}","map":{"version":3,"names":["getNeighbors","detectConnectedComponents","graphData","_a","nodes","_b","edges","allComponents","visited","nodeStack","getComponent","node","push","id","neighbors","_loop_1","i","neighbor","targetNode","filter","length","component","pop","detectStrongConnectComponents","inStack","indices","lowLink","index","n","map","indexOf","_loop_2","targetNodeID","Math","min","tmpNode","_i","nodes_1","getConnectedComponents","directed"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/algorithm/es/connected-component.js"],"sourcesContent":["import { getNeighbors } from \"./util\";\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nexport var detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = getNeighbors(node.id, edges);\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n      allComponents.push(component);\n    }\n  }\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\nexport var detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true;\n    // 考虑每个邻接点\n    var neighbors = getNeighbors(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n        // tree edge\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    }\n    // If node is a root node, generate an SCC\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n  return allComponents;\n};\nexport default function getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}"],"mappings":"AAAA,SAASA,YAAY,QAAQ,QAAQ;AACrC;AACA;AACA;AACA;AACA,OAAO,IAAIC,yBAAyB,GAAG,SAASA,yBAAyBA,CAACC,SAAS,EAAE;EACnF,IAAIC,EAAE,GAAGD,SAAS,CAACE,KAAK;IACtBA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;IAC/BE,EAAE,GAAGH,SAAS,CAACI,KAAK;IACpBA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;EACjC,IAAIE,aAAa,GAAG,EAAE;EACtB,IAAIC,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIC,SAAS,GAAG,EAAE;EAClB,IAAIC,YAAY,GAAG,SAASA,YAAYA,CAACC,IAAI,EAAE;IAC7CF,SAAS,CAACG,IAAI,CAACD,IAAI,CAAC;IACpBH,OAAO,CAACG,IAAI,CAACE,EAAE,CAAC,GAAG,IAAI;IACvB,IAAIC,SAAS,GAAGd,YAAY,CAACW,IAAI,CAACE,EAAE,EAAEP,KAAK,CAAC;IAC5C,IAAIS,OAAO,GAAG,SAASA,OAAOA,CAACC,CAAC,EAAE;MAChC,IAAIC,QAAQ,GAAGH,SAAS,CAACE,CAAC,CAAC;MAC3B,IAAI,CAACR,OAAO,CAACS,QAAQ,CAAC,EAAE;QACtB,IAAIC,UAAU,GAAGd,KAAK,CAACe,MAAM,CAAC,UAAUR,IAAI,EAAE;UAC5C,OAAOA,IAAI,CAACE,EAAE,KAAKI,QAAQ;QAC7B,CAAC,CAAC;QACF,IAAIC,UAAU,CAACE,MAAM,GAAG,CAAC,EAAE;UACzBV,YAAY,CAACQ,UAAU,CAAC,CAAC,CAAC,CAAC;QAC7B;MACF;IACF,CAAC;IACD,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACM,MAAM,EAAE,EAAEJ,CAAC,EAAE;MACzCD,OAAO,CAACC,CAAC,CAAC;IACZ;EACF,CAAC;EACD,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,KAAK,CAACgB,MAAM,EAAEJ,CAAC,EAAE,EAAE;IACrC,IAAIL,IAAI,GAAGP,KAAK,CAACY,CAAC,CAAC;IACnB,IAAI,CAACR,OAAO,CAACG,IAAI,CAACE,EAAE,CAAC,EAAE;MACrB;MACAH,YAAY,CAACC,IAAI,CAAC;MAClB,IAAIU,SAAS,GAAG,EAAE;MAClB,OAAOZ,SAAS,CAACW,MAAM,GAAG,CAAC,EAAE;QAC3BC,SAAS,CAACT,IAAI,CAACH,SAAS,CAACa,GAAG,CAAC,CAAC,CAAC;MACjC;MACAf,aAAa,CAACK,IAAI,CAACS,SAAS,CAAC;IAC/B;EACF;EACA,OAAOd,aAAa;AACtB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIgB,6BAA6B,GAAG,SAASA,6BAA6BA,CAACrB,SAAS,EAAE;EAC3F,IAAIC,EAAE,GAAGD,SAAS,CAACE,KAAK;IACtBA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;IAC/BE,EAAE,GAAGH,SAAS,CAACI,KAAK;IACpBA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;EACjC,IAAII,SAAS,GAAG,EAAE;EAClB,IAAIe,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;EAClB,IAAIC,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIC,OAAO,GAAG,CAAC,CAAC;EAChB,IAAInB,aAAa,GAAG,EAAE;EACtB,IAAIoB,KAAK,GAAG,CAAC;EACb,IAAIjB,YAAY,GAAG,SAASA,YAAYA,CAACC,IAAI,EAAE;IAC7C;IACAc,OAAO,CAACd,IAAI,CAACE,EAAE,CAAC,GAAGc,KAAK;IACxBD,OAAO,CAACf,IAAI,CAACE,EAAE,CAAC,GAAGc,KAAK;IACxBA,KAAK,IAAI,CAAC;IACVlB,SAAS,CAACG,IAAI,CAACD,IAAI,CAAC;IACpBa,OAAO,CAACb,IAAI,CAACE,EAAE,CAAC,GAAG,IAAI;IACvB;IACA,IAAIC,SAAS,GAAGd,YAAY,CAACW,IAAI,CAACE,EAAE,EAAEP,KAAK,EAAE,QAAQ,CAAC,CAACa,MAAM,CAAC,UAAUS,CAAC,EAAE;MACzE,OAAOxB,KAAK,CAACyB,GAAG,CAAC,UAAUlB,IAAI,EAAE;QAC/B,OAAOA,IAAI,CAACE,EAAE;MAChB,CAAC,CAAC,CAACiB,OAAO,CAACF,CAAC,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC,CAAC;IACF,IAAIG,OAAO,GAAG,SAASA,OAAOA,CAACf,CAAC,EAAE;MAChC,IAAIgB,YAAY,GAAGlB,SAAS,CAACE,CAAC,CAAC;MAC/B,IAAI,CAACS,OAAO,CAACO,YAAY,CAAC,IAAIP,OAAO,CAACO,YAAY,CAAC,KAAK,CAAC,EAAE;QACzD,IAAId,UAAU,GAAGd,KAAK,CAACe,MAAM,CAAC,UAAUR,IAAI,EAAE;UAC5C,OAAOA,IAAI,CAACE,EAAE,KAAKmB,YAAY;QACjC,CAAC,CAAC;QACF,IAAId,UAAU,CAACE,MAAM,GAAG,CAAC,EAAE;UACzBV,YAAY,CAACQ,UAAU,CAAC,CAAC,CAAC,CAAC;QAC7B;QACA;QACAQ,OAAO,CAACf,IAAI,CAACE,EAAE,CAAC,GAAGoB,IAAI,CAACC,GAAG,CAACR,OAAO,CAACf,IAAI,CAACE,EAAE,CAAC,EAAEa,OAAO,CAACM,YAAY,CAAC,CAAC;MACtE,CAAC,MAAM,IAAIR,OAAO,CAACQ,YAAY,CAAC,EAAE;QAChC;QACAN,OAAO,CAACf,IAAI,CAACE,EAAE,CAAC,GAAGoB,IAAI,CAACC,GAAG,CAACR,OAAO,CAACf,IAAI,CAACE,EAAE,CAAC,EAAEY,OAAO,CAACO,YAAY,CAAC,CAAC;MACtE;IACF,CAAC;IACD,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACM,MAAM,EAAEJ,CAAC,EAAE,EAAE;MACzCe,OAAO,CAACf,CAAC,CAAC;IACZ;IACA;IACA,IAAIU,OAAO,CAACf,IAAI,CAACE,EAAE,CAAC,KAAKY,OAAO,CAACd,IAAI,CAACE,EAAE,CAAC,EAAE;MACzC,IAAIQ,SAAS,GAAG,EAAE;MAClB,OAAOZ,SAAS,CAACW,MAAM,GAAG,CAAC,EAAE;QAC3B,IAAIe,OAAO,GAAG1B,SAAS,CAACa,GAAG,CAAC,CAAC;QAC7BE,OAAO,CAACW,OAAO,CAACtB,EAAE,CAAC,GAAG,KAAK;QAC3BQ,SAAS,CAACT,IAAI,CAACuB,OAAO,CAAC;QACvB,IAAIA,OAAO,KAAKxB,IAAI,EAAE;MACxB;MACA,IAAIU,SAAS,CAACD,MAAM,GAAG,CAAC,EAAE;QACxBb,aAAa,CAACK,IAAI,CAACS,SAAS,CAAC;MAC/B;IACF;EACF,CAAC;EACD,KAAK,IAAIe,EAAE,GAAG,CAAC,EAAEC,OAAO,GAAGjC,KAAK,EAAEgC,EAAE,GAAGC,OAAO,CAACjB,MAAM,EAAEgB,EAAE,EAAE,EAAE;IAC3D,IAAIzB,IAAI,GAAG0B,OAAO,CAACD,EAAE,CAAC;IACtB,IAAI,CAACX,OAAO,CAACd,IAAI,CAACE,EAAE,CAAC,IAAIY,OAAO,CAACd,IAAI,CAACE,EAAE,CAAC,KAAK,CAAC,EAAE;MAC/CH,YAAY,CAACC,IAAI,CAAC;IACpB;EACF;EACA,OAAOJ,aAAa;AACtB,CAAC;AACD,eAAe,SAAS+B,sBAAsBA,CAACpC,SAAS,EAAEqC,QAAQ,EAAE;EAClE,IAAIA,QAAQ,EAAE,OAAOhB,6BAA6B,CAACrB,SAAS,CAAC;EAC7D,OAAOD,yBAAyB,CAACC,SAAS,CAAC;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}