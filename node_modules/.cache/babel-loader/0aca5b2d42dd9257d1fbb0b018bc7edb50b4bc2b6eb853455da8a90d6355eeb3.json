{"ast":null,"code":"import { lru } from '../../../utils/lru';\nimport { parseGradient } from './gradient';\nfunction newCanvas(createCanvas, width, height) {\n  const c = createCanvas ? createCanvas() : document.createElement('canvas');\n  c.width = width;\n  c.height = height;\n  return c;\n}\n/**\n * Get a point with template.\n * @param radius\n * @param blurFactor\n * @returns\n */\nconst getPointTemplate = lru((radius, blurFactor, createCanvas) => {\n  const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);\n  const tplCtx = tplCanvas.getContext('2d');\n  const x = radius;\n  const y = radius;\n  if (blurFactor === 1) {\n    tplCtx.beginPath();\n    tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);\n    tplCtx.fillStyle = 'rgba(0,0,0,1)';\n    tplCtx.fill();\n  } else {\n    const gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);\n    gradient.addColorStop(0, 'rgba(0,0,0,1)');\n    gradient.addColorStop(1, 'rgba(0,0,0,0)');\n    tplCtx.fillStyle = gradient;\n    tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);\n  }\n  return tplCanvas;\n}, radius => `${radius}`);\n/**\n * Get a color palette with len = 256 base on gradient.\n * @param gradientConfig\n * @returns\n */\nfunction getColorPalette(gradientConfig, createCanvas) {\n  const paletteCanvas = newCanvas(createCanvas, 256, 1);\n  const paletteCtx = paletteCanvas.getContext('2d');\n  const gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\n  parseGradient(gradientConfig).forEach(([r, c]) => {\n    gradient.addColorStop(r, c);\n  });\n  paletteCtx.fillStyle = gradient;\n  paletteCtx.fillRect(0, 0, 256, 1);\n  return paletteCtx.getImageData(0, 0, 256, 1).data;\n}\n/**\n * Draw all circle with alpha.\n */\nfunction drawAlpha(shadowCtx, min, max, data, options, createCanvas) {\n  const {\n    blur\n  } = options;\n  let len = data.length;\n  while (len--) {\n    const {\n      x,\n      y,\n      value: v,\n      radius\n    } = data[len];\n    // Ff value is bigger than max, use max as value.\n    const value = Math.min(v, max);\n    const rectX = x - radius;\n    const rectY = y - radius;\n    const tpl = getPointTemplate(radius, 1 - blur, createCanvas);\n    // Value from minimum / value range, => [0, 1].\n    const templateAlpha = (value - min) / (max - min);\n    // Small values are not visible because globalAlpha < .001 cannot be read from imageData.\n    shadowCtx.globalAlpha = Math.max(templateAlpha, 0.001);\n    shadowCtx.drawImage(tpl, rectX, rectY);\n  }\n  return shadowCtx;\n}\nfunction colorize(shadowCtx, maxWidth, maxHeight, palette, options) {\n  const {\n    minOpacity,\n    opacity,\n    maxOpacity,\n    useGradientOpacity\n  } = options;\n  const x = 0;\n  const y = 0;\n  const width = maxWidth;\n  const height = maxHeight;\n  const img = shadowCtx.getImageData(x, y, width, height);\n  const imgData = img.data;\n  const len = imgData.length;\n  for (let i = 3; i < len; i += 4) {\n    const alpha = imgData[i];\n    const offset = alpha * 4;\n    if (!offset) {\n      continue;\n    }\n    // Should be in [min, max], min >= 0.\n    const finalAlpha = opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));\n    // Update rgba.\n    imgData[i - 3] = palette[offset];\n    imgData[i - 2] = palette[offset + 1];\n    imgData[i - 1] = palette[offset + 2];\n    imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;\n  }\n  return img;\n}\n/**\n * Render a heatmap with canvas.\n * See [heatmap.js](https://github.com/pa7/heatmap.js/blob/master/src/renderer/canvas2d.js).\n */\nexport function HeatmapRenderer(width, height, min, max, data, options, createCanvas) {\n  const opts = Object.assign({\n    blur: 0.85,\n    minOpacity: 0,\n    opacity: 0.6,\n    maxOpacity: 1,\n    gradient: [[0.25, 'rgb(0,0,255)'], [0.55, 'rgb(0,255,0)'], [0.85, 'yellow'], [1.0, 'rgb(255,0,0)']]\n  }, options);\n  opts.minOpacity *= 255;\n  opts.opacity *= 255;\n  opts.maxOpacity *= 255;\n  const shadowCanvas = newCanvas(createCanvas, width, height);\n  const shadowCtx = shadowCanvas.getContext('2d');\n  const palette = getColorPalette(opts.gradient, createCanvas);\n  shadowCtx.clearRect(0, 0, width, height);\n  drawAlpha(shadowCtx, min, max, data, opts, createCanvas);\n  const img = colorize(shadowCtx, width, height, palette, opts);\n  const canvas = newCanvas(createCanvas, width, height);\n  const ctx = canvas.getContext('2d');\n  ctx.putImageData(img, 0, 0);\n  return ctx;\n}","map":{"version":3,"names":["lru","parseGradient","newCanvas","createCanvas","width","height","c","document","createElement","getPointTemplate","radius","blurFactor","tplCanvas","tplCtx","getContext","x","y","beginPath","arc","Math","PI","fillStyle","fill","gradient","createRadialGradient","addColorStop","fillRect","getColorPalette","gradientConfig","paletteCanvas","paletteCtx","createLinearGradient","forEach","r","getImageData","data","drawAlpha","shadowCtx","min","max","options","blur","len","length","value","v","rectX","rectY","tpl","templateAlpha","globalAlpha","drawImage","colorize","maxWidth","maxHeight","palette","minOpacity","opacity","maxOpacity","useGradientOpacity","img","imgData","i","alpha","offset","finalAlpha","HeatmapRenderer","opts","Object","assign","shadowCanvas","clearRect","canvas","ctx","putImageData"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/heatmap/renderer/index.ts"],"sourcesContent":["import { lru } from '../../../utils/lru';\nimport { parseGradient } from './gradient';\nimport {\n  HeatmapGradient,\n  HeatmapRendererData,\n  HeatmapRendererOptions,\n} from './types';\n\nfunction newCanvas(\n  createCanvas: () => HTMLCanvasElement,\n  width: number,\n  height: number,\n) {\n  const c = createCanvas ? createCanvas() : document.createElement('canvas');\n  c.width = width;\n  c.height = height;\n  return c;\n}\n\n/**\n * Get a point with template.\n * @param radius\n * @param blurFactor\n * @returns\n */\nconst getPointTemplate = lru(\n  (\n    radius: number,\n    blurFactor: number,\n    createCanvas?: () => HTMLCanvasElement,\n  ) => {\n    const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);\n    const tplCtx = tplCanvas.getContext('2d');\n    const x = radius;\n    const y = radius;\n\n    if (blurFactor === 1) {\n      tplCtx.beginPath();\n      tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);\n      tplCtx.fillStyle = 'rgba(0,0,0,1)';\n      tplCtx.fill();\n    } else {\n      const gradient = tplCtx.createRadialGradient(\n        x,\n        y,\n        radius * blurFactor,\n        x,\n        y,\n        radius,\n      );\n      gradient.addColorStop(0, 'rgba(0,0,0,1)');\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      tplCtx.fillStyle = gradient;\n      tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);\n    }\n    return tplCanvas;\n  },\n  (radius) => `${radius}`,\n);\n\n/**\n * Get a color palette with len = 256 base on gradient.\n * @param gradientConfig\n * @returns\n */\nfunction getColorPalette(gradientConfig: HeatmapGradient, createCanvas) {\n  const paletteCanvas = newCanvas(createCanvas, 256, 1);\n  const paletteCtx = paletteCanvas.getContext('2d');\n\n  const gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\n  parseGradient(gradientConfig).forEach(([r, c]) => {\n    gradient.addColorStop(r, c);\n  });\n\n  paletteCtx.fillStyle = gradient;\n  paletteCtx.fillRect(0, 0, 256, 1);\n\n  return paletteCtx.getImageData(0, 0, 256, 1).data;\n}\n\n/**\n * Draw all circle with alpha.\n */\nfunction drawAlpha(\n  shadowCtx,\n  min: number,\n  max: number,\n  data: HeatmapRendererData[],\n  options: HeatmapRendererOptions,\n  createCanvas?: () => HTMLCanvasElement,\n) {\n  const { blur } = options;\n  let len = data.length;\n  while (len--) {\n    const { x, y, value: v, radius } = data[len];\n    // Ff value is bigger than max, use max as value.\n    const value = Math.min(v, max);\n    const rectX = x - radius;\n    const rectY = y - radius;\n\n    const tpl = getPointTemplate(radius, 1 - blur, createCanvas);\n    // Value from minimum / value range, => [0, 1].\n    const templateAlpha = (value - min) / (max - min);\n    // Small values are not visible because globalAlpha < .001 cannot be read from imageData.\n    shadowCtx.globalAlpha = Math.max(templateAlpha, 0.001);\n    shadowCtx.drawImage(tpl, rectX, rectY);\n  }\n  return shadowCtx;\n}\n\nfunction colorize(\n  shadowCtx,\n  maxWidth: number,\n  maxHeight: number,\n  palette,\n  options: HeatmapRendererOptions,\n) {\n  const { minOpacity, opacity, maxOpacity, useGradientOpacity } = options;\n  const x = 0;\n  const y = 0;\n  const width = maxWidth;\n  const height = maxHeight;\n\n  const img = shadowCtx.getImageData(x, y, width, height);\n  const imgData = img.data;\n  const len = imgData.length;\n\n  for (let i = 3; i < len; i += 4) {\n    const alpha = imgData[i];\n    const offset = alpha * 4;\n\n    if (!offset) {\n      continue;\n    }\n\n    // Should be in [min, max], min >= 0.\n    const finalAlpha =\n      opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));\n    // Update rgba.\n    imgData[i - 3] = palette[offset];\n    imgData[i - 2] = palette[offset + 1];\n    imgData[i - 1] = palette[offset + 2];\n    imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;\n  }\n\n  return img;\n}\n\n/**\n * Render a heatmap with canvas.\n * See [heatmap.js](https://github.com/pa7/heatmap.js/blob/master/src/renderer/canvas2d.js).\n */\nexport function HeatmapRenderer(\n  width: number,\n  height: number,\n  min: number,\n  max: number,\n  data: HeatmapRendererData[],\n  options: HeatmapRendererOptions,\n  createCanvas: () => HTMLCanvasElement,\n) {\n  const opts: HeatmapRendererOptions = {\n    blur: 0.85,\n    minOpacity: 0,\n    opacity: 0.6,\n    maxOpacity: 1,\n    gradient: [\n      [0.25, 'rgb(0,0,255)'],\n      [0.55, 'rgb(0,255,0)'],\n      [0.85, 'yellow'],\n      [1.0, 'rgb(255,0,0)'],\n    ],\n    ...options,\n  };\n  opts.minOpacity *= 255;\n  opts.opacity *= 255;\n  opts.maxOpacity *= 255;\n\n  const shadowCanvas = newCanvas(createCanvas, width, height);\n  const shadowCtx = shadowCanvas.getContext('2d');\n\n  const palette = getColorPalette(opts.gradient, createCanvas);\n\n  shadowCtx.clearRect(0, 0, width, height);\n  drawAlpha(shadowCtx, min, max, data, opts, createCanvas);\n  const img = colorize(shadowCtx, width, height, palette, opts);\n\n  const canvas = newCanvas(createCanvas, width, height);\n  const ctx = canvas.getContext('2d');\n  ctx.putImageData(img, 0, 0);\n\n  return ctx;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}