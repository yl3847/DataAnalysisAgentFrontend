{"ast":null,"code":"const DURATION = 5000;\n/**\n * A function of linear mapping.\n * @param min\n * @param max\n * @param factor\n */\nfunction lerp(min, max, factor) {\n  return min + (max - min) * factor;\n}\n/**\n * Using Bessel curve to simulate sine wave.\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * Whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1).\n *\n * @param x          x position of the left-most point (a).\n * @param stage      0-3, stating which part of the wave it is.\n * @param waveLength wave length of the sine wave.\n * @param amplitude  wave amplitude.\n * @return Sinusoidal segment curve.\n */\nfunction getWaterWavePositions(x, stage, waveLength, amplitude) {\n  if (stage === 0) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];\n  }\n  if (stage === 1) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];\n  }\n  if (stage === 2) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];\n  }\n  return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];\n}\n/**\n * Get wave path.\n * @param radius\n * @param waterLevel      water level\n * @param waveLength      wave length\n * @param phase\n * @param amplitude\n * @param cx              center x\n * @param cy              center y\n * @return path           path\n */\nfunction getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {\n  const curves = Math.ceil(2 * radius / waveLength * 4) * 4;\n  const path = [];\n  let _phase = phase;\n  // Map phase to [-Math.PI * 2, 0].\n  while (_phase < -Math.PI * 2) {\n    _phase += Math.PI * 2;\n  }\n  while (_phase > 0) {\n    _phase -= Math.PI * 2;\n  }\n  _phase = _phase / Math.PI / 2 * waveLength;\n  const left = cx - radius + _phase - radius * 2;\n  /**\n   * Top-left corner as start point.\n   *\n   * Draws this point.\n   *  |\n   * \\|/\n   *  ~~~~~~~~\n   *  |      |\n   *  +------+\n   */\n  path.push(['M', left, waterLevel]);\n  /**\n   * Top wave.\n   *\n   * ~~~~~~~~ <- Draws this sine wave.\n   * |      |\n   * +------+\n   */\n  let waveRight = 0;\n  for (let c = 0; c < curves; ++c) {\n    const stage = c % 4;\n    const pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);\n    path.push(['C', pos[0][0] + left, -pos[0][1] + waterLevel, pos[1][0] + left, -pos[1][1] + waterLevel, pos[2][0] + left, -pos[2][1] + waterLevel]);\n    if (c === curves - 1) {\n      waveRight = pos[2][0];\n    }\n  }\n  /**\n   * Top-right corner.\n   *\n   *                       ~~~~~~~~\n   * 3. Draws this line. -> |      | <- 1. Draws this line.\n   *                       +------+\n   *                          ^\n   *                          |\n   *                  2. Draws this line.\n   */\n  path.push(['L', waveRight + left, cy + radius]);\n  path.push(['L', left, cy + radius]);\n  path.push(['Z']);\n  return path;\n}\n/**\n * Add wave.\n * @param x           center x\n * @param y           center y\n * @param level       wave level 0～1\n * @param waveCount   wave count\n * @param waveAttrs   style\n * @param group       g\n * @param minY        Minimum height\n * @param radius      radius\n * @param waveLength  wave length\n * @param animation  animation config\n * @param document\n */\nexport function addWave(x, y, level, waveCount, waveAttrs, group, minY, radius, waveLength, animation, document) {\n  // Box property Color width height.\n  const {\n    fill,\n    fillOpacity,\n    opacity\n  } = waveAttrs;\n  // Number of cyclic waveCount.\n  for (let idx = 0; idx < waveCount; idx++) {\n    const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);\n    const path = getWaterWavePath(radius, minY + radius * level, waveLength, 0,\n    // Amplitude height.\n    radius / 40, x, y);\n    // Create wave path.\n    const wave = document.createElement('path', {\n      style: {\n        d: path,\n        fill,\n        opacity: lerp(0.2, 0.9, factor) * Number(opacity || fillOpacity)\n      }\n    });\n    group.appendChild(wave);\n    try {\n      if (animation === false) return;\n      const keyframes = [{\n        transform: 'translate(0, 0)'\n      }, {\n        transform: `translate(${waveLength * 2}, 0)`\n      }];\n      wave.animate(keyframes, {\n        duration: lerp(0.5 * DURATION, DURATION, factor) * 2,\n        iterations: Infinity\n      });\n    } catch (e) {\n      console.warn('off-screen group animate error!');\n    }\n  }\n}","map":{"version":3,"names":["DURATION","lerp","min","max","factor","getWaterWavePositions","x","stage","waveLength","amplitude","Math","PI","getWaterWavePath","radius","waterLevel","phase","cx","cy","curves","ceil","path","_phase","left","push","waveRight","c","pos","addWave","y","level","waveCount","waveAttrs","group","minY","animation","document","fill","fillOpacity","opacity","idx","wave","createElement","style","d","Number","appendChild","keyframes","transform","animate","duration","iterations","Infinity","e","console","warn"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/liquid/wave.ts"],"sourcesContent":["import { PathStyleProps, IAnimation } from '@antv/g';\n\nconst DURATION = 5000;\n\n/**\n * A function of linear mapping.\n * @param min\n * @param max\n * @param factor\n */\nfunction lerp(min: number, max: number, factor: number) {\n  return min + (max - min) * factor;\n}\n\n/**\n * Using Bessel curve to simulate sine wave.\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * Whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1).\n *\n * @param x          x position of the left-most point (a).\n * @param stage      0-3, stating which part of the wave it is.\n * @param waveLength wave length of the sine wave.\n * @param amplitude  wave amplitude.\n * @return Sinusoidal segment curve.\n */\nfunction getWaterWavePositions(\n  x: number,\n  stage: number,\n  waveLength: number,\n  amplitude: number,\n) {\n  if (stage === 0) {\n    return [\n      [x + ((1 / 2) * waveLength) / Math.PI / 2, amplitude / 2],\n      [x + ((1 / 2) * waveLength) / Math.PI, amplitude],\n      [x + waveLength / 4, amplitude],\n    ];\n  }\n  if (stage === 1) {\n    return [\n      [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 2), amplitude],\n      [\n        x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 1),\n        amplitude / 2,\n      ],\n      [x + waveLength / 4, 0],\n    ];\n  }\n  if (stage === 2) {\n    return [\n      [x + ((1 / 2) * waveLength) / Math.PI / 2, -amplitude / 2],\n      [x + ((1 / 2) * waveLength) / Math.PI, -amplitude],\n      [x + waveLength / 4, -amplitude],\n    ];\n  }\n  return [\n    [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 2), -amplitude],\n    [\n      x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 1),\n      -amplitude / 2,\n    ],\n    [x + waveLength / 4, 0],\n  ];\n}\n\n/**\n * Get wave path.\n * @param radius\n * @param waterLevel      water level\n * @param waveLength      wave length\n * @param phase\n * @param amplitude\n * @param cx              center x\n * @param cy              center y\n * @return path           path\n */\nfunction getWaterWavePath(\n  radius: number,\n  waterLevel: number,\n  waveLength: number,\n  phase: number,\n  amplitude: number,\n  cx: number,\n  cy: number,\n) {\n  const curves = Math.ceil(((2 * radius) / waveLength) * 4) * 4;\n  const path = [];\n  let _phase = phase;\n\n  // Map phase to [-Math.PI * 2, 0].\n  while (_phase < -Math.PI * 2) {\n    _phase += Math.PI * 2;\n  }\n  while (_phase > 0) {\n    _phase -= Math.PI * 2;\n  }\n  _phase = (_phase / Math.PI / 2) * waveLength;\n\n  const left = cx - radius + _phase - radius * 2;\n  /**\n   * Top-left corner as start point.\n   *\n   * Draws this point.\n   *  |\n   * \\|/\n   *  ~~~~~~~~\n   *  |      |\n   *  +------+\n   */\n  path.push(['M', left, waterLevel]);\n\n  /**\n   * Top wave.\n   *\n   * ~~~~~~~~ <- Draws this sine wave.\n   * |      |\n   * +------+\n   */\n  let waveRight = 0;\n  for (let c = 0; c < curves; ++c) {\n    const stage = c % 4;\n    const pos = getWaterWavePositions(\n      (c * waveLength) / 4,\n      stage,\n      waveLength,\n      amplitude,\n    );\n    path.push([\n      'C',\n      pos[0][0] + left,\n      -pos[0][1] + waterLevel,\n      pos[1][0] + left,\n      -pos[1][1] + waterLevel,\n      pos[2][0] + left,\n      -pos[2][1] + waterLevel,\n    ]);\n\n    if (c === curves - 1) {\n      waveRight = pos[2][0];\n    }\n  }\n\n  /**\n   * Top-right corner.\n   *\n   *                       ~~~~~~~~\n   * 3. Draws this line. -> |      | <- 1. Draws this line.\n   *                       +------+\n   *                          ^\n   *                          |\n   *                  2. Draws this line.\n   */\n  path.push(['L', waveRight + left, cy + radius]);\n  path.push(['L', left, cy + radius]);\n  path.push(['Z']);\n\n  return path;\n}\n\n/**\n * Add wave.\n * @param x           center x\n * @param y           center y\n * @param level       wave level 0～1\n * @param waveCount   wave count\n * @param waveAttrs   style\n * @param group       g\n * @param minY        Minimum height\n * @param radius      radius\n * @param waveLength  wave length\n * @param animation  animation config\n * @param document\n */\nexport function addWave(\n  x: number,\n  y: number,\n  level: number,\n  waveCount: number,\n  waveAttrs: PathStyleProps,\n  group: any,\n  minY: number,\n  radius: number,\n  waveLength: number,\n  animation: IAnimation | boolean,\n  document: any,\n) {\n  // Box property Color width height.\n  const { fill, fillOpacity, opacity } = waveAttrs;\n\n  // Number of cyclic waveCount.\n  for (let idx = 0; idx < waveCount; idx++) {\n    const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);\n\n    const path = getWaterWavePath(\n      radius,\n      minY + radius * level,\n      waveLength,\n      0,\n      // Amplitude height.\n      radius / 40,\n      x,\n      y,\n    );\n\n    // Create wave path.\n    const wave = document.createElement('path', {\n      style: {\n        d: path,\n        fill,\n        opacity: lerp(0.2, 0.9, factor) * Number(opacity || fillOpacity),\n      },\n    });\n\n    group.appendChild(wave);\n\n    try {\n      if (animation === false) return;\n\n      const keyframes = [\n        {\n          transform: 'translate(0, 0)',\n        },\n        {\n          transform: `translate(${waveLength * 2}, 0)`,\n        },\n      ];\n\n      wave.animate(keyframes, {\n        duration: lerp(0.5 * DURATION, DURATION, factor) * 2,\n        iterations: Infinity,\n      });\n    } catch (e) {\n      console.warn('off-screen group animate error!');\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}