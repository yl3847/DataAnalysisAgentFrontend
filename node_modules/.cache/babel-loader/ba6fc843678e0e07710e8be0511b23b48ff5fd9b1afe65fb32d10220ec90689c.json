{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Rect } from '@antv/g';\nimport { subObject } from '../utils/helper';\nimport { domainOf } from '../utils/scale';\nimport { brush } from './brushHighlight';\nimport { brushXRegion } from './brushXHighlight';\nimport { brushYRegion } from './brushYHighlight';\nimport { selectG2Elements, createDatumof, createValueof, useState, selectPlotArea, mergeState } from './utils';\nexport const AXIS_CLASS_NAME = 'axis';\nexport const AXIS_LINE_CLASS_NAME = 'axis-line';\nexport const AXIS_MAIN_CLASS_NAME = 'axis-main-group';\nexport const AXIS_HOT_AREA_CLASS_NAME = 'axis-hot-area';\nfunction axesOf(container) {\n  return container.getElementsByClassName(AXIS_CLASS_NAME);\n}\nfunction lineOf(axis) {\n  return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];\n}\nfunction mainGroupOf(axis) {\n  return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];\n}\n// Use the bounds of main group of axis as the bounds of axis,\n// get rid of grid and title.\nfunction boundsOfAxis(axis) {\n  return mainGroupOf(axis).getLocalBounds();\n}\n// Brush for vertical axis.\nfunction verticalBrush(axis, _a) {\n  var {\n      cross,\n      offsetX,\n      offsetY\n    } = _a,\n    style = __rest(_a, [\"cross\", \"offsetX\", \"offsetY\"]);\n  const bounds = boundsOfAxis(axis);\n  const axisLine = lineOf(axis);\n  const [lineX] = axisLine.getLocalBounds().min;\n  const [minX, minY] = bounds.min;\n  const [maxX, maxY] = bounds.max;\n  const size = (maxX - minX) * 2;\n  return {\n    brushRegion: brushYRegion,\n    hotZone: new Rect({\n      className: AXIS_HOT_AREA_CLASS_NAME,\n      style: Object.assign({\n        // If it is not cross, draw brush in both side of axisLine,\n        // otherwise the draw brush within bounds area.\n        width: cross ? size / 2 : size,\n        transform: `translate(${(cross ? minX : lineX - size / 2).toFixed(2)}, ${minY})`,\n        height: maxY - minY\n      }, style)\n    }),\n    extent: cross ?\n    // If it is cross, the x range is ignored.\n    (x, y, x1, y1) => [-Infinity, y, Infinity, y1] : (x, y, x1, y1) => [Math.floor(minX - offsetX), y, Math.ceil(maxX - offsetX), y1]\n  };\n}\n// Brush for horizontal axis.\nfunction horizontalBrush(axis, _a) {\n  var {\n      offsetY,\n      offsetX,\n      cross = false\n    } = _a,\n    style = __rest(_a, [\"offsetY\", \"offsetX\", \"cross\"]);\n  const bounds = boundsOfAxis(axis);\n  const axisLine = lineOf(axis);\n  const [, lineY] = axisLine.getLocalBounds().min;\n  const [minX, minY] = bounds.min;\n  const [maxX, maxY] = bounds.max;\n  const size = maxY - minY;\n  return {\n    brushRegion: brushXRegion,\n    hotZone: new Rect({\n      className: AXIS_HOT_AREA_CLASS_NAME,\n      style: Object.assign({\n        width: maxX - minX,\n        // If it is not cross, draw brush in both side of axisLine,\n        // otherwise the draw brush within bounds area.\n        height: cross ? size : size * 2,\n        transform: `translate(${minX}, ${cross ? minY : lineY - size})`\n      }, style)\n    }),\n    extent: cross ?\n    // If it is cross, the y range is ignored.\n    (x, y, x1, y1) => [x, -Infinity, x1, Infinity] : (x, y, x1, y1) => [x, Math.floor(minY - offsetY), x1, Math.ceil(maxY - offsetY)]\n  };\n}\nexport function brushAxisHighlight(root, _a) {\n  var {\n      axes: axesOf,\n      // given root, return axes\n      elements: elementsOf,\n      // given root, return elements\n      points: pointsOf,\n      // given shape, return control points\n      horizontal: isHorizontal,\n      // given axis, return direction\n      datum,\n      // given shape, return datum\n      offsetY,\n      // offsetY for shape area\n      offsetX,\n      // offsetX for shape area\n      reverse = false,\n      state = {},\n      emitter,\n      coordinate\n    } = _a,\n    rest = __rest(_a, [\"axes\", \"elements\", \"points\", \"horizontal\", \"datum\", \"offsetY\", \"offsetX\", \"reverse\", \"state\", \"emitter\", \"coordinate\"]) // style\n  ;\n  const elements = elementsOf(root);\n  const axes = axesOf(root);\n  const valueof = createValueof(elements, datum);\n  const {\n    setState,\n    removeState\n  } = useState(state, valueof);\n  const axisExtent = new Map();\n  const brushStyle = subObject(rest, 'mask');\n  // Only some of shape's points in all mask, it is selected.\n  const brushed = points => Array.from(axisExtent.values()).every(([x, y, x1, y1]) => points.some(([x0, y0]) => {\n    return x0 >= x && x0 <= x1 && y0 >= y && y0 <= y1;\n  }));\n  const scales = axes.map(d => d.attributes.scale);\n  const extentOf = D => D.length > 2 ? [D[0], D[D.length - 1]] : D;\n  const indexDomain = new Map();\n  const initIndexDomain = () => {\n    indexDomain.clear();\n    for (let i = 0; i < axes.length; i++) {\n      const scale = scales[i];\n      const {\n        domain\n      } = scale.getOptions();\n      indexDomain.set(i, extentOf(domain));\n    }\n  };\n  initIndexDomain();\n  // Update element when brush changed.\n  const updateElement = (i, emit) => {\n    const selectedElements = [];\n    for (const element of elements) {\n      const points = pointsOf(element);\n      if (brushed(points)) {\n        setState(element, 'active');\n        selectedElements.push(element);\n      } else setState(element, 'inactive');\n    }\n    indexDomain.set(i, selectionOf(selectedElements, i));\n    if (!emit) return;\n    // Emit events.\n    const selection = () => {\n      if (!cross) return Array.from(indexDomain.values());\n      const S = [];\n      for (const [index, domain] of indexDomain) {\n        const scale = scales[index];\n        const {\n          name\n        } = scale.getOptions();\n        if (name === 'x') S[0] = domain;else S[1] = domain;\n      }\n      return S;\n    };\n    emitter.emit('brushAxis:highlight', {\n      nativeEvent: true,\n      data: {\n        selection: selection()\n      }\n    });\n  };\n  const clearElement = emit => {\n    for (const element of elements) removeState(element, 'active', 'inactive');\n    initIndexDomain();\n    if (!emit) return;\n    emitter.emit('brushAxis:remove', {\n      nativeEvent: true\n    });\n  };\n  const selectionOf = (selected, i) => {\n    const scale = scales[i];\n    const {\n      name\n    } = scale.getOptions();\n    const domain = selected.map(d => {\n      const data = d.__data__;\n      return scale.invert(data[name]);\n    });\n    return extentOf(domainOf(scale, domain));\n  };\n  // Distinguish between parallel coordinates and normal charts.\n  const cross = axes.some(isHorizontal) && axes.some(d => !isHorizontal(d));\n  const handlers = [];\n  for (let i = 0; i < axes.length; i++) {\n    const axis = axes[i];\n    const createBrush = isHorizontal(axis) ? horizontalBrush : verticalBrush;\n    const {\n      hotZone,\n      brushRegion,\n      extent\n    } = createBrush(axis, {\n      offsetY,\n      offsetX,\n      cross,\n      zIndex: 999,\n      fill: 'transparent' // Make it interactive.\n    });\n    axis.parentNode.appendChild(hotZone);\n    const brushHandler = brush(hotZone, Object.assign(Object.assign({}, brushStyle), {\n      reverse,\n      brushRegion,\n      brushended(emit) {\n        axisExtent.delete(axis);\n        if (Array.from(axisExtent.entries()).length === 0) clearElement(emit);else updateElement(i, emit);\n      },\n      brushed(x, y, x1, y1, emit) {\n        axisExtent.set(axis, extent(x, y, x1, y1));\n        updateElement(i, emit);\n      }\n    }));\n    handlers.push(brushHandler);\n  }\n  const onRemove = (event = {}) => {\n    const {\n      nativeEvent\n    } = event;\n    if (nativeEvent) return;\n    handlers.forEach(d => d.remove(false));\n  };\n  const rangeOf = (domain, scale, axis) => {\n    const [d0, d1] = domain;\n    const maybeStep = scale => scale.getStep ? scale.getStep() : 0;\n    const x = abstractOf(d0, scale, axis);\n    const x1 = abstractOf(d1, scale, axis) + maybeStep(scale);\n    if (isHorizontal(axis)) return [x, -Infinity, x1, Infinity];\n    return [-Infinity, x, Infinity, x1];\n  };\n  const abstractOf = (x, scale, axis) => {\n    const {\n      height,\n      width\n    } = coordinate.getOptions();\n    const scale1 = scale.clone();\n    if (isHorizontal(axis)) scale1.update({\n      range: [0, width]\n    });else scale1.update({\n      range: [height, 0]\n    });\n    return scale1.map(x);\n  };\n  const onHighlight = event => {\n    const {\n      nativeEvent\n    } = event;\n    if (nativeEvent) return;\n    const {\n      selection\n    } = event.data;\n    for (let i = 0; i < handlers.length; i++) {\n      const domain = selection[i];\n      const handler = handlers[i];\n      const axis = axes[i];\n      if (domain) {\n        const scale = scales[i];\n        handler.move(...rangeOf(domain, scale, axis), false);\n      } else {\n        handler.remove(false);\n      }\n    }\n  };\n  emitter.on('brushAxis:remove', onRemove);\n  emitter.on('brushAxis:highlight', onHighlight);\n  return () => {\n    handlers.forEach(d => d.destroy());\n    emitter.off('brushAxis:remove', onRemove);\n    emitter.off('brushAxis:highlight', onHighlight);\n  };\n}\n/**\n * @todo Support mask size.\n */\nexport function BrushAxisHighlight(options) {\n  return (target, _, emitter) => {\n    const {\n      container,\n      view,\n      options: viewOptions\n    } = target;\n    const plotArea = selectPlotArea(container);\n    const {\n      x: x0,\n      y: y0\n    } = plotArea.getBBox();\n    const {\n      coordinate\n    } = view;\n    return brushAxisHighlight(container, Object.assign({\n      elements: selectG2Elements,\n      axes: axesOf,\n      offsetY: y0,\n      offsetX: x0,\n      points: element => element.__data__.points,\n      horizontal: axis => {\n        const {\n          startPos: [sx, sy],\n          endPos: [ex, ey]\n        } = axis.attributes;\n        // attention, non-horizontal does not mean vertical\n        // it may has a specific degree angle\n        return sx !== ex && sy === ey;\n      },\n      datum: createDatumof(view),\n      state: mergeState(viewOptions, ['active', ['inactive', {\n        opacity: 0.5\n      }]]),\n      coordinate,\n      emitter\n    }, options));\n  };\n}","map":{"version":3,"names":["Rect","subObject","domainOf","brush","brushXRegion","brushYRegion","selectG2Elements","createDatumof","createValueof","useState","selectPlotArea","mergeState","AXIS_CLASS_NAME","AXIS_LINE_CLASS_NAME","AXIS_MAIN_CLASS_NAME","AXIS_HOT_AREA_CLASS_NAME","axesOf","container","getElementsByClassName","lineOf","axis","mainGroupOf","boundsOfAxis","getLocalBounds","verticalBrush","_a","cross","offsetX","offsetY","style","__rest","bounds","axisLine","lineX","min","minX","minY","maxX","maxY","max","size","brushRegion","hotZone","className","Object","assign","width","transform","toFixed","height","extent","x","y","x1","y1","Infinity","Math","floor","ceil","horizontalBrush","lineY","brushAxisHighlight","root","axes","elements","elementsOf","points","pointsOf","horizontal","isHorizontal","datum","reverse","state","emitter","coordinate","rest","valueof","setState","removeState","axisExtent","Map","brushStyle","brushed","Array","from","values","every","some","x0","y0","scales","map","d","attributes","scale","extentOf","D","length","indexDomain","initIndexDomain","clear","i","domain","getOptions","set","updateElement","emit","selectedElements","element","push","selectionOf","selection","S","index","name","nativeEvent","data","clearElement","selected","__data__","invert","handlers","createBrush","zIndex","fill","parentNode","appendChild","brushHandler","brushended","delete","entries","onRemove","event","forEach","remove","rangeOf","d0","d1","maybeStep","getStep","abstractOf","scale1","clone","update","range","onHighlight","handler","move","on","destroy","off","BrushAxisHighlight","options","target","_","view","viewOptions","plotArea","getBBox","startPos","sx","sy","endPos","ex","ey","opacity"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/brushAxisHighlight.ts"],"sourcesContent":["import { Rect } from '@antv/g';\nimport { subObject } from '../utils/helper';\nimport { domainOf, pixelsOf } from '../utils/scale';\nimport { brush } from './brushHighlight';\nimport { brushXRegion } from './brushXHighlight';\nimport { brushYRegion } from './brushYHighlight';\nimport {\n  selectG2Elements,\n  createDatumof,\n  createValueof,\n  useState,\n  selectPlotArea,\n  mergeState,\n} from './utils';\n\nexport const AXIS_CLASS_NAME = 'axis';\n\nexport const AXIS_LINE_CLASS_NAME = 'axis-line';\n\nexport const AXIS_MAIN_CLASS_NAME = 'axis-main-group';\n\nexport const AXIS_HOT_AREA_CLASS_NAME = 'axis-hot-area';\n\nfunction axesOf(container) {\n  return container.getElementsByClassName(AXIS_CLASS_NAME);\n}\n\nfunction lineOf(axis) {\n  return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];\n}\n\nfunction mainGroupOf(axis) {\n  return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];\n}\n\n// Use the bounds of main group of axis as the bounds of axis,\n// get rid of grid and title.\nfunction boundsOfAxis(axis) {\n  return mainGroupOf(axis).getLocalBounds();\n}\n\n// Brush for vertical axis.\nfunction verticalBrush(axis, { cross, offsetX, offsetY, ...style }) {\n  const bounds = boundsOfAxis(axis);\n  const axisLine = lineOf(axis);\n  const [lineX] = axisLine.getLocalBounds().min;\n  const [minX, minY] = bounds.min;\n  const [maxX, maxY] = bounds.max;\n  const size = (maxX - minX) * 2;\n  return {\n    brushRegion: brushYRegion,\n    hotZone: new Rect({\n      className: AXIS_HOT_AREA_CLASS_NAME,\n      style: {\n        // If it is not cross, draw brush in both side of axisLine,\n        // otherwise the draw brush within bounds area.\n        width: cross ? size / 2 : size,\n        transform: `translate(${(cross ? minX : lineX - size / 2).toFixed(\n          2,\n        )}, ${minY})`,\n        height: maxY - minY,\n        ...style,\n      },\n    }),\n    extent: cross\n      ? // If it is cross, the x range is ignored.\n        (x, y, x1, y1) => [-Infinity, y, Infinity, y1]\n      : (x, y, x1, y1) => [\n          Math.floor(minX - offsetX),\n          y,\n          Math.ceil(maxX - offsetX),\n          y1,\n        ],\n  };\n}\n\n// Brush for horizontal axis.\nfunction horizontalBrush(axis, { offsetY, offsetX, cross = false, ...style }) {\n  const bounds = boundsOfAxis(axis);\n  const axisLine = lineOf(axis);\n  const [, lineY] = axisLine.getLocalBounds().min;\n  const [minX, minY] = bounds.min;\n  const [maxX, maxY] = bounds.max;\n  const size = maxY - minY;\n  return {\n    brushRegion: brushXRegion,\n    hotZone: new Rect({\n      className: AXIS_HOT_AREA_CLASS_NAME,\n      style: {\n        width: maxX - minX,\n        // If it is not cross, draw brush in both side of axisLine,\n        // otherwise the draw brush within bounds area.\n        height: cross ? size : size * 2,\n        transform: `translate(${minX}, ${cross ? minY : lineY - size})`,\n        ...style,\n      },\n    }),\n    extent: cross\n      ? // If it is cross, the y range is ignored.\n        (x, y, x1, y1) => [x, -Infinity, x1, Infinity]\n      : (x, y, x1, y1) => [\n          x,\n          Math.floor(minY - offsetY),\n          x1,\n          Math.ceil(maxY - offsetY),\n        ],\n  };\n}\n\nexport function brushAxisHighlight(\n  root,\n  {\n    axes: axesOf, // given root, return axes\n    elements: elementsOf, // given root, return elements\n    points: pointsOf, // given shape, return control points\n    horizontal: isHorizontal, // given axis, return direction\n    datum, // given shape, return datum\n    offsetY, // offsetY for shape area\n    offsetX, // offsetX for shape area\n    reverse = false,\n    state = {},\n    emitter,\n    coordinate,\n    ...rest // style\n  },\n) {\n  const elements = elementsOf(root);\n  const axes = axesOf(root);\n  const valueof = createValueof(elements, datum);\n  const { setState, removeState } = useState(state, valueof);\n  const axisExtent = new Map();\n  const brushStyle = subObject(rest, 'mask');\n\n  // Only some of shape's points in all mask, it is selected.\n  const brushed = (points) =>\n    Array.from(axisExtent.values()).every(([x, y, x1, y1]) =>\n      points.some(([x0, y0]) => {\n        return x0 >= x && x0 <= x1 && y0 >= y && y0 <= y1;\n      }),\n    );\n\n  const scales = axes.map((d) => d.attributes.scale);\n\n  const extentOf = (D) => (D.length > 2 ? [D[0], D[D.length - 1]] : D);\n\n  const indexDomain = new Map<number, [any, any]>();\n\n  const initIndexDomain = () => {\n    indexDomain.clear();\n    for (let i = 0; i < axes.length; i++) {\n      const scale = scales[i];\n      const { domain } = scale.getOptions();\n      indexDomain.set(i, extentOf(domain));\n    }\n  };\n\n  initIndexDomain();\n\n  // Update element when brush changed.\n  const updateElement = (i, emit) => {\n    const selectedElements = [];\n    for (const element of elements) {\n      const points = pointsOf(element);\n      if (brushed(points)) {\n        setState(element, 'active');\n        selectedElements.push(element);\n      } else setState(element, 'inactive');\n    }\n\n    indexDomain.set(i, selectionOf(selectedElements, i));\n\n    if (!emit) return;\n\n    // Emit events.\n    const selection = () => {\n      if (!cross) return Array.from(indexDomain.values());\n      const S = [];\n      for (const [index, domain] of indexDomain) {\n        const scale = scales[index];\n        const { name } = scale.getOptions();\n        if (name === 'x') S[0] = domain;\n        else S[1] = domain;\n      }\n      return S;\n    };\n    emitter.emit('brushAxis:highlight', {\n      nativeEvent: true,\n      data: {\n        selection: selection(),\n      },\n    });\n  };\n\n  const clearElement = (emit) => {\n    for (const element of elements) removeState(element, 'active', 'inactive');\n    initIndexDomain();\n    if (!emit) return;\n    emitter.emit('brushAxis:remove', { nativeEvent: true });\n  };\n\n  const selectionOf = (selected, i) => {\n    const scale = scales[i];\n    const { name } = scale.getOptions();\n    const domain = selected.map((d) => {\n      const data = d.__data__;\n      return scale.invert(data[name]);\n    });\n    return extentOf(domainOf(scale, domain));\n  };\n\n  // Distinguish between parallel coordinates and normal charts.\n  const cross = axes.some(isHorizontal) && axes.some((d) => !isHorizontal(d));\n  const handlers = [];\n  for (let i = 0; i < axes.length; i++) {\n    const axis = axes[i];\n    const createBrush = isHorizontal(axis) ? horizontalBrush : verticalBrush;\n    const { hotZone, brushRegion, extent } = createBrush(axis, {\n      offsetY,\n      offsetX,\n      cross,\n      zIndex: 999, // Pin mask to top.\n      fill: 'transparent', // Make it interactive.\n    });\n    axis.parentNode.appendChild(hotZone);\n\n    const brushHandler = brush(hotZone, {\n      ...brushStyle,\n      reverse,\n      brushRegion,\n      brushended(emit) {\n        axisExtent.delete(axis);\n        if (Array.from(axisExtent.entries()).length === 0) clearElement(emit);\n        else updateElement(i, emit);\n      },\n      brushed(x, y, x1, y1, emit) {\n        axisExtent.set(axis, extent(x, y, x1, y1));\n        updateElement(i, emit);\n      },\n    });\n    handlers.push(brushHandler);\n  }\n\n  const onRemove = (event: any = {}) => {\n    const { nativeEvent } = event;\n    if (nativeEvent) return;\n    handlers.forEach((d) => d.remove(false));\n  };\n\n  const rangeOf = (domain, scale, axis) => {\n    const [d0, d1] = domain;\n    const maybeStep = (scale) => (scale.getStep ? scale.getStep() : 0);\n    const x = abstractOf(d0, scale, axis);\n    const x1 = abstractOf(d1, scale, axis) + maybeStep(scale);\n    if (isHorizontal(axis)) return [x, -Infinity, x1, Infinity];\n    return [-Infinity, x, Infinity, x1];\n  };\n\n  const abstractOf = (x, scale, axis) => {\n    const { height, width } = coordinate.getOptions();\n    const scale1 = scale.clone();\n    if (isHorizontal(axis)) scale1.update({ range: [0, width] });\n    else scale1.update({ range: [height, 0] });\n    return scale1.map(x);\n  };\n\n  const onHighlight = (event) => {\n    const { nativeEvent } = event;\n    if (nativeEvent) return;\n    const { selection } = event.data;\n    for (let i = 0; i < handlers.length; i++) {\n      const domain = selection[i];\n      const handler = handlers[i];\n      const axis = axes[i];\n      if (domain) {\n        const scale = scales[i];\n        handler.move(...rangeOf(domain, scale, axis), false);\n      } else {\n        handler.remove(false);\n      }\n    }\n  };\n\n  emitter.on('brushAxis:remove', onRemove);\n  emitter.on('brushAxis:highlight', onHighlight);\n\n  return () => {\n    handlers.forEach((d) => d.destroy());\n    emitter.off('brushAxis:remove', onRemove);\n    emitter.off('brushAxis:highlight', onHighlight);\n  };\n}\n\n/**\n * @todo Support mask size.\n */\nexport function BrushAxisHighlight(options) {\n  return (target, _, emitter) => {\n    const { container, view, options: viewOptions } = target;\n    const plotArea = selectPlotArea(container);\n    const { x: x0, y: y0 } = plotArea.getBBox();\n    const { coordinate } = view;\n    return brushAxisHighlight(container, {\n      elements: selectG2Elements,\n      axes: axesOf,\n      offsetY: y0,\n      offsetX: x0,\n      points: (element) => element.__data__.points,\n      horizontal: (axis) => {\n        const {\n          startPos: [sx, sy],\n          endPos: [ex, ey],\n        } = axis.attributes;\n        // attention, non-horizontal does not mean vertical\n        // it may has a specific degree angle\n        return sx !== ex && sy === ey;\n      },\n      datum: createDatumof(view),\n      state: mergeState(viewOptions, [\n        'active',\n        ['inactive', { opacity: 0.5 }],\n      ]),\n      coordinate,\n      emitter,\n      ...options,\n    });\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}