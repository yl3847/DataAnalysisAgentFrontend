{"ast":null,"code":"import { clone } from '@antv/util';\nimport getAdjMatrix from './adjacent-matrix';\nimport Vector from './utils/vector';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot } from './utils/data-preprocessing';\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n  modularity *= 1 / param;\n  return modularity;\n};\n// 模块惯性度，衡量属性相似度\nvar getInertialModularity = function getInertialModularity(nodes, allPropertiesWeight) {\n  if (nodes === void 0) {\n    nodes = [];\n  }\n  var length = nodes.length;\n  var totalProperties = new Vector([]);\n  for (var i = 0; i < length; i++) {\n    totalProperties = totalProperties.add(new Vector(allPropertiesWeight[i]));\n  }\n  // 均值向量\n  var avgProperties = totalProperties.avg(length);\n  avgProperties.normalize();\n  // 节点集合的方差: 节点v与均值向量的平方欧式距离之和\n  var variance = 0;\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new Vector(allPropertiesWeight[i]);\n    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);\n    variance += squareEuclideanDistance;\n  }\n  // 任意两点间的欧式平方距离\n  var squareEuclideanDistanceInfo = [];\n  nodes.forEach(function () {\n    squareEuclideanDistanceInfo.push([]);\n  });\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new Vector(allPropertiesWeight[i]);\n    nodes[i]['clusterInertial'] = 0;\n    for (var j = 0; j < length; j++) {\n      if (i === j) {\n        squareEuclideanDistanceInfo[i][j] = 0;\n        continue;\n      }\n      var propertiesj = new Vector(allPropertiesWeight[j]);\n      squareEuclideanDistanceInfo[i][j] = propertiesi.squareEuclideanDistance(propertiesj);\n      nodes[i]['clusterInertial'] += squareEuclideanDistanceInfo[i][j];\n    }\n  }\n  // 计算模块惯性度\n  var inertialModularity = 0;\n  var param = 2 * length * variance;\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (i === j || clusteri !== clusterj) continue;\n      var inertial = nodes[i].clusterInertial * nodes[j].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i][j] / param;\n      inertialModularity += inertial;\n    }\n  }\n  return Number(inertialModularity.toFixed(4));\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold 差值阈值\n * @param inertialModularity 是否使用惯性模块度（即节点属性相似性）\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param inertialWeight 惯性模块度权重\n */\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  }\n  if (inertialModularity === void 0) {\n    inertialModularity = false;\n  }\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n  if (inertialWeight === void 0) {\n    inertialWeight = 1;\n  }\n  // the origin data\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var allPropertiesWeight = [];\n  if (inertialModularity) {\n    nodes.forEach(function (node, index) {\n      node.properties = node.properties || {};\n      node.originIndex = index;\n    });\n    var nodeTypeInfo_1 = [];\n    if (nodes.every(function (node) {\n      return node.hasOwnProperty('nodeType');\n    })) {\n      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function (node) {\n        return node.nodeType;\n      })));\n      nodes.forEach(function (node) {\n        node.properties.nodeType = nodeTypeInfo_1.findIndex(function (nodeType) {\n          return nodeType === node.nodeType;\n        });\n      });\n    }\n    // 所有节点属性集合\n    var properties = getAllProperties(nodes, propertyKey);\n    // 所有节点属性one-hot特征向量集合\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  }\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  });\n  // the adjacent matrix of calNodes inside clusters\n  var adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  var neighbors = {};\n  // the sum of the weights of all edges in the graph\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n  var finalNodes = [];\n  var finalClusters = {};\n  while (true) {\n    if (inertialModularity && nodes.every(function (node) {\n      return node.hasOwnProperty('properties');\n    })) {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;\n    } else {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    }\n    // 第一次迭代previousModularity直接赋值\n    if (iter === 0) {\n      previousModularity = totalModularity;\n      finalNodes = nodes;\n      finalClusters = clusters;\n    }\n    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;\n    // 总模块度增加才更新最优解\n    if (totalModularity > previousModularity) {\n      finalNodes = nodes.map(function (node) {\n        return {\n          node: node,\n          clusterId: node.clusterId\n        };\n      });\n      finalClusters = clone(clusters);\n      previousModularity = totalModularity;\n    }\n    // whether to terminate the iterations\n    if (increaseWithinThreshold || iter > 100) {\n      break;\n    }\n    ;\n    iter++;\n    // pre compute some values for current clusters\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n          target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    });\n    // move the nodes to increase the delta modularity\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m);\n      // sum of weights of edges from node to nodes in cluster\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      });\n      // the modurarity for **removing** the node i from the origin cluster of node i\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam;\n      // nodes for **removing** node i into this neighbor cluster\n      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function (scNode) {\n        return scNode.id !== node.id;\n      });\n      var propertiesWeightRemove = [];\n      selfClusterNodesAfterRemove.forEach(function (nodeRemove, index) {\n        propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];\n      });\n      // the inertialModularity for **removing** the node i from the origin cluster of node i\n      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;\n      // the neightbors of the node\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        // if the node and the neighbor of node are in the same cluster, reutrn\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes;\n        // if the cluster is empty, remove the cluster and return\n        if (!clusterNodes || !clusterNodes.length) return;\n        // sum of weights of edges from node to nodes in cluster\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        });\n        // the modurarity for **adding** node i into this neighbor cluster\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;\n        // nodes for **adding** node i into this neighbor cluster\n        var clusterNodesAfterAdd = clusterNodes.concat([node]);\n        var propertiesWeightAdd = [];\n        clusterNodesAfterAdd.forEach(function (nodeAdd, index) {\n          propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];\n        });\n        // the inertialModularity for **adding** node i into this neighbor cluster\n        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;\n        // the increase modurarity is the difference between addModurarity and removeModurarity\n        var increase = addModurarity - removeModurarity;\n        if (inertialModularity) {\n          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);\n        }\n        // find the best cluster to move node i into\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      });\n      // if found a best cluster to move into\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id;\n        // move the node to the best cluster\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        // remove from origin cluster\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n            target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        });\n        // the nodes of the clusters to move into and remove are changed, update their sumTot\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  }\n  // delete the empty clusters, assign increasing clusterId\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    var cluster = finalClusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete finalClusters[clusterId];\n      return;\n    }\n    var newId = String(clusterIdx + 1);\n    if (newId === clusterId) {\n      return;\n    }\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    finalClusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete finalClusters[clusterId];\n    clusterIdx++;\n  });\n  // restore node clusterId\n  finalNodes.forEach(function (nodeInfo) {\n    var node = nodeInfo.node,\n      clusterId = nodeInfo.clusterId;\n    if (!node) return;\n    node.clusterId = clusterId;\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  });\n  // get the cluster edges\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n      target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    if (!sourceClusterId || !targetClusterId) return;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    clustersArray.push(finalClusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\nexport default louvain;","map":{"version":3,"names":["clone","getAdjMatrix","Vector","getAllProperties","oneHot","getModularity","nodes","adjMatrix","ks","m","length","param","modularity","i","clusteri","clusterId","j","clusterj","entry","ki","kj","getInertialModularity","allPropertiesWeight","totalProperties","add","avgProperties","avg","normalize","variance","propertiesi","squareEuclideanDistance","squareEuclideanDistanceInfo","forEach","push","propertiesj","inertialModularity","inertial","clusterInertial","Math","pow","Number","toFixed","louvain","graphData","directed","weightPropertyName","threshold","propertyKey","involvedKeys","uninvolvedKeys","inertialWeight","undefined","_a","_b","edges","node","index","properties","originIndex","nodeTypeInfo_1","every","hasOwnProperty","Array","from","Set","map","nodeType","findIndex","uniqueId","clusters","nodeMap","cid","String","id","idx","neighbors","row","k","iid","jid","totalModularity","Infinity","previousModularity","iter","finalNodes","finalClusters","increaseWithinThreshold","Object","keys","sumTot","edge","source","target","sourceClusterId","targetClusterId","selfCluster","bestIncrease","bestCluster","commonParam","kiin","selfClusterNodes","scNode","scNodeIdx","removeModurarity","selfClusterNodesAfterRemove","filter","propertiesWeightRemove","nodeRemove","removeInertialModularity","nodeNeighborIds","neighborNodeId","neighborNode","neighborClusterId","neighborCluster","clusterNodes","neighborClusterKiin","cNode","cNodeIdx","addModurarity","clusterNodesAfterAdd","concat","propertiesWeightAdd","nodeAdd","addInertialModularity","increase","previousClusterId_1","nodeInSelfClusterIdx","indexOf","splice","neighborClusterSumTot_1","selfClusterSumTot_1","newClusterIdMap","clusterIdx","cluster","newId","item","nodeInfo","clusterEdges","clusterEdgeMap","weight","newEdgeId","count","newEdge","clustersArray"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/algorithm/es/louvain.js"],"sourcesContent":["import { clone } from '@antv/util';\nimport getAdjMatrix from './adjacent-matrix';\nimport Vector from './utils/vector';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot } from './utils/data-preprocessing';\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n  modularity *= 1 / param;\n  return modularity;\n};\n// 模块惯性度，衡量属性相似度\nvar getInertialModularity = function getInertialModularity(nodes, allPropertiesWeight) {\n  if (nodes === void 0) {\n    nodes = [];\n  }\n  var length = nodes.length;\n  var totalProperties = new Vector([]);\n  for (var i = 0; i < length; i++) {\n    totalProperties = totalProperties.add(new Vector(allPropertiesWeight[i]));\n  }\n  // 均值向量\n  var avgProperties = totalProperties.avg(length);\n  avgProperties.normalize();\n  // 节点集合的方差: 节点v与均值向量的平方欧式距离之和\n  var variance = 0;\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new Vector(allPropertiesWeight[i]);\n    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);\n    variance += squareEuclideanDistance;\n  }\n  // 任意两点间的欧式平方距离\n  var squareEuclideanDistanceInfo = [];\n  nodes.forEach(function () {\n    squareEuclideanDistanceInfo.push([]);\n  });\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new Vector(allPropertiesWeight[i]);\n    nodes[i]['clusterInertial'] = 0;\n    for (var j = 0; j < length; j++) {\n      if (i === j) {\n        squareEuclideanDistanceInfo[i][j] = 0;\n        continue;\n      }\n      var propertiesj = new Vector(allPropertiesWeight[j]);\n      squareEuclideanDistanceInfo[i][j] = propertiesi.squareEuclideanDistance(propertiesj);\n      nodes[i]['clusterInertial'] += squareEuclideanDistanceInfo[i][j];\n    }\n  }\n  // 计算模块惯性度\n  var inertialModularity = 0;\n  var param = 2 * length * variance;\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (i === j || clusteri !== clusterj) continue;\n      var inertial = nodes[i].clusterInertial * nodes[j].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i][j] / param;\n      inertialModularity += inertial;\n    }\n  }\n  return Number(inertialModularity.toFixed(4));\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold 差值阈值\n * @param inertialModularity 是否使用惯性模块度（即节点属性相似性）\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param inertialWeight 惯性模块度权重\n */\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  }\n  if (inertialModularity === void 0) {\n    inertialModularity = false;\n  }\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n  if (inertialWeight === void 0) {\n    inertialWeight = 1;\n  }\n  // the origin data\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var allPropertiesWeight = [];\n  if (inertialModularity) {\n    nodes.forEach(function (node, index) {\n      node.properties = node.properties || {};\n      node.originIndex = index;\n    });\n    var nodeTypeInfo_1 = [];\n    if (nodes.every(function (node) {\n      return node.hasOwnProperty('nodeType');\n    })) {\n      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function (node) {\n        return node.nodeType;\n      })));\n      nodes.forEach(function (node) {\n        node.properties.nodeType = nodeTypeInfo_1.findIndex(function (nodeType) {\n          return nodeType === node.nodeType;\n        });\n      });\n    }\n    // 所有节点属性集合\n    var properties = getAllProperties(nodes, propertyKey);\n    // 所有节点属性one-hot特征向量集合\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  }\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  });\n  // the adjacent matrix of calNodes inside clusters\n  var adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  var neighbors = {};\n  // the sum of the weights of all edges in the graph\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n  var finalNodes = [];\n  var finalClusters = {};\n  while (true) {\n    if (inertialModularity && nodes.every(function (node) {\n      return node.hasOwnProperty('properties');\n    })) {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;\n    } else {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    }\n    // 第一次迭代previousModularity直接赋值\n    if (iter === 0) {\n      previousModularity = totalModularity;\n      finalNodes = nodes;\n      finalClusters = clusters;\n    }\n    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;\n    // 总模块度增加才更新最优解\n    if (totalModularity > previousModularity) {\n      finalNodes = nodes.map(function (node) {\n        return {\n          node: node,\n          clusterId: node.clusterId\n        };\n      });\n      finalClusters = clone(clusters);\n      previousModularity = totalModularity;\n    }\n    // whether to terminate the iterations\n    if (increaseWithinThreshold || iter > 100) {\n      break;\n    }\n    ;\n    iter++;\n    // pre compute some values for current clusters\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n          target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    });\n    // move the nodes to increase the delta modularity\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m);\n      // sum of weights of edges from node to nodes in cluster\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      });\n      // the modurarity for **removing** the node i from the origin cluster of node i\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam;\n      // nodes for **removing** node i into this neighbor cluster\n      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function (scNode) {\n        return scNode.id !== node.id;\n      });\n      var propertiesWeightRemove = [];\n      selfClusterNodesAfterRemove.forEach(function (nodeRemove, index) {\n        propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];\n      });\n      // the inertialModularity for **removing** the node i from the origin cluster of node i\n      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;\n      // the neightbors of the node\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        // if the node and the neighbor of node are in the same cluster, reutrn\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes;\n        // if the cluster is empty, remove the cluster and return\n        if (!clusterNodes || !clusterNodes.length) return;\n        // sum of weights of edges from node to nodes in cluster\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        });\n        // the modurarity for **adding** node i into this neighbor cluster\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;\n        // nodes for **adding** node i into this neighbor cluster\n        var clusterNodesAfterAdd = clusterNodes.concat([node]);\n        var propertiesWeightAdd = [];\n        clusterNodesAfterAdd.forEach(function (nodeAdd, index) {\n          propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];\n        });\n        // the inertialModularity for **adding** node i into this neighbor cluster\n        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;\n        // the increase modurarity is the difference between addModurarity and removeModurarity\n        var increase = addModurarity - removeModurarity;\n        if (inertialModularity) {\n          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);\n        }\n        // find the best cluster to move node i into\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      });\n      // if found a best cluster to move into\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id;\n        // move the node to the best cluster\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        // remove from origin cluster\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n            target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        });\n        // the nodes of the clusters to move into and remove are changed, update their sumTot\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  }\n  // delete the empty clusters, assign increasing clusterId\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    var cluster = finalClusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete finalClusters[clusterId];\n      return;\n    }\n    var newId = String(clusterIdx + 1);\n    if (newId === clusterId) {\n      return;\n    }\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    finalClusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete finalClusters[clusterId];\n    clusterIdx++;\n  });\n  // restore node clusterId\n  finalNodes.forEach(function (nodeInfo) {\n    var node = nodeInfo.node,\n      clusterId = nodeInfo.clusterId;\n    if (!node) return;\n    node.clusterId = clusterId;\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  });\n  // get the cluster edges\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n      target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    if (!sourceClusterId || !targetClusterId) return;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    clustersArray.push(finalClusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\nexport default louvain;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}