{"ast":null,"code":"import { getLinesIntersection } from '../../utils/line';\nimport { getClosedSpline } from '../../utils/path';\nimport { isCollinear, sortByClockwise } from '../../utils/point';\nimport { add, angle, normalize, perpendicular, scale, subtract, toVector2, toVector3 } from '../../utils/vector';\n/**\n * <zh/> 计算 Hull 路径\n *\n * <en/> Compute Hull Path\n * @param points - <zh/> 顶点列表 | <en/> Vertices of Hull\n * @param padding - <zh/> 内边距 | <en/> padding\n * @param corner - <zh/> 拐角类型，目前支持 'sharp'、'rounded' 和 'smooth' | <en/> Corner type, currently supports 'sharp', 'rounded' and 'smooth'\n * @returns <zh/> Hull 路径 | <en/> Hull Path\n */\nexport function computeHullPath(points, padding, corner) {\n  if (points.length === 1) return genSinglePointHullPath(points[0], padding, corner);\n  if (points.length === 2) return genTwoPointsHullPath(points, padding, corner);\n  if (points.length === 3) {\n    const [p1, p2, p3] = sortByClockwise(points);\n    if (isCollinear(p1, p2, p3)) return genTwoPointsHullPath([p1, p3], padding, corner);\n  }\n  switch (corner) {\n    case 'smooth':\n      return genMultiPointsSmoothHull(points, padding);\n    case 'sharp':\n      return genMultiPointsSharpHull(points, padding);\n    case 'rounded':\n    default:\n      return genMultiPointsRoundedHull(points, padding);\n  }\n}\n/**\n * <zh/> 生成单点 Hull 路径\n *\n * <en/> Generate Hull Path for a single point\n * @param point - <zh/> 单点 | <en/> Single point\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @param corner - <zh/> 拐角类型 | <en/> Corner type\n * @returns <zh/> 单点 Hull 路径 | <en/> Single point Hull Path\n */\nconst genSinglePointHullPath = (point, padding, corner) => {\n  if (corner === 'sharp') return [['M', point[0] - padding, point[1] - padding], ['L', point[0] + padding, point[1] - padding], ['L', point[0] + padding, point[1] + padding], ['L', point[0] - padding, point[1] + padding], ['Z']];\n  const arcData = [padding, padding, 0, 0, 0];\n  return [['M', point[0], point[1] - padding], ['A', ...arcData, point[0], point[1] + padding], ['A', ...arcData, point[0], point[1] - padding]];\n};\n/**\n * <zh/> 生成两点 Hull 路径\n *\n * <en/> Generate Hull Path for two points\n * @param points - <zh/> 两点 | <en/> Two points\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @param corner - <zh/> 拐角类型 | <en/> Corner type\n * @returns <zh/> 两点 Hull 路径 | <en/> Two points Hull Path\n */\nconst genTwoPointsHullPath = (points, padding, corner) => {\n  const arcData = [padding, padding, 0, 0, 0];\n  const point1 = corner === 'sharp' ? add(points[0], scale(normalize(subtract(points[0], points[1])), padding)) : points[0];\n  const point2 = corner === 'sharp' ? add(points[1], scale(normalize(subtract(points[1], points[0])), padding)) : points[1];\n  const offsetVector = scale(normalize(perpendicular(subtract(point1, point2), false)), padding);\n  const invOffsetVector = scale(offsetVector, -1);\n  const prev = add(point1, offsetVector);\n  const current = add(point2, offsetVector);\n  const p2 = add(point2, invOffsetVector);\n  const p3 = add(point1, invOffsetVector);\n  if (corner === 'sharp') {\n    return [['M', prev[0], prev[1]], ['L', current[0], current[1]], ['L', p2[0], p2[1]], ['L', p3[0], p3[1]], ['Z']];\n  }\n  return [['M', prev[0], prev[1]], ['L', current[0], current[1]], ['A', ...arcData, p2[0], p2[1]], ['L', p3[0], p3[1]], ['A', ...arcData, prev[0], prev[1]]];\n};\n/**\n * <zh/> 生成多点 Hull 路径且拐角为圆角\n *\n * <en/> Generate Hull Path for multiple points with rounded corners\n * @param points - <zh/> 形成 Hull 的点集 | <en/> Points that form the Hull\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @returns <zh/> 圆角外壳路径 | <en/> Rounded hull path\n */\nconst genMultiPointsRoundedHull = (points, padding) => {\n  const segments = sortByClockwise(points).map((current, i) => {\n    const prev2Index = (i - 2 + points.length) % points.length;\n    const prevIndex = (i - 1 + points.length) % points.length;\n    const nextIndex = (i + 1) % points.length;\n    const prev2 = points[prev2Index];\n    const prev = points[prevIndex];\n    const next = points[nextIndex];\n    const v0 = subtract(prev2, prev);\n    const v1 = subtract(prev, current);\n    const v2 = subtract(current, next);\n    // 判断是否为凹角 ｜ Determine if it is a concave angle\n    const isConcave = (v1, v2) => {\n      return angle(v1, v2, true) < Math.PI;\n    };\n    const concavePrev = isConcave(v0, v1);\n    const concaveNext = isConcave(v1, v2);\n    const offsetVector = v => scale(normalize(perpendicular(v, false)), padding);\n    const offset = offsetVector(v1);\n    return [{\n      p: toVector2(concavePrev ? add(prev, offsetVector(v0)) : add(prev, offset)),\n      concave: concavePrev && prev\n    }, {\n      p: toVector2(concaveNext ? add(current, offsetVector(v2)) : add(current, offset)),\n      concave: concaveNext && current\n    }];\n  });\n  const arcData = [padding, padding, 0, 0, 0];\n  const startIndex = segments.findIndex((segment, i) => !segments[(i - 1 + segments.length) % segments.length][0].concave && !segments[(i - 1 + segments.length) % segments.length][1].concave && !segment[0].concave && !segment[0].concave && !segment[1].concave);\n  const sortedSegments = segments.slice(startIndex).concat(segments.slice(0, startIndex));\n  let concavePoints = [];\n  return sortedSegments.flatMap((segment, i) => {\n    const pathFragment = [];\n    const lastSegment = sortedSegments[segments.length - 1];\n    if (i === 0) pathFragment.push(['M', ...lastSegment[1].p]);\n    if (!segment[0].concave) {\n      pathFragment.push(['A', ...arcData, ...segment[0].p]);\n    } else {\n      concavePoints.push(segment[0].p, segment[1].p);\n    }\n    if (!segment[1].concave) {\n      pathFragment.push(['L', ...segment[1].p]);\n    } else {\n      concavePoints.unshift(segment[1].p);\n    }\n    if (concavePoints.length === 3) {\n      pathFragment.pop();\n      pathFragment.push(['C', ...concavePoints.flat()]);\n      concavePoints = [];\n    }\n    return pathFragment;\n  });\n};\n/**\n * <zh/> 生成多点 Hull 路径且拐角为平滑\n *\n * <en/> Generate Hull Path for multiple points with smooth corners\n * @param points - <zh/> 形成 Hull 的点集 | <en/> Points that form the Hull\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @returns <zh/> 平滑外壳路径 | <en/> Smooth hull path\n */\nconst genMultiPointsSmoothHull = (points, padding) => {\n  const hullPoints = sortByClockwise(points).map((p, i) => {\n    const pNext = points[(i + 1) % points.length];\n    return {\n      p,\n      v: normalize(subtract(pNext, p))\n    };\n  });\n  // Compute the expanded hull points, and the nearest prior control point for each.\n  hullPoints.forEach((hp, i) => {\n    const priorIndex = i > 0 ? i - 1 : points.length - 1;\n    const prevV = hullPoints[priorIndex].v;\n    const extensionVec = normalize(add(prevV, scale(hp.v, angle(prevV, hp.v, true) < Math.PI ? 1 : -1)));\n    hp.p = add(hp.p, scale(extensionVec, padding));\n  });\n  return getClosedSpline(hullPoints.map(obj => obj.p));\n};\n/**\n * <zh/> 生成多点 Hull 路径且拐角为尖锐\n *\n * <en/> Generate Hull Path for multiple points with sharp corners\n * @param points - <zh/> 形成 Hull 的点集 | <en/> Points that form the Hull\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @returns <zh/> 锐角外壳路径 | <en/> Sharp hull path\n */\nconst genMultiPointsSharpHull = (points, padding) => {\n  const segments = points.map((current, i) => {\n    const prev = points[i === 0 ? points.length - 1 : i - 1];\n    const offset = toVector3(scale(normalize(perpendicular(subtract(prev, current), false)), padding));\n    return [add(prev, offset), add(current, offset)];\n  });\n  const arr = segments.flat();\n  const vertices = arr.map((_, i) => {\n    if (i % 2 === 0) return null;\n    const l1 = [arr[(i - 1) % arr.length], arr[i % arr.length]];\n    const l2 = [arr[(i + 1) % arr.length], arr[(i + 2) % arr.length]];\n    return getLinesIntersection(l1, l2, true);\n  }).filter(Boolean);\n  return vertices.map((point, i) => [i === 0 ? 'M' : 'L', point[0], point[1]]).concat([['Z']]);\n};","map":{"version":3,"names":["getLinesIntersection","getClosedSpline","isCollinear","sortByClockwise","add","angle","normalize","perpendicular","scale","subtract","toVector2","toVector3","computeHullPath","points","padding","corner","length","genSinglePointHullPath","genTwoPointsHullPath","p1","p2","p3","genMultiPointsSmoothHull","genMultiPointsSharpHull","genMultiPointsRoundedHull","point","arcData","point1","point2","offsetVector","invOffsetVector","prev","current","segments","map","i","prev2Index","prevIndex","nextIndex","prev2","next","v0","v1","v2","isConcave","Math","PI","concavePrev","concaveNext","v","offset","p","concave","startIndex","findIndex","segment","sortedSegments","slice","concat","concavePoints","flatMap","pathFragment","lastSegment","push","unshift","pop","flat","hullPoints","pNext","forEach","hp","priorIndex","prevV","extensionVec","obj","arr","vertices","_","l1","l2","filter","Boolean"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/plugins/hull/util.ts"],"sourcesContent":["import { type PathArray } from '@antv/util';\nimport type { Point, Vector2 } from '../../types';\nimport { getLinesIntersection } from '../../utils/line';\nimport { getClosedSpline } from '../../utils/path';\nimport { isCollinear, sortByClockwise } from '../../utils/point';\nimport { add, angle, normalize, perpendicular, scale, subtract, toVector2, toVector3 } from '../../utils/vector';\nimport type { HullOptions } from '../hull';\n\n/**\n * <zh/> 计算 Hull 路径\n *\n * <en/> Compute Hull Path\n * @param points - <zh/> 顶点列表 | <en/> Vertices of Hull\n * @param padding - <zh/> 内边距 | <en/> padding\n * @param corner - <zh/> 拐角类型，目前支持 'sharp'、'rounded' 和 'smooth' | <en/> Corner type, currently supports 'sharp', 'rounded' and 'smooth'\n * @returns <zh/> Hull 路径 | <en/> Hull Path\n */\nexport function computeHullPath(points: Point[], padding: number, corner: 'rounded' | 'smooth' | 'sharp'): PathArray {\n  if (points.length === 1) return genSinglePointHullPath(points[0], padding, corner);\n  if (points.length === 2) return genTwoPointsHullPath(points, padding, corner);\n  if (points.length === 3) {\n    const [p1, p2, p3] = sortByClockwise(points);\n    if (isCollinear(p1, p2, p3)) return genTwoPointsHullPath([p1, p3], padding, corner);\n  }\n\n  switch (corner) {\n    case 'smooth':\n      return genMultiPointsSmoothHull(points, padding);\n    case 'sharp':\n      return genMultiPointsSharpHull(points, padding);\n    case 'rounded':\n    default:\n      return genMultiPointsRoundedHull(points, padding);\n  }\n}\n\n/**\n * <zh/> 生成单点 Hull 路径\n *\n * <en/> Generate Hull Path for a single point\n * @param point - <zh/> 单点 | <en/> Single point\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @param corner - <zh/> 拐角类型 | <en/> Corner type\n * @returns <zh/> 单点 Hull 路径 | <en/> Single point Hull Path\n */\nconst genSinglePointHullPath = (point: Point, padding: number, corner: HullOptions['corner']): PathArray => {\n  if (corner === 'sharp')\n    return [\n      ['M', point[0] - padding, point[1] - padding],\n      ['L', point[0] + padding, point[1] - padding],\n      ['L', point[0] + padding, point[1] + padding],\n      ['L', point[0] - padding, point[1] + padding],\n      ['Z'],\n    ];\n  const arcData: [number, number, number, number, number] = [padding, padding, 0, 0, 0];\n  return [\n    ['M', point[0], point[1] - padding],\n    ['A', ...arcData, point[0], point[1] + padding],\n    ['A', ...arcData, point[0], point[1] - padding],\n  ];\n};\n\n/**\n * <zh/> 生成两点 Hull 路径\n *\n * <en/> Generate Hull Path for two points\n * @param points - <zh/> 两点 | <en/> Two points\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @param corner - <zh/> 拐角类型 | <en/> Corner type\n * @returns <zh/> 两点 Hull 路径 | <en/> Two points Hull Path\n */\nconst genTwoPointsHullPath = (points: Point[], padding: number, corner: HullOptions['corner']): PathArray => {\n  const arcData: [number, number, number, number, number] = [padding, padding, 0, 0, 0];\n\n  const point1 =\n    corner === 'sharp' ? add(points[0], scale(normalize(subtract(points[0], points[1])), padding)) : points[0];\n  const point2 =\n    corner === 'sharp' ? add(points[1], scale(normalize(subtract(points[1], points[0])), padding)) : points[1];\n\n  const offsetVector = scale(normalize(perpendicular(subtract(point1, point2) as Vector2, false)), padding);\n  const invOffsetVector = scale(offsetVector, -1);\n\n  const prev = add(point1, offsetVector);\n  const current = add(point2, offsetVector);\n  const p2 = add(point2, invOffsetVector);\n  const p3 = add(point1, invOffsetVector);\n\n  if (corner === 'sharp') {\n    return [['M', prev[0], prev[1]], ['L', current[0], current[1]], ['L', p2[0], p2[1]], ['L', p3[0], p3[1]], ['Z']];\n  }\n\n  return [\n    ['M', prev[0], prev[1]],\n    ['L', current[0], current[1]],\n    ['A', ...arcData, p2[0], p2[1]],\n    ['L', p3[0], p3[1]],\n    ['A', ...arcData, prev[0], prev[1]],\n  ];\n};\n\n/**\n * <zh/> 生成多点 Hull 路径且拐角为圆角\n *\n * <en/> Generate Hull Path for multiple points with rounded corners\n * @param points - <zh/> 形成 Hull 的点集 | <en/> Points that form the Hull\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @returns <zh/> 圆角外壳路径 | <en/> Rounded hull path\n */\nconst genMultiPointsRoundedHull = (points: Point[], padding: number): PathArray => {\n  const segments = sortByClockwise(points).map((current, i) => {\n    const prev2Index = (i - 2 + points.length) % points.length;\n    const prevIndex = (i - 1 + points.length) % points.length;\n    const nextIndex = (i + 1) % points.length;\n    const prev2 = points[prev2Index];\n    const prev = points[prevIndex];\n    const next = points[nextIndex];\n\n    const v0 = subtract(prev2, prev) as Vector2;\n    const v1 = subtract(prev, current) as Vector2;\n    const v2 = subtract(current, next) as Vector2;\n\n    // 判断是否为凹角 ｜ Determine if it is a concave angle\n    const isConcave = (v1: Vector2, v2: Vector2): boolean => {\n      return angle(v1, v2, true) < Math.PI;\n    };\n    const concavePrev = isConcave(v0, v1);\n    const concaveNext = isConcave(v1, v2);\n\n    const offsetVector = (v: Vector2) => scale(normalize(perpendicular(v, false)), padding);\n    const offset = offsetVector(v1);\n    return [\n      {\n        p: toVector2(concavePrev ? add(prev, offsetVector(v0)) : add(prev, offset)),\n        concave: concavePrev && prev,\n      },\n      {\n        p: toVector2(concaveNext ? add(current, offsetVector(v2)) : add(current, offset)),\n        concave: concaveNext && current,\n      },\n    ];\n  });\n\n  const arcData = [padding, padding, 0, 0, 0];\n  const startIndex = segments.findIndex(\n    (segment, i) =>\n      !segments[(i - 1 + segments.length) % segments.length][0].concave &&\n      !segments[(i - 1 + segments.length) % segments.length][1].concave &&\n      !segment[0].concave &&\n      !segment[0].concave &&\n      !segment[1].concave,\n  );\n  const sortedSegments = segments.slice(startIndex).concat(segments.slice(0, startIndex));\n  let concavePoints: Point[] = [];\n  return sortedSegments.flatMap((segment, i) => {\n    const pathFragment = [];\n    const lastSegment = sortedSegments[segments.length - 1];\n    if (i === 0) pathFragment.push(['M', ...lastSegment[1].p]);\n    if (!segment[0].concave) {\n      pathFragment.push(['A', ...arcData, ...segment[0].p]);\n    } else {\n      concavePoints.push(segment[0].p, segment[1].p);\n    }\n    if (!segment[1].concave) {\n      pathFragment.push(['L', ...segment[1].p]);\n    } else {\n      concavePoints.unshift(segment[1].p);\n    }\n    if (concavePoints.length === 3) {\n      pathFragment.pop();\n      pathFragment.push(['C', ...concavePoints.flat()]);\n      concavePoints = [];\n    }\n    return pathFragment;\n  }) as PathArray;\n};\n\n/**\n * <zh/> 生成多点 Hull 路径且拐角为平滑\n *\n * <en/> Generate Hull Path for multiple points with smooth corners\n * @param points - <zh/> 形成 Hull 的点集 | <en/> Points that form the Hull\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @returns <zh/> 平滑外壳路径 | <en/> Smooth hull path\n */\nconst genMultiPointsSmoothHull = (points: Point[], padding: number): PathArray => {\n  const hullPoints = sortByClockwise(points).map((p, i) => {\n    const pNext = points[(i + 1) % points.length];\n    return { p, v: normalize(subtract(pNext, p)) };\n  });\n\n  // Compute the expanded hull points, and the nearest prior control point for each.\n  hullPoints.forEach((hp, i) => {\n    const priorIndex = i > 0 ? i - 1 : points.length - 1;\n    const prevV = hullPoints[priorIndex].v as Vector2;\n    const extensionVec = normalize(add(prevV, scale(hp.v, angle(prevV, hp.v, true) < Math.PI ? 1 : -1)));\n    hp.p = add(hp.p, scale(extensionVec, padding));\n  });\n\n  return getClosedSpline(hullPoints.map((obj) => obj.p));\n};\n\n/**\n * <zh/> 生成多点 Hull 路径且拐角为尖锐\n *\n * <en/> Generate Hull Path for multiple points with sharp corners\n * @param points - <zh/> 形成 Hull 的点集 | <en/> Points that form the Hull\n * @param padding - <zh/> 内边距 | <en/> Padding\n * @returns <zh/> 锐角外壳路径 | <en/> Sharp hull path\n */\nconst genMultiPointsSharpHull = (points: Point[], padding: number): PathArray => {\n  const segments = points.map((current, i) => {\n    const prev = points[i === 0 ? points.length - 1 : i - 1];\n    const offset = toVector3(scale(normalize(perpendicular(subtract(prev, current) as Vector2, false)), padding));\n    return [add(prev, offset), add(current, offset)];\n  });\n\n  const arr = segments.flat();\n\n  const vertices = arr\n    .map((_, i) => {\n      if (i % 2 === 0) return null;\n      const l1 = [arr[(i - 1) % arr.length], arr[i % arr.length]] as [Point, Point];\n      const l2 = [arr[(i + 1) % arr.length], arr[(i + 2) % arr.length]] as [Point, Point];\n      return getLinesIntersection(l1, l2, true);\n    })\n    .filter(Boolean) as Point[];\n  return vertices.map((point, i) => [i === 0 ? 'M' : 'L', point[0], point[1]]).concat([['Z']]) as PathArray;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}