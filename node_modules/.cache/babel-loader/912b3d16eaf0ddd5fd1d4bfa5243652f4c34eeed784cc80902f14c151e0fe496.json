{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isFisheye } from '../../utils/coordinate';\nimport { Symbols } from '../../utils/marker';\nimport { select } from '../../utils/selection';\nimport { camelCase } from '../../utils/string';\nimport { applyStyle, getOrigin, toOpacityKey } from '../utils';\nexport function getRadius(mode, points, value, coordinate) {\n  if (points.length === 1) return undefined;\n  const {\n    size\n  } = value;\n  if (mode === 'fixed') return size;\n  if (mode === 'normal' || isFisheye(coordinate)) {\n    const [[x0, y0], [x2, y2]] = points;\n    const a = Math.abs((x2 - x0) / 2);\n    const b = Math.abs((y2 - y0) / 2);\n    return Math.max(0, (a + b) / 2);\n  }\n  return size;\n}\n/**\n * Render point in different coordinate.\n */\nexport const Color = (options, context) => {\n  // Render border only when colorAttribute is stroke.\n  const {\n      colorAttribute,\n      symbol,\n      mode = 'auto'\n    } = options,\n    style = __rest(options, [\"colorAttribute\", \"symbol\", \"mode\"]);\n  const path = Symbols.get(camelCase(symbol)) || Symbols.get('point');\n  const {\n    coordinate,\n    document\n  } = context;\n  return (points, value, defaults) => {\n    const {\n      lineWidth,\n      color: defaultColor\n    } = defaults;\n    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;\n    const {\n      color = defaultColor,\n      transform,\n      opacity\n    } = value;\n    const [cx, cy] = getOrigin(points);\n    const r = getRadius(mode, points, value, coordinate);\n    const finalRadius = r || style.r || defaults.r;\n    return select(document.createElement('path', {})).call(applyStyle, defaults).style('fill', 'transparent').style('d', path(cx, cy, finalRadius)).style('lineWidth', finalLineWidth).style('transform', transform).style('transformOrigin', `${cx - finalRadius} ${cy - finalRadius}`).style('stroke', color).style(toOpacityKey(options), opacity).style(colorAttribute, color).call(applyStyle, style).node();\n  };\n};\nColor.props = {\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut'\n};","map":{"version":3,"names":["isFisheye","Symbols","select","camelCase","applyStyle","getOrigin","toOpacityKey","getRadius","mode","points","value","coordinate","length","undefined","size","x0","y0","x2","y2","a","Math","abs","b","max","Color","options","context","colorAttribute","symbol","style","__rest","path","get","document","defaults","lineWidth","color","defaultColor","finalLineWidth","stroke","transform","opacity","cx","cy","r","finalRadius","createElement","call","node","props","defaultEnterAnimation","defaultUpdateAnimation","defaultExitAnimation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/point/color.ts"],"sourcesContent":["import { Coordinate, Vector2 } from '@antv/coord';\nimport { ShapeComponent as SC } from '../../runtime';\nimport { isFisheye } from '../../utils/coordinate';\nimport { Symbols } from '../../utils/marker';\nimport { select } from '../../utils/selection';\nimport { camelCase } from '../../utils/string';\nimport { applyStyle, getOrigin, toOpacityKey } from '../utils';\n\nexport type ColorOptions = {\n  colorAttribute: 'fill' | 'stroke';\n  symbol: string;\n  mode?: 'fixed' | 'auto' | 'normal';\n  [key: string]: any;\n};\n\nexport function getRadius(\n  mode: ColorOptions['mode'],\n  points: Vector2[],\n  value: Record<string, any>,\n  coordinate: Coordinate,\n) {\n  if (points.length === 1) return undefined;\n  const { size } = value;\n  if (mode === 'fixed') return size;\n  if (mode === 'normal' || isFisheye(coordinate)) {\n    const [[x0, y0], [x2, y2]] = points;\n    const a = Math.abs((x2 - x0) / 2);\n    const b = Math.abs((y2 - y0) / 2);\n    return Math.max(0, (a + b) / 2);\n  }\n  return size;\n}\n\n/**\n * Render point in different coordinate.\n */\nexport const Color: SC<ColorOptions> = (options, context) => {\n  // Render border only when colorAttribute is stroke.\n  const { colorAttribute, symbol, mode = 'auto', ...style } = options;\n  const path = Symbols.get(camelCase(symbol)) || Symbols.get('point');\n  const { coordinate, document } = context;\n  return (points, value, defaults) => {\n    const { lineWidth, color: defaultColor } = defaults;\n    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;\n    const { color = defaultColor, transform, opacity } = value;\n    const [cx, cy] = getOrigin(points);\n    const r = getRadius(mode, points, value, coordinate);\n    const finalRadius = r || style.r || defaults.r;\n    return select(document.createElement('path', {}))\n      .call(applyStyle, defaults)\n      .style('fill', 'transparent')\n      .style('d', path(cx, cy, finalRadius))\n      .style('lineWidth', finalLineWidth)\n      .style('transform', transform)\n      .style('transformOrigin', `${cx - finalRadius} ${cy - finalRadius}`)\n      .style('stroke', color)\n      .style(toOpacityKey(options), opacity)\n      .style(colorAttribute, color)\n      .call(applyStyle, style)\n      .node();\n  };\n};\n\nColor.props = {\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut',\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}