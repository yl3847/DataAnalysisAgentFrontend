{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar initOrder = require(\"./init-order\");\nvar crossCount = require(\"./cross-count\");\nvar sortSubgraph = require(\"./sort-subgraph\");\nvar buildLayerGraph = require(\"./build-layer-graph\");\nvar addSubgraphConstraints = require(\"./add-subgraph-constraints\");\nvar Graph = require(\"../graphlib\").Graph;\nvar util = require(\"../util\");\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n  assignOrder(g, best);\n}\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function (lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n}","map":{"version":3,"names":["_","require","initOrder","crossCount","sortSubgraph","buildLayerGraph","addSubgraphConstraints","Graph","util","module","exports","order","g","maxRank","downLayerGraphs","buildLayerGraphs","range","upLayerGraphs","layering","assignOrder","bestCC","Number","POSITIVE_INFINITY","best","i","lastBest","sweepLayerGraphs","buildLayerMatrix","cc","cloneDeep","ranks","relationship","map","rank","layerGraphs","biasRight","cg","forEach","lg","root","graph","sorted","vs","v","node","layer"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/dagre/lib/order/index.js"],"sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar initOrder = require(\"./init-order\");\nvar crossCount = require(\"./cross-count\");\nvar sortSubgraph = require(\"./sort-subgraph\");\nvar buildLayerGraph = require(\"./build-layer-graph\");\nvar addSubgraphConstraints = require(\"./add-subgraph-constraints\");\nvar Graph = require(\"../graphlib\").Graph;\nvar util = require(\"../util\");\n\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function(rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function(lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function(v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}