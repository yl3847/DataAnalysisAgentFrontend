{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Graph } from '@antv/graphlib';\nimport { isNumber } from '@antv/util';\nimport { layout } from './antv-dagre/layout';\nimport { cloneFormatData, formatNumberFn, formatSizeFn } from './util';\nimport { parseSize } from './util/size';\nconst DEFAULTS_LAYOUT_OPTIONS = {\n  rankdir: 'TB',\n  nodesep: 50,\n  ranksep: 50,\n  edgeLabelSpace: true,\n  ranker: 'tight-tree',\n  controlPoints: false,\n  radial: false,\n  focusNode: null // radial 为 true 时生效，关注的节点\n};\n/**\n * <zh/> AntV 实现的 Dagre 布局\n *\n * <en/> AntV implementation of Dagre layout\n */\nexport class AntVDagreLayout {\n  constructor(options = {}) {\n    this.options = options;\n    this.id = 'antv-dagre';\n    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);\n  }\n  /**\n   * Return the positions of nodes and edges(if needed).\n   */\n  execute(graph, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.genericDagreLayout(false, graph, options);\n    });\n  }\n  /**\n   * To directly assign the positions to the nodes.\n   */\n  assign(graph, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.genericDagreLayout(true, graph, options);\n    });\n  }\n  genericDagreLayout(assign, graph, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const mergedOptions = Object.assign(Object.assign({}, this.options), options);\n      const {\n        nodeSize,\n        align,\n        rankdir = 'TB',\n        ranksep,\n        nodesep,\n        ranksepFunc,\n        nodesepFunc,\n        edgeLabelSpace,\n        ranker,\n        nodeOrder,\n        begin,\n        controlPoints,\n        radial,\n        sortByCombo,\n        // focusNode,\n        preset\n      } = mergedOptions;\n      const g = new Graph({\n        tree: []\n      });\n      const ranksepfunc = formatNumberFn(ranksep || 50, ranksepFunc);\n      const nodesepfunc = formatNumberFn(nodesep || 50, nodesepFunc);\n      let horisep = nodesepfunc;\n      let vertisep = ranksepfunc;\n      if (rankdir === 'LR' || rankdir === 'RL') {\n        horisep = ranksepfunc;\n        vertisep = nodesepfunc;\n      }\n      const nodeSizeFunc = formatSizeFn(10, nodeSize, false);\n      // copy graph to g\n      const nodes = graph.getAllNodes();\n      const edges = graph.getAllEdges();\n      nodes.forEach(node => {\n        const size = parseSize(nodeSizeFunc(node));\n        const verti = vertisep(node);\n        const hori = horisep(node);\n        const width = size[0] + 2 * hori;\n        const height = size[1] + 2 * verti;\n        const layer = node.data.layer;\n        if (isNumber(layer)) {\n          // 如果有layer属性，加入到node的label中\n          g.addNode({\n            id: node.id,\n            data: {\n              width,\n              height,\n              layer\n            }\n          });\n        } else {\n          g.addNode({\n            id: node.id,\n            data: {\n              width,\n              height\n            }\n          });\n        }\n      });\n      if (sortByCombo) {\n        g.attachTreeStructure('combo');\n        nodes.forEach(node => {\n          const {\n            parentId\n          } = node.data;\n          if (parentId === undefined) return;\n          if (g.hasNode(parentId)) {\n            g.setParent(node.id, parentId, 'combo');\n          }\n        });\n      }\n      edges.forEach(edge => {\n        // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n        g.addEdge({\n          id: edge.id,\n          source: edge.source,\n          target: edge.target,\n          data: {\n            weight: edge.data.weight || 1\n          }\n        });\n      });\n      let prevGraph = undefined;\n      if (preset === null || preset === void 0 ? void 0 : preset.length) {\n        prevGraph = new Graph({\n          nodes: preset\n        });\n      }\n      layout(g, {\n        prevGraph,\n        edgeLabelSpace,\n        keepNodeOrder: !!nodeOrder,\n        nodeOrder: nodeOrder || [],\n        acyclicer: 'greedy',\n        ranker,\n        rankdir,\n        nodesep,\n        align\n      });\n      const layoutTopLeft = [0, 0];\n      if (begin) {\n        let minX = Infinity;\n        let minY = Infinity;\n        g.getAllNodes().forEach(node => {\n          if (minX > node.data.x) minX = node.data.x;\n          if (minY > node.data.y) minY = node.data.y;\n        });\n        g.getAllEdges().forEach(edge => {\n          var _a;\n          (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach(point => {\n            if (minX > point.x) minX = point.x;\n            if (minY > point.y) minY = point.y;\n          });\n        });\n        layoutTopLeft[0] = begin[0] - minX;\n        layoutTopLeft[1] = begin[1] - minY;\n      }\n      const isHorizontal = rankdir === 'LR' || rankdir === 'RL';\n      if (radial) {\n        // const focusId = (isString(focusNode) ? focusNode : focusNode?.id) as ID;\n        // const focusLayer = focusId ? g.getNode(focusId)?.data._rank as number : 0;\n        // const layers: any[] = [];\n        // const dim = isHorizontal ? \"y\" : \"x\";\n        // const sizeDim = isHorizontal ? \"height\" : \"width\";\n        // // 找到整个图作为环的坐标维度（dim）的最大、最小值，考虑节点宽度\n        // let min = Infinity;\n        // let max = -Infinity;\n        // g.getAllNodes().forEach((node) => {\n        //   const currentNodesep = nodesepfunc(node);\n        //   if (focusLayer === 0) {\n        //     if (!layers[node.data._rank!]) {\n        //       layers[node.data._rank!] = {\n        //         nodes: [],\n        //         totalWidth: 0,\n        //         maxSize: -Infinity,\n        //       };\n        //     }\n        //     layers[node.data._rank!].nodes.push(node);\n        //     layers[node.data._rank!].totalWidth += currentNodesep * 2 + node.data[sizeDim]!;\n        //     if (\n        //       layers[node.data._rank!].maxSize < Math.max(node.data.width!, node.data.height!)\n        //     ) {\n        //       layers[node.data._rank!].maxSize = Math.max(node.data.width!, node.data.height!);\n        //     }\n        //   } else {\n        //     const diffLayer = node.data._rank! - focusLayer!;\n        //     if (diffLayer === 0) {\n        //       if (!layers[diffLayer]) {\n        //         layers[diffLayer] = {\n        //           nodes: [],\n        //           totalWidth: 0,\n        //           maxSize: -Infinity,\n        //         };\n        //       }\n        //       layers[diffLayer].nodes.push(node);\n        //       layers[diffLayer].totalWidth += currentNodesep * 2 + node.data[sizeDim]!;\n        //       if (\n        //         layers[diffLayer].maxSize < Math.max(node.data.width!, node.data.height!)\n        //       ) {\n        //         layers[diffLayer].maxSize = Math.max(node.data.width!, node.data.height!);\n        //       }\n        //     } else {\n        //       const diffLayerAbs = Math.abs(diffLayer);\n        //       if (!layers[diffLayerAbs]) {\n        //         layers[diffLayerAbs] = {\n        //           left: [],\n        //           right: [],\n        //           totalWidth: 0,\n        //           maxSize: -Infinity,\n        //         };\n        //       }\n        //       layers[diffLayerAbs].totalWidth +=\n        //         currentNodesep * 2 + node.data[sizeDim]!;\n        //       if (\n        //         layers[diffLayerAbs].maxSize < Math.max(node.data.width!, node.data.height!)\n        //       ) {\n        //         layers[diffLayerAbs].maxSize = Math.max(\n        //           node.data.width!,\n        //           node.data.height!\n        //         );\n        //       }\n        //       if (diffLayer < 0) {\n        //         layers[diffLayerAbs].left.push(node);\n        //       } else {\n        //         layers[diffLayerAbs].right.push(node);\n        //       }\n        //     }\n        //   }\n        //   const leftPos = node.data[dim]! - node.data[sizeDim]! / 2 - currentNodesep;\n        //   const rightPos = node.data[dim]! + node.data[sizeDim]! / 2 + currentNodesep;\n        //   if (leftPos < min) min = leftPos;\n        //   if (rightPos > max) max = rightPos;\n        // });\n        // // const padding = (max - min) * 0.1; // TODO\n        // // 初始化为第一圈的半径，后面根据每层 ranksep 叠加\n        // let radius = ranksep || 50; // TODO;\n        // const radiusMap: any = {};\n        // // 扩大最大最小值范围，以便为环上留出接缝处的空隙\n        // const rangeLength = (max - min) / 0.9;\n        // const range = [\n        //   (min + max - rangeLength) * 0.5,\n        //   (min + max + rangeLength) * 0.5,\n        // ];\n        // // 根据半径、分布比例，计算节点在环上的位置，并返回该组节点中最大的 ranksep 值\n        // const processNodes = (\n        //   layerNodes: any,\n        //   radius: number,\n        //   propsMaxRanksep = -Infinity,\n        //   arcRange = [0, 1]\n        // ) => {\n        //   let maxRanksep = propsMaxRanksep;\n        //   layerNodes.forEach((node: any) => {\n        //     const coord = g.node(node);\n        //     radiusMap[node] = radius;\n        //     // 获取变形为 radial 后的直角坐标系坐标\n        //     const { x: newX, y: newY } = getRadialPos(\n        //       coord![dim]!,\n        //       range,\n        //       rangeLength,\n        //       radius,\n        //       arcRange\n        //     );\n        //     // 将新坐标写入源数据\n        //     const i = nodes.findIndex((it) => it.id === node);\n        //     if (!nodes[i]) return;\n        //     nodes[i].x = newX + dBegin[0];\n        //     nodes[i].y = newY + dBegin[1];\n        //     // @ts-ignore: pass layer order to data for increment layout use\n        //     nodes[i]._order = coord._order;\n        //     // 找到本层最大的一个 ranksep，作为下一层与本层的间隙，叠加到下一层的半径上\n        //     const currentNodeRanksep = ranksepfunc(nodes[i]);\n        //     if (maxRanksep < currentNodeRanksep) maxRanksep = currentNodeRanksep;\n        //   });\n        //   return maxRanksep;\n        // };\n        // let isFirstLevel = true;\n        // const lastLayerMaxNodeSize = 0;\n        // layers.forEach((layerNodes) => {\n        //   if (\n        //     !layerNodes?.nodes?.length &&\n        //     !layerNodes?.left?.length &&\n        //     !layerNodes?.right?.length\n        //   ) {\n        //     return;\n        //   }\n        //   // 第一层只有一个节点，直接放在圆心，初始半径设定为 0\n        //   if (isFirstLevel && layerNodes.nodes.length === 1) {\n        //     // 将新坐标写入源数据\n        //     const i = nodes.findIndex((it) => it.id === layerNodes.nodes[0]);\n        //     if (i <= -1) return;\n        //     nodes[i].x = dBegin[0];\n        //     nodes[i].y = dBegin[1];\n        //     radiusMap[layerNodes.nodes[0]] = 0;\n        //     radius = ranksepfunc(nodes[i]);\n        //     isFirstLevel = false;\n        //     return;\n        //   }\n        //   // 为接缝留出空隙，半径也需要扩大\n        //   radius = Math.max(radius, layerNodes.totalWidth / (2 * Math.PI)); // / 0.9;\n        //   let maxRanksep = -Infinity;\n        //   if (focusLayer === 0 || layerNodes.nodes?.length) {\n        //     maxRanksep = processNodes(\n        //       layerNodes.nodes,\n        //       radius,\n        //       maxRanksep,\n        //       [0, 1]\n        //     ); // 0.8\n        //   } else {\n        //     const leftRatio =\n        //       layerNodes.left?.length /\n        //       (layerNodes.left?.length + layerNodes.right?.length);\n        //     maxRanksep = processNodes(layerNodes.left, radius, maxRanksep, [\n        //       0,\n        //       leftRatio,\n        //     ]); // 接缝留出 0.05 的缝隙\n        //     maxRanksep = processNodes(layerNodes.right, radius, maxRanksep, [\n        //       leftRatio + 0.05,\n        //       1,\n        //     ]); // 接缝留出 0.05 的缝隙\n        //   }\n        //   radius += maxRanksep;\n        //   isFirstLevel = false;\n        //   lastLayerMaxNodeSize - layerNodes.maxSize;\n        // });\n        // g.edges().forEach((edge: any) => {\n        //   const coord = g.edge(edge);\n        //   const i = edges.findIndex((it) => {\n        //     const source = getEdgeTerminal(it, \"source\");\n        //     const target = getEdgeTerminal(it, \"target\");\n        //     return source === edge.v && target === edge.w;\n        //   });\n        //   if (i <= -1) return;\n        //   if (\n        //     self.edgeLabelSpace &&\n        //     self.controlPoints &&\n        //     edges[i].type !== \"loop\"\n        //   ) {\n        //     const otherDim = dim === \"x\" ? \"y\" : \"x\";\n        //     const controlPoints = coord?.points?.slice(\n        //       1,\n        //       coord.points.length - 1\n        //     );\n        //     const newControlPoints: Point[] = [];\n        //     const sourceOtherDimValue = g.node(edge.v)?.[otherDim]!;\n        //     const otherDimDist =\n        //       sourceOtherDimValue - g.node(edge.w)?.[otherDim]!;\n        //     const sourceRadius = radiusMap[edge.v];\n        //     const radiusDist = sourceRadius - radiusMap[edge.w];\n        //     controlPoints?.forEach((point: any) => {\n        //       // 根据该边的起点、终点半径，及起点、终点、控制点位置关系，确定该控制点的半径\n        //       const cRadius =\n        //         ((point[otherDim] - sourceOtherDimValue) / otherDimDist) *\n        //           radiusDist +\n        //         sourceRadius;\n        //       // 获取变形为 radial 后的直角坐标系坐标\n        //       const newPos = getRadialPos(\n        //         point[dim],\n        //         range,\n        //         rangeLength,\n        //         cRadius\n        //       );\n        //       newControlPoints.push({\n        //         x: newPos.x + dBegin[0],\n        //         y: newPos.y + dBegin[1],\n        //       });\n        //     });\n        //     edges[i].controlPoints = newControlPoints;\n        //   }\n        // });\n      } else {\n        const layerCoords = new Set();\n        const isInvert = rankdir === 'BT' || rankdir === 'RL';\n        const layerCoordSort = isInvert ? (a, b) => b - a : (a, b) => a - b;\n        g.getAllNodes().forEach(node => {\n          // let ndata: any = this.nodeMap[node];\n          // if (!ndata) {\n          //   ndata = combos?.find((it) => it.id === node);\n          // }\n          // if (!ndata) return;\n          // ndata.x = node.data.x! + dBegin[0];\n          // ndata.y = node.data.y! + dBegin[1];\n          // //  pass layer order to data for increment layout use\n          // ndata._order = node.data._order;\n          // layerCoords.add(isHorizontal ? ndata.x : ndata.y);\n          node.data.x = node.data.x + layoutTopLeft[0];\n          node.data.y = node.data.y + layoutTopLeft[1];\n          layerCoords.add(isHorizontal ? node.data.x : node.data.y);\n        });\n        const layerCoordsArr = Array.from(layerCoords).sort(layerCoordSort);\n        // pre-define the isHorizontal related functions to avoid redundant calc in interations\n        const isDifferentLayer = isHorizontal ? (point1, point2) => point1.x !== point2.x : (point1, point2) => point1.y !== point2.y;\n        const filterControlPointsOutOfBoundary = isHorizontal ? (ps, point1, point2) => {\n          const max = Math.max(point1.y, point2.y);\n          const min = Math.min(point1.y, point2.y);\n          return ps.filter(point => point.y <= max && point.y >= min);\n        } : (ps, point1, point2) => {\n          const max = Math.max(point1.x, point2.x);\n          const min = Math.min(point1.x, point2.x);\n          return ps.filter(point => point.x <= max && point.x >= min);\n        };\n        g.getAllEdges().forEach((edge, i) => {\n          var _a;\n          // const i = edges.findIndex((it) => {\n          //   return it.source === edge.source && it.target === edge.target;\n          // });\n          // if (i <= -1) return;\n          if (edgeLabelSpace && controlPoints && edge.data.type !== 'loop') {\n            edge.data.controlPoints = getControlPoints((_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.map(({\n              x,\n              y\n            }) => ({\n              x: x + layoutTopLeft[0],\n              y: y + layoutTopLeft[1]\n            })), g.getNode(edge.source), g.getNode(edge.target), layerCoordsArr, isHorizontal, isDifferentLayer, filterControlPointsOutOfBoundary);\n          }\n        });\n      }\n      // calculated nodes as temporary result\n      let layoutNodes = [];\n      // layout according to the original order in the data.nodes\n      layoutNodes = g.getAllNodes().map(node => cloneFormatData(node));\n      const layoutEdges = g.getAllEdges();\n      if (assign) {\n        layoutNodes.forEach(node => {\n          graph.mergeNodeData(node.id, {\n            x: node.data.x,\n            y: node.data.y\n          });\n        });\n        layoutEdges.forEach(edge => {\n          graph.mergeEdgeData(edge.id, {\n            controlPoints: edge.data.controlPoints\n          });\n        });\n      }\n      const result = {\n        nodes: layoutNodes,\n        edges: layoutEdges\n      };\n      return result;\n    });\n  }\n}\n/**\n * Format controlPoints to avoid polylines crossing nodes\n * @param points\n * @param sourceNode\n * @param targetNode\n * @param layerCoordsArr\n * @param isHorizontal\n * @returns\n */\nconst getControlPoints = (points, sourceNode, targetNode, layerCoordsArr, isHorizontal, isDifferentLayer, filterControlPointsOutOfBoundary) => {\n  let controlPoints = (points === null || points === void 0 ? void 0 : points.slice(1, points.length - 1)) || []; // 去掉头尾\n  // 酌情增加控制点，使折线不穿过跨层的节点\n  if (sourceNode && targetNode) {\n    let {\n      x: sourceX,\n      y: sourceY\n    } = sourceNode.data;\n    let {\n      x: targetX,\n      y: targetY\n    } = targetNode.data;\n    if (isHorizontal) {\n      sourceX = sourceNode.data.y;\n      sourceY = sourceNode.data.x;\n      targetX = targetNode.data.y;\n      targetY = targetNode.data.x;\n    }\n    // 为跨层级的边增加第一个控制点。忽略垂直的/横向的边。\n    // 新控制点 = {\n    //   x: 终点x,\n    //   y: (起点y + 下一层y) / 2,   #下一层y可能不等于终点y\n    // }\n    if (targetY !== sourceY && sourceX !== targetX) {\n      const sourceLayer = layerCoordsArr.indexOf(sourceY);\n      const sourceNextLayerCoord = layerCoordsArr[sourceLayer + 1];\n      if (sourceNextLayerCoord) {\n        const firstControlPoint = controlPoints[0];\n        const insertStartControlPoint = isHorizontal ? {\n          x: (sourceY + sourceNextLayerCoord) / 2,\n          y: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.y) || targetX\n        } : {\n          x: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.x) || targetX,\n          y: (sourceY + sourceNextLayerCoord) / 2\n        };\n        // 当新增的控制点不存在（!=当前第一个控制点）时添加\n        if (!firstControlPoint || isDifferentLayer(firstControlPoint, insertStartControlPoint)) {\n          controlPoints.unshift(insertStartControlPoint);\n        }\n      }\n      const targetLayer = layerCoordsArr.indexOf(targetY);\n      const layerDiff = Math.abs(targetLayer - sourceLayer);\n      if (layerDiff === 1) {\n        controlPoints = filterControlPointsOutOfBoundary(controlPoints, sourceNode.data, targetNode.data);\n        // one controlPoint at least\n        if (!controlPoints.length) {\n          controlPoints.push(isHorizontal ? {\n            x: (sourceY + targetY) / 2,\n            y: sourceX\n          } : {\n            x: sourceX,\n            y: (sourceY + targetY) / 2\n          });\n        }\n      } else if (layerDiff > 1) {\n        const targetLastLayerCoord = layerCoordsArr[targetLayer - 1];\n        if (targetLastLayerCoord) {\n          const lastControlPoints = controlPoints[controlPoints.length - 1];\n          const insertEndControlPoint = isHorizontal ? {\n            x: (targetY + targetLastLayerCoord) / 2,\n            y: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.y) || targetX\n          } : {\n            x: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.x) || sourceX,\n            y: (targetY + targetLastLayerCoord) / 2\n          };\n          // 当新增的控制点不存在（!=当前最后一个控制点）时添加\n          if (!lastControlPoints || isDifferentLayer(lastControlPoints, insertEndControlPoint)) {\n            controlPoints.push(insertEndControlPoint);\n          }\n        }\n      }\n    }\n  }\n  return controlPoints;\n};","map":{"version":3,"names":["Graph","isNumber","layout","cloneFormatData","formatNumberFn","formatSizeFn","parseSize","DEFAULTS_LAYOUT_OPTIONS","rankdir","nodesep","ranksep","edgeLabelSpace","ranker","controlPoints","radial","focusNode","AntVDagreLayout","constructor","options","id","Object","assign","execute","graph","genericDagreLayout","mergedOptions","nodeSize","align","ranksepFunc","nodesepFunc","nodeOrder","begin","sortByCombo","preset","g","tree","ranksepfunc","nodesepfunc","horisep","vertisep","nodeSizeFunc","nodes","getAllNodes","edges","getAllEdges","forEach","node","size","verti","hori","width","height","layer","data","addNode","attachTreeStructure","parentId","undefined","hasNode","setParent","edge","addEdge","source","target","weight","prevGraph","length","keepNodeOrder","acyclicer","layoutTopLeft","minX","Infinity","minY","x","y","_a","points","point","isHorizontal","layerCoords","Set","isInvert","layerCoordSort","a","b","add","layerCoordsArr","Array","from","sort","isDifferentLayer","point1","point2","filterControlPointsOutOfBoundary","ps","max","Math","min","filter","i","type","getControlPoints","map","getNode","layoutNodes","layoutEdges","mergeNodeData","mergeEdgeData","result","sourceNode","targetNode","slice","sourceX","sourceY","targetX","targetY","sourceLayer","indexOf","sourceNextLayerCoord","firstControlPoint","insertStartControlPoint","unshift","targetLayer","layerDiff","abs","push","targetLastLayerCoord","lastControlPoints","insertEndControlPoint"],"sources":["../src/antv-dagre.ts"],"sourcesContent":[null],"mappings":"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AI,CAACoB,CAAE;UAC5C,IAAID,IAAI,GAAG1B,IAAI,CAACO,IAAI,CAACqB,CAAE,EAAEF,IAAI,GAAG1B,IAAI,CAACO,IAAI,CAACqB,CAAE;QAC9C,CAAC,CAAC;QACFxC,CAAC,CAACU,WAAW,EAAE,CAACC,OAAO,CAAEe,IAAI,IAAI;;UAC/B,CAAAe,EAAA,GAAAf,IAAI,CAACP,IAAI,CAACuB,MAAM,cAAAD,EAAA,uBAAAA,EAAA,CAAE9B,OAAO,CAAEgC,KAAY,IAAI;YACzC,IAAIP,IAAI,GAAGO,KAAK,CAACJ,CAAC,EAAEH,IAAI,GAAGO,KAAK,CAACJ,CAAC;YAClC,IAAID,IAAI,GAAGK,KAAK,CAACH,CAAC,EAAEF,IAAI,GAAGK,KAAK,CAACH,CAAC;UACpC,CAAC,CAAC;QACJ,CAAC,CAAC;QACFL,aAAa,CAAC,CAAC,CAAC,GAAGtC,KAAK,CAAC,CAAC,CAAC,GAAGuC,IAAI;QAClCD,aAAa,CAAC,CAAC,CAAC,GAAGtC,KAAK,CAAC,CAAC,CAAC,GAAGyC,IAAI;;MAGpC,MAAMM,YAAY,GAAGtE,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,IAAI;MACzD,IAAIM,MAAM,EAAE;QACV;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;MAAA,CACD,MAAM;QACL,MAAMiE,WAAW,GAAgB,IAAIC,GAAG,EAAE;QAC1C,MAAMC,QAAQ,GAAGzE,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,IAAI;QACrD,MAAM0E,cAAc,GAAGD,QAAQ,GAC3B,CAACE,CAAS,EAAEC,CAAS,KAAKA,CAAC,GAAGD,CAAC,GAC/B,CAACA,CAAS,EAAEC,CAAS,KAAKD,CAAC,GAAGC,CAAC;QACnClD,CAAC,CAACQ,WAAW,EAAE,CAACG,OAAO,CAAEC,IAAI,IAAI;UAC/B;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UAEAA,IAAI,CAACO,IAAI,CAACoB,CAAC,GAAG3B,IAAI,CAACO,IAAI,CAACoB,CAAE,GAAGJ,aAAa,CAAC,CAAC,CAAC;UAC7CvB,IAAI,CAACO,IAAI,CAACqB,CAAC,GAAG5B,IAAI,CAACO,IAAI,CAACqB,CAAE,GAAGL,aAAa,CAAC,CAAC,CAAC;UAC7CU,WAAW,CAACM,GAAG,CAACP,YAAY,GAAGhC,IAAI,CAACO,IAAI,CAACoB,CAAC,GAAG3B,IAAI,CAACO,IAAI,CAACqB,CAAC,CAAC;QAC3D,CAAC,CAAC;QACF,M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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}