{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { area, areaRadial } from '@antv/vendor/d3-shape';\nimport { select } from '../../utils/selection';\nimport { isPolar, isTranspose } from '../../utils/coordinate';\nimport { angleWithQuadrant, sub, dist } from '../../utils/vector';\nimport { applyStyle, computeGradient, getTransform } from '../utils';\nimport { subObject } from '../../utils/helper';\nimport { createElement } from '../../utils/createElement';\n/**\n * Given a points sequence, split it into an array of defined points\n * and an array of undefined segments.\n *\n * Input - [p0, p1, p2, p3, p4, p5], p1 ~ p2 is `Y1`, p3 ~ p5 is `Y0`.\n * Output - When all of Y1 & Y0 is defined, move into defined points, or else undefined segments.\n */\nfunction segmentation(points, defined) {\n  const definedPointsY1 = [];\n  const definedPointsY0 = [];\n  const segments = [];\n  let m = false; // Is in a undefined sequence.\n  let dp = null; // The previous defined point.\n  const mid = points.length / 2;\n  for (let i = 0; i < mid; i++) {\n    const y1 = points[i];\n    const y0 = points[i + mid];\n    // If current point is a undefined point,\n    // enter a undefined sequence.\n    if ([...y1, ...y0].some(v => !defined(v))) m = true;else {\n      definedPointsY1.push(y1);\n      definedPointsY0.push(y0);\n      // If current point is a defined point,\n      // and is in a undefined sequence, save\n      // the two closest defined points as this\n      // undefined sequence and exit it.\n      if (m && dp) {\n        m = false;\n        const [dpy1, dpy0] = dp;\n        segments.push([dpy1, y1, dpy0, y0]);\n      }\n      // Update the previous defined point.\n      dp = [y1, y0];\n    }\n  }\n  return [definedPointsY1.concat(definedPointsY0), segments];\n}\nconst DoubleArea = createElement(g => {\n  const {\n    areaPath,\n    connectPath,\n    areaStyle,\n    connectStyle\n  } = g.attributes;\n  const document = g.ownerDocument;\n  select(g).maybeAppend('connect-path', () => document.createElement('path', {})).style('d', connectPath).call(applyStyle, connectStyle);\n  select(g).maybeAppend('area-path', () => document.createElement('path', {})).style('d', areaPath).call(applyStyle, areaStyle);\n});\nexport const Curve = (options, context) => {\n  const {\n      curve,\n      gradient = false,\n      defined = d => !Number.isNaN(d) && d !== undefined && d !== null,\n      connect: connectNulls = false\n    } = options,\n    style = __rest(options, [\"curve\", \"gradient\", \"defined\", \"connect\"]);\n  const {\n    coordinate,\n    document\n  } = context;\n  return (P, value, defaults) => {\n    const {\n      color: defaultColor\n    } = defaults;\n    const {\n      color = defaultColor,\n      seriesColor: sc,\n      seriesX: sx,\n      seriesY: sy\n    } = value;\n    const tpShape = isTranspose(coordinate);\n    const transform = getTransform(coordinate, value);\n    const fill = gradient && sc ? computeGradient(sc, sx, sy, gradient, undefined, tpShape) : color;\n    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, defaults), {\n      stroke: fill,\n      fill: fill\n    }), transform && {\n      transform\n    }), style);\n    const [DP, MS] = segmentation(P, defined);\n    const connectStyle = subObject(finalStyle, 'connect');\n    const missing = !!MS.length;\n    const getPathNode = path => {\n      return select(document.createElement('path', {})).style('d', path || '').call(applyStyle, finalStyle).node();\n    };\n    if (!isPolar(coordinate)) {\n      /**\n       * Draw area shape by points.\n       */\n      const areaPath = points => {\n        const Y1 = points.slice(0, points.length / 2);\n        const Y0 = points.slice(points.length / 2);\n        return tpShape ? area().y((_, idx) => Y1[idx][1]).x1((_, idx) => Y1[idx][0]).x0((_, idx) => Y0[idx][0]).defined((_, idx) => [...Y1[idx], ...Y0[idx]].every(defined)).curve(curve)(Y1) : area().x((_, idx) => Y1[idx][0]).y1((_, idx) => Y1[idx][1]).y0((_, idx) => Y0[idx][1]).defined((_, idx) => [...Y1[idx], ...Y0[idx]].every(defined)).curve(curve)(Y1);\n      };\n      // Draw one area of connected defined points.\n      if (!missing || connectNulls && !Object.keys(connectStyle).length) {\n        return getPathNode(areaPath(DP));\n      }\n      // Draw one area of unconnected defined points.\n      if (missing && !connectNulls) {\n        return getPathNode(areaPath(P));\n      }\n      // Draw two area.\n      // One for unconnected defined points.\n      // One for connected segments.\n      return select(new DoubleArea()).style('areaStyle', finalStyle).style('connectStyle', Object.assign(Object.assign({}, connectStyle), style)).style('areaPath', areaPath(P)).style('connectPath', MS.map(areaPath).join('')).node();\n    } else {\n      /**\n       * Draw areaRadial shape by points.\n       */\n      const areaRadialPath = points => {\n        const center = coordinate.getCenter();\n        const Y1 = points.slice(0, points.length / 2);\n        const Y0 = points.slice(points.length / 2);\n        return areaRadial().angle((_, idx) => angleWithQuadrant(sub(Y1[idx], center))).outerRadius((_, idx) => dist(Y1[idx], center)).innerRadius((_, idx) => dist(Y0[idx], center)).defined((_, idx) => [...Y1[idx], ...Y0[idx]].every(defined)).curve(curve)(Y0);\n      };\n      // Draw one area of connected defined points.\n      if (!missing || connectNulls && !Object.keys(connectStyle).length) {\n        return getPathNode(areaRadialPath(DP));\n      }\n      // Draw one area of unconnected defined points.\n      if (missing && !connectNulls) {\n        return getPathNode(areaRadialPath(P));\n      }\n      // Draw two area.\n      // One for unconnected defined points.\n      // One for connected segments.\n      return select(new DoubleArea()).style('areaStyle', finalStyle).style('connectStyle', Object.assign(Object.assign({}, connectStyle), style)).style('areaPath', areaRadialPath(P)).style('connectPath', MS.map(areaRadialPath).join('')).node();\n    }\n  };\n};\nCurve.props = {\n  defaultMarker: 'smooth',\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut'\n};","map":{"version":3,"names":["area","areaRadial","select","isPolar","isTranspose","angleWithQuadrant","sub","dist","applyStyle","computeGradient","getTransform","subObject","createElement","segmentation","points","defined","definedPointsY1","definedPointsY0","segments","m","dp","mid","length","i","y1","y0","some","v","push","dpy1","dpy0","concat","DoubleArea","g","areaPath","connectPath","areaStyle","connectStyle","attributes","document","ownerDocument","maybeAppend","style","call","Curve","options","context","curve","gradient","d","Number","isNaN","undefined","connect","connectNulls","__rest","coordinate","P","value","defaults","color","defaultColor","seriesColor","sc","seriesX","sx","seriesY","sy","tpShape","transform","fill","finalStyle","Object","assign","stroke","DP","MS","missing","getPathNode","path","node","Y1","slice","Y0","y","_","idx","x1","x0","every","x","keys","map","join","areaRadialPath","center","getCenter","angle","outerRadius","innerRadius","props","defaultMarker","defaultEnterAnimation","defaultUpdateAnimation","defaultExitAnimation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/area/curve.ts"],"sourcesContent":["import { area, areaRadial, CurveFactory } from '@antv/vendor/d3-shape';\nimport { select } from '../../utils/selection';\nimport { isPolar, isTranspose } from '../../utils/coordinate';\nimport { Vector2, ShapeComponent as SC } from '../../runtime';\nimport { angleWithQuadrant, sub, dist } from '../../utils/vector';\nimport { applyStyle, computeGradient, getTransform } from '../utils';\nimport { subObject } from '../../utils/helper';\nimport { createElement } from '../../utils/createElement';\n\n/**\n * Given a points sequence, split it into an array of defined points\n * and an array of undefined segments.\n *\n * Input - [p0, p1, p2, p3, p4, p5], p1 ~ p2 is `Y1`, p3 ~ p5 is `Y0`.\n * Output - When all of Y1 & Y0 is defined, move into defined points, or else undefined segments.\n */\nfunction segmentation(\n  points: Vector2[],\n  defined: (d: any) => boolean,\n): [Vector2[], [Vector2, Vector2][]] {\n  const definedPointsY1 = [];\n  const definedPointsY0 = [];\n  const segments = [];\n\n  let m = false; // Is in a undefined sequence.\n  let dp = null; // The previous defined point.\n\n  const mid = points.length / 2;\n  for (let i = 0; i < mid; i++) {\n    const y1 = points[i];\n    const y0 = points[i + mid];\n\n    // If current point is a undefined point,\n    // enter a undefined sequence.\n    if ([...y1, ...y0].some((v) => !defined(v))) m = true;\n    else {\n      definedPointsY1.push(y1);\n      definedPointsY0.push(y0);\n      // If current point is a defined point,\n      // and is in a undefined sequence, save\n      // the two closest defined points as this\n      // undefined sequence and exit it.\n      if (m && dp) {\n        m = false;\n        const [dpy1, dpy0] = dp;\n        segments.push([dpy1, y1, dpy0, y0]);\n      }\n      // Update the previous defined point.\n      dp = [y1, y0];\n    }\n  }\n  return [definedPointsY1.concat(definedPointsY0), segments];\n}\n\nexport type CurveOptions = {\n  curve?: CurveFactory;\n  gradient?: boolean | string;\n  [key: string]: any;\n};\n\nconst DoubleArea = createElement((g) => {\n  const { areaPath, connectPath, areaStyle, connectStyle } = g.attributes;\n  const document = g.ownerDocument;\n  select(g)\n    .maybeAppend('connect-path', () => document.createElement('path', {}))\n    .style('d', connectPath)\n    .call(applyStyle, connectStyle);\n  select(g)\n    .maybeAppend('area-path', () => document.createElement('path', {}))\n    .style('d', areaPath)\n    .call(applyStyle, areaStyle);\n});\n\nexport const Curve: SC<CurveOptions> = (options, context) => {\n  const {\n    curve,\n    gradient = false,\n    defined = (d) => !Number.isNaN(d) && d !== undefined && d !== null,\n    connect: connectNulls = false,\n    ...style\n  } = options;\n  const { coordinate, document } = context;\n\n  return (P, value, defaults) => {\n    const { color: defaultColor } = defaults;\n    const {\n      color = defaultColor,\n      seriesColor: sc,\n      seriesX: sx,\n      seriesY: sy,\n    } = value;\n    const tpShape = isTranspose(coordinate);\n    const transform = getTransform(coordinate, value);\n    const fill =\n      gradient && sc\n        ? computeGradient(sc, sx, sy, gradient, undefined, tpShape)\n        : color;\n\n    const finalStyle = {\n      ...defaults,\n      stroke: fill,\n      fill: fill,\n      ...(transform && { transform }),\n      ...style,\n    };\n\n    const [DP, MS] = segmentation(P, defined);\n\n    const connectStyle = subObject(finalStyle, 'connect');\n    const missing = !!MS.length;\n\n    const getPathNode = (path) => {\n      return select(document.createElement('path', {}))\n        .style('d', path || '')\n        .call(applyStyle, finalStyle)\n        .node();\n    };\n\n    if (!isPolar(coordinate)) {\n      /**\n       * Draw area shape by points.\n       */\n      const areaPath = (points) => {\n        const Y1 = points.slice(0, points.length / 2);\n        const Y0 = points.slice(points.length / 2);\n        return tpShape\n          ? area()\n              .y((_, idx) => Y1[idx][1])\n              .x1((_, idx) => Y1[idx][0])\n              .x0((_, idx) => Y0[idx][0])\n              .defined((_, idx) => [...Y1[idx], ...Y0[idx]].every(defined))\n              .curve(curve)(Y1)\n          : area()\n              .x((_, idx) => Y1[idx][0])\n              .y1((_, idx) => Y1[idx][1])\n              .y0((_, idx) => Y0[idx][1])\n              .defined((_, idx) => [...Y1[idx], ...Y0[idx]].every(defined))\n              .curve(curve)(Y1);\n      };\n\n      // Draw one area of connected defined points.\n      if (!missing || (connectNulls && !Object.keys(connectStyle).length)) {\n        return getPathNode(areaPath(DP));\n      }\n\n      // Draw one area of unconnected defined points.\n      if (missing && !connectNulls) {\n        return getPathNode(areaPath(P));\n      }\n\n      // Draw two area.\n      // One for unconnected defined points.\n      // One for connected segments.\n      return select(new DoubleArea())\n        .style('areaStyle', finalStyle)\n        .style('connectStyle', { ...connectStyle, ...style })\n        .style('areaPath', areaPath(P))\n        .style('connectPath', MS.map(areaPath).join(''))\n        .node();\n    } else {\n      /**\n       * Draw areaRadial shape by points.\n       */\n      const areaRadialPath = (points) => {\n        const center = coordinate.getCenter() as Vector2;\n        const Y1 = points.slice(0, points.length / 2);\n        const Y0 = points.slice(points.length / 2);\n\n        return areaRadial()\n          .angle((_, idx) => angleWithQuadrant(sub(Y1[idx], center)))\n          .outerRadius((_, idx) => dist(Y1[idx], center))\n          .innerRadius((_, idx) => dist(Y0[idx], center))\n          .defined((_, idx) => [...Y1[idx], ...Y0[idx]].every(defined))\n          .curve(curve)(Y0);\n      };\n\n      // Draw one area of connected defined points.\n      if (!missing || (connectNulls && !Object.keys(connectStyle).length)) {\n        return getPathNode(areaRadialPath(DP));\n      }\n\n      // Draw one area of unconnected defined points.\n      if (missing && !connectNulls) {\n        return getPathNode(areaRadialPath(P));\n      }\n\n      // Draw two area.\n      // One for unconnected defined points.\n      // One for connected segments.\n      return select(new DoubleArea())\n        .style('areaStyle', finalStyle)\n        .style('connectStyle', { ...connectStyle, ...style })\n        .style('areaPath', areaRadialPath(P))\n        .style('connectPath', MS.map(areaRadialPath).join(''))\n        .node();\n    }\n  };\n};\n\nCurve.props = {\n  defaultMarker: 'smooth',\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut',\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}