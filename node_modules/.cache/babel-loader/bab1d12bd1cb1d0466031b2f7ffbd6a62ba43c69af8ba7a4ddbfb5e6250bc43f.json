{"ast":null,"code":"/**\n * Calls a defined callback function on each key:value of a object,\n * and returns a object contains the result.\n */\nexport function mapObject(object, callbackfn) {\n  return Object.entries(object).reduce((obj, [key, value]) => {\n    obj[key] = callbackfn(value, key, object);\n    return obj;\n  }, {});\n}\nexport function indexOf(array) {\n  return array.map((_, i) => i);\n}\n/**\n * @example [[1, 2, 3], ['a', 'b', 'c']] => [[1, 'a'], [2, 'b'], [3, 'c']]\n */\nexport function transpose(matrix) {\n  const row = matrix.length;\n  const col = matrix[0].length;\n  // Note: new Array(col).fill(new Array(row)) is not ok!!!\n  // Because in this case it will fill new Array(col) with the same array: new Array(row).\n  const transposed = new Array(col).fill(0).map(() => new Array(row));\n  for (let i = 0; i < col; i++) {\n    for (let j = 0; j < row; j++) {\n      transposed[i][j] = matrix[j][i];\n    }\n  }\n  return transposed;\n}\nexport function firstOf(array) {\n  return array[0];\n}\nexport function lastOf(array) {\n  return array[array.length - 1];\n}\nexport function isFlatArray(array) {\n  return !array.some(Array.isArray);\n}\nexport function unique(array) {\n  return Array.from(new Set(array));\n}\nexport function divide(array, callbackfn) {\n  const result = [[], []];\n  array.forEach(item => {\n    result[callbackfn(item) ? 0 : 1].push(item);\n  });\n  return result;\n}\nfunction comb(array, len = array.length) {\n  if (len === 1) return array.map(item => [item]);\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    const rest = array.slice(i + 1);\n    const restComb = comb(rest, len - 1);\n    restComb.forEach(comb => {\n      result.push([array[i], ...comb]);\n    });\n  }\n  return result;\n}\n/**\n * get all combinations of two elements in an array\n * @example [1, 2, 3] => [[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n * @param array\n * @returns\n */\nexport function combine(array) {\n  if (array.length === 1) return [array];\n  const result = [];\n  for (let i = 1; i <= array.length; i++) {\n    result.push(...comb(array, i));\n  }\n  return result;\n}","map":{"version":3,"names":["mapObject","object","callbackfn","Object","entries","reduce","obj","key","value","indexOf","array","map","_","i","transpose","matrix","row","length","col","transposed","Array","fill","j","firstOf","lastOf","isFlatArray","some","isArray","unique","from","Set","divide","result","forEach","item","push","comb","len","rest","slice","restComb","combine"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/utils/array.ts"],"sourcesContent":["/**\n * Calls a defined callback function on each key:value of a object,\n * and returns a object contains the result.\n */\nexport function mapObject<T, U>(\n  object: Record<string, T>,\n  callbackfn: (value: T, key?: string, object?: Record<string, T>) => U,\n): Record<string, U> {\n  return Object.entries(object).reduce((obj, [key, value]) => {\n    obj[key] = callbackfn(value, key, object);\n    return obj;\n  }, {});\n}\n\nexport function indexOf<T>(array: T[]): number[] {\n  return array.map((_, i) => i);\n}\n\n/**\n * @example [[1, 2, 3], ['a', 'b', 'c']] => [[1, 'a'], [2, 'b'], [3, 'c']]\n */\nexport function transpose<T>(matrix: T[][]): T[][] {\n  const row = matrix.length;\n  const col = matrix[0].length;\n  // Note: new Array(col).fill(new Array(row)) is not ok!!!\n  // Because in this case it will fill new Array(col) with the same array: new Array(row).\n  const transposed = new Array(col).fill(0).map(() => new Array(row));\n  for (let i = 0; i < col; i++) {\n    for (let j = 0; j < row; j++) {\n      transposed[i][j] = matrix[j][i];\n    }\n  }\n  return transposed;\n}\n\nexport function firstOf<T>(array: T[]) {\n  return array[0];\n}\n\nexport function lastOf<T>(array: T[]) {\n  return array[array.length - 1];\n}\n\nexport function isFlatArray<T>(array: (T | T[])[]): array is T[] {\n  return !array.some(Array.isArray);\n}\n\nexport function unique<T>(array: T[]): T[] {\n  return Array.from(new Set(array));\n}\n\nexport function divide<T>(\n  array: T[],\n  callbackfn: (item: T) => boolean,\n): [T[], T[]] {\n  const result: [T[], T[]] = [[], []];\n  array.forEach((item) => {\n    result[callbackfn(item) ? 0 : 1].push(item);\n  });\n  return result;\n}\n\nfunction comb<T>(array: T[], len = array.length): T[][] {\n  if (len === 1) return array.map((item) => [item]);\n  const result: T[][] = [];\n  for (let i = 0; i < array.length; i++) {\n    const rest = array.slice(i + 1);\n    const restComb = comb(rest, len - 1);\n    restComb.forEach((comb) => {\n      result.push([array[i], ...comb]);\n    });\n  }\n  return result;\n}\n\n/**\n * get all combinations of two elements in an array\n * @example [1, 2, 3] => [[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n * @param array\n * @returns\n */\nexport function combine<T>(array: T[]): T[][] {\n  if (array.length === 1) return [array];\n  const result: T[][] = [];\n  for (let i = 1; i <= array.length; i++) {\n    result.push(...comb(array, i));\n  }\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}