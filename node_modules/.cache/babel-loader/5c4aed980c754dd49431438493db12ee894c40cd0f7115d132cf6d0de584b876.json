{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix, isNumber } from '@antv/util';\nimport { format } from '@antv/vendor/d3-format';\nimport { indexOf, mapObject } from '../utils/array';\nimport { composeAsync, defined, isStrictObject, isUnset } from '../utils/helper';\nimport { isFullTooltip } from '../utils/mark';\nimport { useLibrary } from './library';\nimport { createColumnOf } from './mark';\nimport { isPosition } from './scale';\nexport const CALLBACK_ITEM_SYMBOL = Symbol('CALLBACK_ITEM');\n// @todo Add more defaults.\nexport function applyDefaults(I, mark, context) {\n  const {\n      encode = {},\n      scale = {},\n      transform = []\n    } = mark,\n    rest = __rest(mark, [\"encode\", \"scale\", \"transform\"]);\n  return [I, Object.assign(Object.assign({}, rest), {\n    encode,\n    scale,\n    transform\n  })];\n}\nexport function applyDataTransform(I, mark, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      library\n    } = context;\n    const {\n      data\n    } = mark;\n    const [useData] = useLibrary('data', library);\n    const descriptor = normalizedDataSource(data);\n    const {\n        transform: T = []\n      } = descriptor,\n      connector = __rest(descriptor, [\"transform\"]);\n    const transform = [connector, ...T];\n    const transformFunctions = transform.map(t => useData(t, context));\n    const transformedData = yield composeAsync(transformFunctions)(data);\n    // Maintain the consistency of shape between input and output data.\n    // If the shape of raw data is like { value: any }\n    // and the returned transformedData is Object,\n    // returns the wrapped data: { value: transformedData },\n    // otherwise returns the processed tabular data.\n    const newData = data && !Array.isArray(data) && !Array.isArray(transformedData) ? {\n      value: transformedData\n    } : transformedData;\n    return [Array.isArray(transformedData) ? indexOf(transformedData) : [], Object.assign(Object.assign({}, mark), {\n      data: newData\n    })];\n  });\n}\nexport function flatEncode(I, mark, context) {\n  const {\n    encode\n  } = mark;\n  if (!encode) return [I, mark];\n  const flattenEncode = {};\n  for (const [key, value] of Object.entries(encode)) {\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        const name = `${key}${i === 0 ? '' : i}`;\n        flattenEncode[name] = value[i];\n      }\n    } else {\n      flattenEncode[key] = value;\n    }\n  }\n  return [I, Object.assign(Object.assign({}, mark), {\n    encode: flattenEncode\n  })];\n}\nexport function inferChannelsType(I, mark, context) {\n  const {\n    encode,\n    data\n  } = mark;\n  if (!encode) return [I, mark];\n  const typedEncode = mapObject(encode, channel => {\n    if (isTypedChannel(channel)) return channel;\n    const type = inferChannelType(data, channel);\n    return {\n      type,\n      value: channel\n    };\n  });\n  return [I, Object.assign(Object.assign({}, mark), {\n    encode: typedEncode\n  })];\n}\nexport function maybeVisualChannel(I, mark, context) {\n  const {\n    encode\n  } = mark;\n  if (!encode) return [I, mark];\n  const newEncode = mapObject(encode, (channel, name) => {\n    const {\n      type\n    } = channel;\n    if (type !== 'constant' || isPosition(name)) return channel;\n    return Object.assign(Object.assign({}, channel), {\n      constant: true\n    });\n  });\n  return [I, Object.assign(Object.assign({}, mark), {\n    encode: newEncode\n  })];\n}\nexport function extractColumns(I, mark, context) {\n  const {\n    encode,\n    data\n  } = mark;\n  if (!encode) return [I, mark];\n  const {\n    library\n  } = context;\n  const columnOf = createColumnOf(library);\n  const valuedEncode = mapObject(encode, channel => columnOf(data, channel));\n  return [I, Object.assign(Object.assign({}, mark), {\n    encode: valuedEncode\n  })];\n}\n/**\n * Normalize mark.tooltip to {title, items}.\n */\nexport function normalizeTooltip(I, mark, context) {\n  const {\n    tooltip = {}\n  } = mark;\n  if (isUnset(tooltip)) return [I, mark];\n  if (Array.isArray(tooltip)) {\n    return [I, Object.assign(Object.assign({}, mark), {\n      tooltip: {\n        items: tooltip\n      }\n    })];\n  }\n  if (isStrictObject(tooltip) && isFullTooltip(tooltip)) {\n    return [I, Object.assign(Object.assign({}, mark), {\n      tooltip\n    })];\n  }\n  return [I, Object.assign(Object.assign({}, mark), {\n    tooltip: {\n      items: [tooltip]\n    }\n  })];\n}\nexport function extractTooltip(I, mark, context) {\n  const {\n    data,\n    encode,\n    tooltip = {}\n  } = mark;\n  if (isUnset(tooltip)) return [I, mark];\n  const valueOf = item => {\n    if (!item) return item;\n    if (typeof item === 'string') {\n      return I.map(i => ({\n        name: item,\n        value: data[i][item]\n      }));\n    }\n    if (isStrictObject(item)) {\n      const {\n        field,\n        channel,\n        color,\n        name = field,\n        valueFormatter = d => d\n      } = item;\n      // Support d3-format.\n      const normalizedValueFormatter = typeof valueFormatter === 'string' ? format(valueFormatter) : valueFormatter;\n      // Field name.\n      const definedChannel = channel && encode[channel];\n      const channelField = definedChannel && encode[channel].field;\n      const name1 = name || channelField || channel;\n      const values = [];\n      for (const i of I) {\n        const value1 = field ? data[i][field] : definedChannel ? encode[channel].value[i] : null;\n        values[i] = {\n          name: name1,\n          color,\n          value: normalizedValueFormatter(value1)\n        };\n      }\n      return values;\n    }\n    if (typeof item === 'function') {\n      const values = [];\n      for (const i of I) {\n        const v = item(data[i], i, data, encode);\n        if (isStrictObject(v)) values[i] = Object.assign(Object.assign({}, v), {\n          [CALLBACK_ITEM_SYMBOL]: true\n        });else values[i] = {\n          value: v\n        };\n      }\n      return values;\n    }\n    return item;\n  };\n  const {\n      title,\n      items = []\n    } = tooltip,\n    rest = __rest(tooltip, [\"title\", \"items\"]);\n  const newTooltip = Object.assign({\n    title: valueOf(title),\n    items: Array.isArray(items) ? items.map(valueOf) : []\n  }, rest);\n  return [I, Object.assign(Object.assign({}, mark), {\n    tooltip: newTooltip\n  })];\n}\nexport function maybeArrayField(I, mark, context) {\n  const {\n      encode\n    } = mark,\n    rest = __rest(mark, [\"encode\"]);\n  if (!encode) return [I, mark];\n  const columns = Object.entries(encode);\n  const arrayColumns = columns.filter(([, channel]) => {\n    const {\n      value: V\n    } = channel;\n    return Array.isArray(V[0]);\n  }).flatMap(([key, V]) => {\n    const columns = [[key, new Array(I.length).fill(undefined)]];\n    const {\n        value: rows\n      } = V,\n      rest = __rest(V, [\"value\"]);\n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      if (Array.isArray(row)) {\n        for (let j = 0; j < row.length; j++) {\n          const column = columns[j] || [`${key}${j}`, new Array(I).fill(undefined)];\n          column[1][i] = row[j];\n          columns[j] = column;\n        }\n      }\n    }\n    return columns.map(([key, value]) => [key, Object.assign({\n      type: 'column',\n      value\n    }, rest)]);\n  });\n  const newEncode = Object.fromEntries([...columns, ...arrayColumns]);\n  return [I, Object.assign(Object.assign({}, rest), {\n    encode: newEncode\n  })];\n}\nexport function addGuideToScale(I, mark, context) {\n  const {\n    axis = {},\n    legend = {},\n    slider = {},\n    scrollbar = {}\n  } = mark;\n  const normalize = (guide, channel) => {\n    if (typeof guide === 'boolean') return guide ? {} : null;\n    const eachGuide = guide[channel];\n    return eachGuide === undefined || eachGuide ? eachGuide : null;\n  };\n  const axisChannels = typeof axis === 'object' ? Array.from(new Set(['x', 'y', 'z', ...Object.keys(axis)])) : ['x', 'y', 'z'];\n  deepMix(mark, {\n    scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map(channel => {\n      const scrollbarOptions = normalize(scrollbar, channel);\n      return [channel, Object.assign({\n        guide: normalize(axis, channel),\n        slider: normalize(slider, channel),\n        scrollbar: scrollbarOptions\n      }, scrollbarOptions && {\n        ratio: scrollbarOptions.ratio === undefined ? 0.5 : scrollbarOptions.ratio\n      })];\n    }))), {\n      color: {\n        guide: normalize(legend, 'color')\n      },\n      size: {\n        guide: normalize(legend, 'size')\n      },\n      shape: {\n        guide: normalize(legend, 'shape')\n      },\n      // fixme: opacity is conflict with DisplayObject.opacity\n      // to be confirm.\n      opacity: {\n        guide: normalize(legend, 'opacity')\n      }\n    })\n  });\n  return [I, mark];\n}\nexport function maybeNonAnimate(I, mark, context) {\n  const {\n    animate\n  } = mark;\n  if (animate || animate === undefined) return [I, mark];\n  deepMix(mark, {\n    animate: {\n      enter: {\n        type: null\n      },\n      exit: {\n        type: null\n      },\n      update: {\n        type: null\n      }\n    }\n  });\n  return [I, mark];\n}\nfunction isTypedChannel(channel) {\n  if (typeof channel !== 'object' || channel instanceof Date || channel === null) {\n    return false;\n  }\n  const {\n    type\n  } = channel;\n  return defined(type);\n}\nfunction inferChannelType(data, channel) {\n  if (typeof channel === 'function') return 'transform';\n  if (typeof channel === 'string' && isField(data, channel)) return 'field';\n  return 'constant';\n}\nfunction isField(data, value) {\n  if (!Array.isArray(data)) return false;\n  return data.some(d => d[value] !== undefined);\n}\nfunction normalizedDataSource(data) {\n  // Liquid、Gauge need number data.\n  if (isNumber(data)) return {\n    type: 'inline',\n    value: data\n  };\n  // Return null as a placeholder.\n  if (!data) return {\n    type: 'inline',\n    value: null\n  };\n  if (Array.isArray(data)) return {\n    type: 'inline',\n    value: data\n  };\n  const {\n      type = 'inline'\n    } = data,\n    rest = __rest(data, [\"type\"]);\n  return Object.assign(Object.assign({}, rest), {\n    type\n  });\n}","map":{"version":3,"names":["deepMix","isNumber","format","indexOf","mapObject","composeAsync","defined","isStrictObject","isUnset","isFullTooltip","useLibrary","createColumnOf","isPosition","CALLBACK_ITEM_SYMBOL","Symbol","applyDefaults","I","mark","context","encode","scale","transform","rest","__rest","Object","assign","applyDataTransform","library","data","useData","descriptor","normalizedDataSource","T","connector","transformFunctions","map","t","transformedData","newData","Array","isArray","value","flatEncode","flattenEncode","key","entries","i","length","name","inferChannelsType","typedEncode","channel","isTypedChannel","type","inferChannelType","maybeVisualChannel","newEncode","constant","extractColumns","columnOf","valuedEncode","normalizeTooltip","tooltip","items","extractTooltip","valueOf","item","field","color","valueFormatter","d","normalizedValueFormatter","definedChannel","channelField","name1","values","value1","v","title","newTooltip","maybeArrayField","columns","arrayColumns","filter","V","flatMap","fill","undefined","rows","row","j","column","fromEntries","addGuideToScale","axis","legend","slider","scrollbar","normalize","guide","eachGuide","axisChannels","from","Set","keys","scrollbarOptions","ratio","size","shape","opacity","maybeNonAnimate","animate","enter","exit","update","Date","isField","some"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/runtime/transform.ts"],"sourcesContent":["import { Primitive } from '@antv/vendor/d3-array';\nimport { deepMix, isNumber } from '@antv/util';\nimport { format } from '@antv/vendor/d3-format';\nimport { indexOf, mapObject } from '../utils/array';\nimport {\n  composeAsync,\n  defined,\n  isStrictObject,\n  isUnset,\n} from '../utils/helper';\nimport { isFullTooltip } from '../utils/mark';\nimport { useLibrary } from './library';\nimport { createColumnOf } from './mark';\nimport { Data, DataComponent } from './types/data';\nimport { G2Mark, G2DataOptions, G2Context } from './types/options';\nimport { isPosition } from './scale';\n\nexport const CALLBACK_ITEM_SYMBOL = Symbol('CALLBACK_ITEM');\n\n// @todo Add more defaults.\nexport function applyDefaults(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { encode = {}, scale = {}, transform = [], ...rest } = mark;\n  return [I, { ...rest, encode, scale, transform }];\n}\n\nexport async function applyDataTransform(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): Promise<[number[], G2Mark]> {\n  const { library } = context;\n  const { data } = mark;\n  const [useData] = useLibrary<G2DataOptions, DataComponent, Data>(\n    'data',\n    library,\n  );\n  const descriptor = normalizedDataSource(data);\n  const { transform: T = [], ...connector } = descriptor;\n  const transform = [connector, ...T];\n  const transformFunctions = transform.map((t) => useData(t, context));\n  const transformedData = await composeAsync(transformFunctions)(data);\n\n  // Maintain the consistency of shape between input and output data.\n  // If the shape of raw data is like { value: any }\n  // and the returned transformedData is Object,\n  // returns the wrapped data: { value: transformedData },\n  // otherwise returns the processed tabular data.\n  const newData =\n    data && !Array.isArray(data) && !Array.isArray(transformedData)\n      ? { value: transformedData }\n      : transformedData;\n\n  return [\n    Array.isArray(transformedData) ? indexOf(transformedData) : [],\n    { ...mark, data: newData },\n  ];\n}\n\nexport function flatEncode(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { encode } = mark;\n  if (!encode) return [I, mark];\n  const flattenEncode = {};\n  for (const [key, value] of Object.entries(encode)) {\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        const name = `${key}${i === 0 ? '' : i}`;\n        flattenEncode[name] = value[i];\n      }\n    } else {\n      flattenEncode[key] = value;\n    }\n  }\n  return [I, { ...mark, encode: flattenEncode }];\n}\n\nexport function inferChannelsType(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { encode, data } = mark;\n  if (!encode) return [I, mark];\n  const typedEncode = mapObject(encode, (channel) => {\n    if (isTypedChannel(channel)) return channel;\n    const type = inferChannelType(data, channel);\n    return { type, value: channel };\n  });\n  return [I, { ...mark, encode: typedEncode }];\n}\n\nexport function maybeVisualChannel(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { encode } = mark;\n  if (!encode) return [I, mark];\n  const newEncode = mapObject(encode, (channel, name) => {\n    const { type } = channel;\n    if (type !== 'constant' || isPosition(name)) return channel;\n    return { ...channel, constant: true };\n  });\n  return [I, { ...mark, encode: newEncode }];\n}\n\nexport function extractColumns(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { encode, data } = mark;\n  if (!encode) return [I, mark];\n  const { library } = context;\n  const columnOf = createColumnOf(library);\n  const valuedEncode = mapObject(encode, (channel) => columnOf(data, channel));\n  return [I, { ...mark, encode: valuedEncode }];\n}\n\n/**\n * Normalize mark.tooltip to {title, items}.\n */\nexport function normalizeTooltip(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { tooltip = {} } = mark;\n  if (isUnset(tooltip)) return [I, mark];\n  if (Array.isArray(tooltip)) {\n    return [I, { ...mark, tooltip: { items: tooltip } }];\n  }\n  if (isStrictObject(tooltip) && isFullTooltip(tooltip)) {\n    return [I, { ...mark, tooltip }];\n  }\n  return [I, { ...mark, tooltip: { items: [tooltip] } }];\n}\n\nexport function extractTooltip(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { data, encode, tooltip = {} } = mark;\n  if (isUnset(tooltip)) return [I, mark];\n  const valueOf = (item) => {\n    if (!item) return item;\n    if (typeof item === 'string') {\n      return I.map((i) => ({ name: item, value: data[i][item] }));\n    }\n    if (isStrictObject(item)) {\n      const {\n        field,\n        channel,\n        color,\n        name = field,\n        valueFormatter = (d) => d,\n      } = item;\n\n      // Support d3-format.\n      const normalizedValueFormatter =\n        typeof valueFormatter === 'string'\n          ? format(valueFormatter)\n          : valueFormatter;\n\n      // Field name.\n      const definedChannel = channel && encode[channel];\n      const channelField = definedChannel && encode[channel].field;\n      const name1 = name || channelField || channel;\n\n      const values = [];\n      for (const i of I) {\n        const value1 = field\n          ? data[i][field]\n          : definedChannel\n          ? encode[channel].value[i]\n          : null;\n        values[i] = {\n          name: name1,\n          color,\n          value: normalizedValueFormatter(value1),\n        };\n      }\n      return values;\n    }\n    if (typeof item === 'function') {\n      const values = [];\n      for (const i of I) {\n        const v = item(data[i], i, data, encode);\n        if (isStrictObject(v))\n          values[i] = { ...v, [CALLBACK_ITEM_SYMBOL]: true };\n        else values[i] = { value: v };\n      }\n      return values;\n    }\n    return item;\n  };\n  const { title, items = [], ...rest } = tooltip;\n  const newTooltip = {\n    title: valueOf(title),\n    items: Array.isArray(items) ? items.map(valueOf) : [],\n    ...rest,\n  };\n  return [I, { ...mark, tooltip: newTooltip }];\n}\n\nexport function maybeArrayField(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { encode, ...rest } = mark;\n  if (!encode) return [I, mark];\n  const columns = Object.entries(encode);\n  const arrayColumns = columns\n    .filter(([, channel]) => {\n      const { value: V } = channel;\n      return Array.isArray(V[0]);\n    })\n    .flatMap(([key, V]) => {\n      const columns = [[key, new Array(I.length).fill(undefined)] as const];\n      const { value: rows, ...rest } = V;\n      for (let i = 0; i < rows.length; i++) {\n        const row = rows[i];\n        if (Array.isArray(row)) {\n          for (let j = 0; j < row.length; j++) {\n            const column = columns[j] || [\n              `${key}${j}`,\n              new Array(I).fill(undefined),\n            ];\n            column[1][i] = row[j];\n            columns[j] = column;\n          }\n        }\n      }\n      return columns.map(([key, value]) => [\n        key,\n        { type: 'column', value, ...rest },\n      ]);\n    });\n  const newEncode = Object.fromEntries([...columns, ...arrayColumns]);\n  return [I, { ...rest, encode: newEncode }];\n}\n\nexport function addGuideToScale(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark;\n  const normalize = (guide: boolean | Record<string, any>, channel: string) => {\n    if (typeof guide === 'boolean') return guide ? {} : null;\n    const eachGuide = guide[channel];\n    return eachGuide === undefined || eachGuide ? eachGuide : null;\n  };\n  const axisChannels =\n    typeof axis === 'object'\n      ? Array.from(new Set(['x', 'y', 'z', ...Object.keys(axis)]))\n      : ['x', 'y', 'z'];\n\n  deepMix(mark, {\n    scale: {\n      ...Object.fromEntries(\n        axisChannels.map((channel) => {\n          const scrollbarOptions = normalize(scrollbar, channel);\n          return [\n            channel,\n            {\n              guide: normalize(axis, channel),\n              slider: normalize(slider, channel),\n              scrollbar: scrollbarOptions,\n              ...(scrollbarOptions && {\n                ratio:\n                  scrollbarOptions.ratio === undefined\n                    ? 0.5\n                    : scrollbarOptions.ratio,\n              }),\n            },\n          ];\n        }),\n      ),\n      color: { guide: normalize(legend, 'color') },\n      size: { guide: normalize(legend, 'size') },\n      shape: { guide: normalize(legend, 'shape') },\n      // fixme: opacity is conflict with DisplayObject.opacity\n      // to be confirm.\n      opacity: { guide: normalize(legend, 'opacity') },\n    },\n  });\n  return [I, mark];\n}\n\nexport function maybeNonAnimate(\n  I: number[],\n  mark: G2Mark,\n  context: G2Context,\n): [number[], G2Mark] {\n  const { animate } = mark;\n  if (animate || animate === undefined) return [I, mark];\n  deepMix(mark, {\n    animate: {\n      enter: { type: null },\n      exit: { type: null },\n      update: { type: null },\n    },\n  });\n  return [I, mark];\n}\n\nfunction isTypedChannel(channel): boolean {\n  if (\n    typeof channel !== 'object' ||\n    channel instanceof Date ||\n    channel === null\n  ) {\n    return false;\n  }\n  const { type } = channel;\n  return defined(type);\n}\n\nfunction inferChannelType(data: Record<string, Primitive>[], channel): string {\n  if (typeof channel === 'function') return 'transform';\n  if (typeof channel === 'string' && isField(data, channel)) return 'field';\n  return 'constant';\n}\n\nfunction isField(data: Record<string, Primitive>[], value: string): boolean {\n  if (!Array.isArray(data)) return false;\n  return data.some((d) => d[value] !== undefined);\n}\n\nfunction normalizedDataSource(data) {\n  // Liquid、Gauge need number data.\n  if (isNumber(data)) return { type: 'inline', value: data };\n  // Return null as a placeholder.\n  if (!data) return { type: 'inline', value: null };\n  if (Array.isArray(data)) return { type: 'inline', value: data };\n  const { type = 'inline', ...rest } = data;\n  return { ...rest, type };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}