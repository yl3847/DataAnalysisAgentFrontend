{"ast":null,"code":"import { compile } from '@antv/expr';\nimport { mapValues } from '@antv/util';\nimport { lru } from './lru';\n// Whitelist of properties that can contain expressions.\nexport const EXPR_WHITE_LIST = ['style', 'encode', 'labels', 'children'];\n/**\n * Compiles an expression string into a function.\n * @param expr Expression string to compile.\n * @returns Compiled function or original string if empty.\n */\nconst compileExpression = lru(expr => {\n  const evaluator = compile(expr);\n  return (...args) => {\n    const paramNames = Array.from({\n      length: args.length\n    }, (_, i) => String.fromCharCode(97 + i));\n    const namedParams = Object.fromEntries(args.map((value, index) => [paramNames[index], value]));\n    // global is used to overview what can i get in props.\n    return evaluator(Object.assign(Object.assign({}, namedParams), {\n      global: Object.assign({}, namedParams)\n    }));\n  };\n}, expr => expr, 128);\n/**\n * Processes options object to convert expressions to functions.\n * @param options Options object to process.\n * @param isSpecRoot Whether the options is the root of the spec.\n * @returns Processed options object with expressions converted to functions.\n */\nexport function parseOptionsExpr(options, isSpecRoot = true) {\n  if (Array.isArray(options)) {\n    return options.map((_, i) => parseOptionsExpr(options[i], isSpecRoot));\n  }\n  if (typeof options === 'object' && options) {\n    return mapValues(options, (value, key) => {\n      // if options is root and the key is in the white list, parse the expression.\n      if (isSpecRoot && EXPR_WHITE_LIST.includes(key)) {\n        return parseOptionsExpr(value, key === 'children');\n      }\n      if (!isSpecRoot) {\n        return parseOptionsExpr(value, false);\n      }\n      return value;\n    });\n  }\n  // if options is a string and is a valid expression.\n  if (typeof options === 'string') {\n    const trimmed = options.trim();\n    if (trimmed.startsWith('{') && trimmed.endsWith('}')) {\n      return compileExpression(trimmed.slice(1, -1));\n    }\n  }\n  return options;\n}","map":{"version":3,"names":["compile","mapValues","lru","EXPR_WHITE_LIST","compileExpression","expr","evaluator","args","paramNames","Array","from","length","_","i","String","fromCharCode","namedParams","Object","fromEntries","map","value","index","assign","global","parseOptionsExpr","options","isSpecRoot","isArray","key","includes","trimmed","trim","startsWith","endsWith","slice"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/utils/expr.ts"],"sourcesContent":["import { compile } from '@antv/expr';\nimport { mapValues } from '@antv/util';\nimport { lru } from './lru';\n\n// Whitelist of properties that can contain expressions.\nexport const EXPR_WHITE_LIST = ['style', 'encode', 'labels', 'children'];\n\n/**\n * Compiles an expression string into a function.\n * @param expr Expression string to compile.\n * @returns Compiled function or original string if empty.\n */\nconst compileExpression = lru(\n  (expr: string): (() => any) | string => {\n    const evaluator = compile(expr);\n\n    return (...args) => {\n      const paramNames = Array.from({ length: args.length }, (_, i) =>\n        String.fromCharCode(97 + i),\n      );\n\n      const namedParams = Object.fromEntries(\n        args.map((value, index) => [paramNames[index], value]),\n      );\n\n      // global is used to overview what can i get in props.\n      return evaluator({\n        ...namedParams,\n        global: { ...namedParams },\n      });\n    };\n  },\n  (expr) => expr,\n  128,\n);\n\n/**\n * Processes options object to convert expressions to functions.\n * @param options Options object to process.\n * @param isSpecRoot Whether the options is the root of the spec.\n * @returns Processed options object with expressions converted to functions.\n */\nexport function parseOptionsExpr(options: any, isSpecRoot = true): any {\n  if (Array.isArray(options)) {\n    return options.map((_, i) => parseOptionsExpr(options[i], isSpecRoot));\n  }\n\n  if (typeof options === 'object' && options) {\n    return mapValues(options, (value, key) => {\n      // if options is root and the key is in the white list, parse the expression.\n      if (isSpecRoot && EXPR_WHITE_LIST.includes(key)) {\n        return parseOptionsExpr(value, key === 'children');\n      }\n      if (!isSpecRoot) {\n        return parseOptionsExpr(value, false);\n      }\n      return value;\n    });\n  }\n\n  // if options is a string and is a valid expression.\n  if (typeof options === 'string') {\n    const trimmed = options.trim();\n    if (trimmed.startsWith('{') && trimmed.endsWith('}')) {\n      return compileExpression(trimmed.slice(1, -1));\n    }\n  }\n\n  return options;\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,YAAY;AACpC,SAASC,SAAS,QAAQ,YAAY;AACtC,SAASC,GAAG,QAAQ,OAAO;AAE3B;AACA,OAAO,MAAMC,eAAe,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,UAAU,CAAC;AAExE;;;;;AAKA,MAAMC,iBAAiB,GAAGF,GAAG,CAC1BG,IAAY,IAA0B;EACrC,MAAMC,SAAS,GAAGN,OAAO,CAACK,IAAI,CAAC;EAE/B,OAAO,CAAC,GAAGE,IAAI,KAAI;IACjB,MAAMC,UAAU,GAAGC,KAAK,CAACC,IAAI,CAAC;MAAEC,MAAM,EAAEJ,IAAI,CAACI;IAAM,CAAE,EAAE,CAACC,CAAC,EAAEC,CAAC,KAC1DC,MAAM,CAACC,YAAY,CAAC,EAAE,GAAGF,CAAC,CAAC,CAC5B;IAED,MAAMG,WAAW,GAAGC,MAAM,CAACC,WAAW,CACpCX,IAAI,CAACY,GAAG,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAK,CAACb,UAAU,CAACa,KAAK,CAAC,EAAED,KAAK,CAAC,CAAC,CACvD;IAED;IACA,OAAOd,SAAS,CAAAW,MAAA,CAAAK,MAAA,CAAAL,MAAA,CAAAK,MAAA,KACXN,WAAW;MACdO,MAAM,EAAAN,MAAA,CAAAK,MAAA,KAAON,WAAW;IAAA,GACxB;EACJ,CAAC;AACH,CAAC,EACAX,IAAI,IAAKA,IAAI,EACd,GAAG,CACJ;AAED;;;;;;AAMA,OAAM,SAAUmB,gBAAgBA,CAACC,OAAY,EAAEC,UAAU,GAAG,IAAI;EAC9D,IAAIjB,KAAK,CAACkB,OAAO,CAACF,OAAO,CAAC,EAAE;IAC1B,OAAOA,OAAO,CAACN,GAAG,CAAC,CAACP,CAAC,EAAEC,CAAC,KAAKW,gBAAgB,CAACC,OAAO,CAACZ,CAAC,CAAC,EAAEa,UAAU,CAAC,CAAC;;EAGxE,IAAI,OAAOD,OAAO,KAAK,QAAQ,IAAIA,OAAO,EAAE;IAC1C,OAAOxB,SAAS,CAACwB,OAAO,EAAE,CAACL,KAAK,EAAEQ,GAAG,KAAI;MACvC;MACA,IAAIF,UAAU,IAAIvB,eAAe,CAAC0B,QAAQ,CAACD,GAAG,CAAC,EAAE;QAC/C,OAAOJ,gBAAgB,CAACJ,KAAK,EAAEQ,GAAG,KAAK,UAAU,CAAC;;MAEpD,IAAI,CAACF,UAAU,EAAE;QACf,OAAOF,gBAAgB,CAACJ,KAAK,EAAE,KAAK,CAAC;;MAEvC,OAAOA,KAAK;IACd,CAAC,CAAC;;EAGJ;EACA,IAAI,OAAOK,OAAO,KAAK,QAAQ,EAAE;IAC/B,MAAMK,OAAO,GAAGL,OAAO,CAACM,IAAI,EAAE;IAC9B,IAAID,OAAO,CAACE,UAAU,CAAC,GAAG,CAAC,IAAIF,OAAO,CAACG,QAAQ,CAAC,GAAG,CAAC,EAAE;MACpD,OAAO7B,iBAAiB,CAAC0B,OAAO,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;;EAIlD,OAAOT,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}