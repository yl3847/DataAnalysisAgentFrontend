{"ast":null,"code":"import { get } from 'lodash';\nimport React from 'react';\nimport { CollapseExpandIcon, RCNode } from '../../core/base';\nimport { formatLabel } from '../../core/utils/label';\nimport { measureTextSize } from '../../core/utils/measure-text';\nimport { getNodeSide } from '../../core/utils/node';\nimport { getBoxedTextNodeStyle, getLinearTextNodeStyle } from '../../core/utils/tree';\nconst {\n  ArrowCountIcon\n} = CollapseExpandIcon;\nconst {\n  TextNode\n} = RCNode;\nexport const DEFAULT_OPTIONS = {\n  node: {\n    type: 'react',\n    state: {\n      active: {\n        halo: false\n      },\n      selected: {\n        halo: false\n      }\n    }\n  },\n  edge: {\n    type: 'cubic-horizontal',\n    style: {\n      lineWidth: 3\n    }\n  },\n  transforms: prev => [...prev, {\n    type: 'collapse-expand-react-node',\n    key: 'collapse-expand-react-node',\n    enable: false,\n    trigger: 'icon',\n    iconRender: function (isCollapsed, data) {\n      const side = getNodeSide(this, data);\n      return React.createElement(ArrowCountIcon, {\n        graph: this,\n        data: data,\n        isCollapsed: isCollapsed,\n        placement: side === 'left' ? 'left' : 'right'\n      });\n    },\n    iconPlacement: function (data) {\n      const side = getNodeSide(this, data);\n      return side === 'left' ? 'left' : 'right';\n    }\n  }],\n  layout: {\n    type: 'mindmap',\n    direction: 'H',\n    preLayout: false,\n    getWidth: () => 120,\n    getHGap: () => 64\n  },\n  animation: {\n    duration: 500\n  }\n};\nexport function getMindMapOptions({\n  type,\n  direction,\n  nodeMinWidth,\n  nodeMaxWidth,\n  labelField\n}) {\n  let options = {};\n  if (type === 'boxed') {\n    const minWidth = nodeMinWidth || 120;\n    const maxWidth = nodeMaxWidth || 300;\n    options = {\n      node: {\n        style: {\n          component: data => {\n            const depth = data.depth;\n            const color = data.style?.color;\n            const label = formatLabel(data, labelField);\n            const {\n              font\n            } = getBoxedTextNodeStyle(label, minWidth, maxWidth, depth);\n            const props = {\n              text: label,\n              color,\n              maxWidth,\n              font\n            };\n            Object.assign(props, depth === 0 ? {\n              type: 'filled',\n              color: '#f1f4f5',\n              style: {\n                color: '#252525'\n              }\n            } : depth === 1 ? {\n              type: 'filled'\n            } : {\n              type: 'outlined'\n            });\n            return React.createElement(TextNode, {\n              ...props\n            });\n          },\n          size: data => {\n            const label = formatLabel(data, labelField);\n            return getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          },\n          dx: function (data) {\n            const side = getNodeSide(this, data);\n            const label = formatLabel(data, labelField);\n            const [width] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n            return side === 'left' ? -width : side === 'center' ? -width / 2 : 0;\n          },\n          ports: [{\n            placement: 'left'\n          }, {\n            placement: 'right'\n          }]\n        }\n      },\n      edge: {\n        style: {\n          stroke: function (data) {\n            const source = this.getNodeData(data.source);\n            return get(source, 'style.color', '#99ADD1');\n          }\n        }\n      },\n      transforms: prev => [...prev, {\n        type: 'assign-color-by-branch',\n        key: 'assign-color-by-branch'\n      }],\n      layout: {\n        type: 'mindmap',\n        getHeight: data => {\n          const label = formatLabel(data, labelField);\n          const [, height] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          return height;\n        },\n        getVGap: () => 14\n      }\n    };\n  } else if (type === 'linear') {\n    const minWidth = nodeMinWidth || 0;\n    const maxWidth = nodeMaxWidth || 300;\n    options = {\n      node: {\n        style: {\n          component: function (data) {\n            const side = getNodeSide(this, data);\n            const depth = data.depth;\n            const color = data.style?.color;\n            const label = formatLabel(data, labelField);\n            const {\n              font\n            } = getLinearTextNodeStyle(label, minWidth, maxWidth, depth);\n            const props = {\n              text: label,\n              color,\n              maxWidth,\n              font\n            };\n            Object.assign(props, depth === 0 ? {\n              type: 'filled',\n              color: '#f1f4f5',\n              style: {\n                color: '#252525'\n              }\n            } : {\n              type: 'underlined',\n              style: side === 'left' ? {\n                textAlign: 'right'\n              } : side === 'center' ? {\n                textAlign: 'center'\n              } : {}\n            });\n            return React.createElement(TextNode, {\n              ...props\n            });\n          },\n          size: data => {\n            const label = formatLabel(data, labelField);\n            return getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          },\n          dx: function (data) {\n            const side = getNodeSide(this, data);\n            const label = formatLabel(data, labelField);\n            const [width] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n            return side === 'left' ? -width : side === 'center' ? -width / 2 : 0;\n          },\n          dy: function (data) {\n            const label = formatLabel(data, labelField);\n            const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n            return height / 2;\n          },\n          ports: function (data) {\n            const side = getNodeSide(this, data);\n            return side === 'center' ? [{\n              placement: 'left'\n            }, {\n              placement: 'right'\n            }] : [{\n              placement: 'left-bottom'\n            }, {\n              placement: 'right-bottom'\n            }];\n          }\n        }\n      },\n      edge: {\n        style: {\n          stroke: function (data) {\n            const target = this.getNodeData(data.target);\n            return get(target, 'style.color', '#99ADD1');\n          }\n        }\n      },\n      layout: {\n        type: 'mindmap',\n        getHeight: data => {\n          const label = formatLabel(data, labelField);\n          const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          return height;\n        },\n        getVGap: () => 12\n      },\n      transforms: prev => [...prev.filter(t => t.key !== 'collapse-expand-react-node'), {\n        type: 'assign-color-by-branch',\n        key: 'assign-color-by-branch'\n      }, {\n        ...prev.find(t => t.key === 'collapse-expand-react-node'),\n        iconOffsetY: data => {\n          if (data.depth === 0) return 0;\n          const label = formatLabel(data, labelField);\n          const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          return height / 2;\n        }\n      }]\n    };\n  } else {\n    const PADDING = [24, 16];\n    options = {\n      node: {\n        style: {\n          component: data => {\n            const label = formatLabel(data, labelField);\n            return React.createElement(TextNode, {\n              type: \"filled\",\n              text: label\n            });\n          },\n          size: data => {\n            const label = formatLabel(data, labelField);\n            return measureTextSize(label, PADDING);\n          },\n          dx: function (data) {\n            const side = getNodeSide(this, data);\n            const label = formatLabel(data, labelField);\n            const [width] = measureTextSize(label, PADDING);\n            return side === 'left' ? -width : side === 'center' ? -width / 2 : 0;\n          },\n          ports: [{\n            placement: 'left'\n          }, {\n            placement: 'right'\n          }]\n        }\n      },\n      layout: {\n        type: 'mindmap',\n        getHeight: data => {\n          const label = formatLabel(data, labelField);\n          const [, height] = measureTextSize(label, PADDING);\n          return height;\n        }\n      }\n    };\n  }\n  if (direction) {\n    options.layout ||= {};\n    options.layout.direction = direction === 'alternate' ? 'H' : direction === 'left' ? 'RL' : 'LR';\n  }\n  return options;\n}","map":{"version":3,"names":["get","React","CollapseExpandIcon","RCNode","formatLabel","measureTextSize","getNodeSide","getBoxedTextNodeStyle","getLinearTextNodeStyle","ArrowCountIcon","TextNode","DEFAULT_OPTIONS","node","type","state","active","halo","selected","edge","style","lineWidth","transforms","prev","key","enable","trigger","iconRender","isCollapsed","data","side","createElement","graph","placement","iconPlacement","layout","direction","preLayout","getWidth","getHGap","animation","duration","getMindMapOptions","nodeMinWidth","nodeMaxWidth","labelField","options","minWidth","maxWidth","component","depth","color","label","font","props","text","Object","assign","size","dx","width","ports","stroke","source","getNodeData","getHeight","height","getVGap","textAlign","dy","target","filter","t","find","iconOffsetY","PADDING"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@ant-design/graphs/es/components/mind-map/options.js"],"sourcesContent":["import { get } from 'lodash';\nimport React from 'react';\nimport { CollapseExpandIcon, RCNode } from '../../core/base';\nimport { formatLabel } from '../../core/utils/label';\nimport { measureTextSize } from '../../core/utils/measure-text';\nimport { getNodeSide } from '../../core/utils/node';\nimport { getBoxedTextNodeStyle, getLinearTextNodeStyle } from '../../core/utils/tree';\nconst { ArrowCountIcon } = CollapseExpandIcon;\nconst { TextNode } = RCNode;\nexport const DEFAULT_OPTIONS = {\n    node: {\n        type: 'react',\n        state: {\n            active: {\n                halo: false,\n            },\n            selected: {\n                halo: false,\n            },\n        },\n    },\n    edge: {\n        type: 'cubic-horizontal',\n        style: {\n            lineWidth: 3,\n        },\n    },\n    transforms: (prev) => [\n        ...prev,\n        {\n            type: 'collapse-expand-react-node',\n            key: 'collapse-expand-react-node',\n            enable: false,\n            trigger: 'icon',\n            iconRender: function (isCollapsed, data) {\n                const side = getNodeSide(this, data);\n                return (React.createElement(ArrowCountIcon, { graph: this, data: data, isCollapsed: isCollapsed, placement: side === 'left' ? 'left' : 'right' }));\n            },\n            iconPlacement: function (data) {\n                const side = getNodeSide(this, data);\n                return side === 'left' ? 'left' : 'right';\n            },\n        },\n    ],\n    layout: {\n        type: 'mindmap',\n        direction: 'H',\n        preLayout: false,\n        getWidth: () => 120,\n        getHGap: () => 64,\n    },\n    animation: {\n        duration: 500,\n    },\n};\nexport function getMindMapOptions({ type, direction, nodeMinWidth, nodeMaxWidth, labelField, }) {\n    let options = {};\n    if (type === 'boxed') {\n        const minWidth = nodeMinWidth || 120;\n        const maxWidth = nodeMaxWidth || 300;\n        options = {\n            node: {\n                style: {\n                    component: (data) => {\n                        const depth = data.depth;\n                        const color = data.style?.color;\n                        const label = formatLabel(data, labelField);\n                        const { font } = getBoxedTextNodeStyle(label, minWidth, maxWidth, depth);\n                        const props = { text: label, color, maxWidth, font };\n                        Object.assign(props, depth === 0\n                            ? { type: 'filled', color: '#f1f4f5', style: { color: '#252525' } }\n                            : depth === 1\n                                ? { type: 'filled' }\n                                : { type: 'outlined' });\n                        return React.createElement(TextNode, { ...props });\n                    },\n                    size: (data) => {\n                        const label = formatLabel(data, labelField);\n                        return getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    },\n                    dx: function (data) {\n                        const side = getNodeSide(this, data);\n                        const label = formatLabel(data, labelField);\n                        const [width] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                        return side === 'left' ? -width : side === 'center' ? -width / 2 : 0;\n                    },\n                    ports: [{ placement: 'left' }, { placement: 'right' }],\n                },\n            },\n            edge: {\n                style: {\n                    stroke: function (data) {\n                        const source = this.getNodeData(data.source);\n                        return get(source, 'style.color', '#99ADD1');\n                    },\n                },\n            },\n            transforms: (prev) => [...prev, { type: 'assign-color-by-branch', key: 'assign-color-by-branch' }],\n            layout: {\n                type: 'mindmap',\n                getHeight: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [, height] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    return height;\n                },\n                getVGap: () => 14,\n            },\n        };\n    }\n    else if (type === 'linear') {\n        const minWidth = nodeMinWidth || 0;\n        const maxWidth = nodeMaxWidth || 300;\n        options = {\n            node: {\n                style: {\n                    component: function (data) {\n                        const side = getNodeSide(this, data);\n                        const depth = data.depth;\n                        const color = data.style?.color;\n                        const label = formatLabel(data, labelField);\n                        const { font } = getLinearTextNodeStyle(label, minWidth, maxWidth, depth);\n                        const props = { text: label, color, maxWidth, font };\n                        Object.assign(props, depth === 0\n                            ? { type: 'filled', color: '#f1f4f5', style: { color: '#252525' } }\n                            : {\n                                type: 'underlined',\n                                style: side === 'left' ? { textAlign: 'right' } : side === 'center' ? { textAlign: 'center' } : {},\n                            });\n                        return React.createElement(TextNode, { ...props });\n                    },\n                    size: (data) => {\n                        const label = formatLabel(data, labelField);\n                        return getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    },\n                    dx: function (data) {\n                        const side = getNodeSide(this, data);\n                        const label = formatLabel(data, labelField);\n                        const [width] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                        return side === 'left' ? -width : side === 'center' ? -width / 2 : 0;\n                    },\n                    dy: function (data) {\n                        const label = formatLabel(data, labelField);\n                        const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                        return height / 2;\n                    },\n                    ports: function (data) {\n                        const side = getNodeSide(this, data);\n                        return side === 'center'\n                            ? [{ placement: 'left' }, { placement: 'right' }]\n                            : [{ placement: 'left-bottom' }, { placement: 'right-bottom' }];\n                    },\n                },\n            },\n            edge: {\n                style: {\n                    stroke: function (data) {\n                        const target = this.getNodeData(data.target);\n                        return get(target, 'style.color', '#99ADD1');\n                    },\n                },\n            },\n            layout: {\n                type: 'mindmap',\n                getHeight: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    return height;\n                },\n                getVGap: () => 12,\n            },\n            transforms: (prev) => [\n                ...prev.filter((t) => t.key !== 'collapse-expand-react-node'),\n                {\n                    type: 'assign-color-by-branch',\n                    key: 'assign-color-by-branch',\n                },\n                {\n                    ...prev.find((t) => t.key === 'collapse-expand-react-node'),\n                    iconOffsetY: (data) => {\n                        if (data.depth === 0)\n                            return 0;\n                        const label = formatLabel(data, labelField);\n                        const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                        return height / 2;\n                    },\n                },\n            ],\n        };\n    }\n    else {\n        const PADDING = [24, 16];\n        options = {\n            node: {\n                style: {\n                    component: (data) => {\n                        const label = formatLabel(data, labelField);\n                        return React.createElement(TextNode, { type: \"filled\", text: label });\n                    },\n                    size: (data) => {\n                        const label = formatLabel(data, labelField);\n                        return measureTextSize(label, PADDING);\n                    },\n                    dx: function (data) {\n                        const side = getNodeSide(this, data);\n                        const label = formatLabel(data, labelField);\n                        const [width] = measureTextSize(label, PADDING);\n                        return side === 'left' ? -width : side === 'center' ? -width / 2 : 0;\n                    },\n                    ports: [{ placement: 'left' }, { placement: 'right' }],\n                },\n            },\n            layout: {\n                type: 'mindmap',\n                getHeight: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [, height] = measureTextSize(label, PADDING);\n                    return height;\n                },\n            },\n        };\n    }\n    if (direction) {\n        options.layout ||= {};\n        options.layout.direction =\n            direction === 'alternate' ? 'H' : direction === 'left' ? 'RL' : 'LR';\n    }\n    return options;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}