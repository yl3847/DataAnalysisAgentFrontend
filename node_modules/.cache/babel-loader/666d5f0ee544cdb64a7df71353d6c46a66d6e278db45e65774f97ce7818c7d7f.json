{"ast":null,"code":"function flru(max) {\n  var num, curr, prev;\n  var limit = max || 1;\n  function keep(key, value) {\n    if (++num > limit) {\n      prev = curr;\n      reset(1);\n      ++num;\n    }\n    curr[key] = value;\n  }\n  function reset(isPartial) {\n    num = 0;\n    curr = Object.create(null);\n    isPartial || (prev = Object.create(null));\n  }\n  reset();\n  return {\n    clear: reset,\n    has: function (key) {\n      return curr[key] !== void 0 || prev[key] !== void 0;\n    },\n    get: function (key) {\n      var val = curr[key];\n      if (val !== void 0) return val;\n      if ((val = prev[key]) !== void 0) {\n        keep(key, val);\n        return val;\n      }\n    },\n    set: function (key, value) {\n      if (curr[key] !== void 0) {\n        curr[key] = value;\n      } else {\n        keep(key, value);\n      }\n    }\n  };\n}\nvar CacheMap = new Map();\n/**\n * 缓存函数的计算结果，避免重复计算\n * @example\n * _.memoize(calColor);\n * _.memoize(calColor, (...args) => args[0]);\n * @param fn 缓存的函数\n * @param resolver 生成缓存 key 的函数\n * @param maxSize lru 缓存的大小\n */\nexport default function memoize(fn, resolver, maxSize) {\n  if (maxSize === void 0) {\n    maxSize = 128;\n  }\n  var memoized = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    // 使用方法构造 key，如果不存在 resolver，则直接取第一个参数作为 key\n    var key = resolver ? resolver.apply(this, args) : args[0];\n    if (!CacheMap.has(fn)) CacheMap.set(fn, flru(maxSize));\n    var cache = CacheMap.get(fn);\n    if (cache.has(key)) return cache.get(key);\n    var result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n  return memoized;\n}","map":{"version":3,"names":["flru","max","num","curr","prev","limit","keep","key","value","reset","isPartial","Object","create","clear","has","get","val","set","CacheMap","Map","memoize","fn","resolver","maxSize","memoized","args","_i","arguments","length","apply","cache","result"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/util/src/lodash/memoize.ts"],"sourcesContent":["function flru(max: number) {\n  let num, curr, prev;\n  const limit = max || 1;\n\n  function keep(key, value) {\n    if (++num > limit) {\n      prev = curr;\n      reset(1);\n      ++num;\n    }\n    curr[key] = value;\n  }\n\n  function reset(isPartial?: number) {\n    num = 0;\n    curr = Object.create(null);\n    isPartial || (prev = Object.create(null));\n  }\n\n  reset();\n\n  return {\n    clear: reset,\n    has: function (key) {\n      return curr[key] !== void 0 || prev[key] !== void 0;\n    },\n    get: function (key) {\n      var val = curr[key];\n      if (val !== void 0) return val;\n      if ((val = prev[key]) !== void 0) {\n        keep(key, val);\n        return val;\n      }\n    },\n    set: function (key, value) {\n      if (curr[key] !== void 0) {\n        curr[key] = value;\n      } else {\n        keep(key, value);\n      }\n    },\n  };\n}\n\nconst CacheMap = new Map<Function, ReturnType<typeof flru>>();\n\n/**\n * 缓存函数的计算结果，避免重复计算\n * @example\n * _.memoize(calColor);\n * _.memoize(calColor, (...args) => args[0]);\n * @param fn 缓存的函数\n * @param resolver 生成缓存 key 的函数\n * @param maxSize lru 缓存的大小\n */\nexport default function memoize<T extends Function>(fn: T, resolver?: (...args: any[]) => string, maxSize = 128) {\n  const memoized = function (...args) {\n    // 使用方法构造 key，如果不存在 resolver，则直接取第一个参数作为 key\n    const key = resolver ? resolver.apply(this, args) : args[0];\n    if (!CacheMap.has(fn)) CacheMap.set(fn, flru(maxSize));\n    const cache = CacheMap.get(fn);\n\n    if (cache.has(key)) return cache.get(key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n\n  return memoized as unknown as T;\n}\n"],"mappings":"AAAA,SAASA,IAAIA,CAACC,GAAW;EACvB,IAAIC,GAAG,EAAEC,IAAI,EAAEC,IAAI;EACnB,IAAMC,KAAK,GAAGJ,GAAG,IAAI,CAAC;EAEtB,SAASK,IAAIA,CAACC,GAAG,EAAEC,KAAK;IACtB,IAAI,EAAEN,GAAG,GAAGG,KAAK,EAAE;MACjBD,IAAI,GAAGD,IAAI;MACXM,KAAK,CAAC,CAAC,CAAC;MACR,EAAEP,GAAG;IACP;IACAC,IAAI,CAACI,GAAG,CAAC,GAAGC,KAAK;EACnB;EAEA,SAASC,KAAKA,CAACC,SAAkB;IAC/BR,GAAG,GAAG,CAAC;IACPC,IAAI,GAAGQ,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;IAC1BF,SAAS,KAAKN,IAAI,GAAGO,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC,CAAC;EAC3C;EAEAH,KAAK,EAAE;EAEP,OAAO;IACLI,KAAK,EAAEJ,KAAK;IACZK,GAAG,EAAE,SAAAA,CAAUP,GAAG;MAChB,OAAOJ,IAAI,CAACI,GAAG,CAAC,KAAK,KAAK,CAAC,IAAIH,IAAI,CAACG,GAAG,CAAC,KAAK,KAAK,CAAC;IACrD,CAAC;IACDQ,GAAG,EAAE,SAAAA,CAAUR,GAAG;MAChB,IAAIS,GAAG,GAAGb,IAAI,CAACI,GAAG,CAAC;MACnB,IAAIS,GAAG,KAAK,KAAK,CAAC,EAAE,OAAOA,GAAG;MAC9B,IAAI,CAACA,GAAG,GAAGZ,IAAI,CAACG,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;QAChCD,IAAI,CAACC,GAAG,EAAES,GAAG,CAAC;QACd,OAAOA,GAAG;MACZ;IACF,CAAC;IACDC,GAAG,EAAE,SAAAA,CAAUV,GAAG,EAAEC,KAAK;MACvB,IAAIL,IAAI,CAACI,GAAG,CAAC,KAAK,KAAK,CAAC,EAAE;QACxBJ,IAAI,CAACI,GAAG,CAAC,GAAGC,KAAK;MACnB,CAAC,MAAM;QACLF,IAAI,CAACC,GAAG,EAAEC,KAAK,CAAC;MAClB;IACF;GACD;AACH;AAEA,IAAMU,QAAQ,GAAG,IAAIC,GAAG,EAAqC;AAE7D;;;;;;;;;AASA,eAAc,SAAUC,OAAOA,CAAqBC,EAAK,EAAEC,QAAqC,EAAEC,OAAa;EAAb,IAAAA,OAAA;IAAAA,OAAA,MAAa;EAAA;EAC7G,IAAMC,QAAQ,GAAG,SAAAA,CAAA;IAAU,IAAAC,IAAA;SAAA,IAAAC,EAAA,IAAO,EAAPA,EAAA,GAAAC,SAAA,CAAAC,MAAO,EAAPF,EAAA,EAAO;MAAPD,IAAA,CAAAC,EAAA,IAAAC,SAAA,CAAAD,EAAA;;IACzB;IACA,IAAMnB,GAAG,GAAGe,QAAQ,GAAGA,QAAQ,CAACO,KAAK,CAAC,IAAI,EAAEJ,IAAI,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;IAC3D,IAAI,CAACP,QAAQ,CAACJ,GAAG,CAACO,EAAE,CAAC,EAAEH,QAAQ,CAACD,GAAG,CAACI,EAAE,EAAErB,IAAI,CAACuB,OAAO,CAAC,CAAC;IACtD,IAAMO,KAAK,GAAGZ,QAAQ,CAACH,GAAG,CAACM,EAAE,CAAC;IAE9B,IAAIS,KAAK,CAAChB,GAAG,CAACP,GAAG,CAAC,EAAE,OAAOuB,KAAK,CAACf,GAAG,CAACR,GAAG,CAAC;IACzC,IAAMwB,MAAM,GAAGV,EAAE,CAACQ,KAAK,CAAC,IAAI,EAAEJ,IAAI,CAAC;IACnCK,KAAK,CAACb,GAAG,CAACV,GAAG,EAAEwB,MAAM,CAAC;IACtB,OAAOA,MAAM;EACf,CAAC;EAED,OAAOP,QAAwB;AACjC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}