{"ast":null,"code":"\"use strict\";\n\nvar rankUtil = require(\"./util\");\nvar longestPath = rankUtil.longestPath;\nvar feasibleTree = require(\"./feasible-tree\");\nvar networkSimplex = require(\"./network-simplex\");\nmodule.exports = rank;\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case \"network-simplex\":\n      networkSimplexRanker(g);\n      break;\n    case \"tight-tree\":\n      tightTreeRanker(g);\n      break;\n    case \"longest-path\":\n      longestPathRanker(g);\n      break;\n    default:\n      networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}","map":{"version":3,"names":["rankUtil","require","longestPath","feasibleTree","networkSimplex","module","exports","rank","g","graph","ranker","networkSimplexRanker","tightTreeRanker","longestPathRanker"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/dagre/lib/rank/index.js"],"sourcesContent":["\"use strict\";\n\nvar rankUtil = require(\"./util\");\nvar longestPath = rankUtil.longestPath;\nvar feasibleTree = require(\"./feasible-tree\");\nvar networkSimplex = require(\"./network-simplex\");\n\nmodule.exports = rank;\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch(g.graph().ranker) {\n  case \"network-simplex\": networkSimplexRanker(g); break;\n  case \"tight-tree\": tightTreeRanker(g); break;\n  case \"longest-path\": longestPathRanker(g); break;\n  default: networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,IAAIC,WAAW,GAAGF,QAAQ,CAACE,WAAW;AACtC,IAAIC,YAAY,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAC7C,IAAIG,cAAc,GAAGH,OAAO,CAAC,mBAAmB,CAAC;AAEjDI,MAAM,CAACC,OAAO,GAAGC,IAAI;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAIA,CAACC,CAAC,EAAE;EACf,QAAOA,CAAC,CAACC,KAAK,CAAC,CAAC,CAACC,MAAM;IACvB,KAAK,iBAAiB;MAAEC,oBAAoB,CAACH,CAAC,CAAC;MAAE;IACjD,KAAK,YAAY;MAAEI,eAAe,CAACJ,CAAC,CAAC;MAAE;IACvC,KAAK,cAAc;MAAEK,iBAAiB,CAACL,CAAC,CAAC;MAAE;IAC3C;MAASG,oBAAoB,CAACH,CAAC,CAAC;EAChC;AACF;;AAEA;AACA,IAAIK,iBAAiB,GAAGX,WAAW;AAEnC,SAASU,eAAeA,CAACJ,CAAC,EAAE;EAC1BN,WAAW,CAACM,CAAC,CAAC;EACdL,YAAY,CAACK,CAAC,CAAC;AACjB;AAEA,SAASG,oBAAoBA,CAACH,CAAC,EAAE;EAC/BJ,cAAc,CAACI,CAAC,CAAC;AACnB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}