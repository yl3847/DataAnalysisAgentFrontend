{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { isEmpty, memoize } from '@antv/util';\nimport { idOf } from '../utils/id';\nimport { parseSize } from '../utils/size';\nimport { BaseLayout } from './base-layout';\n/**\n * <zh/> 鱼骨图布局\n *\n * <en/> Fishbone layout\n * @remarks\n * <zh/> [鱼骨图布局](https://en.wikipedia.org/wiki/Ishikawa_diagram)是一种专门用于表示层次结构数据的图形布局方式。它通过模拟鱼骨的形状，将数据节点按照层次结构排列，使得数据的层次关系更加清晰直观。鱼骨图布局特别适用于需要展示因果关系、层次结构或分类信息的数据集。\n *\n * <en/> [Fishbone layout](https://en.wikipedia.org/wiki/Ishikawa_diagram) is a graphical layout method specifically designed to represent hierarchical data. By simulating the shape of a fishbone, it arranges data nodes according to their hierarchical structure, making the hierarchical relationships of the data clearer and more intuitive. The fishbone diagram layout is particularly suitable for datasets that need to display causal relationships, hierarchical structures, or classification information.\n */\nexport class FishboneLayout extends BaseLayout {\n  constructor() {\n    super(...arguments);\n    this.id = 'fishbone';\n  }\n  getRoot() {\n    const roots = this.context.model.getRootsData();\n    if (isEmpty(roots) || roots.length > 2) return;\n    return roots[0];\n  }\n  formatSize(nodeSize) {\n    const nodeSizeFunc = typeof nodeSize === 'function' ? nodeSize : () => nodeSize;\n    return node => parseSize(nodeSizeFunc(node));\n  }\n  doLayout(root, options) {\n    const {\n      hGap,\n      getRibSep,\n      vGap,\n      nodeSize,\n      height\n    } = options;\n    const {\n      model\n    } = this.context;\n    const getSize = this.formatSize(nodeSize);\n    let ribX = getSize(root)[0] + getRibSep(root);\n    const getHorizontalOffset = (node, result = 0) => {\n      var _a;\n      result += hGap * ((node.children || []).length + 1);\n      (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach(childId => {\n        var _a;\n        const child = model.getNodeLikeDatum(childId);\n        (_a = child.children) === null || _a === void 0 ? void 0 : _a.forEach(grandChildId => {\n          const grandChild = model.getNodeLikeDatum(grandChildId);\n          result = getHorizontalOffset(grandChild, result);\n        });\n      });\n      return result;\n    };\n    const getAuxiliaryPoint = node => {\n      if (node.depth === 1) return ribX;\n      const parent = model.getParentData(node.id, 'tree');\n      if (isAtEvenDepth(node)) {\n        const ancestor = model.getParentData(parent.id, 'tree');\n        const deltaY = calculateY(node) - calculateY(ancestor);\n        return getAuxiliaryPoint(parent) + deltaY * hGap / vGap;\n      } else {\n        const nodeIndex = (parent.children || []).indexOf(node.id);\n        const followingSiblingsIncludeSelf = model.getNodeData((parent.children || []).slice(nodeIndex));\n        return calculateX(parent) - followingSiblingsIncludeSelf.reduce((acc, sibling) => acc + getHorizontalOffset(sibling), 0) - getSize(parent)[0] / 2;\n      }\n    };\n    const calculateX = memoize(node => {\n      if (isRoot(node)) return getSize(node)[0] / 2;\n      const parent = model.getParentData(node.id, 'tree');\n      if (isAtEvenDepth(node)) {\n        return getAuxiliaryPoint(node) + getHorizontalOffset(node) + getSize(node)[0] / 2;\n      } else {\n        const deltaY = calculateY(node) - calculateY(parent);\n        const ratio = hGap / vGap;\n        return getAuxiliaryPoint(node) + deltaY * ratio;\n      }\n    }, node => node.id);\n    const getParentY = nodeId => calculateY(model.getParentData(nodeId, 'tree'));\n    const calculateY = memoize(node => {\n      if (isRoot(node)) return height / 2;\n      if (!isAtEvenDepth(node)) {\n        // If the node has no children, calculate Y based on the parent\n        if (isEmpty(node.children)) return getParentY(node.id) + vGap;\n        // If the last child has no children, calculate Y based on the last child\n        const lastChild = model.getNodeLikeDatum(node.children.slice(-1)[0]);\n        if (isEmpty(lastChild.children)) return calculateY(lastChild) + vGap;\n        // If the last child has children, calculate Y based on the last descendant of the last child\n        const lastDescendant = model.getDescendantsData(node.id).slice(-1)[0];\n        return (isAtEvenDepth(lastDescendant) ? getParentY(lastDescendant.id) : calculateY(lastDescendant)) + vGap;\n      } else {\n        // depth > 0 && isAtEvenDepth(node)\n        const parent = model.getParentData(node.id, 'tree');\n        const nodeIndex = parent.children.indexOf(node.id);\n        // If the node is the first sibling, return Y based on parent\n        if (nodeIndex === 0) return getParentY(parent.id) + vGap;\n        // If the previous sibling has no children, calculate Y based on the previous sibling\n        const prevSibling = model.getNodeLikeDatum(parent.children[nodeIndex - 1]);\n        if (isEmpty(prevSibling.children)) return calculateY(prevSibling) + vGap;\n        // If the previous sibling has children, calculate Y based on the last descendant of the previous sibling\n        const descendants = model.getDescendantsData(prevSibling.id);\n        return Math.max(...descendants.map(descendant => isAtEvenDepth(descendant) ? getParentY(descendant.id) : calculateY(descendant))) + vGap;\n      }\n    }, node => node.id);\n    let tmpRibX = 0;\n    const result = {\n      nodes: [],\n      edges: []\n    };\n    const layout = node => {\n      var _a;\n      (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach(childId => layout(model.getNodeLikeDatum(childId)));\n      const y = calculateY(node);\n      const x = calculateX(node);\n      result.nodes.push({\n        id: node.id,\n        x,\n        y\n      });\n      if (isRoot(node)) return;\n      const edge = model.getRelatedEdgesData(node.id, 'in')[0];\n      const controlPoint = [getAuxiliaryPoint(node), isAtEvenDepth(node) ? y : getParentY(node.id)];\n      result.edges.push({\n        id: idOf(edge),\n        controlPoints: [controlPoint],\n        relatedNodeId: node.id\n      });\n      tmpRibX = Math.max(tmpRibX, x + getRibSep(node));\n      if (node.depth === 1) ribX = tmpRibX;\n    };\n    layout(root);\n    return result;\n  }\n  placeAlterative(result, root) {\n    const oddIndexedRibs = (root.children || []).filter((_, index) => index % 2 !== 0);\n    if (oddIndexedRibs.length === 0) return result;\n    const {\n      model\n    } = this.context;\n    const rootY = result.nodes.find(node => node.id === root.id).y;\n    const shouldFlip = nodeId => {\n      const ancestors = model.getAncestorsData(nodeId, 'tree');\n      if (isEmpty(ancestors)) return false;\n      const ribId = ancestors.length === 1 ? nodeId : ancestors[ancestors.length - 2].id;\n      return oddIndexedRibs.includes(ribId);\n    };\n    result.nodes.forEach(node => {\n      if (shouldFlip(node.id)) node.y = 2 * rootY - node.y;\n    });\n    result.edges.forEach(edge => {\n      if (shouldFlip(edge.relatedNodeId)) {\n        edge.controlPoints = edge.controlPoints.map(point => [point[0], 2 * rootY - point[1]]);\n      }\n    });\n  }\n  rightToLeft(result, options) {\n    result.nodes.forEach(node => node.x = options.width - node.x);\n    result.edges.forEach(edge => {\n      edge.controlPoints = edge.controlPoints.map(point => [options.width - point[0], point[1]]);\n    });\n    return result;\n  }\n  execute(data, propOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const options = Object.assign(Object.assign(Object.assign({}, FishboneLayout.defaultOptions), this.options), propOptions);\n      const {\n        direction,\n        nodeSize\n      } = options;\n      const root = this.getRoot();\n      if (!root) return data;\n      const getSize = this.formatSize(nodeSize);\n      options.vGap || (options.vGap = Math.max(...(data.nodes || []).map(node => getSize(node)[1])));\n      options.hGap || (options.hGap = Math.max(...(data.nodes || []).map(node => getSize(node)[0])));\n      let result = this.doLayout(root, options);\n      this.placeAlterative(result, root);\n      if (direction === 'RL') {\n        result = this.rightToLeft(result, options);\n      }\n      const {\n        model\n      } = this.context;\n      const nodes = [];\n      const edges = [];\n      result.nodes.forEach(node => {\n        const {\n          id,\n          x,\n          y\n        } = node;\n        const nodeData = model.getNodeLikeDatum(id);\n        nodes.push(assignElementStyle(nodeData, {\n          x,\n          y\n        }));\n      });\n      result.edges.forEach(edge => {\n        const {\n          id,\n          controlPoints\n        } = edge;\n        const edgeData = model.getEdgeDatum(id);\n        edges.push(assignElementStyle(edgeData, {\n          controlPoints\n        }));\n      });\n      return {\n        nodes,\n        edges\n      };\n    });\n  }\n}\nFishboneLayout.defaultOptions = {\n  direction: 'RL',\n  getRibSep: () => 60\n};\nconst assignElementStyle = (element, style) => {\n  return Object.assign(Object.assign({}, element), {\n    style: Object.assign(Object.assign({}, element.style || {}), style)\n  });\n};\nconst isRoot = node => node.depth === 0;\nconst isAtEvenDepth = node => (node.depth || (node.depth = 0)) % 2 === 0;","map":{"version":3,"names":["isEmpty","memoize","idOf","parseSize","BaseLayout","FishboneLayout","constructor","id","getRoot","roots","context","model","getRootsData","length","formatSize","nodeSize","nodeSizeFunc","node","doLayout","root","options","hGap","getRibSep","vGap","height","getSize","ribX","getHorizontalOffset","result","children","_a","forEach","childId","child","getNodeLikeDatum","grandChildId","grandChild","getAuxiliaryPoint","depth","parent","getParentData","isAtEvenDepth","ancestor","deltaY","calculateY","nodeIndex","indexOf","followingSiblingsIncludeSelf","getNodeData","slice","calculateX","reduce","acc","sibling","isRoot","ratio","getParentY","nodeId","lastChild","lastDescendant","getDescendantsData","prevSibling","descendants","Math","max","map","descendant","tmpRibX","nodes","edges","layout","y","x","push","edge","getRelatedEdgesData","controlPoint","controlPoints","relatedNodeId","placeAlterative","oddIndexedRibs","filter","_","index","rootY","find","shouldFlip","ancestors","getAncestorsData","ribId","includes","point","rightToLeft","width","execute","data","propOptions","Object","assign","defaultOptions","direction","nodeData","assignElementStyle","edgeData","getEdgeDatum","element","style"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/layouts/fishbone.ts"],"sourcesContent":["import { isEmpty, memoize } from '@antv/util';\nimport type { BaseLayoutOptions } from '../layouts/types';\nimport type { EdgeData, GraphData, NodeData } from '../spec';\nimport type { ElementDatum, ID, Point, Size, STDSize } from '../types';\nimport { idOf } from '../utils/id';\nimport { parseSize } from '../utils/size';\nimport { BaseLayout } from './base-layout';\n\nexport interface FishboneLayoutOptions extends BaseLayoutOptions {\n  /**\n   * <zh/> 节点大小\n   *\n   * <en/> Node size\n   */\n  nodeSize?: Size | ((node: NodeData) => Size);\n  /**\n   * <zh/> 排布方向\n   * - `'RL'` 从右到左，鱼头在右\n   * - `'LR'` 从左到右，鱼头在左\n   *\n   * <en/> Layout direction\n   * - `'RL'` From right to left, the fish head is on the right\n   * - `'LR'` From left to right, the fish head is on the left\n   * @defaultValue `'LR'`\n   */\n  direction?: 'RL' | 'LR';\n  /**\n   * <zh/> 获取水平间距\n   *\n   * <en/> Get horizontal spacing\n   */\n  hGap?: number;\n  /**\n   * <zh/> 获取垂直间距\n   *\n   * <en/> Get vertical spacing\n   */\n  vGap?: number;\n  /**\n   * <zh/> 获取鱼骨间距\n   *\n   * <en/> Get rib separation\n   * @defaultValue () => 60\n   */\n  getRibSep?: (node: NodeData) => number;\n  /**\n   * <zh/> 布局宽度\n   *\n   * <en/> Layout width\n   */\n  width?: number;\n  /**\n   * <zh/> 布局高度\n   *\n   * <en/> Layout height\n   */\n  height?: number;\n}\n\ntype NodeResult = { id: ID; x: number; y: number };\ntype EdgeResult = { id: ID; controlPoints: Point[]; relatedNodeId: ID };\ntype LayoutResult = { nodes: NodeResult[]; edges: EdgeResult[] };\n\n/**\n * <zh/> 鱼骨图布局\n *\n * <en/> Fishbone layout\n * @remarks\n * <zh/> [鱼骨图布局](https://en.wikipedia.org/wiki/Ishikawa_diagram)是一种专门用于表示层次结构数据的图形布局方式。它通过模拟鱼骨的形状，将数据节点按照层次结构排列，使得数据的层次关系更加清晰直观。鱼骨图布局特别适用于需要展示因果关系、层次结构或分类信息的数据集。\n *\n * <en/> [Fishbone layout](https://en.wikipedia.org/wiki/Ishikawa_diagram) is a graphical layout method specifically designed to represent hierarchical data. By simulating the shape of a fishbone, it arranges data nodes according to their hierarchical structure, making the hierarchical relationships of the data clearer and more intuitive. The fishbone diagram layout is particularly suitable for datasets that need to display causal relationships, hierarchical structures, or classification information.\n */\nexport class FishboneLayout extends BaseLayout {\n  id = 'fishbone';\n\n  static defaultOptions: Partial<FishboneLayoutOptions> = {\n    direction: 'RL',\n    getRibSep: () => 60,\n  };\n\n  private getRoot() {\n    const roots = this.context.model.getRootsData();\n    if (isEmpty(roots) || roots.length > 2) return;\n\n    return roots[0];\n  }\n\n  private formatSize(nodeSize: Size | ((node: NodeData) => Size)): (node: NodeData) => STDSize {\n    const nodeSizeFunc = typeof nodeSize === 'function' ? nodeSize : () => nodeSize;\n    return (node: NodeData) => parseSize(nodeSizeFunc(node));\n  }\n\n  private doLayout(root: NodeData, options: Required<FishboneLayoutOptions>): LayoutResult {\n    const { hGap, getRibSep, vGap, nodeSize, height } = options;\n\n    const { model } = this.context;\n\n    const getSize = this.formatSize(nodeSize);\n    let ribX = getSize(root)[0] + getRibSep(root);\n\n    const getHorizontalOffset = (node: NodeData, result = 0): number => {\n      result += hGap * ((node.children || []).length + 1);\n\n      node.children?.forEach((childId) => {\n        const child = model.getNodeLikeDatum(childId) as NodeData;\n        child.children?.forEach((grandChildId) => {\n          const grandChild = model.getNodeLikeDatum(grandChildId) as NodeData;\n          result = getHorizontalOffset(grandChild, result);\n        });\n      });\n\n      return result;\n    };\n\n    const getAuxiliaryPoint = (node: NodeData): number => {\n      if (node.depth === 1) return ribX;\n\n      const parent = model.getParentData(node.id, 'tree') as NodeData;\n\n      if (isAtEvenDepth(node)) {\n        const ancestor = model.getParentData(parent.id, 'tree') as NodeData;\n        const deltaY = calculateY(node) - calculateY(ancestor);\n        return getAuxiliaryPoint(parent) + (deltaY * hGap) / vGap;\n      } else {\n        const nodeIndex = (parent.children || []).indexOf(node.id);\n        const followingSiblingsIncludeSelf = model.getNodeData((parent.children || []).slice(nodeIndex));\n        return (\n          calculateX(parent) -\n          followingSiblingsIncludeSelf.reduce((acc, sibling) => acc + getHorizontalOffset(sibling), 0) -\n          getSize(parent)[0] / 2\n        );\n      }\n    };\n\n    const calculateX = memoize(\n      (node: NodeData): number => {\n        if (isRoot(node)) return getSize(node)[0] / 2;\n\n        const parent = model.getParentData(node.id, 'tree') as NodeData;\n\n        if (isAtEvenDepth(node)) {\n          return getAuxiliaryPoint(node) + getHorizontalOffset(node) + getSize(node)[0] / 2;\n        } else {\n          const deltaY = calculateY(node) - calculateY(parent);\n          const ratio = hGap / vGap;\n          return getAuxiliaryPoint(node) + deltaY * ratio;\n        }\n      },\n      (node) => node.id,\n    );\n\n    const getParentY = (nodeId: ID): number => calculateY(model.getParentData(nodeId, 'tree')!);\n\n    const calculateY = memoize(\n      (node: NodeData): number => {\n        if (isRoot(node)) return height / 2;\n\n        if (!isAtEvenDepth(node)) {\n          // If the node has no children, calculate Y based on the parent\n          if (isEmpty(node.children)) return getParentY(node.id) + vGap;\n\n          // If the last child has no children, calculate Y based on the last child\n          const lastChild = model.getNodeLikeDatum(node.children!.slice(-1)[0]);\n          if (isEmpty(lastChild.children)) return calculateY(lastChild) + vGap;\n\n          // If the last child has children, calculate Y based on the last descendant of the last child\n          const lastDescendant = model.getDescendantsData(node.id).slice(-1)[0];\n          return (isAtEvenDepth(lastDescendant) ? getParentY(lastDescendant.id) : calculateY(lastDescendant)) + vGap;\n        } else {\n          // depth > 0 && isAtEvenDepth(node)\n          const parent = model.getParentData(node.id, 'tree') as NodeData;\n          const nodeIndex = parent.children!.indexOf(node.id);\n          // If the node is the first sibling, return Y based on parent\n          if (nodeIndex === 0) return getParentY(parent.id) + vGap;\n\n          // If the previous sibling has no children, calculate Y based on the previous sibling\n          const prevSibling = model.getNodeLikeDatum(parent.children![nodeIndex - 1]);\n          if (isEmpty(prevSibling.children)) return calculateY(prevSibling) + vGap;\n\n          // If the previous sibling has children, calculate Y based on the last descendant of the previous sibling\n          const descendants = model.getDescendantsData(prevSibling.id);\n          return (\n            Math.max(\n              ...descendants.map((descendant) =>\n                isAtEvenDepth(descendant) ? getParentY(descendant.id) : calculateY(descendant),\n              ),\n            ) + vGap\n          );\n        }\n      },\n      (node) => node.id,\n    );\n\n    let tmpRibX = 0;\n    const result: LayoutResult = { nodes: [], edges: [] };\n\n    const layout = (node: NodeData) => {\n      node.children?.forEach((childId) => layout(model.getNodeLikeDatum(childId)));\n\n      const y = calculateY(node);\n      const x = calculateX(node);\n      result.nodes.push({ id: node.id, x, y });\n\n      if (isRoot(node)) return;\n\n      const edge = model.getRelatedEdgesData(node.id, 'in')[0];\n      const controlPoint = [getAuxiliaryPoint(node), isAtEvenDepth(node) ? y : getParentY(node.id)] as Point;\n      result.edges.push({ id: idOf(edge), controlPoints: [controlPoint], relatedNodeId: node.id });\n\n      tmpRibX = Math.max(tmpRibX, x + getRibSep(node));\n      if (node.depth === 1) ribX = tmpRibX;\n    };\n\n    layout(root);\n\n    return result;\n  }\n\n  private placeAlterative(result: LayoutResult, root: NodeData) {\n    const oddIndexedRibs = (root.children || []).filter((_, index) => index % 2 !== 0);\n    if (oddIndexedRibs.length === 0) return result;\n\n    const { model } = this.context;\n    const rootY = result.nodes.find((node) => node.id === root.id)!.y;\n\n    const shouldFlip = (nodeId: ID) => {\n      const ancestors = model.getAncestorsData(nodeId, 'tree');\n      if (isEmpty(ancestors)) return false;\n      const ribId = ancestors.length === 1 ? nodeId : ancestors[ancestors.length - 2].id;\n      return oddIndexedRibs.includes(ribId);\n    };\n\n    result.nodes.forEach((node) => {\n      if (shouldFlip(node.id)) node.y = 2 * rootY - node.y;\n    });\n    result.edges.forEach((edge) => {\n      if (shouldFlip(edge.relatedNodeId)) {\n        edge.controlPoints = edge.controlPoints.map((point) => [point[0], 2 * rootY - point[1]]);\n      }\n    });\n  }\n\n  private rightToLeft(result: LayoutResult, options: Required<FishboneLayoutOptions>) {\n    result.nodes.forEach((node) => (node.x = options.width! - node.x));\n    result.edges.forEach((edge) => {\n      edge.controlPoints = edge.controlPoints.map((point) => [options.width! - point[0], point[1]]);\n    });\n    return result;\n  }\n\n  async execute(data: GraphData, propOptions: FishboneLayoutOptions): Promise<GraphData> {\n    const options = { ...FishboneLayout.defaultOptions, ...this.options, ...propOptions };\n    const { direction, nodeSize } = options;\n\n    const root = this.getRoot();\n    if (!root) return data;\n\n    const getSize = this.formatSize(nodeSize);\n    options.vGap ||= Math.max(...(data.nodes || []).map((node) => getSize(node)[1]));\n    options.hGap ||= Math.max(...(data.nodes || []).map((node) => getSize(node)[0]));\n\n    let result = this.doLayout(root, options);\n\n    this.placeAlterative(result, root);\n\n    if (direction === 'RL') {\n      result = this.rightToLeft(result, options);\n    }\n\n    const { model } = this.context;\n    const nodes: NodeData[] = [];\n    const edges: EdgeData[] = [];\n\n    result.nodes.forEach((node) => {\n      const { id, x, y } = node;\n      const nodeData = model.getNodeLikeDatum(id);\n      nodes.push(assignElementStyle(nodeData, { x, y }) as NodeData);\n    });\n\n    result.edges.forEach((edge) => {\n      const { id, controlPoints } = edge;\n      const edgeData = model.getEdgeDatum(id);\n      edges.push(assignElementStyle(edgeData, { controlPoints }) as EdgeData);\n    });\n\n    return { nodes, edges };\n  }\n}\n\nconst assignElementStyle = (element: ElementDatum, style: Record<string, unknown>) => {\n  return { ...element, style: { ...(element.style || {}), ...style } };\n};\n\nconst isRoot = (node: NodeData) => node.depth === 0;\n\nconst isAtEvenDepth = (node: NodeData) => (node.depth ||= 0) % 2 === 0;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,OAAO,EAAEC,OAAO,QAAQ,YAAY;AAI7C,SAASC,IAAI,QAAQ,aAAa;AAClC,SAASC,SAAS,QAAQ,eAAe;AACzC,SAASC,UAAU,QAAQ,eAAe;AAyD1C;;;;;;;;;AASA,OAAM,MAAOC,cAAe,SAAQD,UAAU;EAA9CE,YAAA;;IACE,KAAAC,EAAE,GAAG,UAAU;EAsNjB;EA/MUC,OAAOA,CAAA;IACb,MAAMC,KAAK,GAAG,IAAI,CAACC,OAAO,CAACC,KAAK,CAACC,YAAY,EAAE;IAC/C,IAAIZ,OAAO,CAACS,KAAK,CAAC,IAAIA,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE;IAExC,OAAOJ,KAAK,CAAC,CAAC,CAAC;EACjB;EAEQK,UAAUA,CAACC,QAA2C;IAC5D,MAAMC,YAAY,GAAG,OAAOD,QAAQ,KAAK,UAAU,GAAGA,QAAQ,GAAG,MAAMA,QAAQ;IAC/E,OAAQE,IAAc,IAAKd,SAAS,CAACa,YAAY,CAACC,IAAI,CAAC,CAAC;EAC1D;EAEQC,QAAQA,CAACC,IAAc,EAAEC,OAAwC;IACvE,MAAM;MAAEC,IAAI;MAAEC,SAAS;MAAEC,IAAI;MAAER,QAAQ;MAAES;IAAM,CAAE,GAAGJ,OAAO;IAE3D,MAAM;MAAET;IAAK,CAAE,GAAG,IAAI,CAACD,OAAO;IAE9B,MAAMe,OAAO,GAAG,IAAI,CAACX,UAAU,CAACC,QAAQ,CAAC;IACzC,IAAIW,IAAI,GAAGD,OAAO,CAACN,IAAI,CAAC,CAAC,CAAC,CAAC,GAAGG,SAAS,CAACH,IAAI,CAAC;IAE7C,MAAMQ,mBAAmB,GAAGA,CAACV,IAAc,EAAEW,MAAM,GAAG,CAAC,KAAY;;MACjEA,MAAM,IAAIP,IAAI,IAAI,CAACJ,IAAI,CAACY,QAAQ,IAAI,EAAE,EAAEhB,MAAM,GAAG,CAAC,CAAC;MAEnD,CAAAiB,EAAA,GAAAb,IAAI,CAACY,QAAQ,cAAAC,EAAA,uBAAAA,EAAA,CAAEC,OAAO,CAAEC,OAAO,IAAI;;QACjC,MAAMC,KAAK,GAAGtB,KAAK,CAACuB,gBAAgB,CAACF,OAAO,CAAa;QACzD,CAAAF,EAAA,GAAAG,KAAK,CAACJ,QAAQ,cAAAC,EAAA,uBAAAA,EAAA,CAAEC,OAAO,CAAEI,YAAY,IAAI;UACvC,MAAMC,UAAU,GAAGzB,KAAK,CAACuB,gBAAgB,CAACC,YAAY,CAAa;UACnEP,MAAM,GAAGD,mBAAmB,CAACS,UAAU,EAAER,MAAM,CAAC;QAClD,CAAC,CAAC;MACJ,CAAC,CAAC;MAEF,OAAOA,MAAM;IACf,CAAC;IAED,MAAMS,iBAAiB,GAAIpB,IAAc,IAAY;MACnD,IAAIA,IAAI,CAACqB,KAAK,KAAK,CAAC,EAAE,OAAOZ,IAAI;MAEjC,MAAMa,MAAM,GAAG5B,KAAK,CAAC6B,aAAa,CAACvB,IAAI,CAACV,EAAE,EAAE,MAAM,CAAa;MAE/D,IAAIkC,aAAa,CAACxB,IAAI,CAAC,EAAE;QACvB,MAAMyB,QAAQ,GAAG/B,KAAK,CAAC6B,aAAa,CAACD,MAAM,CAAChC,EAAE,EAAE,MAAM,CAAa;QACnE,MAAMoC,MAAM,GAAGC,UAAU,CAAC3B,IAAI,CAAC,GAAG2B,UAAU,CAACF,QAAQ,CAAC;QACtD,OAAOL,iBAAiB,CAACE,MAAM,CAAC,GAAII,MAAM,GAAGtB,IAAI,GAAIE,IAAI;MAC3D,CAAC,MAAM;QACL,MAAMsB,SAAS,GAAG,CAACN,MAAM,CAACV,QAAQ,IAAI,EAAE,EAAEiB,OAAO,CAAC7B,IAAI,CAACV,EAAE,CAAC;QAC1D,MAAMwC,4BAA4B,GAAGpC,KAAK,CAACqC,WAAW,CAAC,CAACT,MAAM,CAACV,QAAQ,IAAI,EAAE,EAAEoB,KAAK,CAACJ,SAAS,CAAC,CAAC;QAChG,OACEK,UAAU,CAACX,MAAM,CAAC,GAClBQ,4BAA4B,CAACI,MAAM,CAAC,CAACC,GAAG,EAAEC,OAAO,KAAKD,GAAG,GAAGzB,mBAAmB,CAAC0B,OAAO,CAAC,EAAE,CAAC,CAAC,GAC5F5B,OAAO,CAACc,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MAE1B;IACF,CAAC;IAED,MAAMW,UAAU,GAAGjD,OAAO,CACvBgB,IAAc,IAAY;MACzB,IAAIqC,MAAM,CAACrC,IAAI,CAAC,EAAE,OAAOQ,OAAO,CAACR,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MAE7C,MAAMsB,MAAM,GAAG5B,KAAK,CAAC6B,aAAa,CAACvB,IAAI,CAACV,EAAE,EAAE,MAAM,CAAa;MAE/D,IAAIkC,aAAa,CAACxB,IAAI,CAAC,EAAE;QACvB,OAAOoB,iBAAiB,CAACpB,IAAI,CAAC,GAAGU,mBAAmB,CAACV,IAAI,CAAC,GAAGQ,OAAO,CAACR,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MACnF,CAAC,MAAM;QACL,MAAM0B,MAAM,GAAGC,UAAU,CAAC3B,IAAI,CAAC,GAAG2B,UAAU,CAACL,MAAM,CAAC;QACpD,MAAMgB,KAAK,GAAGlC,IAAI,GAAGE,IAAI;QACzB,OAAOc,iBAAiB,CAACpB,IAAI,CAAC,GAAG0B,MAAM,GAAGY,KAAK;MACjD;IACF,CAAC,EACAtC,IAAI,IAAKA,IAAI,CAACV,EAAE,CAClB;IAED,MAAMiD,UAAU,GAAIC,MAAU,IAAab,UAAU,CAACjC,KAAK,CAAC6B,aAAa,CAACiB,MAAM,EAAE,MAAM,CAAE,CAAC;IAE3F,MAAMb,UAAU,GAAG3C,OAAO,CACvBgB,IAAc,IAAY;MACzB,IAAIqC,MAAM,CAACrC,IAAI,CAAC,EAAE,OAAOO,MAAM,GAAG,CAAC;MAEnC,IAAI,CAACiB,aAAa,CAACxB,IAAI,CAAC,EAAE;QACxB;QACA,IAAIjB,OAAO,CAACiB,IAAI,CAACY,QAAQ,CAAC,EAAE,OAAO2B,UAAU,CAACvC,IAAI,CAACV,EAAE,CAAC,GAAGgB,IAAI;QAE7D;QACA,MAAMmC,SAAS,GAAG/C,KAAK,CAACuB,gBAAgB,CAACjB,IAAI,CAACY,QAAS,CAACoB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACrE,IAAIjD,OAAO,CAAC0D,SAAS,CAAC7B,QAAQ,CAAC,EAAE,OAAOe,UAAU,CAACc,SAAS,CAAC,GAAGnC,IAAI;QAEpE;QACA,MAAMoC,cAAc,GAAGhD,KAAK,CAACiD,kBAAkB,CAAC3C,IAAI,CAACV,EAAE,CAAC,CAAC0C,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACrE,OAAO,CAACR,aAAa,CAACkB,cAAc,CAAC,GAAGH,UAAU,CAACG,cAAc,CAACpD,EAAE,CAAC,GAAGqC,UAAU,CAACe,cAAc,CAAC,IAAIpC,IAAI;MAC5G,CAAC,MAAM;QACL;QACA,MAAMgB,MAAM,GAAG5B,KAAK,CAAC6B,aAAa,CAACvB,IAAI,CAACV,EAAE,EAAE,MAAM,CAAa;QAC/D,MAAMsC,SAAS,GAAGN,MAAM,CAACV,QAAS,CAACiB,OAAO,CAAC7B,IAAI,CAACV,EAAE,CAAC;QACnD;QACA,IAAIsC,SAAS,KAAK,CAAC,EAAE,OAAOW,UAAU,CAACjB,MAAM,CAAChC,EAAE,CAAC,GAAGgB,IAAI;QAExD;QACA,MAAMsC,WAAW,GAAGlD,KAAK,CAACuB,gBAAgB,CAACK,MAAM,CAACV,QAAS,CAACgB,SAAS,GAAG,CAAC,CAAC,CAAC;QAC3E,IAAI7C,OAAO,CAAC6D,WAAW,CAAChC,QAAQ,CAAC,EAAE,OAAOe,UAAU,CAACiB,WAAW,CAAC,GAAGtC,IAAI;QAExE;QACA,MAAMuC,WAAW,GAAGnD,KAAK,CAACiD,kBAAkB,CAACC,WAAW,CAACtD,EAAE,CAAC;QAC5D,OACEwD,IAAI,CAACC,GAAG,CACN,GAAGF,WAAW,CAACG,GAAG,CAAEC,UAAU,IAC5BzB,aAAa,CAACyB,UAAU,CAAC,GAAGV,UAAU,CAACU,UAAU,CAAC3D,EAAE,CAAC,GAAGqC,UAAU,CAACsB,UAAU,CAAC,CAC/E,CACF,GAAG3C,IAAI;MAEZ;IACF,CAAC,EACAN,IAAI,IAAKA,IAAI,CAACV,EAAE,CAClB;IAED,IAAI4D,OAAO,GAAG,CAAC;IACf,MAAMvC,MAAM,GAAiB;MAAEwC,KAAK,EAAE,EAAE;MAAEC,KAAK,EAAE;IAAE,CAAE;IAErD,MAAMC,MAAM,GAAIrD,IAAc,IAAI;;MAChC,CAAAa,EAAA,GAAAb,IAAI,CAACY,QAAQ,cAAAC,EAAA,uBAAAA,EAAA,CAAEC,OAAO,CAAEC,OAAO,IAAKsC,MAAM,CAAC3D,KAAK,CAACuB,gBAAgB,CAACF,OAAO,CAAC,CAAC,CAAC;MAE5E,MAAMuC,CAAC,GAAG3B,UAAU,CAAC3B,IAAI,CAAC;MAC1B,MAAMuD,CAAC,GAAGtB,UAAU,CAACjC,IAAI,CAAC;MAC1BW,MAAM,CAACwC,KAAK,CAACK,IAAI,CAAC;QAAElE,EAAE,EAAEU,IAAI,CAACV,EAAE;QAAEiE,CAAC;QAAED;MAAC,CAAE,CAAC;MAExC,IAAIjB,MAAM,CAACrC,IAAI,CAAC,EAAE;MAElB,MAAMyD,IAAI,GAAG/D,KAAK,CAACgE,mBAAmB,CAAC1D,IAAI,CAACV,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;MACxD,MAAMqE,YAAY,GAAG,CAACvC,iBAAiB,CAACpB,IAAI,CAAC,EAAEwB,aAAa,CAACxB,IAAI,CAAC,GAAGsD,CAAC,GAAGf,UAAU,CAACvC,IAAI,CAACV,EAAE,CAAC,CAAU;MACtGqB,MAAM,CAACyC,KAAK,CAACI,IAAI,CAAC;QAAElE,EAAE,EAAEL,IAAI,CAACwE,IAAI,CAAC;QAAEG,aAAa,EAAE,CAACD,YAAY,CAAC;QAAEE,aAAa,EAAE7D,IAAI,CAACV;MAAE,CAAE,CAAC;MAE5F4D,OAAO,GAAGJ,IAAI,CAACC,GAAG,CAACG,OAAO,EAAEK,CAAC,GAAGlD,SAAS,CAACL,IAAI,CAAC,CAAC;MAChD,IAAIA,IAAI,CAACqB,KAAK,KAAK,CAAC,EAAEZ,IAAI,GAAGyC,OAAO;IACtC,CAAC;IAEDG,MAAM,CAACnD,IAAI,CAAC;IAEZ,OAAOS,MAAM;EACf;EAEQmD,eAAeA,CAACnD,MAAoB,EAAET,IAAc;IAC1D,MAAM6D,cAAc,GAAG,CAAC7D,IAAI,CAACU,QAAQ,IAAI,EAAE,EAAEoD,MAAM,CAAC,CAACC,CAAC,EAAEC,KAAK,KAAKA,KAAK,GAAG,CAAC,KAAK,CAAC,CAAC;IAClF,IAAIH,cAAc,CAACnE,MAAM,KAAK,CAAC,EAAE,OAAOe,MAAM;IAE9C,MAAM;MAAEjB;IAAK,CAAE,GAAG,IAAI,CAACD,OAAO;IAC9B,MAAM0E,KAAK,GAAGxD,MAAM,CAACwC,KAAK,CAACiB,IAAI,CAAEpE,IAAI,IAAKA,IAAI,CAACV,EAAE,KAAKY,IAAI,CAACZ,EAAE,CAAE,CAACgE,CAAC;IAEjE,MAAMe,UAAU,GAAI7B,MAAU,IAAI;MAChC,MAAM8B,SAAS,GAAG5E,KAAK,CAAC6E,gBAAgB,CAAC/B,MAAM,EAAE,MAAM,CAAC;MACxD,IAAIzD,OAAO,CAACuF,SAAS,CAAC,EAAE,OAAO,KAAK;MACpC,MAAME,KAAK,GAAGF,SAAS,CAAC1E,MAAM,KAAK,CAAC,GAAG4C,MAAM,GAAG8B,SAAS,CAACA,SAAS,CAAC1E,MAAM,GAAG,CAAC,CAAC,CAACN,EAAE;MAClF,OAAOyE,cAAc,CAACU,QAAQ,CAACD,KAAK,CAAC;IACvC,CAAC;IAED7D,MAAM,CAACwC,KAAK,CAACrC,OAAO,CAAEd,IAAI,IAAI;MAC5B,IAAIqE,UAAU,CAACrE,IAAI,CAACV,EAAE,CAAC,EAAEU,IAAI,CAACsD,CAAC,GAAG,CAAC,GAAGa,KAAK,GAAGnE,IAAI,CAACsD,CAAC;IACtD,CAAC,CAAC;IACF3C,MAAM,CAACyC,KAAK,CAACtC,OAAO,CAAE2C,IAAI,IAAI;MAC5B,IAAIY,UAAU,CAACZ,IAAI,CAACI,aAAa,CAAC,EAAE;QAClCJ,IAAI,CAACG,aAAa,GAAGH,IAAI,CAACG,aAAa,CAACZ,GAAG,CAAE0B,KAAK,IAAK,CAACA,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,GAAGP,KAAK,GAAGO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAC1F;IACF,CAAC,CAAC;EACJ;EAEQC,WAAWA,CAAChE,MAAoB,EAAER,OAAwC;IAChFQ,MAAM,CAACwC,KAAK,CAACrC,OAAO,CAAEd,IAAI,IAAMA,IAAI,CAACuD,CAAC,GAAGpD,OAAO,CAACyE,KAAM,GAAG5E,IAAI,CAACuD,CAAE,CAAC;IAClE5C,MAAM,CAACyC,KAAK,CAACtC,OAAO,CAAE2C,IAAI,IAAI;MAC5BA,IAAI,CAACG,aAAa,GAAGH,IAAI,CAACG,aAAa,CAACZ,GAAG,CAAE0B,KAAK,IAAK,CAACvE,OAAO,CAACyE,KAAM,GAAGF,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/F,CAAC,CAAC;IACF,OAAO/D,MAAM;EACf;EAEMkE,OAAOA,CAACC,IAAe,EAAEC,WAAkC;;MAC/D,MAAM5E,OAAO,GAAA6E,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAQ7F,cAAc,CAAC8F,cAAc,GAAK,IAAI,CAAC/E,OAAO,GAAK4E,WAAW,CAAE;MACrF,MAAM;QAAEI,SAAS;QAAErF;MAAQ,CAAE,GAAGK,OAAO;MAEvC,MAAMD,IAAI,GAAG,IAAI,CAACX,OAAO,EAAE;MAC3B,IAAI,CAACW,IAAI,EAAE,OAAO4E,IAAI;MAEtB,MAAMtE,OAAO,GAAG,IAAI,CAACX,UAAU,CAACC,QAAQ,CAAC;MACzCK,OAAO,CAACG,IAAI,KAAZH,OAAO,CAACG,IAAI,GAAKwC,IAAI,CAACC,GAAG,CAAC,GAAG,CAAC+B,IAAI,CAAC3B,KAAK,IAAI,EAAE,EAAEH,GAAG,CAAEhD,IAAI,IAAKQ,OAAO,CAACR,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAChFG,OAAO,CAACC,IAAI,KAAZD,OAAO,CAACC,IAAI,GAAK0C,IAAI,CAACC,GAAG,CAAC,GAAG,CAAC+B,IAAI,CAAC3B,KAAK,IAAI,EAAE,EAAEH,GAAG,CAAEhD,IAAI,IAAKQ,OAAO,CAACR,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAEhF,IAAIW,MAAM,GAAG,IAAI,CAACV,QAAQ,CAACC,IAAI,EAAEC,OAAO,CAAC;MAEzC,IAAI,CAAC2D,eAAe,CAACnD,MAAM,EAAET,IAAI,CAAC;MAElC,IAAIiF,SAAS,KAAK,IAAI,EAAE;QACtBxE,MAAM,GAAG,IAAI,CAACgE,WAAW,CAAChE,MAAM,EAAER,OAAO,CAAC;MAC5C;MAEA,MAAM;QAAET;MAAK,CAAE,GAAG,IAAI,CAACD,OAAO;MAC9B,MAAM0D,KAAK,GAAe,EAAE;MAC5B,MAAMC,KAAK,GAAe,EAAE;MAE5BzC,MAAM,CAACwC,KAAK,CAACrC,OAAO,CAAEd,IAAI,IAAI;QAC5B,MAAM;UAAEV,EAAE;UAAEiE,CAAC;UAAED;QAAC,CAAE,GAAGtD,IAAI;QACzB,MAAMoF,QAAQ,GAAG1F,KAAK,CAACuB,gBAAgB,CAAC3B,EAAE,CAAC;QAC3C6D,KAAK,CAACK,IAAI,CAAC6B,kBAAkB,CAACD,QAAQ,EAAE;UAAE7B,CAAC;UAAED;QAAC,CAAE,CAAa,CAAC;MAChE,CAAC,CAAC;MAEF3C,MAAM,CAACyC,KAAK,CAACtC,OAAO,CAAE2C,IAAI,IAAI;QAC5B,MAAM;UAAEnE,EAAE;UAAEsE;QAAa,CAAE,GAAGH,IAAI;QAClC,MAAM6B,QAAQ,GAAG5F,KAAK,CAAC6F,YAAY,CAACjG,EAAE,CAAC;QACvC8D,KAAK,CAACI,IAAI,CAAC6B,kBAAkB,CAACC,QAAQ,EAAE;UAAE1B;QAAa,CAAE,CAAa,CAAC;MACzE,CAAC,CAAC;MAEF,OAAO;QAAET,KAAK;QAAEC;MAAK,CAAE;IACzB,CAAC;;;AAnNMhE,cAAA,CAAA8F,cAAc,GAAmC;EACtDC,SAAS,EAAE,IAAI;EACf9E,SAAS,EAAEA,CAAA,KAAM;CAClB;AAmNH,MAAMgF,kBAAkB,GAAGA,CAACG,OAAqB,EAAEC,KAA8B,KAAI;EACnF,OAAAT,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAYO,OAAO;IAAEC,KAAK,EAAAT,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAQO,OAAO,CAACC,KAAK,IAAI,EAAG,GAAKA,KAAK;EAAA;AAClE,CAAC;AAED,MAAMpD,MAAM,GAAIrC,IAAc,IAAKA,IAAI,CAACqB,KAAK,KAAK,CAAC;AAEnD,MAAMG,aAAa,GAAIxB,IAAc,IAAK,CAACA,IAAI,CAACqB,KAAK,KAAVrB,IAAI,CAACqB,KAAK,GAAK,CAAC,KAAI,CAAC,KAAK,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}