{"ast":null,"code":"import { difference, isEqual } from '@antv/util';\nimport { getBBoxHeight, getBBoxWidth, getCombinedBBox, getNearestBoundaryPoint, getNearestBoundarySide, getNodeBBox, isPointBBoxCenter, isPointInBBox, isPointOnBBoxBoundary, isPointOutsideBBox } from '../bbox';\nimport { isOrthogonal, moveTo, round } from '../point';\nimport { angle, distance, subtract, toVector2, toVector3 } from '../vector';\nconst defaultOptions = {\n  padding: 10\n};\n/**\n * <zh/> 获取两点之间的正交线段路径\n *\n * <en/> Get orthogonal line segments between two points\n * @param sourcePoint - <zh/> 起始点 | <en/> start point\n * @param targetPoint - <zh/> 终止点 | <en/> end point\n * @param sourceNode - <zh/> 起始节点 | <en/> source node\n * @param targetNode - <zh/> 终止节点 | <en/> target node\n * @param controlPoints - <zh/> 控制点 | <en/> control points\n * @param options - <zh/> 配置项 | <en/> options\n * @returns <zh/> 路径点集 | <en/> vertices\n */\nexport function orth(sourcePoint, targetPoint, sourceNode, targetNode, controlPoints, options) {\n  const {\n    padding\n  } = Object.assign(defaultOptions, options);\n  const sourceBBox = getNodeBBox(sourceNode, padding);\n  const targetBBox = getNodeBBox(targetNode, padding);\n  const points = [sourcePoint, ...controlPoints, targetPoint];\n  // direction of previous route segment\n  let direction = null;\n  const result = [];\n  for (let fromIdx = 0, len = points.length; fromIdx < len - 1; fromIdx++) {\n    const toIdx = fromIdx + 1;\n    const from = points[fromIdx];\n    const to = points[toIdx];\n    const isOrth = isOrthogonal(from, to);\n    let route = null;\n    if (fromIdx === 0) {\n      if (toIdx === len - 1) {\n        // source -> target\n        if (sourceBBox.intersects(targetBBox)) {\n          route = insideNode(from, to, sourceBBox, targetBBox);\n        } else if (!isPointBBoxCenter(from, sourceBBox) && !isPointBBoxCenter(to, targetBBox)) {\n          const fromWithPadding = getNearestBoundaryPoint(from, sourceBBox);\n          const toWithPadding = getNearestBoundaryPoint(to, targetBBox);\n          route = pointToPoint(fromWithPadding, toWithPadding, getDirection(fromWithPadding, toWithPadding));\n          route.points.unshift(fromWithPadding);\n          route.points.push(toWithPadding);\n        } else if (!isOrth) {\n          route = nodeToNode(from, to, sourceBBox, targetBBox);\n        }\n      } else {\n        // source -> point\n        if (isPointInBBox(to, sourceBBox)) {\n          route = insideNode(from, to, sourceBBox, getNodeBBox(to, padding), direction);\n        } else if (!isOrth) {\n          route = nodeToPoint(from, to, sourceBBox);\n        }\n      }\n    } else if (toIdx === len - 1) {\n      // point -> target\n      if (isPointInBBox(from, targetBBox)) {\n        route = insideNode(from, to, getNodeBBox(from, padding), targetBBox, direction);\n      } else if (!isOrth) {\n        route = pointToNode(from, to, targetBBox, direction);\n      }\n    } else if (!isOrth) {\n      // point -> point\n      route = pointToPoint(from, to, direction);\n    }\n    // set direction for next iteration\n    if (route) {\n      result.push(...route.points);\n      direction = route.direction;\n    } else {\n      // orthogonal route and not looped\n      direction = getDirection(from, to);\n    }\n    if (toIdx < len - 1) result.push(to);\n  }\n  return result.map(toVector2);\n}\n/**\n * Direction to opposites direction map\n */\nconst opposites = {\n  N: 'S',\n  S: 'N',\n  W: 'E',\n  E: 'W'\n};\n/**\n * Direction to radians map\n */\nconst radians = {\n  N: -Math.PI / 2,\n  S: Math.PI / 2,\n  E: 0,\n  W: Math.PI\n};\n/**\n * <zh/> 获取两点之间的方向，从 `from` 到 `to` 的方向\n *\n * <en/> Get the direction between two points, the direction from `from` to `to`\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @returns <zh/> 方向 | <en/> direction\n */\nexport function getDirection(from, to) {\n  const [fx, fy] = from;\n  const [tx, ty] = to;\n  if (fx === tx) {\n    return fy > ty ? 'N' : 'S';\n  }\n  if (fy === ty) {\n    return fx > tx ? 'W' : 'E';\n  }\n  return null;\n}\n/**\n * <zh/> 获取包围盒的尺寸，根据方向返回宽度或者高度\n *\n * <en/> Get the size of the bounding box, return the width or height according to the direction\n * @param bbox - <zh/> 包围盒 | <en/> bounding box\n * @param direction - <zh/> 方向 | <en/> direction\n * @returns <zh/> 尺寸 | <en/> size\n */\nexport function getBBoxSize(bbox, direction) {\n  return direction === 'N' || direction === 'S' ? getBBoxHeight(bbox) : getBBoxWidth(bbox);\n}\n/**\n * <zh/> 从一个点到另一个点计算正交路由\n *\n * <en/> Calculate orthogonal route from one point to another\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param direction - <zh/> 前一条线段的方向 | <en/> direction of the previous segment\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function pointToPoint(from, to, direction) {\n  const p1 = [from[0], to[1]];\n  const p2 = [to[0], from[1]];\n  const d1 = getDirection(from, p1);\n  const d2 = getDirection(from, p2);\n  const opposite = direction ? opposites[direction] : null;\n  const p = d1 === direction || d1 !== opposite && d2 !== direction ? p1 : p2;\n  return {\n    points: [p],\n    direction: getDirection(p, to)\n  };\n}\n/**\n * <zh/> 从节点到点计算正交路由\n *\n * <en/> Calculate orthogonal route from node to point\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param fromBBox - <zh/> 起始节点的包围盒 | <en/> bounding box of the start node\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function nodeToPoint(from, to, fromBBox) {\n  if (isPointBBoxCenter(from, fromBBox)) {\n    const p = freeJoin(from, to, fromBBox);\n    return {\n      points: [p],\n      direction: getDirection(p, to)\n    };\n  } else {\n    const fromWithPadding = getNearestBoundaryPoint(from, fromBBox);\n    const isHorizontal = ['left', 'right'].includes(getNearestBoundarySide(from, fromBBox));\n    const p = isHorizontal ? [to[0], fromWithPadding[1]] : [fromWithPadding[0], to[1]];\n    return {\n      points: [p],\n      direction: getDirection(p, to)\n    };\n  }\n}\n/**\n * <zh/> 从点到节点计算正交路由\n *\n * <en/> Calculate orthogonal route from point to node\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param toBBox - <zh/> 终止节点的包围盒 | <en/> bounding box of the end node\n * @param direction - <zh/> 前一条线段的方向 | <en/> direction of the previous segment\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function pointToNode(from, to, toBBox, direction) {\n  const toWithPadding = isPointBBoxCenter(to, toBBox) ? to : getNearestBoundaryPoint(to, toBBox);\n  const points = [[toWithPadding[0], from[1]], [from[0], toWithPadding[1]]];\n  const freePoints = points.filter(p => isPointOutsideBBox(p, toBBox) && !isPointOnBBoxBoundary(p, toBBox, true));\n  const freeDirectionPoints = freePoints.filter(p => getDirection(p, from) !== direction);\n  if (freeDirectionPoints.length > 0) {\n    // Pick a point which bears the same direction as the previous segment.\n    const p = freeDirectionPoints.find(p => getDirection(from, p) === direction) || freeDirectionPoints[0];\n    return {\n      points: [p],\n      direction: getDirection(p, to)\n    };\n  } else {\n    // Here we found only points which are either contained in the element or they would create\n    // a link segment going in opposites direction from the previous one.\n    // We take the point inside element and move it outside the element in the direction the\n    // route is going. Now we can join this point with the current end (using freeJoin).\n    const p = difference(points, freePoints)[0];\n    const p2 = moveTo(to, p, getBBoxSize(toBBox, direction) / 2);\n    const p1 = freeJoin(p2, from, toBBox);\n    return {\n      points: [p1, p2],\n      direction: getDirection(p2, to)\n    };\n  }\n}\n/**\n * <zh/> 从节点到节点计算正交路由\n *\n * <en/> Calculate orthogonal route from node to node\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param fromBBox - <zh/> 起始节点的包围盒 | <en/> bounding box of the start node\n * @param toBBox - <zh/> 终止节点的包围盒 | <en/> bounding box of the end node\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function nodeToNode(from, to, fromBBox, toBBox) {\n  let route = nodeToPoint(from, to, fromBBox);\n  const p1 = toVector3(route.points[0]);\n  if (isPointInBBox(p1, toBBox)) {\n    route = nodeToPoint(to, from, toBBox);\n    const p2 = toVector3(route.points[0]);\n    if (isPointInBBox(p2, fromBBox)) {\n      const fromBorder = moveTo(from, p1, getBBoxSize(fromBBox, getDirection(from, p1)) / 2);\n      const toBorder = moveTo(to, p2, getBBoxSize(toBBox, getDirection(to, p2)) / 2);\n      const midPoint = [(fromBorder[0] + toBorder[0]) / 2, (fromBorder[1] + toBorder[1]) / 2];\n      const startRoute = nodeToPoint(from, midPoint, fromBBox);\n      const endRoute = pointToNode(midPoint, to, toBBox, startRoute.direction);\n      route.points = [startRoute.points[0], endRoute.points[0]];\n      route.direction = endRoute.direction;\n    }\n  }\n  return route;\n}\n/**\n * <zh/> 在两个节点内部计算路由\n *\n * <en/> Calculate route inside two nodes\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param fromBBox - <zh/> 起始节点的包围盒 | <en/> bounding box of the start node\n * @param toBBox - <zh/> 终止节点的包围盒 | <en/> bounding box of the end node\n * @param direction - <zh/> 方向 | <en/> direction\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function insideNode(from, to, fromBBox, toBBox, direction) {\n  const DEFAULT_OFFSET = 0.01;\n  const boundary = getCombinedBBox([fromBBox, toBBox]);\n  const reversed = distance(to, boundary.center) > distance(from, boundary.center);\n  const [start, end] = reversed ? [to, from] : [from, to];\n  const halfPerimeter = getBBoxHeight(boundary) + getBBoxWidth(boundary);\n  let p1;\n  if (direction) {\n    const ref = [start[0] + halfPerimeter * Math.cos(radians[direction]), start[1] + halfPerimeter * Math.sin(radians[direction])];\n    // `getNearestBoundaryPoint` returns a point on the boundary, so we need to move it a bit to ensure it's outside the element and then get the correct `p2` via `freeJoin`.\n    p1 = moveTo(getNearestBoundaryPoint(ref, boundary), ref, DEFAULT_OFFSET);\n  } else {\n    p1 = moveTo(getNearestBoundaryPoint(start, boundary), start, -DEFAULT_OFFSET);\n  }\n  let p2 = freeJoin(p1, end, boundary);\n  let points = [round(p1, 2), round(p2, 2)];\n  if (isEqual(round(p1), round(p2))) {\n    const rad = angle(subtract(p1, start), [1, 0, 0]) + Math.PI / 2;\n    p2 = [end[0] + halfPerimeter * Math.cos(rad), end[1] + halfPerimeter * Math.sin(rad), 0];\n    p2 = round(moveTo(getNearestBoundaryPoint(p2, boundary), end, -DEFAULT_OFFSET), 2);\n    const p3 = freeJoin(p1, p2, boundary);\n    points = [p1, p3, p2];\n  }\n  return {\n    points: reversed ? points.reverse() : points,\n    direction: reversed ? getDirection(p1, to) : getDirection(p2, to)\n  };\n}\n/**\n * <zh/> 返回一个点 `p`，使得线段 p,p1 和 p,p2 互相垂直，p 尽可能不在给定的包围盒内\n *\n * <en/> Returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained in the given box\n * @param p1 - <zh/> 点 | <en/> point\n * @param p2 - <zh/> 点 | <en/> point\n * @param bbox - <zh/> 包围盒 | <en/> bounding box\n * @returns <zh/> 点 | <en/> point\n */\nexport function freeJoin(p1, p2, bbox) {\n  let p = [p1[0], p2[1]];\n  if (isPointInBBox(p, bbox)) {\n    p = [p2[0], p1[1]];\n  }\n  return p;\n}","map":{"version":3,"names":["difference","isEqual","getBBoxHeight","getBBoxWidth","getCombinedBBox","getNearestBoundaryPoint","getNearestBoundarySide","getNodeBBox","isPointBBoxCenter","isPointInBBox","isPointOnBBoxBoundary","isPointOutsideBBox","isOrthogonal","moveTo","round","angle","distance","subtract","toVector2","toVector3","defaultOptions","padding","orth","sourcePoint","targetPoint","sourceNode","targetNode","controlPoints","options","Object","assign","sourceBBox","targetBBox","points","direction","result","fromIdx","len","length","toIdx","from","to","isOrth","route","intersects","insideNode","fromWithPadding","toWithPadding","pointToPoint","getDirection","unshift","push","nodeToNode","nodeToPoint","pointToNode","map","opposites","N","S","W","E","radians","Math","PI","fx","fy","tx","ty","getBBoxSize","bbox","p1","p2","d1","d2","opposite","p","fromBBox","freeJoin","isHorizontal","includes","toBBox","freePoints","filter","freeDirectionPoints","find","fromBorder","toBorder","midPoint","startRoute","endRoute","DEFAULT_OFFSET","boundary","reversed","center","start","end","halfPerimeter","ref","cos","sin","rad","p3","reverse"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/router/orth.ts"],"sourcesContent":["import type { AABB } from '@antv/g';\nimport { difference, isEqual } from '@antv/util';\nimport type { Node, OrthRouterOptions, Point } from '../../types';\nimport {\n  getBBoxHeight,\n  getBBoxWidth,\n  getCombinedBBox,\n  getNearestBoundaryPoint,\n  getNearestBoundarySide,\n  getNodeBBox,\n  isPointBBoxCenter,\n  isPointInBBox,\n  isPointOnBBoxBoundary,\n  isPointOutsideBBox,\n} from '../bbox';\nimport { isOrthogonal, moveTo, round } from '../point';\nimport { angle, distance, subtract, toVector2, toVector3 } from '../vector';\n\nexport type Direction = 'N' | 'S' | 'W' | 'E' | null;\n\ntype Route = {\n  points: Point[];\n  direction: Direction;\n};\n\nconst defaultOptions: OrthRouterOptions = {\n  padding: 10,\n};\n\n/**\n * <zh/> 获取两点之间的正交线段路径\n *\n * <en/> Get orthogonal line segments between two points\n * @param sourcePoint - <zh/> 起始点 | <en/> start point\n * @param targetPoint - <zh/> 终止点 | <en/> end point\n * @param sourceNode - <zh/> 起始节点 | <en/> source node\n * @param targetNode - <zh/> 终止节点 | <en/> target node\n * @param controlPoints - <zh/> 控制点 | <en/> control points\n * @param options - <zh/> 配置项 | <en/> options\n * @returns <zh/> 路径点集 | <en/> vertices\n */\nexport function orth(\n  sourcePoint: Point,\n  targetPoint: Point,\n  sourceNode: Node,\n  targetNode: Node,\n  controlPoints: Point[],\n  options: OrthRouterOptions,\n) {\n  const { padding } = Object.assign(defaultOptions, options);\n\n  const sourceBBox = getNodeBBox(sourceNode, padding);\n  const targetBBox = getNodeBBox(targetNode, padding);\n\n  const points: Point[] = [sourcePoint, ...controlPoints, targetPoint];\n\n  // direction of previous route segment\n  let direction: Direction = null;\n  const result: Point[] = [];\n\n  for (let fromIdx = 0, len = points.length; fromIdx < len - 1; fromIdx++) {\n    const toIdx = fromIdx + 1;\n    const from = points[fromIdx];\n    const to = points[toIdx];\n    const isOrth = isOrthogonal(from, to);\n\n    let route = null;\n\n    if (fromIdx === 0) {\n      if (toIdx === len - 1) {\n        // source -> target\n        if (sourceBBox.intersects(targetBBox)) {\n          route = insideNode(from, to, sourceBBox, targetBBox);\n        } else if (!isPointBBoxCenter(from, sourceBBox) && !isPointBBoxCenter(to, targetBBox)) {\n          const fromWithPadding = getNearestBoundaryPoint(from, sourceBBox);\n          const toWithPadding = getNearestBoundaryPoint(to, targetBBox);\n          route = pointToPoint(fromWithPadding, toWithPadding, getDirection(fromWithPadding, toWithPadding));\n          route.points.unshift(fromWithPadding);\n          route.points.push(toWithPadding);\n        } else if (!isOrth) {\n          route = nodeToNode(from, to, sourceBBox, targetBBox);\n        }\n      } else {\n        // source -> point\n        if (isPointInBBox(to, sourceBBox)) {\n          route = insideNode(from, to, sourceBBox, getNodeBBox(to, padding), direction);\n        } else if (!isOrth) {\n          route = nodeToPoint(from, to, sourceBBox);\n        }\n      }\n    } else if (toIdx === len - 1) {\n      // point -> target\n      if (isPointInBBox(from, targetBBox)) {\n        route = insideNode(from, to, getNodeBBox(from, padding), targetBBox, direction);\n      } else if (!isOrth) {\n        route = pointToNode(from, to, targetBBox, direction);\n      }\n    } else if (!isOrth) {\n      // point -> point\n      route = pointToPoint(from, to, direction);\n    }\n\n    // set direction for next iteration\n    if (route) {\n      result.push(...route.points);\n      direction = route.direction;\n    } else {\n      // orthogonal route and not looped\n      direction = getDirection(from, to);\n    }\n\n    if (toIdx < len - 1) result.push(to);\n  }\n\n  return result.map(toVector2);\n}\n\n/**\n * Direction to opposites direction map\n */\nconst opposites = {\n  N: 'S',\n  S: 'N',\n  W: 'E',\n  E: 'W',\n};\n\n/**\n * Direction to radians map\n */\nconst radians = {\n  N: -Math.PI / 2,\n  S: Math.PI / 2,\n  E: 0,\n  W: Math.PI,\n};\n\n/**\n * <zh/> 获取两点之间的方向，从 `from` 到 `to` 的方向\n *\n * <en/> Get the direction between two points, the direction from `from` to `to`\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @returns <zh/> 方向 | <en/> direction\n */\nexport function getDirection(from: Point, to: Point): Direction | null {\n  const [fx, fy] = from;\n  const [tx, ty] = to;\n  if (fx === tx) {\n    return fy > ty ? 'N' : 'S';\n  }\n  if (fy === ty) {\n    return fx > tx ? 'W' : 'E';\n  }\n  return null;\n}\n\n/**\n * <zh/> 获取包围盒的尺寸，根据方向返回宽度或者高度\n *\n * <en/> Get the size of the bounding box, return the width or height according to the direction\n * @param bbox - <zh/> 包围盒 | <en/> bounding box\n * @param direction - <zh/> 方向 | <en/> direction\n * @returns <zh/> 尺寸 | <en/> size\n */\nexport function getBBoxSize(bbox: AABB, direction: Direction): number {\n  return direction === 'N' || direction === 'S' ? getBBoxHeight(bbox) : getBBoxWidth(bbox);\n}\n\n/**\n * <zh/> 从一个点到另一个点计算正交路由\n *\n * <en/> Calculate orthogonal route from one point to another\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param direction - <zh/> 前一条线段的方向 | <en/> direction of the previous segment\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function pointToPoint(from: Point, to: Point, direction: Direction): Route {\n  const p1: Point = [from[0], to[1]];\n  const p2: Point = [to[0], from[1]];\n  const d1 = getDirection(from, p1);\n  const d2 = getDirection(from, p2);\n  const opposite = direction ? opposites[direction] : null;\n  const p = d1 === direction || (d1 !== opposite && d2 !== direction) ? p1 : p2;\n\n  return { points: [p], direction: getDirection(p, to) };\n}\n\n/**\n * <zh/> 从节点到点计算正交路由\n *\n * <en/> Calculate orthogonal route from node to point\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param fromBBox - <zh/> 起始节点的包围盒 | <en/> bounding box of the start node\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function nodeToPoint(from: Point, to: Point, fromBBox: AABB): Route {\n  if (isPointBBoxCenter(from, fromBBox)) {\n    const p = freeJoin(from, to, fromBBox);\n\n    return { points: [p], direction: getDirection(p, to) };\n  } else {\n    const fromWithPadding = getNearestBoundaryPoint(from, fromBBox);\n    const isHorizontal = ['left', 'right'].includes(getNearestBoundarySide(from, fromBBox));\n    const p: Point = isHorizontal ? [to[0], fromWithPadding[1]] : [fromWithPadding[0], to[1]];\n\n    return { points: [p], direction: getDirection(p, to) };\n  }\n}\n\n/**\n * <zh/> 从点到节点计算正交路由\n *\n * <en/> Calculate orthogonal route from point to node\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param toBBox - <zh/> 终止节点的包围盒 | <en/> bounding box of the end node\n * @param direction - <zh/> 前一条线段的方向 | <en/> direction of the previous segment\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function pointToNode(from: Point, to: Point, toBBox: AABB, direction: Direction): Route {\n  const toWithPadding = isPointBBoxCenter(to, toBBox) ? to : getNearestBoundaryPoint(to, toBBox);\n  const points: Point[] = [\n    [toWithPadding[0], from[1]],\n    [from[0], toWithPadding[1]],\n  ];\n  const freePoints = points.filter((p) => isPointOutsideBBox(p, toBBox) && !isPointOnBBoxBoundary(p, toBBox, true));\n\n  const freeDirectionPoints = freePoints.filter((p) => getDirection(p, from) !== direction);\n\n  if (freeDirectionPoints.length > 0) {\n    // Pick a point which bears the same direction as the previous segment.\n    const p = freeDirectionPoints.find((p) => getDirection(from, p) === direction) || freeDirectionPoints[0];\n    return {\n      points: [p],\n      direction: getDirection(p, to),\n    };\n  } else {\n    // Here we found only points which are either contained in the element or they would create\n    // a link segment going in opposites direction from the previous one.\n    // We take the point inside element and move it outside the element in the direction the\n    // route is going. Now we can join this point with the current end (using freeJoin).\n    const p = difference(points, freePoints)[0];\n    const p2 = moveTo(to, p, getBBoxSize(toBBox, direction) / 2);\n    const p1 = freeJoin(p2, from, toBBox);\n    return {\n      points: [p1, p2],\n      direction: getDirection(p2, to),\n    };\n  }\n}\n\n/**\n * <zh/> 从节点到节点计算正交路由\n *\n * <en/> Calculate orthogonal route from node to node\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param fromBBox - <zh/> 起始节点的包围盒 | <en/> bounding box of the start node\n * @param toBBox - <zh/> 终止节点的包围盒 | <en/> bounding box of the end node\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function nodeToNode(from: Point, to: Point, fromBBox: AABB, toBBox: AABB): Route {\n  let route = nodeToPoint(from, to, fromBBox);\n  const p1 = toVector3(route.points[0]);\n\n  if (isPointInBBox(p1, toBBox)) {\n    route = nodeToPoint(to, from, toBBox);\n    const p2 = toVector3(route.points[0]);\n\n    if (isPointInBBox(p2, fromBBox)) {\n      const fromBorder = moveTo(from, p1, getBBoxSize(fromBBox, getDirection(from, p1)) / 2);\n      const toBorder = moveTo(to, p2, getBBoxSize(toBBox, getDirection(to, p2)) / 2);\n      const midPoint: Point = [(fromBorder[0] + toBorder[0]) / 2, (fromBorder[1] + toBorder[1]) / 2];\n\n      const startRoute = nodeToPoint(from, midPoint, fromBBox);\n      const endRoute = pointToNode(midPoint, to, toBBox, startRoute.direction);\n\n      route.points = [startRoute.points[0], endRoute.points[0]];\n      route.direction = endRoute.direction;\n    }\n  }\n\n  return route;\n}\n\n/**\n * <zh/> 在两个节点内部计算路由\n *\n * <en/> Calculate route inside two nodes\n * @param from - <zh/> 起始点 | <en/> start point\n * @param to - <zh/> 终止点 | <en/> end point\n * @param fromBBox - <zh/> 起始节点的包围盒 | <en/> bounding box of the start node\n * @param toBBox - <zh/> 终止节点的包围盒 | <en/> bounding box of the end node\n * @param direction - <zh/> 方向 | <en/> direction\n * @returns <zh/> 正交路由 | <en/> orthogonal route\n */\nexport function insideNode(from: Point, to: Point, fromBBox: AABB, toBBox: AABB, direction?: Direction): Route {\n  const DEFAULT_OFFSET = 0.01;\n  const boundary = getCombinedBBox([fromBBox, toBBox]);\n  const reversed = distance(to, boundary.center) > distance(from, boundary.center);\n  const [start, end] = reversed ? [to, from] : [from, to];\n  const halfPerimeter = getBBoxHeight(boundary) + getBBoxWidth(boundary);\n\n  let p1: Point;\n  if (direction) {\n    const ref: Point = [\n      start[0] + halfPerimeter * Math.cos(radians[direction]),\n      start[1] + halfPerimeter * Math.sin(radians[direction]),\n    ];\n    // `getNearestBoundaryPoint` returns a point on the boundary, so we need to move it a bit to ensure it's outside the element and then get the correct `p2` via `freeJoin`.\n    p1 = moveTo(getNearestBoundaryPoint(ref, boundary), ref, DEFAULT_OFFSET);\n  } else {\n    p1 = moveTo(getNearestBoundaryPoint(start, boundary), start, -DEFAULT_OFFSET);\n  }\n\n  let p2 = freeJoin(p1, end, boundary);\n\n  let points = [round(p1, 2), round(p2, 2)];\n\n  if (isEqual(round(p1), round(p2))) {\n    const rad = angle(subtract(p1, start), [1, 0, 0]) + Math.PI / 2;\n    p2 = [end[0] + halfPerimeter * Math.cos(rad), end[1] + halfPerimeter * Math.sin(rad), 0];\n    p2 = round(moveTo(getNearestBoundaryPoint(p2, boundary), end, -DEFAULT_OFFSET), 2);\n    const p3 = freeJoin(p1, p2, boundary);\n    points = [p1, p3, p2];\n  }\n\n  return {\n    points: reversed ? points.reverse() : points,\n    direction: reversed ? getDirection(p1, to) : getDirection(p2, to),\n  };\n}\n\n/**\n * <zh/> 返回一个点 `p`，使得线段 p,p1 和 p,p2 互相垂直，p 尽可能不在给定的包围盒内\n *\n * <en/> Returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained in the given box\n * @param p1 - <zh/> 点 | <en/> point\n * @param p2 - <zh/> 点 | <en/> point\n * @param bbox - <zh/> 包围盒 | <en/> bounding box\n * @returns <zh/> 点 | <en/> point\n */\nexport function freeJoin(p1: Point, p2: Point, bbox: AABB): Point {\n  let p: Point = [p1[0], p2[1]];\n  if (isPointInBBox(p, bbox)) {\n    p = [p2[0], p1[1]];\n  }\n  return p;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}