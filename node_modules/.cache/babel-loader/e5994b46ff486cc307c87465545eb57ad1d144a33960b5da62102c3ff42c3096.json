{"ast":null,"code":"import { group, ascending, maxIndex } from '@antv/vendor/d3-array';\nimport { defined } from '../../utils/helper';\nimport { indexOf } from '../../utils/array';\nimport { columnOf } from './helper';\nexport function createGroups(groupBy, I, mark) {\n  const {\n    encode\n  } = mark;\n  if (groupBy === null) return [I];\n  const G = normalizeGroupBy(groupBy).map(k => {\n    var _a;\n    return [k, (_a = columnOf(encode, k)) === null || _a === void 0 ? void 0 : _a[0]];\n  }).filter(([, column]) => defined(column));\n  const key = i => G.map(([, V]) => V[i]).join('-');\n  return Array.from(group(I, key).values());\n}\nexport function normalizeComparator(order) {\n  if (Array.isArray(order)) return createFieldsOrder(order);\n  if (typeof order === 'function') return createFunctionOrder(order);\n  if (order === 'series') return createSeriesOrder;\n  if (order === 'value') return createValueOrder;\n  if (order === 'sum') return createSumOrder;\n  if (order === 'maxIndex') return createMaxIndexOrder;\n  return null;\n}\nexport function applyOrder(groups, comparator) {\n  for (const group of groups) {\n    group.sort(comparator);\n  }\n}\nexport function domainOf(value, scale) {\n  return (scale === null || scale === void 0 ? void 0 : scale.domain) || Array.from(new Set(value));\n}\nfunction normalizeGroupBy(groupBy) {\n  if (Array.isArray(groupBy)) return groupBy;\n  return [groupBy];\n}\nfunction createSeriesOrder(data, Y, S) {\n  return ascendingComparator(i => S[i]);\n}\nfunction createFunctionOrder(order) {\n  return (data, Y, S) => {\n    return ascendingComparator(i => order(data[i]));\n  };\n}\nfunction createFieldsOrder(order) {\n  return (data, Y, S) => {\n    return (i, j) => order.reduce((eq, f) => eq !== 0 ? eq : ascending(data[i][f], data[j][f]), 0);\n  };\n}\nfunction createValueOrder(data, Y, S) {\n  return ascendingComparator(i => Y[i]);\n}\nfunction createSumOrder(data, Y, S) {\n  const I = indexOf(data);\n  const groups = Array.from(group(I, i => S[+i]).entries());\n  const seriesSum = new Map(groups.map(([k, GI]) => [k, GI.reduce((s, i) => s + +Y[i])]));\n  return ascendingComparator(i => seriesSum.get(S[i]));\n}\nfunction createMaxIndexOrder(data, Y, S) {\n  const I = indexOf(data);\n  const groups = Array.from(group(I, i => S[+i]).entries());\n  const seriesMaxIndex = new Map(groups.map(([k, GI]) => [k, maxIndex(GI, i => Y[i])]));\n  return ascendingComparator(i => seriesMaxIndex.get(S[i]));\n}\nfunction ascendingComparator(order) {\n  return (i, j) => ascending(order(i), order(j));\n}","map":{"version":3,"names":["group","ascending","maxIndex","defined","indexOf","columnOf","createGroups","groupBy","I","mark","encode","G","normalizeGroupBy","map","k","_a","filter","column","key","i","V","join","Array","from","values","normalizeComparator","order","isArray","createFieldsOrder","createFunctionOrder","createSeriesOrder","createValueOrder","createSumOrder","createMaxIndexOrder","applyOrder","groups","comparator","sort","domainOf","value","scale","domain","Set","data","Y","S","ascendingComparator","j","reduce","eq","f","entries","seriesSum","Map","GI","s","get","seriesMaxIndex"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/utils/order.ts"],"sourcesContent":["import { group, ascending, maxIndex, Primitive } from '@antv/vendor/d3-array';\nimport { defined } from '../../utils/helper';\nimport { TabularData, G2Mark } from '../../runtime';\nimport { indexOf } from '../../utils/array';\nimport { columnOf } from './helper';\n\nexport type IndexComparatorFactory = (\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n) => IndexComparator;\n\nexport type IndexComparator = (i: number, j: number) => number;\n\nexport type Order =\n  | 'value'\n  | 'sum'\n  | 'series'\n  | 'maxIndex'\n  | string[]\n  | ((data: Record<string, Primitive>) => Primitive);\n\nexport function createGroups(\n  groupBy: string | string[],\n  I: number[],\n  mark: G2Mark,\n): number[][] {\n  const { encode } = mark;\n  if (groupBy === null) return [I];\n  const G = normalizeGroupBy(groupBy)\n    .map((k) => [k, columnOf(encode, k)?.[0]] as const)\n    .filter(([, column]) => defined(column));\n  const key = (i: number) => G.map(([, V]) => V[i]).join('-');\n  return Array.from(group(I, key).values());\n}\n\nexport function normalizeComparator(\n  order: Order,\n): IndexComparatorFactory | null {\n  if (Array.isArray(order)) return createFieldsOrder(order);\n  if (typeof order === 'function') return createFunctionOrder(order);\n  if (order === 'series') return createSeriesOrder;\n  if (order === 'value') return createValueOrder;\n  if (order === 'sum') return createSumOrder;\n  if (order === 'maxIndex') return createMaxIndexOrder;\n  return null;\n}\n\nexport function applyOrder(groups: number[][], comparator: IndexComparator) {\n  for (const group of groups) {\n    group.sort(comparator);\n  }\n}\n\nexport function domainOf(value: Primitive[], scale: Record<string, any>) {\n  return scale?.domain || Array.from(new Set(value));\n}\n\nfunction normalizeGroupBy(groupBy: string | string[]): string[] {\n  if (Array.isArray(groupBy)) return groupBy;\n  return [groupBy];\n}\n\nfunction createSeriesOrder(\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n): IndexComparator {\n  return ascendingComparator((i: number) => S[i]);\n}\n\nfunction createFunctionOrder(\n  order: (data: Record<string, Primitive>) => Primitive,\n): IndexComparatorFactory {\n  return (data, Y, S) => {\n    return ascendingComparator((i) => order(data[i]));\n  };\n}\n\nfunction createFieldsOrder(order: string[]): IndexComparatorFactory {\n  return (data, Y, S) => {\n    return (i, j) =>\n      order.reduce(\n        (eq, f) => (eq !== 0 ? eq : ascending(data[i][f], data[j][f])),\n        0,\n      );\n  };\n}\n\nfunction createValueOrder(\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n): IndexComparator {\n  return ascendingComparator((i: number) => Y[i]);\n}\n\nfunction createSumOrder(\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n): IndexComparator {\n  const I = indexOf(data);\n  const groups = Array.from(group(I, (i) => S[+i]).entries());\n  const seriesSum = new Map(\n    groups.map(([k, GI]) => [k, GI.reduce((s, i) => s + +Y[i])] as const),\n  );\n  return ascendingComparator((i: number) => seriesSum.get(S[i]));\n}\n\nfunction createMaxIndexOrder(\n  data: TabularData,\n  Y: Primitive[],\n  S: Primitive[],\n): IndexComparator {\n  const I = indexOf(data);\n  const groups = Array.from(group(I, (i) => S[+i]).entries());\n  const seriesMaxIndex = new Map(\n    groups.map(([k, GI]) => [k, maxIndex(GI, (i) => Y[i])] as const),\n  );\n  return ascendingComparator((i: number) => seriesMaxIndex.get(S[i]));\n}\n\nfunction ascendingComparator(order: (i: number) => any): IndexComparator {\n  return (i, j) => ascending(order(i), order(j));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}