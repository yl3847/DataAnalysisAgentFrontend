{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { line, lineRadial } from '@antv/vendor/d3-shape';\nimport { isPolar, isTranspose } from '../../utils/coordinate';\nimport { select } from '../../utils/selection';\nimport { applyStyle, computeGradient, getTransform } from '../utils';\nimport { createElement } from '../../utils/createElement';\nimport { subObject } from '../../utils/helper';\nimport { angleWithQuadrant, dist, sub } from '../../utils/vector';\nconst DoublePath = createElement(g => {\n  const {\n    d1,\n    d2,\n    style1,\n    style2\n  } = g.attributes;\n  const document = g.ownerDocument;\n  select(g).maybeAppend('line', () => document.createElement('path', {})).style('d', d1).call(applyStyle, style1);\n  select(g).maybeAppend('line1', () => document.createElement('path', {})).style('d', d2).call(applyStyle, style2);\n});\n/**\n * Given a points sequence, split it into an array of defined points\n * and an array of undefined segments.\n *\n * Input - [[1, 2], [3, 4], [null, null], [null, null], [5, 6], [null, null], [7, 8]]\n * Output\n *  - [[1, 2], [3, 4], [5, 6], [7, 8]]\n *  - [\n *      [[3, 4], [5, 6]],\n *      [[5, 6], [7, 8]]\n *    ]\n */\nfunction segmentation(points, defined) {\n  const definedPoints = [];\n  const segments = [];\n  let m = false; // Is in a undefined sequence.\n  let dp = null; // The previous defined point.\n  for (const p of points) {\n    // If current point is a undefined point,\n    // enter a undefined sequence.\n    if (!defined(p[0]) || !defined(p[1])) m = true;else {\n      definedPoints.push(p);\n      // If current point is a defined point,\n      // and is in a undefined sequence, save\n      // the two closest defined points as this\n      // undefined sequence and exit it.\n      if (m) {\n        m = false;\n        segments.push([dp, p]);\n      }\n      // Update the previous defined point.\n      dp = p;\n    }\n  }\n  return [definedPoints, segments];\n}\nexport const Curve = (options, context) => {\n  const {\n      curve,\n      gradient = false,\n      // The color for each segment.\n      gradientColor = 'between',\n      defined = d => !Number.isNaN(d) && d !== undefined && d !== null,\n      connect: connectNulls = false\n    } = options,\n    style = __rest(options, [\"curve\", \"gradient\", \"gradientColor\", \"defined\", \"connect\"]);\n  const {\n    coordinate,\n    document\n  } = context;\n  return (P, value, defaults) => {\n    // Compute styles.\n    const {\n        color: defaultColor,\n        lineWidth: defaultSize\n      } = defaults,\n      rest = __rest(defaults, [\"color\", \"lineWidth\"]);\n    const {\n      color = defaultColor,\n      size = defaultSize,\n      seriesColor: sc,\n      seriesX: sx,\n      seriesY: sy\n    } = value;\n    const transform = getTransform(coordinate, value);\n    const tpShape = isTranspose(coordinate);\n    const stroke = gradient && sc ? computeGradient(sc, sx, sy, gradient, gradientColor, tpShape) : color;\n    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), stroke && {\n      stroke\n    }), size && {\n      lineWidth: size\n    }), transform && {\n      transform\n    }), style);\n    // Compute points and segments.\n    let linePath;\n    if (isPolar(coordinate)) {\n      const center = coordinate.getCenter();\n      linePath = points => lineRadial().angle((_, idx) => angleWithQuadrant(sub(points[idx], center))).radius((_, idx) => dist(points[idx], center)).defined(([x, y]) => defined(x) && defined(y)).curve(curve)(points);\n    } else {\n      linePath = line().x(d => d[0]).y(d => d[1]).defined(([x, y]) => defined(x) && defined(y)).curve(curve);\n    }\n    const [DP, MS] = segmentation(P, defined);\n    const connectStyle = subObject(finalStyle, 'connect');\n    const missing = !!MS.length;\n    // Draw one path of connected defined points.\n    if (!missing || connectNulls && !Object.keys(connectStyle).length) {\n      return select(document.createElement('path', {})).style('d', linePath(DP) || []).call(applyStyle, finalStyle).node();\n    }\n    // Draw one path of unconnected defined points.\n    if (missing && !connectNulls) {\n      return select(document.createElement('path', {})).style('d', linePath(P)).call(applyStyle, finalStyle).node();\n    }\n    // Draw two path.\n    // One for unconnected defined points.\n    // One for connected segments.\n    const connectPath = segments => segments.map(linePath).join(',');\n    return select(new DoublePath()).style('style1', Object.assign(Object.assign({}, finalStyle), connectStyle)).style('style2', finalStyle).style('d1', connectPath(MS)).style('d2', linePath(P)).node();\n  };\n};\nCurve.props = {\n  defaultMarker: 'smooth',\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut'\n};","map":{"version":3,"names":["line","lineRadial","isPolar","isTranspose","select","applyStyle","computeGradient","getTransform","createElement","subObject","angleWithQuadrant","dist","sub","DoublePath","g","d1","d2","style1","style2","attributes","document","ownerDocument","maybeAppend","style","call","segmentation","points","defined","definedPoints","segments","m","dp","p","push","Curve","options","context","curve","gradient","gradientColor","d","Number","isNaN","undefined","connect","connectNulls","__rest","coordinate","P","value","defaults","color","defaultColor","lineWidth","defaultSize","rest","size","seriesColor","sc","seriesX","sx","seriesY","sy","transform","tpShape","stroke","finalStyle","Object","assign","linePath","center","getCenter","angle","_","idx","radius","x","y","DP","MS","connectStyle","missing","length","keys","node","connectPath","map","join","props","defaultMarker","defaultEnterAnimation","defaultUpdateAnimation","defaultExitAnimation"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/shape/line/curve.ts"],"sourcesContent":["import {\n  line,\n  lineRadial,\n  CurveFactory,\n  CurveFactoryLineOnly,\n} from '@antv/vendor/d3-shape';\nimport { Vector2 } from '@antv/coord';\nimport { isPolar, isTranspose } from '../../utils/coordinate';\nimport { select } from '../../utils/selection';\nimport { ShapeComponent as SC } from '../../runtime';\nimport { applyStyle, computeGradient, getTransform } from '../utils';\nimport { createElement } from '../../utils/createElement';\nimport { subObject } from '../../utils/helper';\nimport { angleWithQuadrant, dist, sub } from '../../utils/vector';\n\nconst DoublePath = createElement((g) => {\n  const { d1, d2, style1, style2 } = g.attributes;\n  const document = g.ownerDocument;\n  select(g)\n    .maybeAppend('line', () => document.createElement('path', {}))\n    .style('d', d1)\n    .call(applyStyle, style1);\n  select(g)\n    .maybeAppend('line1', () => document.createElement('path', {}))\n    .style('d', d2)\n    .call(applyStyle, style2);\n});\n\n/**\n * Given a points sequence, split it into an array of defined points\n * and an array of undefined segments.\n *\n * Input - [[1, 2], [3, 4], [null, null], [null, null], [5, 6], [null, null], [7, 8]]\n * Output\n *  - [[1, 2], [3, 4], [5, 6], [7, 8]]\n *  - [\n *      [[3, 4], [5, 6]],\n *      [[5, 6], [7, 8]]\n *    ]\n */\nfunction segmentation(\n  points: Vector2[],\n  defined: (d: any) => boolean,\n): [Vector2[], [Vector2, Vector2][]] {\n  const definedPoints = [];\n  const segments = [];\n  let m = false; // Is in a undefined sequence.\n  let dp = null; // The previous defined point.\n  for (const p of points) {\n    // If current point is a undefined point,\n    // enter a undefined sequence.\n    if (!defined(p[0]) || !defined(p[1])) m = true;\n    else {\n      definedPoints.push(p);\n      // If current point is a defined point,\n      // and is in a undefined sequence, save\n      // the two closest defined points as this\n      // undefined sequence and exit it.\n      if (m) {\n        m = false;\n        segments.push([dp, p]);\n      }\n      // Update the previous defined point.\n      dp = p;\n    }\n  }\n  return [definedPoints, segments];\n}\n\nexport type CurveOptions = {\n  curve?: CurveFactory | CurveFactoryLineOnly;\n  gradient?: boolean;\n  [key: string]: any;\n};\n\nexport const Curve: SC<CurveOptions> = (options, context) => {\n  const {\n    curve,\n    gradient = false,\n    // The color for each segment.\n    gradientColor = 'between',\n    defined = (d) => !Number.isNaN(d) && d !== undefined && d !== null,\n    connect: connectNulls = false,\n    ...style\n  } = options;\n  const { coordinate, document } = context;\n  return (P, value, defaults) => {\n    // Compute styles.\n    const { color: defaultColor, lineWidth: defaultSize, ...rest } = defaults;\n    const {\n      color = defaultColor,\n      size = defaultSize,\n      seriesColor: sc,\n      seriesX: sx,\n      seriesY: sy,\n    } = value;\n\n    const transform = getTransform(coordinate, value);\n    const tpShape = isTranspose(coordinate);\n    const stroke =\n      gradient && sc\n        ? computeGradient(sc, sx, sy, gradient, gradientColor, tpShape)\n        : color;\n\n    const finalStyle = {\n      ...rest,\n      ...(stroke && { stroke }),\n      ...(size && { lineWidth: size }),\n      ...(transform && { transform }),\n      ...style,\n    };\n\n    // Compute points and segments.\n    let linePath;\n    if (isPolar(coordinate)) {\n      const center = coordinate.getCenter() as Vector2;\n      linePath = (points) =>\n        lineRadial()\n          .angle((_, idx) => angleWithQuadrant(sub(points[idx], center)))\n          .radius((_, idx) => dist(points[idx], center))\n          .defined(([x, y]) => defined(x) && defined(y))\n          .curve(curve)(points);\n    } else {\n      linePath = line()\n        .x((d) => d[0])\n        .y((d) => d[1])\n        .defined(([x, y]) => defined(x) && defined(y))\n        .curve(curve);\n    }\n    const [DP, MS] = segmentation(P, defined);\n    const connectStyle = subObject(finalStyle, 'connect');\n    const missing = !!MS.length;\n\n    // Draw one path of connected defined points.\n    if (!missing || (connectNulls && !Object.keys(connectStyle).length)) {\n      return select(document.createElement('path', {}))\n        .style('d', linePath(DP) || [])\n        .call(applyStyle, finalStyle)\n        .node();\n    }\n\n    // Draw one path of unconnected defined points.\n    if (missing && !connectNulls) {\n      return select(document.createElement('path', {}))\n        .style('d', linePath(P))\n        .call(applyStyle, finalStyle)\n        .node();\n    }\n\n    // Draw two path.\n    // One for unconnected defined points.\n    // One for connected segments.\n    const connectPath = (segments) => segments.map(linePath).join(',');\n    return select(new DoublePath())\n      .style('style1', { ...finalStyle, ...connectStyle })\n      .style('style2', finalStyle)\n      .style('d1', connectPath(MS))\n      .style('d2', linePath(P))\n      .node();\n  };\n};\n\nCurve.props = {\n  defaultMarker: 'smooth',\n  defaultEnterAnimation: 'fadeIn',\n  defaultUpdateAnimation: 'morphing',\n  defaultExitAnimation: 'fadeOut',\n};\n"],"mappings":";;;;;;;;AAAA,SACEA,IAAI,EACJC,UAAU,QAGL,uBAAuB;AAE9B,SAASC,OAAO,EAAEC,WAAW,QAAQ,wBAAwB;AAC7D,SAASC,MAAM,QAAQ,uBAAuB;AAE9C,SAASC,UAAU,EAAEC,eAAe,EAAEC,YAAY,QAAQ,UAAU;AACpE,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,SAASC,iBAAiB,EAAEC,IAAI,EAAEC,GAAG,QAAQ,oBAAoB;AAEjE,MAAMC,UAAU,GAAGL,aAAa,CAAEM,CAAC,IAAI;EACrC,MAAM;IAAEC,EAAE;IAAEC,EAAE;IAAEC,MAAM;IAAEC;EAAM,CAAE,GAAGJ,CAAC,CAACK,UAAU;EAC/C,MAAMC,QAAQ,GAAGN,CAAC,CAACO,aAAa;EAChCjB,MAAM,CAACU,CAAC,CAAC,CACNQ,WAAW,CAAC,MAAM,EAAE,MAAMF,QAAQ,CAACZ,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAC7De,KAAK,CAAC,GAAG,EAAER,EAAE,CAAC,CACdS,IAAI,CAACnB,UAAU,EAAEY,MAAM,CAAC;EAC3Bb,MAAM,CAACU,CAAC,CAAC,CACNQ,WAAW,CAAC,OAAO,EAAE,MAAMF,QAAQ,CAACZ,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAC9De,KAAK,CAAC,GAAG,EAAEP,EAAE,CAAC,CACdQ,IAAI,CAACnB,UAAU,EAAEa,MAAM,CAAC;AAC7B,CAAC,CAAC;AAEF;;;;;;;;;;;;AAYA,SAASO,YAAYA,CACnBC,MAAiB,EACjBC,OAA4B;EAE5B,MAAMC,aAAa,GAAG,EAAE;EACxB,MAAMC,QAAQ,GAAG,EAAE;EACnB,IAAIC,CAAC,GAAG,KAAK,CAAC,CAAC;EACf,IAAIC,EAAE,GAAG,IAAI,CAAC,CAAC;EACf,KAAK,MAAMC,CAAC,IAAIN,MAAM,EAAE;IACtB;IACA;IACA,IAAI,CAACC,OAAO,CAACK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAACL,OAAO,CAACK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEF,CAAC,GAAG,IAAI,CAAC,KAC1C;MACHF,aAAa,CAACK,IAAI,CAACD,CAAC,CAAC;MACrB;MACA;MACA;MACA;MACA,IAAIF,CAAC,EAAE;QACLA,CAAC,GAAG,KAAK;QACTD,QAAQ,CAACI,IAAI,CAAC,CAACF,EAAE,EAAEC,CAAC,CAAC,CAAC;;MAExB;MACAD,EAAE,GAAGC,CAAC;;;EAGV,OAAO,CAACJ,aAAa,EAAEC,QAAQ,CAAC;AAClC;AAQA,OAAO,MAAMK,KAAK,GAAqBA,CAACC,OAAO,EAAEC,OAAO,KAAI;EAC1D,MAAM;MACJC,KAAK;MACLC,QAAQ,GAAG,KAAK;MAChB;MACAC,aAAa,GAAG,SAAS;MACzBZ,OAAO,GAAIa,CAAC,IAAK,CAACC,MAAM,CAACC,KAAK,CAACF,CAAC,CAAC,IAAIA,CAAC,KAAKG,SAAS,IAAIH,CAAC,KAAK,IAAI;MAClEI,OAAO,EAAEC,YAAY,GAAG;IAAK,IAE3BV,OAAO;IADNZ,KAAK,GAAAuB,MAAA,CACNX,OAAO,EARL,4DAQL,CAAU;EACX,MAAM;IAAEY,UAAU;IAAE3B;EAAQ,CAAE,GAAGgB,OAAO;EACxC,OAAO,CAACY,CAAC,EAAEC,KAAK,EAAEC,QAAQ,KAAI;IAC5B;IACA,MAAM;QAAEC,KAAK,EAAEC,YAAY;QAAEC,SAAS,EAAEC;MAAW,IAAcJ,QAAQ;MAAjBK,IAAI,GAAAT,MAAA,CAAKI,QAAQ,EAAnE,sBAAwD,CAAW;IACzE,MAAM;MACJC,KAAK,GAAGC,YAAY;MACpBI,IAAI,GAAGF,WAAW;MAClBG,WAAW,EAAEC,EAAE;MACfC,OAAO,EAAEC,EAAE;MACXC,OAAO,EAAEC;IAAE,CACZ,GAAGb,KAAK;IAET,MAAMc,SAAS,GAAGxD,YAAY,CAACwC,UAAU,EAAEE,KAAK,CAAC;IACjD,MAAMe,OAAO,GAAG7D,WAAW,CAAC4C,UAAU,CAAC;IACvC,MAAMkB,MAAM,GACV3B,QAAQ,IAAIoB,EAAE,GACVpD,eAAe,CAACoD,EAAE,EAAEE,EAAE,EAAEE,EAAE,EAAExB,QAAQ,EAAEC,aAAa,EAAEyB,OAAO,CAAC,GAC7Db,KAAK;IAEX,MAAMe,UAAU,GAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACXb,IAAI,GACHU,MAAM,IAAI;MAAEA;IAAM,CAAG,GACrBT,IAAI,IAAI;MAAEH,SAAS,EAAEG;IAAI,CAAG,GAC5BO,SAAS,IAAI;MAAEA;IAAS,CAAG,GAC5BxC,KAAK,CACT;IAED;IACA,IAAI8C,QAAQ;IACZ,IAAInE,OAAO,CAAC6C,UAAU,CAAC,EAAE;MACvB,MAAMuB,MAAM,GAAGvB,UAAU,CAACwB,SAAS,EAAa;MAChDF,QAAQ,GAAI3C,MAAM,IAChBzB,UAAU,EAAE,CACTuE,KAAK,CAAC,CAACC,CAAC,EAAEC,GAAG,KAAKhE,iBAAiB,CAACE,GAAG,CAACc,MAAM,CAACgD,GAAG,CAAC,EAAEJ,MAAM,CAAC,CAAC,CAAC,CAC9DK,MAAM,CAAC,CAACF,CAAC,EAAEC,GAAG,KAAK/D,IAAI,CAACe,MAAM,CAACgD,GAAG,CAAC,EAAEJ,MAAM,CAAC,CAAC,CAC7C3C,OAAO,CAAC,CAAC,CAACiD,CAAC,EAAEC,CAAC,CAAC,KAAKlD,OAAO,CAACiD,CAAC,CAAC,IAAIjD,OAAO,CAACkD,CAAC,CAAC,CAAC,CAC7CxC,KAAK,CAACA,KAAK,CAAC,CAACX,MAAM,CAAC;KAC1B,MAAM;MACL2C,QAAQ,GAAGrE,IAAI,EAAE,CACd4E,CAAC,CAAEpC,CAAC,IAAKA,CAAC,CAAC,CAAC,CAAC,CAAC,CACdqC,CAAC,CAAErC,CAAC,IAAKA,CAAC,CAAC,CAAC,CAAC,CAAC,CACdb,OAAO,CAAC,CAAC,CAACiD,CAAC,EAAEC,CAAC,CAAC,KAAKlD,OAAO,CAACiD,CAAC,CAAC,IAAIjD,OAAO,CAACkD,CAAC,CAAC,CAAC,CAC7CxC,KAAK,CAACA,KAAK,CAAC;;IAEjB,MAAM,CAACyC,EAAE,EAAEC,EAAE,CAAC,GAAGtD,YAAY,CAACuB,CAAC,EAAErB,OAAO,CAAC;IACzC,MAAMqD,YAAY,GAAGvE,SAAS,CAACyD,UAAU,EAAE,SAAS,CAAC;IACrD,MAAMe,OAAO,GAAG,CAAC,CAACF,EAAE,CAACG,MAAM;IAE3B;IACA,IAAI,CAACD,OAAO,IAAKpC,YAAY,IAAI,CAACsB,MAAM,CAACgB,IAAI,CAACH,YAAY,CAAC,CAACE,MAAO,EAAE;MACnE,OAAO9E,MAAM,CAACgB,QAAQ,CAACZ,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAC9Ce,KAAK,CAAC,GAAG,EAAE8C,QAAQ,CAACS,EAAE,CAAC,IAAI,EAAE,CAAC,CAC9BtD,IAAI,CAACnB,UAAU,EAAE6D,UAAU,CAAC,CAC5BkB,IAAI,EAAE;;IAGX;IACA,IAAIH,OAAO,IAAI,CAACpC,YAAY,EAAE;MAC5B,OAAOzC,MAAM,CAACgB,QAAQ,CAACZ,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAC9Ce,KAAK,CAAC,GAAG,EAAE8C,QAAQ,CAACrB,CAAC,CAAC,CAAC,CACvBxB,IAAI,CAACnB,UAAU,EAAE6D,UAAU,CAAC,CAC5BkB,IAAI,EAAE;;IAGX;IACA;IACA;IACA,MAAMC,WAAW,GAAIxD,QAAQ,IAAKA,QAAQ,CAACyD,GAAG,CAACjB,QAAQ,CAAC,CAACkB,IAAI,CAAC,GAAG,CAAC;IAClE,OAAOnF,MAAM,CAAC,IAAIS,UAAU,EAAE,CAAC,CAC5BU,KAAK,CAAC,QAAQ,EAAA4C,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAOF,UAAU,GAAKc,YAAY,EAAG,CACnDzD,KAAK,CAAC,QAAQ,EAAE2C,UAAU,CAAC,CAC3B3C,KAAK,CAAC,IAAI,EAAE8D,WAAW,CAACN,EAAE,CAAC,CAAC,CAC5BxD,KAAK,CAAC,IAAI,EAAE8C,QAAQ,CAACrB,CAAC,CAAC,CAAC,CACxBoC,IAAI,EAAE;EACX,CAAC;AACH,CAAC;AAEDlD,KAAK,CAACsD,KAAK,GAAG;EACZC,aAAa,EAAE,QAAQ;EACvBC,qBAAqB,EAAE,QAAQ;EAC/BC,sBAAsB,EAAE,UAAU;EAClCC,oBAAoB,EAAE;CACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}