{"ast":null,"code":"import { PointBowtie, PointCross, PointDiamond, PointHexagon, PointHollowBowtie, PointHollowDiamond, PointHollowHexagon, PointHollow, PointHollowSquare, PointHollowTriangle, PointHollowTriangleDown, PointHyphen, PointLine, PointTriangleDown, PointPlus, PointSquare, PointShape, PointTick, PointTriangle, PointCircle, PointHollowCircle } from '../shape';\nimport { MaybeZeroX, MaybeZeroY, MaybeSize } from '../transform';\nimport { baseGeometryChannels, basePostInference, basePreInference, createBandOffset, tooltip2d } from './utils';\nconst shape = {\n  hollow: PointHollow,\n  hollowDiamond: PointHollowDiamond,\n  hollowHexagon: PointHollowHexagon,\n  hollowSquare: PointHollowSquare,\n  hollowTriangleDown: PointHollowTriangleDown,\n  hollowTriangle: PointHollowTriangle,\n  hollowBowtie: PointHollowBowtie,\n  hollowCircle: PointHollowCircle,\n  point: PointShape,\n  plus: PointPlus,\n  diamond: PointDiamond,\n  square: PointSquare,\n  triangle: PointTriangle,\n  hexagon: PointHexagon,\n  cross: PointCross,\n  bowtie: PointBowtie,\n  hyphen: PointHyphen,\n  line: PointLine,\n  tick: PointTick,\n  triangleDown: PointTriangleDown,\n  circle: PointCircle\n};\n/**\n * Convert value for each channel to point shapes.\n * Calc the bbox of each point based on x, y and r.\n * This is for allowing their radius can be affected by coordinate(e.g. fisheye).\n */\nexport const Point = options => {\n  return (index, scale, value, coordinate) => {\n    const {\n      x: X,\n      y: Y,\n      x1: X1,\n      y1: Y1,\n      size: S,\n      dx: DX,\n      dy: DY\n    } = value;\n    const [width, height] = coordinate.getSize();\n    const offset = createBandOffset(scale, value, options);\n    const xy = i => {\n      const dx = +((DX === null || DX === void 0 ? void 0 : DX[i]) || 0);\n      const dy = +((DY === null || DY === void 0 ? void 0 : DY[i]) || 0);\n      const x = X1 ? (+X[i] + +X1[i]) / 2 : +X[i];\n      const y = Y1 ? (+Y[i] + +Y1[i]) / 2 : +Y[i];\n      const cx = x + dx;\n      const cy = y + dy;\n      return [cx, cy];\n    };\n    const P = S ? Array.from(index, i => {\n      const [cx, cy] = xy(i);\n      const r = +S[i];\n      const a = r / width;\n      const b = r / height;\n      const p1 = [cx - a, cy - b];\n      const p2 = [cx + a, cy + b];\n      return [coordinate.map(offset(p1, i)), coordinate.map(offset(p2, i))];\n    }) : Array.from(index, i => [coordinate.map(offset(xy(i), i))]);\n    return [index, P];\n  };\n};\nPoint.props = {\n  defaultShape: 'hollow',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [...baseGeometryChannels({\n    shapes: Object.keys(shape)\n  }), {\n    name: 'x',\n    required: true\n  }, {\n    name: 'y',\n    required: true\n  }, {\n    name: 'series',\n    scale: 'band'\n  }, {\n    name: 'size',\n    quantitative: 'sqrt'\n  }, {\n    name: 'dx',\n    scale: 'identity'\n  }, {\n    name: 'dy',\n    scale: 'identity'\n  }],\n  preInference: [...basePreInference(), {\n    type: MaybeZeroX\n  }, {\n    type: MaybeZeroY\n  }],\n  postInference: [...basePostInference(), {\n    type: MaybeSize\n  }, ...tooltip2d()]\n};","map":{"version":3,"names":["PointBowtie","PointCross","PointDiamond","PointHexagon","PointHollowBowtie","PointHollowDiamond","PointHollowHexagon","PointHollow","PointHollowSquare","PointHollowTriangle","PointHollowTriangleDown","PointHyphen","PointLine","PointTriangleDown","PointPlus","PointSquare","PointShape","PointTick","PointTriangle","PointCircle","PointHollowCircle","MaybeZeroX","MaybeZeroY","MaybeSize","baseGeometryChannels","basePostInference","basePreInference","createBandOffset","tooltip2d","shape","hollow","hollowDiamond","hollowHexagon","hollowSquare","hollowTriangleDown","hollowTriangle","hollowBowtie","hollowCircle","point","plus","diamond","square","triangle","hexagon","cross","bowtie","hyphen","line","tick","triangleDown","circle","Point","options","index","scale","value","coordinate","x","X","y","Y","x1","X1","y1","Y1","size","S","dx","DX","dy","DY","width","height","getSize","offset","xy","i","cx","cy","P","Array","from","r","a","b","p1","p2","map","props","defaultShape","defaultLabelShape","composite","channels","shapes","Object","keys","name","required","quantitative","preInference","type","postInference"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/mark/point.ts"],"sourcesContent":["import { MarkComponent as MC, Vector2 } from '../runtime';\nimport { PointMark } from '../spec';\nimport {\n  PointBowtie,\n  PointCross,\n  PointDiamond,\n  PointHexagon,\n  PointHollowBowtie,\n  PointHollowDiamond,\n  PointHollowHexagon,\n  PointHollow,\n  PointHollowSquare,\n  PointHollowTriangle,\n  PointHollowTriangleDown,\n  PointHyphen,\n  PointLine,\n  PointTriangleDown,\n  PointPlus,\n  PointSquare,\n  PointShape,\n  PointTick,\n  PointTriangle,\n  PointCircle,\n  PointHollowCircle,\n} from '../shape';\nimport { MaybeZeroX, MaybeZeroY, MaybeSize } from '../transform';\nimport {\n  baseGeometryChannels,\n  basePostInference,\n  basePreInference,\n  createBandOffset,\n  tooltip2d,\n} from './utils';\n\nconst shape = {\n  hollow: PointHollow,\n  hollowDiamond: PointHollowDiamond,\n  hollowHexagon: PointHollowHexagon,\n  hollowSquare: PointHollowSquare,\n  hollowTriangleDown: PointHollowTriangleDown,\n  hollowTriangle: PointHollowTriangle,\n  hollowBowtie: PointHollowBowtie,\n  hollowCircle: PointHollowCircle,\n  point: PointShape,\n  plus: PointPlus,\n  diamond: PointDiamond,\n  square: PointSquare,\n  triangle: PointTriangle,\n  hexagon: PointHexagon,\n  cross: PointCross,\n  bowtie: PointBowtie,\n  hyphen: PointHyphen,\n  line: PointLine,\n  tick: PointTick,\n  triangleDown: PointTriangleDown,\n  circle: PointCircle,\n};\n\nexport type PointOptions = Omit<PointMark, 'type'>;\n\n/**\n * Convert value for each channel to point shapes.\n * Calc the bbox of each point based on x, y and r.\n * This is for allowing their radius can be affected by coordinate(e.g. fisheye).\n */\nexport const Point: MC<PointOptions> = (options) => {\n  return (index, scale, value, coordinate) => {\n    const { x: X, y: Y, x1: X1, y1: Y1, size: S, dx: DX, dy: DY } = value;\n    const [width, height] = coordinate.getSize();\n    const offset = createBandOffset(scale, value, options);\n    const xy: (i: number) => Vector2 = (i) => {\n      const dx = +(DX?.[i] || 0);\n      const dy = +(DY?.[i] || 0);\n      const x = X1 ? (+X[i] + +X1[i]) / 2 : +X[i];\n      const y = Y1 ? (+Y[i] + +Y1[i]) / 2 : +Y[i];\n      const cx = x + dx;\n      const cy = y + dy;\n      return [cx, cy];\n    };\n    const P = S\n      ? Array.from(index, (i) => {\n          const [cx, cy] = xy(i);\n          const r = +S[i];\n          const a = r / width;\n          const b = r / height;\n          const p1: Vector2 = [cx - a, cy - b];\n          const p2: Vector2 = [cx + a, cy + b];\n          return [\n            coordinate.map(offset(p1, i)),\n            coordinate.map(offset(p2, i)),\n          ] as Vector2[];\n        })\n      : Array.from(\n          index,\n          (i) => [coordinate.map(offset(xy(i), i))] as Vector2[],\n        );\n    return [index, P];\n  };\n};\n\nPoint.props = {\n  defaultShape: 'hollow',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [\n    ...baseGeometryChannels({ shapes: Object.keys(shape) }),\n    { name: 'x', required: true },\n    { name: 'y', required: true },\n    { name: 'series', scale: 'band' },\n    { name: 'size', quantitative: 'sqrt' },\n    { name: 'dx', scale: 'identity' },\n    { name: 'dy', scale: 'identity' },\n  ],\n  preInference: [\n    ...basePreInference(),\n    { type: MaybeZeroX },\n    { type: MaybeZeroY },\n  ],\n  postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()],\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}