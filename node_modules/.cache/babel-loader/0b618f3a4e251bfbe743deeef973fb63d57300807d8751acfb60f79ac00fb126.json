{"ast":null,"code":"import { MaybeKey, MaybeTitle, MaybeTooltip } from '../transform';\nexport function baseChannels(options = {}) {\n  const {\n    shapes\n  } = options;\n  return [{\n    name: 'color'\n  }, {\n    name: 'opacity'\n  }, {\n    name: 'shape',\n    range: shapes\n  }, {\n    name: 'enterType'\n  }, {\n    name: 'enterDelay',\n    scaleKey: 'enter'\n  }, {\n    name: 'enterDuration',\n    scaleKey: 'enter'\n  }, {\n    name: 'enterEasing'\n  }, {\n    name: 'key',\n    scale: 'identity'\n  }, {\n    name: 'groupKey',\n    scale: 'identity'\n  }, {\n    name: 'label',\n    scale: 'identity'\n  }];\n}\nexport function baseGeometryChannels(options = {}) {\n  return [...baseChannels(options), {\n    name: 'title',\n    scale: 'identity'\n  }];\n}\nexport function tooltip3d() {\n  return [{\n    type: MaybeTitle,\n    channel: 'color'\n  }, {\n    type: MaybeTooltip,\n    channel: ['x', 'y', 'z']\n  }];\n}\nexport function tooltip2d() {\n  return [{\n    type: MaybeTitle,\n    channel: 'color'\n  }, {\n    type: MaybeTooltip,\n    channel: ['x', 'y']\n  }];\n}\nexport function tooltip1d() {\n  return [{\n    type: MaybeTitle,\n    channel: 'x'\n  }, {\n    type: MaybeTooltip,\n    channel: ['y']\n  }];\n}\nexport function tooltipXd() {\n  return [{\n    type: MaybeTitle,\n    channel: 'color'\n  }, {\n    type: MaybeTooltip,\n    channel: ['position']\n  }];\n}\nexport function baseAnnotationChannels(options = {}) {\n  return baseChannels(options);\n}\nexport function basePreInference() {\n  return [{\n    type: MaybeKey\n  }];\n}\nexport function basePostInference() {\n  return [];\n}\nexport function bandWidth(scale, x) {\n  return scale.getBandWidth(scale.invert(x));\n}\nexport function createBandOffset(scale, value, options = {}) {\n  const {\n    x: X,\n    y: Y,\n    series: S\n  } = value;\n  const {\n    x,\n    y,\n    series\n  } = scale;\n  const {\n    style: {\n      bandOffset = series ? 0 : 0.5,\n      bandOffsetX = bandOffset,\n      bandOffsetY = bandOffset\n    } = {}\n  } = options;\n  const isBandX = !!(x === null || x === void 0 ? void 0 : x.getBandWidth);\n  const isBandY = !!(y === null || y === void 0 ? void 0 : y.getBandWidth);\n  const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);\n  if (!isBandX && !isBandY) return d => d;\n  return (d, i) => {\n    const widthX = isBandX ? bandWidth(x, X[i]) : 0;\n    const widthY = isBandY ? bandWidth(y, Y[i]) : 0;\n    const f = () => (bandWidth(series, S[i]) / 2 + +S[i]) * widthX;\n    const offset = isSeries && S ? f() : 0;\n    const [x0, y0] = d;\n    return [x0 + bandOffsetX * widthX + offset, y0 + bandOffsetY * widthY];\n  };\n}\nexport function p(d) {\n  return parseFloat(d) / 100;\n}\nexport function visualMark(index, scale, value, coordinate) {\n  const {\n    x: X,\n    y: Y\n  } = value;\n  const {\n    innerWidth,\n    innerHeight\n  } = coordinate.getOptions();\n  const P = Array.from(index, i => {\n    const x0 = X[i];\n    const y0 = Y[i];\n    const x = typeof x0 === 'string' ? p(x0) * innerWidth : +x0;\n    const y = typeof y0 === 'string' ? p(y0) * innerHeight : +y0;\n    return [[x, y]];\n  });\n  return [index, P];\n}\nexport function field(encode) {\n  return typeof encode === 'function' ? encode : d => d[encode];\n}\nexport function valueof(data, encode) {\n  return Array.from(data, field(encode));\n}\nexport function initializeData(data, encode) {\n  const {\n    source = d => d.source,\n    target = d => d.target,\n    value = d => d.value\n  } = encode;\n  const {\n    links,\n    nodes\n  } = data;\n  const LS = valueof(links, source);\n  const LT = valueof(links, target);\n  const LV = valueof(links, value);\n  return {\n    links: links.map((_, i) => ({\n      target: LT[i],\n      source: LS[i],\n      value: LV[i]\n    })),\n    nodes: nodes || Array.from(new Set([...LS, ...LT]), key => ({\n      key\n    }))\n  };\n}","map":{"version":3,"names":["MaybeKey","MaybeTitle","MaybeTooltip","baseChannels","options","shapes","name","range","scaleKey","scale","baseGeometryChannels","tooltip3d","type","channel","tooltip2d","tooltip1d","tooltipXd","baseAnnotationChannels","basePreInference","basePostInference","bandWidth","x","getBandWidth","invert","createBandOffset","value","X","y","Y","series","S","style","bandOffset","bandOffsetX","bandOffsetY","isBandX","isBandY","isSeries","d","i","widthX","widthY","f","offset","x0","y0","p","parseFloat","visualMark","index","coordinate","innerWidth","innerHeight","getOptions","P","Array","from","field","encode","valueof","data","initializeData","source","target","links","nodes","LS","LT","LV","map","_","Set","key"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/mark/utils.ts"],"sourcesContent":["import { Band } from '@antv/scale';\nimport { Primitive } from '@antv/vendor/d3-array';\nimport { Vector2 } from '@antv/coord';\nimport { Scale } from '../runtime/types/component';\nimport { Channel } from '../runtime';\nimport { MaybeKey, MaybeTitle, MaybeTooltip } from '../transform';\n\nexport type ChannelOptions = {\n  shapes?: (string | { (...args: any[]); props?: Record<string, any> })[];\n};\n\nexport function baseChannels(options: ChannelOptions = {}): Channel[] {\n  const { shapes } = options;\n  return [\n    { name: 'color' },\n    { name: 'opacity' },\n    { name: 'shape', range: shapes },\n    { name: 'enterType' },\n    { name: 'enterDelay', scaleKey: 'enter' },\n    { name: 'enterDuration', scaleKey: 'enter' },\n    { name: 'enterEasing' },\n    { name: 'key', scale: 'identity' },\n    { name: 'groupKey', scale: 'identity' },\n    { name: 'label', scale: 'identity' },\n  ];\n}\n\nexport function baseGeometryChannels(options: ChannelOptions = {}): Channel[] {\n  return [...baseChannels(options), { name: 'title', scale: 'identity' }];\n}\n\nexport function tooltip3d() {\n  return [\n    { type: MaybeTitle, channel: 'color' },\n    { type: MaybeTooltip, channel: ['x', 'y', 'z'] },\n  ];\n}\n\nexport function tooltip2d() {\n  return [\n    { type: MaybeTitle, channel: 'color' },\n    { type: MaybeTooltip, channel: ['x', 'y'] },\n  ];\n}\n\nexport function tooltip1d() {\n  return [\n    { type: MaybeTitle, channel: 'x' },\n    { type: MaybeTooltip, channel: ['y'] },\n  ];\n}\n\nexport function tooltipXd() {\n  return [\n    { type: MaybeTitle, channel: 'color' },\n    { type: MaybeTooltip, channel: ['position'] },\n  ];\n}\n\nexport function baseAnnotationChannels(\n  options: ChannelOptions = {},\n): Channel[] {\n  return baseChannels(options);\n}\n\nexport function basePreInference() {\n  return [{ type: MaybeKey }];\n}\n\nexport function basePostInference() {\n  return [];\n}\n\nexport function bandWidth(scale: Band, x: any): number {\n  return scale.getBandWidth(scale.invert(x));\n}\n\nexport function createBandOffset(\n  scale: Record<string, Scale>,\n  value: Record<string, Primitive[]>,\n  options: Record<string, any> = {},\n): (d: [number, number], i?: number) => [number, number] {\n  const { x: X, y: Y, series: S } = value;\n  const { x, y, series } = scale;\n  const {\n    style: {\n      bandOffset = series ? 0 : 0.5,\n      bandOffsetX = bandOffset,\n      bandOffsetY = bandOffset,\n    } = {},\n  } = options;\n  const isBandX = !!x?.getBandWidth;\n  const isBandY = !!y?.getBandWidth;\n  const isSeries = !!series?.getBandWidth;\n  if (!isBandX && !isBandY) return (d) => d;\n  return (d, i) => {\n    const widthX = isBandX ? bandWidth(x as Band, X[i]) : 0;\n    const widthY = isBandY ? bandWidth(y as Band, Y[i]) : 0;\n    const f = () => (bandWidth(series as Band, S[i]) / 2 + +S[i]) * widthX;\n    const offset = isSeries && S ? f() : 0;\n    const [x0, y0] = d;\n    return [x0 + bandOffsetX * widthX + offset, y0 + bandOffsetY * widthY];\n  };\n}\n\nexport function p(d) {\n  return parseFloat(d) / 100;\n}\n\nexport function visualMark(index: number[], scale, value, coordinate) {\n  const { x: X, y: Y } = value;\n  const { innerWidth, innerHeight } = coordinate.getOptions();\n  const P: Vector2[][] = Array.from(index, (i) => {\n    const x0 = X[i];\n    const y0 = Y[i];\n    const x = typeof x0 === 'string' ? p(x0) * innerWidth : +x0;\n    const y = typeof y0 === 'string' ? p(y0) * innerHeight : +y0;\n    return [[x, y]];\n  });\n  return [index, P];\n}\n\ntype Encode = 'string' | ((d: any) => any);\n\nexport function field(encode: Encode): (d: any) => any {\n  return typeof encode === 'function' ? encode : (d) => d[encode];\n}\n\nexport function valueof(data: Record<string, any>[], encode: Encode): any[] {\n  return Array.from(data, field(encode));\n}\n\nexport function initializeData(\n  data: { nodes?: any[]; links: any[] },\n  encode: Record<string, Encode>,\n): {\n  links: { target: string; source: string; value: any }[];\n  nodes: { key: string }[];\n} {\n  const {\n    source = (d) => d.source,\n    target = (d) => d.target,\n    value = (d) => d.value,\n  } = encode;\n  const { links, nodes } = data;\n  const LS = valueof(links, source);\n  const LT = valueof(links, target);\n  const LV = valueof(links, value);\n  return {\n    links: links.map((_, i) => ({\n      target: LT[i],\n      source: LS[i],\n      value: LV[i],\n    })),\n    nodes: nodes || Array.from(new Set([...LS, ...LT]), (key) => ({ key })),\n  };\n}\n"],"mappings":"AAKA,SAASA,QAAQ,EAAEC,UAAU,EAAEC,YAAY,QAAQ,cAAc;AAMjE,OAAM,SAAUC,YAAYA,CAACC,OAAA,GAA0B,EAAE;EACvD,MAAM;IAAEC;EAAM,CAAE,GAAGD,OAAO;EAC1B,OAAO,CACL;IAAEE,IAAI,EAAE;EAAO,CAAE,EACjB;IAAEA,IAAI,EAAE;EAAS,CAAE,EACnB;IAAEA,IAAI,EAAE,OAAO;IAAEC,KAAK,EAAEF;EAAM,CAAE,EAChC;IAAEC,IAAI,EAAE;EAAW,CAAE,EACrB;IAAEA,IAAI,EAAE,YAAY;IAAEE,QAAQ,EAAE;EAAO,CAAE,EACzC;IAAEF,IAAI,EAAE,eAAe;IAAEE,QAAQ,EAAE;EAAO,CAAE,EAC5C;IAAEF,IAAI,EAAE;EAAa,CAAE,EACvB;IAAEA,IAAI,EAAE,KAAK;IAAEG,KAAK,EAAE;EAAU,CAAE,EAClC;IAAEH,IAAI,EAAE,UAAU;IAAEG,KAAK,EAAE;EAAU,CAAE,EACvC;IAAEH,IAAI,EAAE,OAAO;IAAEG,KAAK,EAAE;EAAU,CAAE,CACrC;AACH;AAEA,OAAM,SAAUC,oBAAoBA,CAACN,OAAA,GAA0B,EAAE;EAC/D,OAAO,CAAC,GAAGD,YAAY,CAACC,OAAO,CAAC,EAAE;IAAEE,IAAI,EAAE,OAAO;IAAEG,KAAK,EAAE;EAAU,CAAE,CAAC;AACzE;AAEA,OAAM,SAAUE,SAASA,CAAA;EACvB,OAAO,CACL;IAAEC,IAAI,EAAEX,UAAU;IAAEY,OAAO,EAAE;EAAO,CAAE,EACtC;IAAED,IAAI,EAAEV,YAAY;IAAEW,OAAO,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;EAAC,CAAE,CACjD;AACH;AAEA,OAAM,SAAUC,SAASA,CAAA;EACvB,OAAO,CACL;IAAEF,IAAI,EAAEX,UAAU;IAAEY,OAAO,EAAE;EAAO,CAAE,EACtC;IAAED,IAAI,EAAEV,YAAY;IAAEW,OAAO,EAAE,CAAC,GAAG,EAAE,GAAG;EAAC,CAAE,CAC5C;AACH;AAEA,OAAM,SAAUE,SAASA,CAAA;EACvB,OAAO,CACL;IAAEH,IAAI,EAAEX,UAAU;IAAEY,OAAO,EAAE;EAAG,CAAE,EAClC;IAAED,IAAI,EAAEV,YAAY;IAAEW,OAAO,EAAE,CAAC,GAAG;EAAC,CAAE,CACvC;AACH;AAEA,OAAM,SAAUG,SAASA,CAAA;EACvB,OAAO,CACL;IAAEJ,IAAI,EAAEX,UAAU;IAAEY,OAAO,EAAE;EAAO,CAAE,EACtC;IAAED,IAAI,EAAEV,YAAY;IAAEW,OAAO,EAAE,CAAC,UAAU;EAAC,CAAE,CAC9C;AACH;AAEA,OAAM,SAAUI,sBAAsBA,CACpCb,OAAA,GAA0B,EAAE;EAE5B,OAAOD,YAAY,CAACC,OAAO,CAAC;AAC9B;AAEA,OAAM,SAAUc,gBAAgBA,CAAA;EAC9B,OAAO,CAAC;IAAEN,IAAI,EAAEZ;EAAQ,CAAE,CAAC;AAC7B;AAEA,OAAM,SAAUmB,iBAAiBA,CAAA;EAC/B,OAAO,EAAE;AACX;AAEA,OAAM,SAAUC,SAASA,CAACX,KAAW,EAAEY,CAAM;EAC3C,OAAOZ,KAAK,CAACa,YAAY,CAACb,KAAK,CAACc,MAAM,CAACF,CAAC,CAAC,CAAC;AAC5C;AAEA,OAAM,SAAUG,gBAAgBA,CAC9Bf,KAA4B,EAC5BgB,KAAkC,EAClCrB,OAAA,GAA+B,EAAE;EAEjC,MAAM;IAAEiB,CAAC,EAAEK,CAAC;IAAEC,CAAC,EAAEC,CAAC;IAAEC,MAAM,EAAEC;EAAC,CAAE,GAAGL,KAAK;EACvC,MAAM;IAAEJ,CAAC;IAAEM,CAAC;IAAEE;EAAM,CAAE,GAAGpB,KAAK;EAC9B,MAAM;IACJsB,KAAK,EAAE;MACLC,UAAU,GAAGH,MAAM,GAAG,CAAC,GAAG,GAAG;MAC7BI,WAAW,GAAGD,UAAU;MACxBE,WAAW,GAAGF;IAAU,CACzB,GAAG;EAAE,CACP,GAAG5B,OAAO;EACX,MAAM+B,OAAO,GAAG,CAAC,EAACd,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAEC,YAAY;EACjC,MAAMc,OAAO,GAAG,CAAC,EAACT,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAEL,YAAY;EACjC,MAAMe,QAAQ,GAAG,CAAC,EAACR,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEP,YAAY;EACvC,IAAI,CAACa,OAAO,IAAI,CAACC,OAAO,EAAE,OAAQE,CAAC,IAAKA,CAAC;EACzC,OAAO,CAACA,CAAC,EAAEC,CAAC,KAAI;IACd,MAAMC,MAAM,GAAGL,OAAO,GAAGf,SAAS,CAACC,CAAS,EAAEK,CAAC,CAACa,CAAC,CAAC,CAAC,GAAG,CAAC;IACvD,MAAME,MAAM,GAAGL,OAAO,GAAGhB,SAAS,CAACO,CAAS,EAAEC,CAAC,CAACW,CAAC,CAAC,CAAC,GAAG,CAAC;IACvD,MAAMG,CAAC,GAAGA,CAAA,KAAM,CAACtB,SAAS,CAACS,MAAc,EAAEC,CAAC,CAACS,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAACT,CAAC,CAACS,CAAC,CAAC,IAAIC,MAAM;IACtE,MAAMG,MAAM,GAAGN,QAAQ,IAAIP,CAAC,GAAGY,CAAC,EAAE,GAAG,CAAC;IACtC,MAAM,CAACE,EAAE,EAAEC,EAAE,CAAC,GAAGP,CAAC;IAClB,OAAO,CAACM,EAAE,GAAGX,WAAW,GAAGO,MAAM,GAAGG,MAAM,EAAEE,EAAE,GAAGX,WAAW,GAAGO,MAAM,CAAC;EACxE,CAAC;AACH;AAEA,OAAM,SAAUK,CAACA,CAACR,CAAC;EACjB,OAAOS,UAAU,CAACT,CAAC,CAAC,GAAG,GAAG;AAC5B;AAEA,OAAM,SAAUU,UAAUA,CAACC,KAAe,EAAExC,KAAK,EAAEgB,KAAK,EAAEyB,UAAU;EAClE,MAAM;IAAE7B,CAAC,EAAEK,CAAC;IAAEC,CAAC,EAAEC;EAAC,CAAE,GAAGH,KAAK;EAC5B,MAAM;IAAE0B,UAAU;IAAEC;EAAW,CAAE,GAAGF,UAAU,CAACG,UAAU,EAAE;EAC3D,MAAMC,CAAC,GAAgBC,KAAK,CAACC,IAAI,CAACP,KAAK,EAAGV,CAAC,IAAI;IAC7C,MAAMK,EAAE,GAAGlB,CAAC,CAACa,CAAC,CAAC;IACf,MAAMM,EAAE,GAAGjB,CAAC,CAACW,CAAC,CAAC;IACf,MAAMlB,CAAC,GAAG,OAAOuB,EAAE,KAAK,QAAQ,GAAGE,CAAC,CAACF,EAAE,CAAC,GAAGO,UAAU,GAAG,CAACP,EAAE;IAC3D,MAAMjB,CAAC,GAAG,OAAOkB,EAAE,KAAK,QAAQ,GAAGC,CAAC,CAACD,EAAE,CAAC,GAAGO,WAAW,GAAG,CAACP,EAAE;IAC5D,OAAO,CAAC,CAACxB,CAAC,EAAEM,CAAC,CAAC,CAAC;EACjB,CAAC,CAAC;EACF,OAAO,CAACsB,KAAK,EAAEK,CAAC,CAAC;AACnB;AAIA,OAAM,SAAUG,KAAKA,CAACC,MAAc;EAClC,OAAO,OAAOA,MAAM,KAAK,UAAU,GAAGA,MAAM,GAAIpB,CAAC,IAAKA,CAAC,CAACoB,MAAM,CAAC;AACjE;AAEA,OAAM,SAAUC,OAAOA,CAACC,IAA2B,EAAEF,MAAc;EACjE,OAAOH,KAAK,CAACC,IAAI,CAACI,IAAI,EAAEH,KAAK,CAACC,MAAM,CAAC,CAAC;AACxC;AAEA,OAAM,SAAUG,cAAcA,CAC5BD,IAAqC,EACrCF,MAA8B;EAK9B,MAAM;IACJI,MAAM,GAAIxB,CAAC,IAAKA,CAAC,CAACwB,MAAM;IACxBC,MAAM,GAAIzB,CAAC,IAAKA,CAAC,CAACyB,MAAM;IACxBtC,KAAK,GAAIa,CAAC,IAAKA,CAAC,CAACb;EAAK,CACvB,GAAGiC,MAAM;EACV,MAAM;IAAEM,KAAK;IAAEC;EAAK,CAAE,GAAGL,IAAI;EAC7B,MAAMM,EAAE,GAAGP,OAAO,CAACK,KAAK,EAAEF,MAAM,CAAC;EACjC,MAAMK,EAAE,GAAGR,OAAO,CAACK,KAAK,EAAED,MAAM,CAAC;EACjC,MAAMK,EAAE,GAAGT,OAAO,CAACK,KAAK,EAAEvC,KAAK,CAAC;EAChC,OAAO;IACLuC,KAAK,EAAEA,KAAK,CAACK,GAAG,CAAC,CAACC,CAAC,EAAE/B,CAAC,MAAM;MAC1BwB,MAAM,EAAEI,EAAE,CAAC5B,CAAC,CAAC;MACbuB,MAAM,EAAEI,EAAE,CAAC3B,CAAC,CAAC;MACbd,KAAK,EAAE2C,EAAE,CAAC7B,CAAC;KACZ,CAAC,CAAC;IACH0B,KAAK,EAAEA,KAAK,IAAIV,KAAK,CAACC,IAAI,CAAC,IAAIe,GAAG,CAAC,CAAC,GAAGL,EAAE,EAAE,GAAGC,EAAE,CAAC,CAAC,EAAGK,GAAG,KAAM;MAAEA;IAAG,CAAE,CAAC;GACvE;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}