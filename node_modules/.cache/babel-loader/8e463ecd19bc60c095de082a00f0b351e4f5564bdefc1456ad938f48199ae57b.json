{"ast":null,"code":"import { CommonEvent } from '../../constants';\nimport { Circle } from '../../elements';\nimport { idOf } from '../../utils/id';\nimport { parsePoint, toPointObject } from '../../utils/point';\nimport { positionOf } from '../../utils/position';\nimport { distance } from '../../utils/vector';\nimport { BasePlugin } from '../base-plugin';\nconst defaultLensStyle = {\n  fill: '#fff',\n  fillOpacity: 1,\n  lineWidth: 1,\n  stroke: '#000',\n  strokeOpacity: 0.8,\n  zIndex: -Infinity\n};\nconst DELTA = 0.05;\n/**\n * <zh/> 边过滤镜插件\n *\n * <en/> Edge filter lens plugin\n * @remarks\n * <zh/> 边过滤镜可以将关注的边保留在过滤镜范围内，其他边将在该范围内不显示。\n *\n * <en/> EdgeFilterLens can keep the focused edges within the lens range, while other edges will not be displayed within that range.\n */\nexport class EdgeFilterLens extends BasePlugin {\n  constructor(context, options) {\n    super(context, Object.assign({}, EdgeFilterLens.defaultOptions, options));\n    this.shapes = new Map();\n    this.r = this.options.r;\n    this.onEdgeFilter = event => {\n      if (this.options.trigger === 'drag' && this.isLensOn) return;\n      const origin = parsePoint(event.canvas);\n      this.renderLens(origin);\n      this.renderFocusElements();\n    };\n    this.renderLens = origin => {\n      const style = Object.assign({}, defaultLensStyle, this.options.style);\n      if (!this.isLensOn) {\n        this.lens = new Circle({\n          style\n        });\n        this.canvas.appendChild(this.lens);\n      }\n      Object.assign(style, toPointObject(origin), {\n        size: this.r * 2\n      });\n      this.lens.update(style);\n    };\n    this.getFilterData = () => {\n      const {\n        filter\n      } = this.options;\n      const {\n        model\n      } = this.context;\n      const data = model.getData();\n      if (!filter) return data;\n      const {\n        nodes,\n        edges,\n        combos\n      } = data;\n      return {\n        nodes: nodes.filter(node => filter(idOf(node), 'node')),\n        edges: edges.filter(edge => filter(idOf(edge), 'edge')),\n        combos: combos.filter(combo => filter(idOf(combo), 'combo'))\n      };\n    };\n    this.getFocusElements = origin => {\n      const {\n        nodes,\n        edges\n      } = this.getFilterData();\n      const focusNodes = nodes.filter(datum => distance(positionOf(datum), origin) < this.r);\n      const focusNodeIds = focusNodes.map(node => idOf(node));\n      const focusEdges = edges.filter(datum => {\n        const {\n          source,\n          target\n        } = datum;\n        const isSourceFocus = focusNodeIds.includes(source);\n        const isTargetFocus = focusNodeIds.includes(target);\n        switch (this.options.nodeType) {\n          case 'both':\n            return isSourceFocus && isTargetFocus;\n          case 'either':\n            return isSourceFocus !== isTargetFocus;\n          case 'source':\n            return isSourceFocus && !isTargetFocus;\n          case 'target':\n            return !isSourceFocus && isTargetFocus;\n          default:\n            return false;\n        }\n      });\n      return {\n        nodes: focusNodes,\n        edges: focusEdges\n      };\n    };\n    this.renderFocusElements = () => {\n      const {\n        element,\n        graph\n      } = this.context;\n      if (!this.isLensOn) return;\n      const origin = this.lens.getCenter();\n      const {\n        nodes,\n        edges\n      } = this.getFocusElements(origin);\n      const ids = new Set();\n      const iterate = datum => {\n        const id = idOf(datum);\n        ids.add(id);\n        const shape = element.getElement(id);\n        if (!shape) return;\n        const cloneShape = this.shapes.get(id) || shape.cloneNode();\n        cloneShape.setPosition(shape.getPosition());\n        cloneShape.id = shape.id;\n        if (!this.shapes.has(id)) {\n          this.canvas.appendChild(cloneShape);\n          this.shapes.set(id, cloneShape);\n        } else {\n          Object.entries(shape.attributes).forEach(([key, value]) => {\n            if (cloneShape.style[key] !== value) cloneShape.style[key] = value;\n          });\n        }\n        const elementType = graph.getElementType(id);\n        const style = this.getElementStyle(elementType, datum);\n        // @ts-ignore\n        cloneShape.update(style);\n      };\n      nodes.forEach(iterate);\n      edges.forEach(iterate);\n      this.shapes.forEach((shape, id) => {\n        if (!ids.has(id)) {\n          shape.destroy();\n          this.shapes.delete(id);\n        }\n      });\n    };\n    this.scaleRByWheel = event => {\n      var _a;\n      if (this.options.preventDefault) event.preventDefault();\n      const {\n        clientX,\n        clientY,\n        deltaX,\n        deltaY\n      } = event;\n      const {\n        graph,\n        canvas\n      } = this.context;\n      const scaleOrigin = graph.getCanvasByClient([clientX, clientY]);\n      const origin = (_a = this.lens) === null || _a === void 0 ? void 0 : _a.getCenter();\n      if (!this.isLensOn || distance(scaleOrigin, origin) > this.r) {\n        return;\n      }\n      const {\n        maxR,\n        minR\n      } = this.options;\n      const ratio = deltaX + deltaY > 0 ? 1 / (1 - DELTA) : 1 - DELTA;\n      const canvasR = Math.min(...canvas.getSize()) / 2;\n      this.r = Math.max(minR || 0, Math.min(maxR || canvasR, this.r * ratio));\n      this.renderLens(origin);\n      this.renderFocusElements();\n    };\n    this.isLensDragging = false;\n    this.onDragStart = event => {\n      var _a;\n      const dragOrigin = parsePoint(event.canvas);\n      const origin = (_a = this.lens) === null || _a === void 0 ? void 0 : _a.getCenter();\n      if (!this.isLensOn || distance(dragOrigin, origin) > this.r) return;\n      this.isLensDragging = true;\n    };\n    this.onDrag = event => {\n      if (!this.isLensDragging) return;\n      const dragOrigin = parsePoint(event.canvas);\n      this.renderLens(dragOrigin);\n      this.renderFocusElements();\n    };\n    this.onDragEnd = () => {\n      this.isLensDragging = false;\n    };\n    this.bindEvents();\n  }\n  get canvas() {\n    return this.context.canvas.getLayer('transient');\n  }\n  get isLensOn() {\n    return this.lens && !this.lens.destroyed;\n  }\n  getElementStyle(elementType, datum) {\n    const styler = elementType === 'node' ? this.options.nodeStyle : this.options.edgeStyle;\n    if (typeof styler === 'function') return styler(datum);\n    return styler;\n  }\n  get graphDom() {\n    return this.context.graph.getCanvas().getContextService().getDomElement();\n  }\n  bindEvents() {\n    var _a;\n    const {\n      graph\n    } = this.context;\n    const {\n      trigger,\n      scaleRBy\n    } = this.options;\n    const canvas = graph.getCanvas().getLayer();\n    if (['click', 'drag'].includes(trigger)) {\n      canvas.addEventListener(CommonEvent.CLICK, this.onEdgeFilter);\n    }\n    if (trigger === 'pointermove') {\n      canvas.addEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);\n    } else if (trigger === 'drag') {\n      canvas.addEventListener(CommonEvent.DRAG_START, this.onDragStart);\n      canvas.addEventListener(CommonEvent.DRAG, this.onDrag);\n      canvas.addEventListener(CommonEvent.DRAG_END, this.onDragEnd);\n    }\n    if (scaleRBy === 'wheel') {\n      (_a = this.graphDom) === null || _a === void 0 ? void 0 : _a.addEventListener(CommonEvent.WHEEL, this.scaleRByWheel, {\n        passive: false\n      });\n    }\n  }\n  unbindEvents() {\n    var _a;\n    const {\n      graph\n    } = this.context;\n    const {\n      trigger,\n      scaleRBy\n    } = this.options;\n    const canvas = graph.getCanvas().getLayer();\n    if (['click', 'drag'].includes(trigger)) {\n      canvas.removeEventListener(CommonEvent.CLICK, this.onEdgeFilter);\n    }\n    if (trigger === 'pointermove') {\n      canvas.removeEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);\n    } else if (trigger === 'drag') {\n      canvas.removeEventListener(CommonEvent.DRAG_START, this.onDragStart);\n      canvas.removeEventListener(CommonEvent.DRAG, this.onDrag);\n      canvas.removeEventListener(CommonEvent.DRAG_END, this.onDragEnd);\n    }\n    if (scaleRBy === 'wheel') {\n      (_a = this.graphDom) === null || _a === void 0 ? void 0 : _a.removeEventListener(CommonEvent.WHEEL, this.scaleRByWheel);\n    }\n  }\n  update(options) {\n    var _a;\n    this.unbindEvents();\n    super.update(options);\n    this.r = (_a = options.r) !== null && _a !== void 0 ? _a : this.r;\n    this.bindEvents();\n  }\n  destroy() {\n    this.unbindEvents();\n    if (this.isLensOn) {\n      this.lens.destroy();\n    }\n    this.shapes.forEach((shape, id) => {\n      shape.destroy();\n      this.shapes.delete(id);\n    });\n    super.destroy();\n  }\n}\nEdgeFilterLens.defaultOptions = {\n  trigger: 'pointermove',\n  r: 60,\n  nodeType: 'both',\n  filter: () => true,\n  style: {\n    lineWidth: 2\n  },\n  nodeStyle: {\n    label: false\n  },\n  edgeStyle: {\n    label: true\n  },\n  scaleRBy: 'wheel',\n  preventDefault: true\n};","map":{"version":3,"names":["CommonEvent","Circle","idOf","parsePoint","toPointObject","positionOf","distance","BasePlugin","defaultLensStyle","fill","fillOpacity","lineWidth","stroke","strokeOpacity","zIndex","Infinity","DELTA","EdgeFilterLens","constructor","context","options","Object","assign","defaultOptions","shapes","Map","r","onEdgeFilter","event","trigger","isLensOn","origin","canvas","renderLens","renderFocusElements","style","lens","appendChild","size","update","getFilterData","filter","model","data","getData","nodes","edges","combos","node","edge","combo","getFocusElements","focusNodes","datum","focusNodeIds","map","focusEdges","source","target","isSourceFocus","includes","isTargetFocus","nodeType","element","graph","getCenter","ids","Set","iterate","id","add","shape","getElement","cloneShape","get","cloneNode","setPosition","getPosition","has","set","entries","attributes","forEach","key","value","elementType","getElementType","getElementStyle","destroy","delete","scaleRByWheel","preventDefault","clientX","clientY","deltaX","deltaY","scaleOrigin","getCanvasByClient","_a","maxR","minR","ratio","canvasR","Math","min","getSize","max","isLensDragging","onDragStart","dragOrigin","onDrag","onDragEnd","bindEvents","getLayer","destroyed","styler","nodeStyle","edgeStyle","graphDom","getCanvas","getContextService","getDomElement","scaleRBy","addEventListener","CLICK","POINTER_MOVE","DRAG_START","DRAG","DRAG_END","WHEEL","passive","unbindEvents","removeEventListener","label"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/plugins/edge-filter-lens/index.ts"],"sourcesContent":["import { CommonEvent } from '../../constants';\nimport { Circle, type CircleStyleProps } from '../../elements';\nimport type { RuntimeContext } from '../../runtime/types';\nimport type { EdgeData, GraphData, NodeData } from '../../spec';\nimport type { EdgeStyle } from '../../spec/element/edge';\nimport type { NodeStyle } from '../../spec/element/node';\nimport type {\n  Element,\n  ElementDatum,\n  ElementType,\n  ID,\n  IDragEvent,\n  IPointerEvent,\n  Point,\n  PointObject,\n} from '../../types';\nimport { idOf } from '../../utils/id';\nimport { parsePoint, toPointObject } from '../../utils/point';\nimport { positionOf } from '../../utils/position';\nimport { distance } from '../../utils/vector';\nimport type { BasePluginOptions } from '../base-plugin';\nimport { BasePlugin } from '../base-plugin';\n\n/**\n * <zh/> 边过滤镜插件配置项\n *\n * <en/> Edge filter lens plugin options\n */\nexport interface EdgeFilterLensOptions extends BasePluginOptions {\n  /**\n   * <zh/> 移动透镜的方式\n   * - `'pointermove'`：始终跟随鼠标移动\n   * - `'click'`：鼠标点击时透镜移动\n   * - `'drag'`：拖拽透镜\n   *\n   * <en/> The way to move the lens\n   * - `'pointermove'`: always follow the mouse movement\n   * - `'click'`: move the lens when the mouse clicks\n   * - `'drag'`: drag the lens\n   * @defaultValue 'pointermove'\n   */\n  trigger?: 'pointermove' | 'click' | 'drag';\n  /**\n   * <zh/> 透镜的半径\n   *\n   * <en/> The radius of the lens\n   * @defaultValue 60\n   */\n  r?: number;\n  /**\n   * <zh/> 透镜的最大半径。只有在 `scaleRBy` 为 `wheel` 时生效\n   *\n   * <en/> The maximum radius of the lens. Only valid when `scaleRBy` is `wheel`\n   * @defaultValue canvas 宽高最小值的一半\n   */\n  maxR?: number;\n  /**\n   * <zh/> 透镜的最小半径。只有在 `scaleRBy` 为 `wheel` 时生效\n   *\n   * <en/> The minimum radius of the lens. Only valid when `scaleRBy` is `wheel`\n   * @defaultValue 0\n   */\n  minR?: number;\n  /**\n   * <zh/> 缩放透镜半径的方式\n   * - `'wheel'`：通过滚轮缩放透镜的半径\n   *\n   * <en/> The way to scale the radius of the lens\n   * - `'wheel'`: scale the radius of the lens by the wheel\n   * @defaultValue `'wheel'`\n   */\n  scaleRBy?: 'wheel';\n  /**\n   * <zh/> 边显示的条件\n   * - `'both'`：只有起始节点和目标节点都在透镜中时，边才会显示\n   * - `'source'`：只有起始节点在透镜中时，边才会显示\n   * - `'target'`：只有目标节点在透镜中时，边才会显示\n   * - `'either'`：只要起始节点或目标节点有一个在透镜中时，边就会显示\n   *\n   * <en/> The condition for displaying the edge\n   * - `'both'`: The edge is displayed only when both the source node and the target node are in the lens\n   * - `'source'`: The edge is displayed only when the source node is in the lens\n   * - `'target'`: The edge is displayed only when the target node is in the lens\n   * - `'either'`: The edge is displayed when either the source node or the target node is in the lens\n   * @defaultValue 'both'\n   */\n  nodeType?: 'both' | 'source' | 'target' | 'either';\n  /**\n   * <zh/> 过滤出始终不在透镜中显示的元素\n   *\n   * <en/> Filter elements that are never displayed in the lens\n   * @param id - <zh/> 元素的 id | <en/> The id of the element\n   * @param elementType - <zh/> 元素的类型 | <en/> The type of the element\n   * @returns <zh/> 是否显示 | <en/> Whether to display\n   */\n  filter?: (id: ID, elementType: ElementType) => boolean;\n  /**\n   * <zh/> 透镜的样式\n   *\n   * <en/> The style of the lens\n   */\n  style?: Partial<CircleStyleProps>;\n  /**\n   * <zh/> 在透镜中节点的样式\n   *\n   * <en/> The style of the nodes displayed in the lens\n   */\n  nodeStyle?: NodeStyle | ((datum: NodeData) => NodeStyle);\n  /**\n   * <zh/> 在透镜中边的样式\n   *\n   * <en/> The style of the edges displayed in the lens\n   */\n  edgeStyle?: EdgeStyle | ((datum: EdgeData) => EdgeStyle);\n  /**\n   * <zh/> 是否阻止默认事件\n   *\n   * <en/> Whether to prevent the default event\n   * @defaultValue true\n   */\n  preventDefault?: boolean;\n}\n\nconst defaultLensStyle: Exclude<CircleStyleProps, 'r'> = {\n  fill: '#fff',\n  fillOpacity: 1,\n  lineWidth: 1,\n  stroke: '#000',\n  strokeOpacity: 0.8,\n  zIndex: -Infinity,\n};\n\nconst DELTA = 0.05;\n\n/**\n * <zh/> 边过滤镜插件\n *\n * <en/> Edge filter lens plugin\n * @remarks\n * <zh/> 边过滤镜可以将关注的边保留在过滤镜范围内，其他边将在该范围内不显示。\n *\n * <en/> EdgeFilterLens can keep the focused edges within the lens range, while other edges will not be displayed within that range.\n */\nexport class EdgeFilterLens extends BasePlugin<EdgeFilterLensOptions> {\n  static defaultOptions: Partial<EdgeFilterLensOptions> = {\n    trigger: 'pointermove',\n    r: 60,\n    nodeType: 'both',\n    filter: () => true,\n    style: { lineWidth: 2 },\n    nodeStyle: { label: false },\n    edgeStyle: { label: true },\n    scaleRBy: 'wheel',\n    preventDefault: true,\n  };\n\n  constructor(context: RuntimeContext, options: EdgeFilterLensOptions) {\n    super(context, Object.assign({}, EdgeFilterLens.defaultOptions, options));\n    this.bindEvents();\n  }\n\n  private lens!: Circle;\n\n  private shapes = new Map<ID, Element>();\n\n  private r = this.options.r;\n\n  private get canvas() {\n    return this.context.canvas.getLayer('transient');\n  }\n\n  private get isLensOn() {\n    return this.lens && !this.lens.destroyed;\n  }\n\n  protected onEdgeFilter = (event: IPointerEvent) => {\n    if (this.options.trigger === 'drag' && this.isLensOn) return;\n\n    const origin = parsePoint(event.canvas as PointObject);\n    this.renderLens(origin);\n    this.renderFocusElements();\n  };\n\n  private renderLens = (origin: Point) => {\n    const style = Object.assign({}, defaultLensStyle, this.options.style);\n\n    if (!this.isLensOn) {\n      this.lens = new Circle({ style });\n      this.canvas.appendChild(this.lens);\n    }\n\n    Object.assign(style, toPointObject(origin), { size: this.r * 2 });\n\n    this.lens.update(style);\n  };\n\n  private getFilterData = (): Required<GraphData> => {\n    const { filter } = this.options;\n    const { model } = this.context;\n    const data = model.getData();\n\n    if (!filter) return data;\n\n    const { nodes, edges, combos } = data;\n\n    return {\n      nodes: nodes.filter((node) => filter(idOf(node), 'node')),\n      edges: edges.filter((edge) => filter(idOf(edge), 'edge')),\n      combos: combos.filter((combo) => filter(idOf(combo), 'combo')),\n    };\n  };\n\n  private getFocusElements = (origin: Point) => {\n    const { nodes, edges } = this.getFilterData();\n\n    const focusNodes = nodes.filter((datum) => distance(positionOf(datum), origin) < this.r);\n    const focusNodeIds = focusNodes.map((node) => idOf(node));\n\n    const focusEdges = edges.filter((datum) => {\n      const { source, target } = datum;\n      const isSourceFocus = focusNodeIds.includes(source);\n      const isTargetFocus = focusNodeIds.includes(target);\n\n      switch (this.options.nodeType) {\n        case 'both':\n          return isSourceFocus && isTargetFocus;\n        case 'either':\n          return isSourceFocus !== isTargetFocus;\n        case 'source':\n          return isSourceFocus && !isTargetFocus;\n        case 'target':\n          return !isSourceFocus && isTargetFocus;\n        default:\n          return false;\n      }\n    });\n\n    return { nodes: focusNodes, edges: focusEdges };\n  };\n\n  private renderFocusElements = () => {\n    const { element, graph } = this.context;\n    if (!this.isLensOn) return;\n\n    const origin = this.lens.getCenter();\n    const { nodes, edges } = this.getFocusElements(origin);\n\n    const ids = new Set<ID>();\n\n    const iterate = (datum: ElementDatum) => {\n      const id = idOf(datum);\n      ids.add(id);\n\n      const shape = element!.getElement(id);\n      if (!shape) return;\n\n      const cloneShape = this.shapes.get(id) || shape.cloneNode();\n\n      cloneShape.setPosition(shape.getPosition());\n      cloneShape.id = shape.id;\n\n      if (!this.shapes.has(id)) {\n        this.canvas.appendChild(cloneShape);\n        this.shapes.set(id, cloneShape);\n      } else {\n        Object.entries(shape.attributes).forEach(([key, value]) => {\n          if (cloneShape.style[key] !== value) cloneShape.style[key] = value;\n        });\n      }\n\n      const elementType = graph.getElementType(id) as Exclude<ElementType, 'combo'>;\n      const style = this.getElementStyle(elementType, datum);\n\n      // @ts-ignore\n      cloneShape.update(style);\n    };\n\n    nodes.forEach(iterate);\n    edges.forEach(iterate);\n\n    this.shapes.forEach((shape, id) => {\n      if (!ids.has(id)) {\n        shape.destroy();\n        this.shapes.delete(id);\n      }\n    });\n  };\n\n  private getElementStyle(elementType: ElementType, datum: ElementDatum) {\n    const styler = elementType === 'node' ? this.options.nodeStyle : this.options.edgeStyle;\n    if (typeof styler === 'function') return styler(datum as any);\n    return styler;\n  }\n\n  private scaleRByWheel = (event: WheelEvent) => {\n    if (this.options.preventDefault) event.preventDefault();\n    const { clientX, clientY, deltaX, deltaY } = event;\n    const { graph, canvas } = this.context;\n    const scaleOrigin = graph.getCanvasByClient([clientX, clientY]);\n    const origin = this.lens?.getCenter();\n\n    if (!this.isLensOn || distance(scaleOrigin, origin) > this.r) {\n      return;\n    }\n\n    const { maxR, minR } = this.options;\n    const ratio = deltaX + deltaY > 0 ? 1 / (1 - DELTA) : 1 - DELTA;\n    const canvasR = Math.min(...canvas.getSize()) / 2;\n    this.r = Math.max(minR || 0, Math.min(maxR || canvasR, this.r * ratio));\n\n    this.renderLens(origin);\n    this.renderFocusElements();\n  };\n\n  get graphDom() {\n    return this.context.graph.getCanvas().getContextService().getDomElement();\n  }\n\n  private isLensDragging = false;\n\n  private onDragStart = (event: IDragEvent) => {\n    const dragOrigin = parsePoint(event.canvas as PointObject);\n    const origin = this.lens?.getCenter();\n\n    if (!this.isLensOn || distance(dragOrigin, origin) > this.r) return;\n\n    this.isLensDragging = true;\n  };\n\n  private onDrag = (event: IDragEvent) => {\n    if (!this.isLensDragging) return;\n\n    const dragOrigin = parsePoint(event.canvas as PointObject);\n    this.renderLens(dragOrigin);\n    this.renderFocusElements();\n  };\n\n  private onDragEnd = () => {\n    this.isLensDragging = false;\n  };\n\n  private bindEvents() {\n    const { graph } = this.context;\n    const { trigger, scaleRBy } = this.options;\n\n    const canvas = graph.getCanvas().getLayer();\n\n    if (['click', 'drag'].includes(trigger)) {\n      canvas.addEventListener(CommonEvent.CLICK, this.onEdgeFilter);\n    }\n\n    if (trigger === 'pointermove') {\n      canvas.addEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);\n    } else if (trigger === 'drag') {\n      canvas.addEventListener(CommonEvent.DRAG_START, this.onDragStart);\n      canvas.addEventListener(CommonEvent.DRAG, this.onDrag);\n      canvas.addEventListener(CommonEvent.DRAG_END, this.onDragEnd);\n    }\n\n    if (scaleRBy === 'wheel') {\n      this.graphDom?.addEventListener(CommonEvent.WHEEL, this.scaleRByWheel, { passive: false });\n    }\n  }\n\n  private unbindEvents() {\n    const { graph } = this.context;\n    const { trigger, scaleRBy } = this.options;\n    const canvas = graph.getCanvas().getLayer();\n\n    if (['click', 'drag'].includes(trigger)) {\n      canvas.removeEventListener(CommonEvent.CLICK, this.onEdgeFilter);\n    }\n\n    if (trigger === 'pointermove') {\n      canvas.removeEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);\n    } else if (trigger === 'drag') {\n      canvas.removeEventListener(CommonEvent.DRAG_START, this.onDragStart);\n      canvas.removeEventListener(CommonEvent.DRAG, this.onDrag);\n      canvas.removeEventListener(CommonEvent.DRAG_END, this.onDragEnd);\n    }\n\n    if (scaleRBy === 'wheel') {\n      this.graphDom?.removeEventListener(CommonEvent.WHEEL, this.scaleRByWheel);\n    }\n  }\n\n  public update(options: Partial<EdgeFilterLensOptions>) {\n    this.unbindEvents();\n    super.update(options);\n    this.r = options.r ?? this.r;\n    this.bindEvents();\n  }\n\n  public destroy() {\n    this.unbindEvents();\n    if (this.isLensOn) {\n      this.lens.destroy();\n    }\n    this.shapes.forEach((shape, id) => {\n      shape.destroy();\n      this.shapes.delete(id);\n    });\n    super.destroy();\n  }\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,iBAAiB;AAC7C,SAASC,MAAM,QAA+B,gBAAgB;AAe9D,SAASC,IAAI,QAAQ,gBAAgB;AACrC,SAASC,UAAU,EAAEC,aAAa,QAAQ,mBAAmB;AAC7D,SAASC,UAAU,QAAQ,sBAAsB;AACjD,SAASC,QAAQ,QAAQ,oBAAoB;AAE7C,SAASC,UAAU,QAAQ,gBAAgB;AAsG3C,MAAMC,gBAAgB,GAAmC;EACvDC,IAAI,EAAE,MAAM;EACZC,WAAW,EAAE,CAAC;EACdC,SAAS,EAAE,CAAC;EACZC,MAAM,EAAE,MAAM;EACdC,aAAa,EAAE,GAAG;EAClBC,MAAM,EAAE,CAACC;CACV;AAED,MAAMC,KAAK,GAAG,IAAI;AAElB;;;;;;;;;AASA,OAAM,MAAOC,cAAe,SAAQV,UAAiC;EAanEW,YAAYC,OAAuB,EAAEC,OAA8B;IACjE,KAAK,CAACD,OAAO,EAAEE,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEL,cAAc,CAACM,cAAc,EAAEH,OAAO,CAAC,CAAC;IAMnE,KAAAI,MAAM,GAAG,IAAIC,GAAG,EAAe;IAE/B,KAAAC,CAAC,GAAG,IAAI,CAACN,OAAO,CAACM,CAAC;IAUhB,KAAAC,YAAY,GAAIC,KAAoB,IAAI;MAChD,IAAI,IAAI,CAACR,OAAO,CAACS,OAAO,KAAK,MAAM,IAAI,IAAI,CAACC,QAAQ,EAAE;MAEtD,MAAMC,MAAM,GAAG5B,UAAU,CAACyB,KAAK,CAACI,MAAqB,CAAC;MACtD,IAAI,CAACC,UAAU,CAACF,MAAM,CAAC;MACvB,IAAI,CAACG,mBAAmB,EAAE;IAC5B,CAAC;IAEO,KAAAD,UAAU,GAAIF,MAAa,IAAI;MACrC,MAAMI,KAAK,GAAGd,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEd,gBAAgB,EAAE,IAAI,CAACY,OAAO,CAACe,KAAK,CAAC;MAErE,IAAI,CAAC,IAAI,CAACL,QAAQ,EAAE;QAClB,IAAI,CAACM,IAAI,GAAG,IAAInC,MAAM,CAAC;UAAEkC;QAAK,CAAE,CAAC;QACjC,IAAI,CAACH,MAAM,CAACK,WAAW,CAAC,IAAI,CAACD,IAAI,CAAC;MACpC;MAEAf,MAAM,CAACC,MAAM,CAACa,KAAK,EAAE/B,aAAa,CAAC2B,MAAM,CAAC,EAAE;QAAEO,IAAI,EAAE,IAAI,CAACZ,CAAC,GAAG;MAAC,CAAE,CAAC;MAEjE,IAAI,CAACU,IAAI,CAACG,MAAM,CAACJ,KAAK,CAAC;IACzB,CAAC;IAEO,KAAAK,aAAa,GAAG,MAA0B;MAChD,MAAM;QAAEC;MAAM,CAAE,GAAG,IAAI,CAACrB,OAAO;MAC/B,MAAM;QAAEsB;MAAK,CAAE,GAAG,IAAI,CAACvB,OAAO;MAC9B,MAAMwB,IAAI,GAAGD,KAAK,CAACE,OAAO,EAAE;MAE5B,IAAI,CAACH,MAAM,EAAE,OAAOE,IAAI;MAExB,MAAM;QAAEE,KAAK;QAAEC,KAAK;QAAEC;MAAM,CAAE,GAAGJ,IAAI;MAErC,OAAO;QACLE,KAAK,EAAEA,KAAK,CAACJ,MAAM,CAAEO,IAAI,IAAKP,MAAM,CAACvC,IAAI,CAAC8C,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;QACzDF,KAAK,EAAEA,KAAK,CAACL,MAAM,CAAEQ,IAAI,IAAKR,MAAM,CAACvC,IAAI,CAAC+C,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;QACzDF,MAAM,EAAEA,MAAM,CAACN,MAAM,CAAES,KAAK,IAAKT,MAAM,CAACvC,IAAI,CAACgD,KAAK,CAAC,EAAE,OAAO,CAAC;OAC9D;IACH,CAAC;IAEO,KAAAC,gBAAgB,GAAIpB,MAAa,IAAI;MAC3C,MAAM;QAAEc,KAAK;QAAEC;MAAK,CAAE,GAAG,IAAI,CAACN,aAAa,EAAE;MAE7C,MAAMY,UAAU,GAAGP,KAAK,CAACJ,MAAM,CAAEY,KAAK,IAAK/C,QAAQ,CAACD,UAAU,CAACgD,KAAK,CAAC,EAAEtB,MAAM,CAAC,GAAG,IAAI,CAACL,CAAC,CAAC;MACxF,MAAM4B,YAAY,GAAGF,UAAU,CAACG,GAAG,CAAEP,IAAI,IAAK9C,IAAI,CAAC8C,IAAI,CAAC,CAAC;MAEzD,MAAMQ,UAAU,GAAGV,KAAK,CAACL,MAAM,CAAEY,KAAK,IAAI;QACxC,MAAM;UAAEI,MAAM;UAAEC;QAAM,CAAE,GAAGL,KAAK;QAChC,MAAMM,aAAa,GAAGL,YAAY,CAACM,QAAQ,CAACH,MAAM,CAAC;QACnD,MAAMI,aAAa,GAAGP,YAAY,CAACM,QAAQ,CAACF,MAAM,CAAC;QAEnD,QAAQ,IAAI,CAACtC,OAAO,CAAC0C,QAAQ;UAC3B,KAAK,MAAM;YACT,OAAOH,aAAa,IAAIE,aAAa;UACvC,KAAK,QAAQ;YACX,OAAOF,aAAa,KAAKE,aAAa;UACxC,KAAK,QAAQ;YACX,OAAOF,aAAa,IAAI,CAACE,aAAa;UACxC,KAAK,QAAQ;YACX,OAAO,CAACF,aAAa,IAAIE,aAAa;UACxC;YACE,OAAO,KAAK;QAChB;MACF,CAAC,CAAC;MAEF,OAAO;QAAEhB,KAAK,EAAEO,UAAU;QAAEN,KAAK,EAAEU;MAAU,CAAE;IACjD,CAAC;IAEO,KAAAtB,mBAAmB,GAAG,MAAK;MACjC,MAAM;QAAE6B,OAAO;QAAEC;MAAK,CAAE,GAAG,IAAI,CAAC7C,OAAO;MACvC,IAAI,CAAC,IAAI,CAACW,QAAQ,EAAE;MAEpB,MAAMC,MAAM,GAAG,IAAI,CAACK,IAAI,CAAC6B,SAAS,EAAE;MACpC,MAAM;QAAEpB,KAAK;QAAEC;MAAK,CAAE,GAAG,IAAI,CAACK,gBAAgB,CAACpB,MAAM,CAAC;MAEtD,MAAMmC,GAAG,GAAG,IAAIC,GAAG,EAAM;MAEzB,MAAMC,OAAO,GAAIf,KAAmB,IAAI;QACtC,MAAMgB,EAAE,GAAGnE,IAAI,CAACmD,KAAK,CAAC;QACtBa,GAAG,CAACI,GAAG,CAACD,EAAE,CAAC;QAEX,MAAME,KAAK,GAAGR,OAAQ,CAACS,UAAU,CAACH,EAAE,CAAC;QACrC,IAAI,CAACE,KAAK,EAAE;QAEZ,MAAME,UAAU,GAAG,IAAI,CAACjD,MAAM,CAACkD,GAAG,CAACL,EAAE,CAAC,IAAIE,KAAK,CAACI,SAAS,EAAE;QAE3DF,UAAU,CAACG,WAAW,CAACL,KAAK,CAACM,WAAW,EAAE,CAAC;QAC3CJ,UAAU,CAACJ,EAAE,GAAGE,KAAK,CAACF,EAAE;QAExB,IAAI,CAAC,IAAI,CAAC7C,MAAM,CAACsD,GAAG,CAACT,EAAE,CAAC,EAAE;UACxB,IAAI,CAACrC,MAAM,CAACK,WAAW,CAACoC,UAAU,CAAC;UACnC,IAAI,CAACjD,MAAM,CAACuD,GAAG,CAACV,EAAE,EAAEI,UAAU,CAAC;QACjC,CAAC,MAAM;UACLpD,MAAM,CAAC2D,OAAO,CAACT,KAAK,CAACU,UAAU,CAAC,CAACC,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAI;YACxD,IAAIX,UAAU,CAACtC,KAAK,CAACgD,GAAG,CAAC,KAAKC,KAAK,EAAEX,UAAU,CAACtC,KAAK,CAACgD,GAAG,CAAC,GAAGC,KAAK;UACpE,CAAC,CAAC;QACJ;QAEA,MAAMC,WAAW,GAAGrB,KAAK,CAACsB,cAAc,CAACjB,EAAE,CAAkC;QAC7E,MAAMlC,KAAK,GAAG,IAAI,CAACoD,eAAe,CAACF,WAAW,EAAEhC,KAAK,CAAC;QAEtD;QACAoB,UAAU,CAAClC,MAAM,CAACJ,KAAK,CAAC;MAC1B,CAAC;MAEDU,KAAK,CAACqC,OAAO,CAACd,OAAO,CAAC;MACtBtB,KAAK,CAACoC,OAAO,CAACd,OAAO,CAAC;MAEtB,IAAI,CAAC5C,MAAM,CAAC0D,OAAO,CAAC,CAACX,KAAK,EAAEF,EAAE,KAAI;QAChC,IAAI,CAACH,GAAG,CAACY,GAAG,CAACT,EAAE,CAAC,EAAE;UAChBE,KAAK,CAACiB,OAAO,EAAE;UACf,IAAI,CAAChE,MAAM,CAACiE,MAAM,CAACpB,EAAE,CAAC;QACxB;MACF,CAAC,CAAC;IACJ,CAAC;IAQO,KAAAqB,aAAa,GAAI9D,KAAiB,IAAI;;MAC5C,IAAI,IAAI,CAACR,OAAO,CAACuE,cAAc,EAAE/D,KAAK,CAAC+D,cAAc,EAAE;MACvD,MAAM;QAAEC,OAAO;QAAEC,OAAO;QAAEC,MAAM;QAAEC;MAAM,CAAE,GAAGnE,KAAK;MAClD,MAAM;QAAEoC,KAAK;QAAEhC;MAAM,CAAE,GAAG,IAAI,CAACb,OAAO;MACtC,MAAM6E,WAAW,GAAGhC,KAAK,CAACiC,iBAAiB,CAAC,CAACL,OAAO,EAAEC,OAAO,CAAC,CAAC;MAC/D,MAAM9D,MAAM,GAAG,CAAAmE,EAAA,OAAI,CAAC9D,IAAI,cAAA8D,EAAA,uBAAAA,EAAA,CAAEjC,SAAS,EAAE;MAErC,IAAI,CAAC,IAAI,CAACnC,QAAQ,IAAIxB,QAAQ,CAAC0F,WAAW,EAAEjE,MAAM,CAAC,GAAG,IAAI,CAACL,CAAC,EAAE;QAC5D;MACF;MAEA,MAAM;QAAEyE,IAAI;QAAEC;MAAI,CAAE,GAAG,IAAI,CAAChF,OAAO;MACnC,MAAMiF,KAAK,GAAGP,MAAM,GAAGC,MAAM,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG/E,KAAK,CAAC,GAAG,CAAC,GAAGA,KAAK;MAC/D,MAAMsF,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAGxE,MAAM,CAACyE,OAAO,EAAE,CAAC,GAAG,CAAC;MACjD,IAAI,CAAC/E,CAAC,GAAG6E,IAAI,CAACG,GAAG,CAACN,IAAI,IAAI,CAAC,EAAEG,IAAI,CAACC,GAAG,CAACL,IAAI,IAAIG,OAAO,EAAE,IAAI,CAAC5E,CAAC,GAAG2E,KAAK,CAAC,CAAC;MAEvE,IAAI,CAACpE,UAAU,CAACF,MAAM,CAAC;MACvB,IAAI,CAACG,mBAAmB,EAAE;IAC5B,CAAC;IAMO,KAAAyE,cAAc,GAAG,KAAK;IAEtB,KAAAC,WAAW,GAAIhF,KAAiB,IAAI;;MAC1C,MAAMiF,UAAU,GAAG1G,UAAU,CAACyB,KAAK,CAACI,MAAqB,CAAC;MAC1D,MAAMD,MAAM,GAAG,CAAAmE,EAAA,OAAI,CAAC9D,IAAI,cAAA8D,EAAA,uBAAAA,EAAA,CAAEjC,SAAS,EAAE;MAErC,IAAI,CAAC,IAAI,CAACnC,QAAQ,IAAIxB,QAAQ,CAACuG,UAAU,EAAE9E,MAAM,CAAC,GAAG,IAAI,CAACL,CAAC,EAAE;MAE7D,IAAI,CAACiF,cAAc,GAAG,IAAI;IAC5B,CAAC;IAEO,KAAAG,MAAM,GAAIlF,KAAiB,IAAI;MACrC,IAAI,CAAC,IAAI,CAAC+E,cAAc,EAAE;MAE1B,MAAME,UAAU,GAAG1G,UAAU,CAACyB,KAAK,CAACI,MAAqB,CAAC;MAC1D,IAAI,CAACC,UAAU,CAAC4E,UAAU,CAAC;MAC3B,IAAI,CAAC3E,mBAAmB,EAAE;IAC5B,CAAC;IAEO,KAAA6E,SAAS,GAAG,MAAK;MACvB,IAAI,CAACJ,cAAc,GAAG,KAAK;IAC7B,CAAC;IArLC,IAAI,CAACK,UAAU,EAAE;EACnB;EAQA,IAAYhF,MAAMA,CAAA;IAChB,OAAO,IAAI,CAACb,OAAO,CAACa,MAAM,CAACiF,QAAQ,CAAC,WAAW,CAAC;EAClD;EAEA,IAAYnF,QAAQA,CAAA;IAClB,OAAO,IAAI,CAACM,IAAI,IAAI,CAAC,IAAI,CAACA,IAAI,CAAC8E,SAAS;EAC1C;EAmHQ3B,eAAeA,CAACF,WAAwB,EAAEhC,KAAmB;IACnE,MAAM8D,MAAM,GAAG9B,WAAW,KAAK,MAAM,GAAG,IAAI,CAACjE,OAAO,CAACgG,SAAS,GAAG,IAAI,CAAChG,OAAO,CAACiG,SAAS;IACvF,IAAI,OAAOF,MAAM,KAAK,UAAU,EAAE,OAAOA,MAAM,CAAC9D,KAAY,CAAC;IAC7D,OAAO8D,MAAM;EACf;EAsBA,IAAIG,QAAQA,CAAA;IACV,OAAO,IAAI,CAACnG,OAAO,CAAC6C,KAAK,CAACuD,SAAS,EAAE,CAACC,iBAAiB,EAAE,CAACC,aAAa,EAAE;EAC3E;EAyBQT,UAAUA,CAAA;;IAChB,MAAM;MAAEhD;IAAK,CAAE,GAAG,IAAI,CAAC7C,OAAO;IAC9B,MAAM;MAAEU,OAAO;MAAE6F;IAAQ,CAAE,GAAG,IAAI,CAACtG,OAAO;IAE1C,MAAMY,MAAM,GAAGgC,KAAK,CAACuD,SAAS,EAAE,CAACN,QAAQ,EAAE;IAE3C,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAACrD,QAAQ,CAAC/B,OAAO,CAAC,EAAE;MACvCG,MAAM,CAAC2F,gBAAgB,CAAC3H,WAAW,CAAC4H,KAAK,EAAE,IAAI,CAACjG,YAAY,CAAC;IAC/D;IAEA,IAAIE,OAAO,KAAK,aAAa,EAAE;MAC7BG,MAAM,CAAC2F,gBAAgB,CAAC3H,WAAW,CAAC6H,YAAY,EAAE,IAAI,CAAClG,YAAY,CAAC;IACtE,CAAC,MAAM,IAAIE,OAAO,KAAK,MAAM,EAAE;MAC7BG,MAAM,CAAC2F,gBAAgB,CAAC3H,WAAW,CAAC8H,UAAU,EAAE,IAAI,CAAClB,WAAW,CAAC;MACjE5E,MAAM,CAAC2F,gBAAgB,CAAC3H,WAAW,CAAC+H,IAAI,EAAE,IAAI,CAACjB,MAAM,CAAC;MACtD9E,MAAM,CAAC2F,gBAAgB,CAAC3H,WAAW,CAACgI,QAAQ,EAAE,IAAI,CAACjB,SAAS,CAAC;IAC/D;IAEA,IAAIW,QAAQ,KAAK,OAAO,EAAE;MACxB,CAAAxB,EAAA,OAAI,CAACoB,QAAQ,cAAApB,EAAA,uBAAAA,EAAA,CAAEyB,gBAAgB,CAAC3H,WAAW,CAACiI,KAAK,EAAE,IAAI,CAACvC,aAAa,EAAE;QAAEwC,OAAO,EAAE;MAAK,CAAE,CAAC;IAC5F;EACF;EAEQC,YAAYA,CAAA;;IAClB,MAAM;MAAEnE;IAAK,CAAE,GAAG,IAAI,CAAC7C,OAAO;IAC9B,MAAM;MAAEU,OAAO;MAAE6F;IAAQ,CAAE,GAAG,IAAI,CAACtG,OAAO;IAC1C,MAAMY,MAAM,GAAGgC,KAAK,CAACuD,SAAS,EAAE,CAACN,QAAQ,EAAE;IAE3C,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAACrD,QAAQ,CAAC/B,OAAO,CAAC,EAAE;MACvCG,MAAM,CAACoG,mBAAmB,CAACpI,WAAW,CAAC4H,KAAK,EAAE,IAAI,CAACjG,YAAY,CAAC;IAClE;IAEA,IAAIE,OAAO,KAAK,aAAa,EAAE;MAC7BG,MAAM,CAACoG,mBAAmB,CAACpI,WAAW,CAAC6H,YAAY,EAAE,IAAI,CAAClG,YAAY,CAAC;IACzE,CAAC,MAAM,IAAIE,OAAO,KAAK,MAAM,EAAE;MAC7BG,MAAM,CAACoG,mBAAmB,CAACpI,WAAW,CAAC8H,UAAU,EAAE,IAAI,CAAClB,WAAW,CAAC;MACpE5E,MAAM,CAACoG,mBAAmB,CAACpI,WAAW,CAAC+H,IAAI,EAAE,IAAI,CAACjB,MAAM,CAAC;MACzD9E,MAAM,CAACoG,mBAAmB,CAACpI,WAAW,CAACgI,QAAQ,EAAE,IAAI,CAACjB,SAAS,CAAC;IAClE;IAEA,IAAIW,QAAQ,KAAK,OAAO,EAAE;MACxB,CAAAxB,EAAA,OAAI,CAACoB,QAAQ,cAAApB,EAAA,uBAAAA,EAAA,CAAEkC,mBAAmB,CAACpI,WAAW,CAACiI,KAAK,EAAE,IAAI,CAACvC,aAAa,CAAC;IAC3E;EACF;EAEOnD,MAAMA,CAACnB,OAAuC;;IACnD,IAAI,CAAC+G,YAAY,EAAE;IACnB,KAAK,CAAC5F,MAAM,CAACnB,OAAO,CAAC;IACrB,IAAI,CAACM,CAAC,GAAG,CAAAwE,EAAA,GAAA9E,OAAO,CAACM,CAAC,cAAAwE,EAAA,cAAAA,EAAA,GAAI,IAAI,CAACxE,CAAC;IAC5B,IAAI,CAACsF,UAAU,EAAE;EACnB;EAEOxB,OAAOA,CAAA;IACZ,IAAI,CAAC2C,YAAY,EAAE;IACnB,IAAI,IAAI,CAACrG,QAAQ,EAAE;MACjB,IAAI,CAACM,IAAI,CAACoD,OAAO,EAAE;IACrB;IACA,IAAI,CAAChE,MAAM,CAAC0D,OAAO,CAAC,CAACX,KAAK,EAAEF,EAAE,KAAI;MAChCE,KAAK,CAACiB,OAAO,EAAE;MACf,IAAI,CAAChE,MAAM,CAACiE,MAAM,CAACpB,EAAE,CAAC;IACxB,CAAC,CAAC;IACF,KAAK,CAACmB,OAAO,EAAE;EACjB;;AAnQOvE,cAAA,CAAAM,cAAc,GAAmC;EACtDM,OAAO,EAAE,aAAa;EACtBH,CAAC,EAAE,EAAE;EACLoC,QAAQ,EAAE,MAAM;EAChBrB,MAAM,EAAEA,CAAA,KAAM,IAAI;EAClBN,KAAK,EAAE;IAAExB,SAAS,EAAE;EAAC,CAAE;EACvByG,SAAS,EAAE;IAAEiB,KAAK,EAAE;EAAK,CAAE;EAC3BhB,SAAS,EAAE;IAAEgB,KAAK,EAAE;EAAI,CAAE;EAC1BX,QAAQ,EAAE,OAAO;EACjB/B,cAAc,EAAE;CACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}