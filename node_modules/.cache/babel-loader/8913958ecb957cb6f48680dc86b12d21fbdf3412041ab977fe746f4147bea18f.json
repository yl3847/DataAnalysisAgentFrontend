{"ast":null,"code":"import { get } from 'lodash';\nimport React from 'react';\nimport { CollapseExpandIcon, RCNode } from '../../core/base';\nimport { formatLabel } from '../../core/utils/label';\nimport { measureTextSize } from '../../core/utils/measure-text';\nimport { getNodeSide } from '../../core/utils/node';\nimport { getBoxedTextNodeStyle, getLinearTextNodeStyle } from '../../core/utils/tree';\nconst {\n  ArrowCountIcon\n} = CollapseExpandIcon;\nconst {\n  TextNode\n} = RCNode;\nexport const DEFAULT_OPTIONS = {\n  node: {\n    type: 'react',\n    state: {\n      active: {\n        halo: false\n      },\n      selected: {\n        halo: false\n      }\n    }\n  },\n  edge: {\n    type: 'indented',\n    style: {\n      lineWidth: 3\n    }\n  },\n  transforms: prev => [...prev, {\n    type: 'collapse-expand-react-node',\n    key: 'collapse-expand-react-node',\n    enable: false,\n    trigger: 'icon',\n    iconRender: function (isCollapsed, data) {\n      return React.createElement(ArrowCountIcon, {\n        graph: this,\n        data: data,\n        isCollapsed: isCollapsed\n      });\n    }\n  }],\n  layout: {\n    type: 'indented',\n    direction: 'LR',\n    indent: node => getIndent(node, 20),\n    getVGap: () => 14,\n    preLayout: false\n  },\n  animation: {\n    duration: 500\n  }\n};\nconst getIndent = (node, preset) => {\n  if (node.depth === 0) return 0;\n  let totalWidth = preset;\n  let currentNode = node.parent;\n  while (currentNode) {\n    totalWidth += currentNode.width / 2;\n    currentNode = currentNode.parent;\n  }\n  return totalWidth / node.depth;\n};\nconst getNodeTextAlign = (graph, data) => {\n  const side = getNodeSide(graph, data);\n  return side === 'left' ? 'right' : side === 'center' ? 'center' : 'left';\n};\nexport const getIndentedTreeOptions = ({\n  type,\n  nodeMinWidth,\n  nodeMaxWidth,\n  direction,\n  labelField\n}) => {\n  let options = {};\n  const minWidth = nodeMinWidth || 0;\n  const maxWidth = nodeMaxWidth || 300;\n  if (type === 'boxed') {\n    options = {\n      node: {\n        style: {\n          component: function (data) {\n            const depth = data.depth;\n            const color = data.style?.color;\n            const label = formatLabel(data, labelField);\n            const {\n              font\n            } = getBoxedTextNodeStyle(label, minWidth, maxWidth, depth);\n            const props = {\n              type: depth === 0 || depth === 1 ? 'filled' : 'outlined',\n              text: label,\n              color: depth === 0 ? '#f1f4f5' : color,\n              maxWidth,\n              font,\n              style: {\n                textAlign: getNodeTextAlign(this, data),\n                ...(depth === 0 ? {\n                  color: '#252525'\n                } : {})\n              }\n            };\n            return React.createElement(TextNode, {\n              ...props\n            });\n          },\n          size: data => {\n            const label = formatLabel(data, labelField);\n            return getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          }\n        }\n      },\n      edge: {\n        style: {\n          stroke: function (data) {\n            const source = this.getNodeData(data.source);\n            return get(source, 'style.color', '#99ADD1');\n          },\n          radius: 16\n        }\n      },\n      transforms: prev => [...prev, {\n        type: 'assign-color-by-branch',\n        key: 'assign-color-by-branch'\n      }],\n      layout: {\n        type: 'indented',\n        getWidth: data => {\n          const label = formatLabel(data, labelField);\n          const [width] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          return width;\n        },\n        getHeight: data => {\n          const label = formatLabel(data, labelField);\n          const [, height] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          return height;\n        }\n      }\n    };\n  } else if (type === 'linear') {\n    options = {\n      node: {\n        style: {\n          component: function (data) {\n            const depth = data.depth;\n            const color = data.style?.color;\n            const label = formatLabel(data, labelField);\n            const {\n              font\n            } = getLinearTextNodeStyle(label, minWidth, maxWidth, depth);\n            const props = {\n              text: label,\n              color,\n              maxWidth,\n              font\n            };\n            Object.assign(props, depth === 0 ? {\n              type: 'filled',\n              color: '#f1f4f5',\n              style: {\n                color: '#252525'\n              }\n            } : {\n              type: 'underlined',\n              style: {\n                textAlign: getNodeTextAlign(this, data)\n              }\n            });\n            return React.createElement(TextNode, {\n              ...props\n            });\n          },\n          size: data => {\n            const label = formatLabel(data, labelField);\n            return getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          },\n          ports: function (data) {\n            const side = getNodeSide(this, data);\n            return side === 'left' ? [{\n              placement: 'bottom'\n            }, {\n              placement: 'bottom-right'\n            }] : side === 'center' ? [{\n              placement: 'bottom'\n            }] : [{\n              placement: 'bottom'\n            }, {\n              placement: 'bottom-left'\n            }];\n          }\n        }\n      },\n      edge: {\n        style: {\n          stroke: function (data) {\n            const target = this.getNodeData(data.target);\n            return get(target, 'style.color', '#99ADD1');\n          },\n          radius: 24\n        }\n      },\n      layout: {\n        type: 'indented',\n        getWidth: data => {\n          const label = formatLabel(data, labelField);\n          const [width] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          return width;\n        },\n        getHeight: data => {\n          const label = formatLabel(data, labelField);\n          const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n          return height;\n        },\n        getVGap: () => 12\n      },\n      transforms: prev => [...prev, {\n        type: 'assign-color-by-branch',\n        key: 'assign-color-by-branch'\n      }, {\n        type: 'arrange-edge-z-index',\n        key: 'arrange-edge-z-index'\n      }]\n    };\n  } else {\n    const PADDING = [24, 16];\n    options = {\n      node: {\n        style: {\n          component: data => {\n            const label = formatLabel(data, labelField);\n            return React.createElement(TextNode, {\n              type: \"filled\",\n              text: label\n            });\n          },\n          size: data => {\n            const label = formatLabel(data, labelField);\n            return measureTextSize(label, PADDING);\n          }\n        }\n      },\n      layout: {\n        type: 'indented',\n        getWidth: data => {\n          const label = formatLabel(data, labelField);\n          const [width] = measureTextSize(label, PADDING);\n          return width;\n        },\n        getHeight: data => {\n          const label = formatLabel(data, labelField);\n          const [, height] = measureTextSize(label, PADDING);\n          return height;\n        }\n      }\n    };\n  }\n  if (direction) {\n    options.layout ||= {};\n    Object.assign(options.layout, {\n      direction: direction === 'alternate' ? 'H' : direction === 'left' ? 'RL' : 'LR'\n    });\n  }\n  return options;\n};","map":{"version":3,"names":["get","React","CollapseExpandIcon","RCNode","formatLabel","measureTextSize","getNodeSide","getBoxedTextNodeStyle","getLinearTextNodeStyle","ArrowCountIcon","TextNode","DEFAULT_OPTIONS","node","type","state","active","halo","selected","edge","style","lineWidth","transforms","prev","key","enable","trigger","iconRender","isCollapsed","data","createElement","graph","layout","direction","indent","getIndent","getVGap","preLayout","animation","duration","preset","depth","totalWidth","currentNode","parent","width","getNodeTextAlign","side","getIndentedTreeOptions","nodeMinWidth","nodeMaxWidth","labelField","options","minWidth","maxWidth","component","color","label","font","props","text","textAlign","size","stroke","source","getNodeData","radius","getWidth","getHeight","height","Object","assign","ports","placement","target","PADDING"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@ant-design/graphs/es/components/indented-tree/options.js"],"sourcesContent":["import { get } from 'lodash';\nimport React from 'react';\nimport { CollapseExpandIcon, RCNode } from '../../core/base';\nimport { formatLabel } from '../../core/utils/label';\nimport { measureTextSize } from '../../core/utils/measure-text';\nimport { getNodeSide } from '../../core/utils/node';\nimport { getBoxedTextNodeStyle, getLinearTextNodeStyle } from '../../core/utils/tree';\nconst { ArrowCountIcon } = CollapseExpandIcon;\nconst { TextNode } = RCNode;\nexport const DEFAULT_OPTIONS = {\n    node: {\n        type: 'react',\n        state: {\n            active: {\n                halo: false,\n            },\n            selected: {\n                halo: false,\n            },\n        },\n    },\n    edge: {\n        type: 'indented',\n        style: {\n            lineWidth: 3,\n        },\n    },\n    transforms: (prev) => [\n        ...prev,\n        {\n            type: 'collapse-expand-react-node',\n            key: 'collapse-expand-react-node',\n            enable: false,\n            trigger: 'icon',\n            iconRender: function (isCollapsed, data) {\n                return React.createElement(ArrowCountIcon, { graph: this, data: data, isCollapsed: isCollapsed });\n            },\n        },\n    ],\n    layout: {\n        type: 'indented',\n        direction: 'LR',\n        indent: (node) => getIndent(node, 20),\n        getVGap: () => 14,\n        preLayout: false,\n    },\n    animation: {\n        duration: 500,\n    },\n};\nconst getIndent = (node, preset) => {\n    if (node.depth === 0)\n        return 0;\n    let totalWidth = preset;\n    let currentNode = node.parent;\n    while (currentNode) {\n        totalWidth += currentNode.width / 2;\n        currentNode = currentNode.parent;\n    }\n    return totalWidth / node.depth;\n};\nconst getNodeTextAlign = (graph, data) => {\n    const side = getNodeSide(graph, data);\n    return side === 'left' ? 'right' : side === 'center' ? 'center' : 'left';\n};\nexport const getIndentedTreeOptions = ({ type, nodeMinWidth, nodeMaxWidth, direction, labelField, }) => {\n    let options = {};\n    const minWidth = nodeMinWidth || 0;\n    const maxWidth = nodeMaxWidth || 300;\n    if (type === 'boxed') {\n        options = {\n            node: {\n                style: {\n                    component: function (data) {\n                        const depth = data.depth;\n                        const color = data.style?.color;\n                        const label = formatLabel(data, labelField);\n                        const { font } = getBoxedTextNodeStyle(label, minWidth, maxWidth, depth);\n                        const props = {\n                            type: depth === 0 || depth === 1 ? 'filled' : 'outlined',\n                            text: label,\n                            color: depth === 0 ? '#f1f4f5' : color,\n                            maxWidth,\n                            font,\n                            style: {\n                                textAlign: getNodeTextAlign(this, data),\n                                ...(depth === 0 ? { color: '#252525' } : {}),\n                            },\n                        };\n                        return React.createElement(TextNode, { ...props });\n                    },\n                    size: (data) => {\n                        const label = formatLabel(data, labelField);\n                        return getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    },\n                },\n            },\n            edge: {\n                style: {\n                    stroke: function (data) {\n                        const source = this.getNodeData(data.source);\n                        return get(source, 'style.color', '#99ADD1');\n                    },\n                    radius: 16,\n                },\n            },\n            transforms: (prev) => [\n                ...prev,\n                {\n                    type: 'assign-color-by-branch',\n                    key: 'assign-color-by-branch',\n                },\n            ],\n            layout: {\n                type: 'indented',\n                getWidth: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [width] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    return width;\n                },\n                getHeight: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [, height] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    return height;\n                },\n            },\n        };\n    }\n    else if (type === 'linear') {\n        options = {\n            node: {\n                style: {\n                    component: function (data) {\n                        const depth = data.depth;\n                        const color = data.style?.color;\n                        const label = formatLabel(data, labelField);\n                        const { font } = getLinearTextNodeStyle(label, minWidth, maxWidth, depth);\n                        const props = { text: label, color, maxWidth, font };\n                        Object.assign(props, depth === 0\n                            ? { type: 'filled', color: '#f1f4f5', style: { color: '#252525' } }\n                            : {\n                                type: 'underlined',\n                                style: { textAlign: getNodeTextAlign(this, data) },\n                            });\n                        return React.createElement(TextNode, { ...props });\n                    },\n                    size: (data) => {\n                        const label = formatLabel(data, labelField);\n                        return getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    },\n                    ports: function (data) {\n                        const side = getNodeSide(this, data);\n                        return side === 'left'\n                            ? [{ placement: 'bottom' }, { placement: 'bottom-right' }]\n                            : side === 'center'\n                                ? [{ placement: 'bottom' }]\n                                : [{ placement: 'bottom' }, { placement: 'bottom-left' }];\n                    },\n                },\n            },\n            edge: {\n                style: {\n                    stroke: function (data) {\n                        const target = this.getNodeData(data.target);\n                        return get(target, 'style.color', '#99ADD1');\n                    },\n                    radius: 24,\n                },\n            },\n            layout: {\n                type: 'indented',\n                getWidth: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [width] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    return width;\n                },\n                getHeight: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;\n                    return height;\n                },\n                getVGap: () => 12,\n            },\n            transforms: (prev) => [\n                ...prev,\n                {\n                    type: 'assign-color-by-branch',\n                    key: 'assign-color-by-branch',\n                },\n                {\n                    type: 'arrange-edge-z-index',\n                    key: 'arrange-edge-z-index',\n                },\n            ],\n        };\n    }\n    else {\n        const PADDING = [24, 16];\n        options = {\n            node: {\n                style: {\n                    component: (data) => {\n                        const label = formatLabel(data, labelField);\n                        return React.createElement(TextNode, { type: \"filled\", text: label });\n                    },\n                    size: (data) => {\n                        const label = formatLabel(data, labelField);\n                        return measureTextSize(label, PADDING);\n                    },\n                },\n            },\n            layout: {\n                type: 'indented',\n                getWidth: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [width] = measureTextSize(label, PADDING);\n                    return width;\n                },\n                getHeight: (data) => {\n                    const label = formatLabel(data, labelField);\n                    const [, height] = measureTextSize(label, PADDING);\n                    return height;\n                },\n            },\n        };\n    }\n    if (direction) {\n        options.layout ||= {};\n        Object.assign(options.layout, {\n            direction: direction === 'alternate' ? 'H' : direction === 'left' ? 'RL' : 'LR',\n        });\n    }\n    return options;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}