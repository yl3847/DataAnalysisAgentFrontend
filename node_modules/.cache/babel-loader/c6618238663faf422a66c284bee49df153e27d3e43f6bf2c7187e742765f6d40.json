{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isNumber } from '@antv/util';\nimport { getContainerSize } from '../utils/size';\nimport { deepAssign } from '../utils/helper';\nimport { Node } from './node';\n// Keys can specified by new Chart({...}).\n// Keys can bubble form mark-level options to view-level options.\nexport const VIEW_KEYS = ['width', 'height', 'depth', 'padding', 'paddingLeft', 'paddingRight', 'paddingBottom', 'paddingTop', 'inset', 'insetLeft', 'insetRight', 'insetTop', 'insetBottom', 'margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'autoFit', 'theme', 'title', 'interaction'];\nexport const REMOVE_FLAG = '__remove__';\nexport const CALLBACK_NODE = '__callback__';\n/** Minimum chart width */\nexport const MIN_CHART_WIDTH = 1;\n/** Minimum chart height */\nexport const MIN_CHART_HEIGHT = 1;\nexport function normalizeContainer(container) {\n  if (container === undefined) {\n    const container = document.createElement('div');\n    container[REMOVE_FLAG] = true;\n    return container;\n  }\n  if (typeof container === 'string') {\n    const node = document.getElementById(container);\n    return node;\n  }\n  return container;\n}\nexport function removeContainer(container) {\n  const parent = container.parentNode;\n  if (parent) {\n    parent.removeChild(container);\n  }\n}\nexport function normalizeRoot(node) {\n  if (node.type !== null) return node;\n  const root = node.children[node.children.length - 1];\n  for (const key of VIEW_KEYS) root.attr(key, node.attr(key));\n  return root;\n}\nexport function valueOf(node) {\n  return Object.assign(Object.assign({}, node.value), {\n    type: node.type\n  });\n}\nexport function sizeOf(options, container) {\n  const {\n    width,\n    height,\n    autoFit,\n    depth = 0\n  } = options;\n  let effectiveWidth = 640;\n  let effectiveHeight = 480;\n  if (autoFit) {\n    const {\n      width: containerWidth,\n      height: containerHeight\n    } = getContainerSize(container);\n    effectiveWidth = containerWidth || effectiveWidth;\n    effectiveHeight = containerHeight || effectiveHeight;\n  }\n  effectiveWidth = width || effectiveWidth;\n  effectiveHeight = height || effectiveHeight;\n  return {\n    width: Math.max(isNumber(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),\n    height: Math.max(isNumber(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),\n    depth\n  };\n}\nexport function optionsOf(node) {\n  const root = normalizeRoot(node);\n  const discovered = [root];\n  const nodeValue = new Map();\n  nodeValue.set(root, valueOf(root));\n  while (discovered.length) {\n    const node = discovered.pop();\n    const value = nodeValue.get(node);\n    const {\n      children = []\n    } = node;\n    for (const child of children) {\n      if (child.type === CALLBACK_NODE) {\n        value.children = child.value;\n      } else {\n        const childValue = valueOf(child);\n        const {\n          children = []\n        } = value;\n        children.push(childValue);\n        discovered.push(child);\n        nodeValue.set(child, childValue);\n        value.children = children;\n      }\n    }\n  }\n  return nodeValue.get(root);\n}\nfunction isMark(type, mark) {\n  if (typeof type === 'function') return true;\n  return new Set(Object.keys(mark)).has(type);\n}\nfunction isComposition(type, composition) {\n  return typeof type !== 'function' && new Set(Object.keys(composition)).has(type);\n}\nfunction normalizeRootOptions(node, options, previousType, marks, composition) {\n  const {\n    type: oldType\n  } = node;\n  const {\n    type = previousType || oldType\n  } = options;\n  if (isComposition(type, composition)) {\n    for (const key of VIEW_KEYS) {\n      if (node.attr(key) !== undefined && options[key] === undefined) {\n        options[key] = node.attr(key);\n      }\n    }\n    return options;\n  }\n  if (isMark(type, marks)) {\n    const view = {\n      type: 'view'\n    };\n    const mark = Object.assign({}, options);\n    for (const key of VIEW_KEYS) {\n      if (mark[key] !== undefined) {\n        view[key] = mark[key];\n        delete mark[key];\n      }\n    }\n    return Object.assign(Object.assign({}, view), {\n      children: [mark]\n    });\n  }\n  return options;\n}\nfunction typeCtor(type, mark, composition) {\n  if (typeof type === 'function') return mark.mark;\n  const node = Object.assign(Object.assign({}, mark), composition);\n  const ctor = node[type];\n  if (!ctor) throw new Error(`Unknown mark: ${type}.`);\n  return ctor;\n}\n// Create node from options.\nfunction createNode(options, mark, composition) {\n  if (typeof options === 'function') {\n    const node = new Node();\n    node.value = options;\n    node.type = CALLBACK_NODE;\n    return node;\n  }\n  const {\n      type,\n      children\n    } = options,\n    value = __rest(options, [\"type\", \"children\"]);\n  const Ctor = typeCtor(type, mark, composition);\n  const node = new Ctor();\n  node.value = value;\n  // @ts-ignore\n  node.type = type;\n  return node;\n}\n// Update node by options.\nfunction updateNode(node, newOptions) {\n  const {\n      type,\n      children\n    } = newOptions,\n    value = __rest(newOptions, [\"type\", \"children\"]);\n  if (node.type === type || type === undefined) {\n    // Update node.\n    deepAssign(node.value, value);\n  } else if (typeof type === 'string') {\n    // Transform node.\n    node.type = type;\n    node.value = value;\n  }\n}\n// Create a nested node tree from newOptions, and append it to the parent.\nfunction appendNode(parent, newOptions, mark, composition) {\n  if (!parent) return;\n  const discovered = [[parent, newOptions]];\n  while (discovered.length) {\n    const [parent, nodeOptions] = discovered.shift();\n    const node = createNode(nodeOptions, mark, composition);\n    if (Array.isArray(parent.children)) parent.push(node);\n    const {\n      children\n    } = nodeOptions;\n    if (Array.isArray(children)) {\n      for (const child of children) {\n        discovered.push([node, child]);\n      }\n    } else if (typeof children === 'function') {\n      discovered.push([node, children]);\n    }\n  }\n}\n// Update node tree from options.\nexport function updateRoot(node, options, definedType, mark, composition) {\n  const rootOptions = normalizeRootOptions(node, options, definedType, mark, composition);\n  const discovered = [[null, node, rootOptions]];\n  while (discovered.length) {\n    const [parent, oldNode, newNode] = discovered.shift();\n    // If there is no oldNode, create a node tree directly.\n    if (!oldNode) {\n      appendNode(parent, newNode, mark, composition);\n    } else if (!newNode) {\n      oldNode.remove();\n    } else {\n      updateNode(oldNode, newNode);\n      const {\n        children: newChildren\n      } = newNode;\n      const {\n        children: oldChildren\n      } = oldNode;\n      if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {\n        // Only update node specified in newChildren,\n        // the extra oldChildren will remain still.\n        const n = Math.max(newChildren.length, oldChildren.length);\n        for (let i = 0; i < n; i++) {\n          const newChild = newChildren[i];\n          const oldChild = oldChildren[i];\n          discovered.push([oldNode, oldChild, newChild]);\n        }\n      } else if (typeof newChildren === 'function') {\n        discovered.push([oldNode, null, newChildren]);\n      }\n    }\n  }\n}\nexport function createEmptyPromise() {\n  let reject;\n  let resolve;\n  const cloned = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [cloned, resolve, reject];\n}","map":{"version":3,"names":["isNumber","getContainerSize","deepAssign","Node","VIEW_KEYS","REMOVE_FLAG","CALLBACK_NODE","MIN_CHART_WIDTH","MIN_CHART_HEIGHT","normalizeContainer","container","undefined","document","createElement","node","getElementById","removeContainer","parent","parentNode","removeChild","normalizeRoot","type","root","children","length","key","attr","valueOf","Object","assign","value","sizeOf","options","width","height","autoFit","depth","effectiveWidth","effectiveHeight","containerWidth","containerHeight","Math","max","optionsOf","discovered","nodeValue","Map","set","pop","get","child","childValue","push","isMark","mark","Set","keys","has","isComposition","composition","normalizeRootOptions","previousType","marks","oldType","view","typeCtor","ctor","Error","createNode","__rest","Ctor","updateNode","newOptions","appendNode","nodeOptions","shift","Array","isArray","updateRoot","definedType","rootOptions","oldNode","newNode","remove","newChildren","oldChildren","n","i","newChild","oldChild","createEmptyPromise","reject","resolve","cloned","Promise","res","rej"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/api/utils.ts"],"sourcesContent":["import { isNumber } from '@antv/util';\nimport { G2ViewTree } from '../runtime';\nimport { getContainerSize } from '../utils/size';\nimport { deepAssign } from '../utils/helper';\nimport { Node } from './node';\n\n// Keys can specified by new Chart({...}).\n// Keys can bubble form mark-level options to view-level options.\nexport const VIEW_KEYS = [\n  'width',\n  'height',\n  'depth',\n  'padding',\n  'paddingLeft',\n  'paddingRight',\n  'paddingBottom',\n  'paddingTop',\n  'inset',\n  'insetLeft',\n  'insetRight',\n  'insetTop',\n  'insetBottom',\n  'margin',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'marginBottom',\n  'autoFit',\n  'theme',\n  'title',\n  'interaction',\n];\n\nexport const REMOVE_FLAG = '__remove__';\n\nexport const CALLBACK_NODE = '__callback__';\n\n/** Minimum chart width */\nexport const MIN_CHART_WIDTH = 1;\n/** Minimum chart height */\nexport const MIN_CHART_HEIGHT = 1;\n\nexport function normalizeContainer(\n  container: string | HTMLElement,\n): HTMLElement {\n  if (container === undefined) {\n    const container = document.createElement('div');\n    container[REMOVE_FLAG] = true;\n    return container;\n  }\n  if (typeof container === 'string') {\n    const node = document.getElementById(container);\n    return node;\n  }\n  return container;\n}\n\nexport function removeContainer(container: HTMLElement) {\n  const parent = container.parentNode;\n  if (parent) {\n    parent.removeChild(container);\n  }\n}\n\nexport function normalizeRoot(node: Node) {\n  if (node.type !== null) return node;\n  const root = node.children[node.children.length - 1];\n  for (const key of VIEW_KEYS) root.attr(key, node.attr(key));\n  return root;\n}\n\nexport function valueOf(node: Node): Record<string, any> {\n  return {\n    ...node.value,\n    type: node.type,\n  };\n}\n\nexport function sizeOf(options, container) {\n  const { width, height, autoFit, depth = 0 } = options;\n  let effectiveWidth = 640;\n  let effectiveHeight = 480;\n\n  if (autoFit) {\n    const { width: containerWidth, height: containerHeight } =\n      getContainerSize(container);\n    effectiveWidth = containerWidth || effectiveWidth;\n    effectiveHeight = containerHeight || effectiveHeight;\n  }\n\n  effectiveWidth = width || effectiveWidth;\n  effectiveHeight = height || effectiveHeight;\n\n  return {\n    width: Math.max(\n      isNumber(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH,\n      MIN_CHART_WIDTH,\n    ),\n    height: Math.max(\n      isNumber(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT,\n      MIN_CHART_HEIGHT,\n    ),\n    depth,\n  };\n}\n\nexport function optionsOf(node: Node): Record<string, any> {\n  const root = normalizeRoot(node);\n  const discovered: Node[] = [root];\n  const nodeValue = new Map<Node, Record<string, any>>();\n  nodeValue.set(root, valueOf(root));\n  while (discovered.length) {\n    const node = discovered.pop();\n    const value = nodeValue.get(node);\n    const { children = [] } = node;\n    for (const child of children) {\n      if (child.type === CALLBACK_NODE) {\n        value.children = child.value;\n      } else {\n        const childValue = valueOf(child);\n        const { children = [] } = value;\n        children.push(childValue);\n        discovered.push(child);\n        nodeValue.set(child, childValue);\n        value.children = children;\n      }\n    }\n  }\n  return nodeValue.get(root);\n}\n\nfunction isMark(\n  type: string | ((...args: any[]) => any),\n  mark: Record<string, new () => Node>,\n): boolean {\n  if (typeof type === 'function') return true;\n  return new Set(Object.keys(mark)).has(type);\n}\n\nfunction isComposition(\n  type: string | ((...args: any[]) => any),\n  composition: Record<string, new () => Node>,\n): boolean {\n  return (\n    typeof type !== 'function' && new Set(Object.keys(composition)).has(type)\n  );\n}\n\nfunction normalizeRootOptions(\n  node: Node,\n  options: G2ViewTree,\n  previousType: string,\n  marks: Record<string, new () => Node>,\n  composition: Record<string, new () => Node>,\n) {\n  const { type: oldType } = node;\n  const { type = previousType || oldType } = options;\n  if (isComposition(type, composition)) {\n    for (const key of VIEW_KEYS) {\n      if (node.attr(key) !== undefined && options[key] === undefined) {\n        options[key] = node.attr(key);\n      }\n    }\n    return options;\n  }\n  if (isMark(type, marks)) {\n    const view = { type: 'view' };\n    const mark = { ...options };\n    for (const key of VIEW_KEYS) {\n      if (mark[key] !== undefined) {\n        view[key] = mark[key];\n        delete mark[key];\n      }\n    }\n    return { ...view, children: [mark] };\n  }\n  return options;\n}\n\nfunction typeCtor(\n  type: string | ((...args: any[]) => any),\n  mark: Record<string, new () => Node>,\n  composition: Record<string, new () => Node>,\n): new () => Node {\n  if (typeof type === 'function') return mark.mark;\n  const node = { ...mark, ...composition };\n  const ctor = node[type];\n  if (!ctor) throw new Error(`Unknown mark: ${type}.`);\n  return ctor;\n}\n\n// Create node from options.\nfunction createNode(\n  options: G2ViewTree,\n  mark: Record<string, new () => Node>,\n  composition: Record<string, new () => Node>,\n): Node {\n  if (typeof options === 'function') {\n    const node = new Node();\n    node.value = options;\n    node.type = CALLBACK_NODE;\n    return node;\n  }\n  const { type, children, ...value } = options;\n  const Ctor = typeCtor(type, mark, composition);\n  const node = new Ctor();\n  node.value = value;\n  // @ts-ignore\n  node.type = type;\n  return node;\n}\n\n// Update node by options.\nfunction updateNode(node: Node, newOptions: G2ViewTree) {\n  const { type, children, ...value } = newOptions;\n  if (node.type === type || type === undefined) {\n    // Update node.\n    deepAssign(node.value, value);\n  } else if (typeof type === 'string') {\n    // Transform node.\n    node.type = type;\n    node.value = value;\n  }\n}\n\n// Create a nested node tree from newOptions, and append it to the parent.\nfunction appendNode(\n  parent: Node,\n  newOptions: G2ViewTree,\n  mark: Record<string, new () => Node>,\n  composition: Record<string, new () => Node>,\n) {\n  if (!parent) return;\n  const discovered = [[parent, newOptions]];\n  while (discovered.length) {\n    const [parent, nodeOptions] = discovered.shift();\n    const node = createNode(nodeOptions, mark, composition);\n    if (Array.isArray(parent.children)) parent.push(node);\n    const { children } = nodeOptions;\n    if (Array.isArray(children)) {\n      for (const child of children) {\n        discovered.push([node, child]);\n      }\n    } else if (typeof children === 'function') {\n      discovered.push([node, children]);\n    }\n  }\n}\n\n// Update node tree from options.\nexport function updateRoot(\n  node: Node,\n  options: G2ViewTree,\n  definedType: string,\n  mark: Record<string, new () => Node>,\n  composition: Record<string, new () => Node>,\n) {\n  const rootOptions = normalizeRootOptions(\n    node,\n    options,\n    definedType,\n    mark,\n    composition,\n  );\n  const discovered: [Node, Node, G2ViewTree][] = [[null, node, rootOptions]];\n  while (discovered.length) {\n    const [parent, oldNode, newNode] = discovered.shift();\n    // If there is no oldNode, create a node tree directly.\n    if (!oldNode) {\n      appendNode(parent, newNode, mark, composition);\n    } else if (!newNode) {\n      oldNode.remove();\n    } else {\n      updateNode(oldNode, newNode);\n      const { children: newChildren } = newNode;\n      const { children: oldChildren } = oldNode;\n      if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {\n        // Only update node specified in newChildren,\n        // the extra oldChildren will remain still.\n        const n = Math.max(newChildren.length, oldChildren.length);\n        for (let i = 0; i < n; i++) {\n          const newChild = newChildren[i];\n          const oldChild = oldChildren[i];\n          discovered.push([oldNode, oldChild, newChild]);\n        }\n      } else if (typeof newChildren === 'function') {\n        discovered.push([oldNode, null, newChildren]);\n      }\n    }\n  }\n}\n\nexport function createEmptyPromise<T>(): [\n  Promise<T>,\n  (reason?: any) => void,\n  (value: T | PromiseLike<T>) => void,\n] {\n  let reject: (reason?: any) => void;\n  let resolve: (value: T | PromiseLike<T>) => void;\n  const cloned = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [cloned, resolve, reject];\n}\n"],"mappings":";;;;;;;;AAAA,SAASA,QAAQ,QAAQ,YAAY;AAErC,SAASC,gBAAgB,QAAQ,eAAe;AAChD,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,IAAI,QAAQ,QAAQ;AAE7B;AACA;AACA,OAAO,MAAMC,SAAS,GAAG,CACvB,OAAO,EACP,QAAQ,EACR,OAAO,EACP,SAAS,EACT,aAAa,EACb,cAAc,EACd,eAAe,EACf,YAAY,EACZ,OAAO,EACP,WAAW,EACX,YAAY,EACZ,UAAU,EACV,aAAa,EACb,QAAQ,EACR,YAAY,EACZ,aAAa,EACb,WAAW,EACX,cAAc,EACd,SAAS,EACT,OAAO,EACP,OAAO,EACP,aAAa,CACd;AAED,OAAO,MAAMC,WAAW,GAAG,YAAY;AAEvC,OAAO,MAAMC,aAAa,GAAG,cAAc;AAE3C;AACA,OAAO,MAAMC,eAAe,GAAG,CAAC;AAChC;AACA,OAAO,MAAMC,gBAAgB,GAAG,CAAC;AAEjC,OAAM,SAAUC,kBAAkBA,CAChCC,SAA+B;EAE/B,IAAIA,SAAS,KAAKC,SAAS,EAAE;IAC3B,MAAMD,SAAS,GAAGE,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAC/CH,SAAS,CAACL,WAAW,CAAC,GAAG,IAAI;IAC7B,OAAOK,SAAS;;EAElB,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;IACjC,MAAMI,IAAI,GAAGF,QAAQ,CAACG,cAAc,CAACL,SAAS,CAAC;IAC/C,OAAOI,IAAI;;EAEb,OAAOJ,SAAS;AAClB;AAEA,OAAM,SAAUM,eAAeA,CAACN,SAAsB;EACpD,MAAMO,MAAM,GAAGP,SAAS,CAACQ,UAAU;EACnC,IAAID,MAAM,EAAE;IACVA,MAAM,CAACE,WAAW,CAACT,SAAS,CAAC;;AAEjC;AAEA,OAAM,SAAUU,aAAaA,CAACN,IAAU;EACtC,IAAIA,IAAI,CAACO,IAAI,KAAK,IAAI,EAAE,OAAOP,IAAI;EACnC,MAAMQ,IAAI,GAAGR,IAAI,CAACS,QAAQ,CAACT,IAAI,CAACS,QAAQ,CAACC,MAAM,GAAG,CAAC,CAAC;EACpD,KAAK,MAAMC,GAAG,IAAIrB,SAAS,EAAEkB,IAAI,CAACI,IAAI,CAACD,GAAG,EAAEX,IAAI,CAACY,IAAI,CAACD,GAAG,CAAC,CAAC;EAC3D,OAAOH,IAAI;AACb;AAEA,OAAM,SAAUK,OAAOA,CAACb,IAAU;EAChC,OAAAc,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKf,IAAI,CAACgB,KAAK;IACbT,IAAI,EAAEP,IAAI,CAACO;EAAI;AAEnB;AAEA,OAAM,SAAUU,MAAMA,CAACC,OAAO,EAAEtB,SAAS;EACvC,MAAM;IAAEuB,KAAK;IAAEC,MAAM;IAAEC,OAAO;IAAEC,KAAK,GAAG;EAAC,CAAE,GAAGJ,OAAO;EACrD,IAAIK,cAAc,GAAG,GAAG;EACxB,IAAIC,eAAe,GAAG,GAAG;EAEzB,IAAIH,OAAO,EAAE;IACX,MAAM;MAAEF,KAAK,EAAEM,cAAc;MAAEL,MAAM,EAAEM;IAAe,CAAE,GACtDvC,gBAAgB,CAACS,SAAS,CAAC;IAC7B2B,cAAc,GAAGE,cAAc,IAAIF,cAAc;IACjDC,eAAe,GAAGE,eAAe,IAAIF,eAAe;;EAGtDD,cAAc,GAAGJ,KAAK,IAAII,cAAc;EACxCC,eAAe,GAAGJ,MAAM,IAAII,eAAe;EAE3C,OAAO;IACLL,KAAK,EAAEQ,IAAI,CAACC,GAAG,CACb1C,QAAQ,CAACqC,cAAc,CAAC,GAAGA,cAAc,GAAG9B,eAAe,EAC3DA,eAAe,CAChB;IACD2B,MAAM,EAAEO,IAAI,CAACC,GAAG,CACd1C,QAAQ,CAACsC,eAAe,CAAC,GAAGA,eAAe,GAAG9B,gBAAgB,EAC9DA,gBAAgB,CACjB;IACD4B;GACD;AACH;AAEA,OAAM,SAAUO,SAASA,CAAC7B,IAAU;EAClC,MAAMQ,IAAI,GAAGF,aAAa,CAACN,IAAI,CAAC;EAChC,MAAM8B,UAAU,GAAW,CAACtB,IAAI,CAAC;EACjC,MAAMuB,SAAS,GAAG,IAAIC,GAAG,EAA6B;EACtDD,SAAS,CAACE,GAAG,CAACzB,IAAI,EAAEK,OAAO,CAACL,IAAI,CAAC,CAAC;EAClC,OAAOsB,UAAU,CAACpB,MAAM,EAAE;IACxB,MAAMV,IAAI,GAAG8B,UAAU,CAACI,GAAG,EAAE;IAC7B,MAAMlB,KAAK,GAAGe,SAAS,CAACI,GAAG,CAACnC,IAAI,CAAC;IACjC,MAAM;MAAES,QAAQ,GAAG;IAAE,CAAE,GAAGT,IAAI;IAC9B,KAAK,MAAMoC,KAAK,IAAI3B,QAAQ,EAAE;MAC5B,IAAI2B,KAAK,CAAC7B,IAAI,KAAKf,aAAa,EAAE;QAChCwB,KAAK,CAACP,QAAQ,GAAG2B,KAAK,CAACpB,KAAK;OAC7B,MAAM;QACL,MAAMqB,UAAU,GAAGxB,OAAO,CAACuB,KAAK,CAAC;QACjC,MAAM;UAAE3B,QAAQ,GAAG;QAAE,CAAE,GAAGO,KAAK;QAC/BP,QAAQ,CAAC6B,IAAI,CAACD,UAAU,CAAC;QACzBP,UAAU,CAACQ,IAAI,CAACF,KAAK,CAAC;QACtBL,SAAS,CAACE,GAAG,CAACG,KAAK,EAAEC,UAAU,CAAC;QAChCrB,KAAK,CAACP,QAAQ,GAAGA,QAAQ;;;;EAI/B,OAAOsB,SAAS,CAACI,GAAG,CAAC3B,IAAI,CAAC;AAC5B;AAEA,SAAS+B,MAAMA,CACbhC,IAAwC,EACxCiC,IAAoC;EAEpC,IAAI,OAAOjC,IAAI,KAAK,UAAU,EAAE,OAAO,IAAI;EAC3C,OAAO,IAAIkC,GAAG,CAAC3B,MAAM,CAAC4B,IAAI,CAACF,IAAI,CAAC,CAAC,CAACG,GAAG,CAACpC,IAAI,CAAC;AAC7C;AAEA,SAASqC,aAAaA,CACpBrC,IAAwC,EACxCsC,WAA2C;EAE3C,OACE,OAAOtC,IAAI,KAAK,UAAU,IAAI,IAAIkC,GAAG,CAAC3B,MAAM,CAAC4B,IAAI,CAACG,WAAW,CAAC,CAAC,CAACF,GAAG,CAACpC,IAAI,CAAC;AAE7E;AAEA,SAASuC,oBAAoBA,CAC3B9C,IAAU,EACVkB,OAAmB,EACnB6B,YAAoB,EACpBC,KAAqC,EACrCH,WAA2C;EAE3C,MAAM;IAAEtC,IAAI,EAAE0C;EAAO,CAAE,GAAGjD,IAAI;EAC9B,MAAM;IAAEO,IAAI,GAAGwC,YAAY,IAAIE;EAAO,CAAE,GAAG/B,OAAO;EAClD,IAAI0B,aAAa,CAACrC,IAAI,EAAEsC,WAAW,CAAC,EAAE;IACpC,KAAK,MAAMlC,GAAG,IAAIrB,SAAS,EAAE;MAC3B,IAAIU,IAAI,CAACY,IAAI,CAACD,GAAG,CAAC,KAAKd,SAAS,IAAIqB,OAAO,CAACP,GAAG,CAAC,KAAKd,SAAS,EAAE;QAC9DqB,OAAO,CAACP,GAAG,CAAC,GAAGX,IAAI,CAACY,IAAI,CAACD,GAAG,CAAC;;;IAGjC,OAAOO,OAAO;;EAEhB,IAAIqB,MAAM,CAAChC,IAAI,EAAEyC,KAAK,CAAC,EAAE;IACvB,MAAME,IAAI,GAAG;MAAE3C,IAAI,EAAE;IAAM,CAAE;IAC7B,MAAMiC,IAAI,GAAA1B,MAAA,CAAAC,MAAA,KAAQG,OAAO,CAAE;IAC3B,KAAK,MAAMP,GAAG,IAAIrB,SAAS,EAAE;MAC3B,IAAIkD,IAAI,CAAC7B,GAAG,CAAC,KAAKd,SAAS,EAAE;QAC3BqD,IAAI,CAACvC,GAAG,CAAC,GAAG6B,IAAI,CAAC7B,GAAG,CAAC;QACrB,OAAO6B,IAAI,CAAC7B,GAAG,CAAC;;;IAGpB,OAAAG,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAYmC,IAAI;MAAEzC,QAAQ,EAAE,CAAC+B,IAAI;IAAC;;EAEpC,OAAOtB,OAAO;AAChB;AAEA,SAASiC,QAAQA,CACf5C,IAAwC,EACxCiC,IAAoC,EACpCK,WAA2C;EAE3C,IAAI,OAAOtC,IAAI,KAAK,UAAU,EAAE,OAAOiC,IAAI,CAACA,IAAI;EAChD,MAAMxC,IAAI,GAAAc,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAQyB,IAAI,GAAKK,WAAW,CAAE;EACxC,MAAMO,IAAI,GAAGpD,IAAI,CAACO,IAAI,CAAC;EACvB,IAAI,CAAC6C,IAAI,EAAE,MAAM,IAAIC,KAAK,CAAC,iBAAiB9C,IAAI,GAAG,CAAC;EACpD,OAAO6C,IAAI;AACb;AAEA;AACA,SAASE,UAAUA,CACjBpC,OAAmB,EACnBsB,IAAoC,EACpCK,WAA2C;EAE3C,IAAI,OAAO3B,OAAO,KAAK,UAAU,EAAE;IACjC,MAAMlB,IAAI,GAAG,IAAIX,IAAI,EAAE;IACvBW,IAAI,CAACgB,KAAK,GAAGE,OAAO;IACpBlB,IAAI,CAACO,IAAI,GAAGf,aAAa;IACzB,OAAOQ,IAAI;;EAEb,MAAM;MAAEO,IAAI;MAAEE;IAAQ,IAAeS,OAAO;IAAjBF,KAAK,GAAAuC,MAAA,CAAKrC,OAAO,EAAtC,oBAA4B,CAAU;EAC5C,MAAMsC,IAAI,GAAGL,QAAQ,CAAC5C,IAAI,EAAEiC,IAAI,EAAEK,WAAW,CAAC;EAC9C,MAAM7C,IAAI,GAAG,IAAIwD,IAAI,EAAE;EACvBxD,IAAI,CAACgB,KAAK,GAAGA,KAAK;EAClB;EACAhB,IAAI,CAACO,IAAI,GAAGA,IAAI;EAChB,OAAOP,IAAI;AACb;AAEA;AACA,SAASyD,UAAUA,CAACzD,IAAU,EAAE0D,UAAsB;EACpD,MAAM;MAAEnD,IAAI;MAAEE;IAAQ,IAAeiD,UAAU;IAApB1C,KAAK,GAAAuC,MAAA,CAAKG,UAAU,EAAzC,oBAA4B,CAAa;EAC/C,IAAI1D,IAAI,CAACO,IAAI,KAAKA,IAAI,IAAIA,IAAI,KAAKV,SAAS,EAAE;IAC5C;IACAT,UAAU,CAACY,IAAI,CAACgB,KAAK,EAAEA,KAAK,CAAC;GAC9B,MAAM,IAAI,OAAOT,IAAI,KAAK,QAAQ,EAAE;IACnC;IACAP,IAAI,CAACO,IAAI,GAAGA,IAAI;IAChBP,IAAI,CAACgB,KAAK,GAAGA,KAAK;;AAEtB;AAEA;AACA,SAAS2C,UAAUA,CACjBxD,MAAY,EACZuD,UAAsB,EACtBlB,IAAoC,EACpCK,WAA2C;EAE3C,IAAI,CAAC1C,MAAM,EAAE;EACb,MAAM2B,UAAU,GAAG,CAAC,CAAC3B,MAAM,EAAEuD,UAAU,CAAC,CAAC;EACzC,OAAO5B,UAAU,CAACpB,MAAM,EAAE;IACxB,MAAM,CAACP,MAAM,EAAEyD,WAAW,CAAC,GAAG9B,UAAU,CAAC+B,KAAK,EAAE;IAChD,MAAM7D,IAAI,GAAGsD,UAAU,CAACM,WAAW,EAAEpB,IAAI,EAAEK,WAAW,CAAC;IACvD,IAAIiB,KAAK,CAACC,OAAO,CAAC5D,MAAM,CAACM,QAAQ,CAAC,EAAEN,MAAM,CAACmC,IAAI,CAACtC,IAAI,CAAC;IACrD,MAAM;MAAES;IAAQ,CAAE,GAAGmD,WAAW;IAChC,IAAIE,KAAK,CAACC,OAAO,CAACtD,QAAQ,CAAC,EAAE;MAC3B,KAAK,MAAM2B,KAAK,IAAI3B,QAAQ,EAAE;QAC5BqB,UAAU,CAACQ,IAAI,CAAC,CAACtC,IAAI,EAAEoC,KAAK,CAAC,CAAC;;KAEjC,MAAM,IAAI,OAAO3B,QAAQ,KAAK,UAAU,EAAE;MACzCqB,UAAU,CAACQ,IAAI,CAAC,CAACtC,IAAI,EAAES,QAAQ,CAAC,CAAC;;;AAGvC;AAEA;AACA,OAAM,SAAUuD,UAAUA,CACxBhE,IAAU,EACVkB,OAAmB,EACnB+C,WAAmB,EACnBzB,IAAoC,EACpCK,WAA2C;EAE3C,MAAMqB,WAAW,GAAGpB,oBAAoB,CACtC9C,IAAI,EACJkB,OAAO,EACP+C,WAAW,EACXzB,IAAI,EACJK,WAAW,CACZ;EACD,MAAMf,UAAU,GAA+B,CAAC,CAAC,IAAI,EAAE9B,IAAI,EAAEkE,WAAW,CAAC,CAAC;EAC1E,OAAOpC,UAAU,CAACpB,MAAM,EAAE;IACxB,MAAM,CAACP,MAAM,EAAEgE,OAAO,EAAEC,OAAO,CAAC,GAAGtC,UAAU,CAAC+B,KAAK,EAAE;IACrD;IACA,IAAI,CAACM,OAAO,EAAE;MACZR,UAAU,CAACxD,MAAM,EAAEiE,OAAO,EAAE5B,IAAI,EAAEK,WAAW,CAAC;KAC/C,MAAM,IAAI,CAACuB,OAAO,EAAE;MACnBD,OAAO,CAACE,MAAM,EAAE;KACjB,MAAM;MACLZ,UAAU,CAACU,OAAO,EAAEC,OAAO,CAAC;MAC5B,MAAM;QAAE3D,QAAQ,EAAE6D;MAAW,CAAE,GAAGF,OAAO;MACzC,MAAM;QAAE3D,QAAQ,EAAE8D;MAAW,CAAE,GAAGJ,OAAO;MACzC,IAAIL,KAAK,CAACC,OAAO,CAACO,WAAW,CAAC,IAAIR,KAAK,CAACC,OAAO,CAACQ,WAAW,CAAC,EAAE;QAC5D;QACA;QACA,MAAMC,CAAC,GAAG7C,IAAI,CAACC,GAAG,CAAC0C,WAAW,CAAC5D,MAAM,EAAE6D,WAAW,CAAC7D,MAAM,CAAC;QAC1D,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,CAAC,EAAEC,CAAC,EAAE,EAAE;UAC1B,MAAMC,QAAQ,GAAGJ,WAAW,CAACG,CAAC,CAAC;UAC/B,MAAME,QAAQ,GAAGJ,WAAW,CAACE,CAAC,CAAC;UAC/B3C,UAAU,CAACQ,IAAI,CAAC,CAAC6B,OAAO,EAAEQ,QAAQ,EAAED,QAAQ,CAAC,CAAC;;OAEjD,MAAM,IAAI,OAAOJ,WAAW,KAAK,UAAU,EAAE;QAC5CxC,UAAU,CAACQ,IAAI,CAAC,CAAC6B,OAAO,EAAE,IAAI,EAAEG,WAAW,CAAC,CAAC;;;;AAIrD;AAEA,OAAM,SAAUM,kBAAkBA,CAAA;EAKhC,IAAIC,MAA8B;EAClC,IAAIC,OAA4C;EAChD,MAAMC,MAAM,GAAG,IAAIC,OAAO,CAAI,CAACC,GAAG,EAAEC,GAAG,KAAI;IACzCJ,OAAO,GAAGG,GAAG;IACbJ,MAAM,GAAGK,GAAG;EACd,CAAC,CAAC;EACF,OAAO,CAACH,MAAM,EAAED,OAAO,EAAED,MAAM,CAAC;AAClC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}