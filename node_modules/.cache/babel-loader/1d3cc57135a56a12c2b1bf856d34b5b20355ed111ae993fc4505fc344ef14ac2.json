{"ast":null,"code":"import { distance } from './vector';\n/**\n * Get WordWrapWidth for a text according the the length of the label and 'maxWidth'.\n * @param length  - length\n * @param maxWidth - maxWidth\n * @returns wordWrapWidth\n */\nexport function getWordWrapWidthWithBase(length, maxWidth) {\n  let wordWrapWidth = 2 * length;\n  if (typeof maxWidth === 'string') {\n    wordWrapWidth = length * Number(maxWidth.replace('%', '')) / 100;\n  } else if (typeof maxWidth === 'number') {\n    wordWrapWidth = maxWidth;\n  }\n  if (isNaN(wordWrapWidth)) wordWrapWidth = 2 * length;\n  return wordWrapWidth;\n}\n/**\n * Get the proper wordWrapWidth for a labelShape according the the 'maxWidth' of keyShape.\n * @param keyShapeBox - keyShapeBox\n * @param maxWidth - maxWidth\n * @param zoom - zoom\n * @param enableBalanceShape - enableBalanceShape\n * @returns Get WordWrapWidth by bbox\n */\nexport function getWordWrapWidthByBox(keyShapeBox, maxWidth, zoom = 1, enableBalanceShape = false) {\n  const balanceZoom = enableBalanceShape ? zoom : 1;\n  const keyShapeWidth = (keyShapeBox.max[0] - keyShapeBox.min[0]) * balanceZoom;\n  return getWordWrapWidthWithBase(keyShapeWidth, maxWidth);\n}\n/**\n * Get the proper wordWrapWidth for a labelShape according the the distance between two end points and 'maxWidth'.\n * @param points - points\n * @param maxWidth - maxWidth\n * @param zoom - zoom\n * @returns - wordWrapWidth for text\n */\nexport function getWordWrapWidthByEnds(points, maxWidth, zoom = 1) {\n  const dist = distance(points[0], points[1]) * zoom;\n  return getWordWrapWidthWithBase(dist, maxWidth);\n}","map":{"version":3,"names":["distance","getWordWrapWidthWithBase","length","maxWidth","wordWrapWidth","Number","replace","isNaN","getWordWrapWidthByBox","keyShapeBox","zoom","enableBalanceShape","balanceZoom","keyShapeWidth","max","min","getWordWrapWidthByEnds","points","dist"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/text.ts"],"sourcesContent":["import { AABB } from '@antv/g';\nimport type { Point } from '../types';\nimport { distance } from './vector';\n\n/**\n * Get WordWrapWidth for a text according the the length of the label and 'maxWidth'.\n * @param length  - length\n * @param maxWidth - maxWidth\n * @returns wordWrapWidth\n */\nexport function getWordWrapWidthWithBase(length: number, maxWidth: string | number): number {\n  let wordWrapWidth = 2 * length;\n  if (typeof maxWidth === 'string') {\n    wordWrapWidth = (length * Number(maxWidth.replace('%', ''))) / 100;\n  } else if (typeof maxWidth === 'number') {\n    wordWrapWidth = maxWidth;\n  }\n  if (isNaN(wordWrapWidth)) wordWrapWidth = 2 * length;\n  return wordWrapWidth;\n}\n\n/**\n * Get the proper wordWrapWidth for a labelShape according the the 'maxWidth' of keyShape.\n * @param keyShapeBox - keyShapeBox\n * @param maxWidth - maxWidth\n * @param zoom - zoom\n * @param enableBalanceShape - enableBalanceShape\n * @returns Get WordWrapWidth by bbox\n */\nexport function getWordWrapWidthByBox(\n  keyShapeBox: AABB,\n  maxWidth: string | number,\n  zoom = 1,\n  enableBalanceShape = false,\n): number {\n  const balanceZoom = enableBalanceShape ? zoom : 1;\n  const keyShapeWidth = (keyShapeBox.max[0] - keyShapeBox.min[0]) * balanceZoom;\n  return getWordWrapWidthWithBase(keyShapeWidth, maxWidth);\n}\n\n/**\n * Get the proper wordWrapWidth for a labelShape according the the distance between two end points and 'maxWidth'.\n * @param points - points\n * @param maxWidth - maxWidth\n * @param zoom - zoom\n * @returns - wordWrapWidth for text\n */\nexport function getWordWrapWidthByEnds(points: [Point, Point], maxWidth: string | number, zoom = 1): number {\n  const dist = distance(points[0], points[1]) * zoom;\n  return getWordWrapWidthWithBase(dist, maxWidth);\n}\n"],"mappings":"AAEA,SAASA,QAAQ,QAAQ,UAAU;AAEnC;;;;;;AAMA,OAAM,SAAUC,wBAAwBA,CAACC,MAAc,EAAEC,QAAyB;EAChF,IAAIC,aAAa,GAAG,CAAC,GAAGF,MAAM;EAC9B,IAAI,OAAOC,QAAQ,KAAK,QAAQ,EAAE;IAChCC,aAAa,GAAIF,MAAM,GAAGG,MAAM,CAACF,QAAQ,CAACG,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAI,GAAG;EACpE,CAAC,MAAM,IAAI,OAAOH,QAAQ,KAAK,QAAQ,EAAE;IACvCC,aAAa,GAAGD,QAAQ;EAC1B;EACA,IAAII,KAAK,CAACH,aAAa,CAAC,EAAEA,aAAa,GAAG,CAAC,GAAGF,MAAM;EACpD,OAAOE,aAAa;AACtB;AAEA;;;;;;;;AAQA,OAAM,SAAUI,qBAAqBA,CACnCC,WAAiB,EACjBN,QAAyB,EACzBO,IAAI,GAAG,CAAC,EACRC,kBAAkB,GAAG,KAAK;EAE1B,MAAMC,WAAW,GAAGD,kBAAkB,GAAGD,IAAI,GAAG,CAAC;EACjD,MAAMG,aAAa,GAAG,CAACJ,WAAW,CAACK,GAAG,CAAC,CAAC,CAAC,GAAGL,WAAW,CAACM,GAAG,CAAC,CAAC,CAAC,IAAIH,WAAW;EAC7E,OAAOX,wBAAwB,CAACY,aAAa,EAAEV,QAAQ,CAAC;AAC1D;AAEA;;;;;;;AAOA,OAAM,SAAUa,sBAAsBA,CAACC,MAAsB,EAAEd,QAAyB,EAAEO,IAAI,GAAG,CAAC;EAChG,MAAMQ,IAAI,GAAGlB,QAAQ,CAACiB,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGP,IAAI;EAClD,OAAOT,wBAAwB,CAACiB,IAAI,EAAEf,QAAQ,CAAC;AACjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}