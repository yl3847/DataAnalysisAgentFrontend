{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix } from '@antv/util';\nimport { mergeData } from './utils';\n/**\n * @todo Propagate more options to children.(e.g. filter)\n * @todo Propagate encode options to children. This is useful for Matrix composition.\n * @todo Move this to runtime, do not treat it as a composition to cause confusion.\n */\nexport const View = () => {\n  return options => {\n    const {\n        children\n      } = options,\n      restOptions = __rest(options, [\"children\"]);\n    if (!Array.isArray(children)) return [];\n    const {\n        data: viewData,\n        scale: viewScale = {},\n        axis: viewAxis = {},\n        legend: viewLegend = {},\n        encode: viewEncode = {},\n        transform: viewTransform = []\n      } = restOptions,\n      rest = __rest(restOptions, [\"data\", \"scale\", \"axis\", \"legend\", \"encode\", \"transform\"]);\n    const marks = children.map(_a => {\n      var {\n          data,\n          scale = {},\n          axis = {},\n          legend = {},\n          encode = {},\n          transform = []\n        } = _a,\n        rest = __rest(_a, [\"data\", \"scale\", \"axis\", \"legend\", \"encode\", \"transform\"]);\n      return Object.assign({\n        data: mergeData(data, viewData),\n        scale: deepMix({}, viewScale, scale),\n        encode: deepMix({}, viewEncode, encode),\n        transform: [...viewTransform, ...transform],\n        axis: axis && viewAxis ? deepMix({}, viewAxis, axis) : false,\n        legend: legend && viewLegend ? deepMix({}, viewLegend, legend) : false\n      }, rest);\n    });\n    return [Object.assign(Object.assign({}, rest), {\n      marks,\n      type: 'standardView'\n    })];\n  };\n};\nView.props = {};","map":{"version":3,"names":["deepMix","mergeData","View","options","children","restOptions","__rest","Array","isArray","data","viewData","scale","viewScale","axis","viewAxis","legend","viewLegend","encode","viewEncode","transform","viewTransform","rest","marks","map","_a","Object","assign","type","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/composition/view.ts"],"sourcesContent":["import { deepMix } from '@antv/util';\nimport { CompositionComponent as CC } from '../runtime';\nimport { ViewComposition } from '../spec';\nimport { mergeData } from './utils';\n\nexport type ViewOptions = Omit<ViewComposition, 'type'>;\n\n/**\n * @todo Propagate more options to children.(e.g. filter)\n * @todo Propagate encode options to children. This is useful for Matrix composition.\n * @todo Move this to runtime, do not treat it as a composition to cause confusion.\n */\nexport const View: CC<ViewOptions> = () => {\n  return (options) => {\n    const { children, ...restOptions } = options;\n    if (!Array.isArray(children)) return [];\n    const {\n      data: viewData,\n      scale: viewScale = {},\n      axis: viewAxis = {},\n      legend: viewLegend = {},\n      encode: viewEncode = {},\n      transform: viewTransform = [],\n      ...rest\n    } = restOptions;\n    const marks = children.map(\n      ({\n        data,\n        scale = {},\n        axis = {},\n        legend = {},\n        encode = {},\n        transform = [],\n        ...rest\n      }) => ({\n        data: mergeData(data, viewData),\n        scale: deepMix({}, viewScale, scale),\n        encode: deepMix({}, viewEncode, encode),\n        transform: [...viewTransform, ...transform],\n        axis: axis && viewAxis ? deepMix({}, viewAxis, axis) : false,\n        legend: legend && viewLegend ? deepMix({}, viewLegend, legend) : false,\n        ...rest,\n      }),\n    );\n    return [{ ...rest, marks, type: 'standardView' }];\n  };\n};\n\nView.props = {};\n"],"mappings":";;;;;;;;AAAA,SAASA,OAAO,QAAQ,YAAY;AAGpC,SAASC,SAAS,QAAQ,SAAS;AAInC;;;;;AAKA,OAAO,MAAMC,IAAI,GAAoBA,CAAA,KAAK;EACxC,OAAQC,OAAO,IAAI;IACjB,MAAM;QAAEC;MAAQ,IAAqBD,OAAO;MAAvBE,WAAW,GAAAC,MAAA,CAAKH,OAAO,EAAtC,YAA4B,CAAU;IAC5C,IAAI,CAACI,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAAC,EAAE,OAAO,EAAE;IACvC,MAAM;QACJK,IAAI,EAAEC,QAAQ;QACdC,KAAK,EAAEC,SAAS,GAAG,EAAE;QACrBC,IAAI,EAAEC,QAAQ,GAAG,EAAE;QACnBC,MAAM,EAAEC,UAAU,GAAG,EAAE;QACvBC,MAAM,EAAEC,UAAU,GAAG,EAAE;QACvBC,SAAS,EAAEC,aAAa,GAAG;MAAE,IAE3Bf,WAAW;MADVgB,IAAI,GAAAf,MAAA,CACLD,WAAW,EART,0DAQL,CAAc;IACf,MAAMiB,KAAK,GAAGlB,QAAQ,CAACmB,GAAG,CACvBC,EAQA,IAAI;UARJ;UACCf,IAAI;UACJE,KAAK,GAAG,EAAE;UACVE,IAAI,GAAG,EAAE;UACTE,MAAM,GAAG,EAAE;UACXE,MAAM,GAAG,EAAE;UACXE,SAAS,GAAG;QAAE,IAAAK,EAEf;QADIH,IAAI,GAAAf,MAAA,CAAAkB,EAAA,EAPR,0DAQA,CADQ;MACH,OAAAC,MAAA,CAAAC,MAAA;QACJjB,IAAI,EAAER,SAAS,CAACQ,IAAI,EAAEC,QAAQ,CAAC;QAC/BC,KAAK,EAAEX,OAAO,CAAC,EAAE,EAAEY,SAAS,EAAED,KAAK,CAAC;QACpCM,MAAM,EAAEjB,OAAO,CAAC,EAAE,EAAEkB,UAAU,EAAED,MAAM,CAAC;QACvCE,SAAS,EAAE,CAAC,GAAGC,aAAa,EAAE,GAAGD,SAAS,CAAC;QAC3CN,IAAI,EAAEA,IAAI,IAAIC,QAAQ,GAAGd,OAAO,CAAC,EAAE,EAAEc,QAAQ,EAAED,IAAI,CAAC,GAAG,KAAK;QAC5DE,MAAM,EAAEA,MAAM,IAAIC,UAAU,GAAGhB,OAAO,CAAC,EAAE,EAAEgB,UAAU,EAAED,MAAM,CAAC,GAAG;MAAK,GACnEM,IAAI;KACP,CACH;IACD,OAAO,CAAAI,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAML,IAAI;MAAEC,KAAK;MAAEK,IAAI,EAAE;IAAc,GAAG;EACnD,CAAC;AACH,CAAC;AAEDzB,IAAI,CAAC0B,KAAK,GAAG,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}