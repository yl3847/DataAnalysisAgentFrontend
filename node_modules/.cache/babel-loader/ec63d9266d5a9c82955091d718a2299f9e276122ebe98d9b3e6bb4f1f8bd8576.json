{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { deepMix, throttle, upperFirst, get } from '@antv/util';\nimport { CustomEvent } from '@antv/g';\nimport { isTranspose } from '../utils/coordinate';\nimport { invert, domainOf, abstractOf } from '../utils/scale';\nexport const SLIDER_CLASS_NAME = 'slider';\nfunction filterDataByDomain(options, scaleOptions, prefix, hasState = false, channel0 = 'x', channel1 = 'y') {\n  const {\n    marks\n  } = options;\n  const newMarks = marks.map(mark => {\n    var _a, _b;\n    return deepMix({\n      // Hide label to keep smooth transition.\n      axis: {\n        x: {\n          transform: [{\n            type: 'hide'\n          }]\n        },\n        y: {\n          transform: [{\n            type: 'hide'\n          }]\n        }\n      }\n    }, mark, {\n      scale: scaleOptions,\n      // Don't rerender sliders.\n      [prefix]: Object.assign(Object.assign({}, ((_a = mark[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {\n        [channel0]: Object.assign({\n          preserve: true\n        }, hasState && {\n          ratio: null\n        })\n      }), ((_b = mark[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {\n        [channel1]: {\n          preserve: true\n        }\n      }),\n      animate: false\n    });\n  });\n  // Rerender and update view.\n  return Object.assign(Object.assign({}, options), {\n    marks: newMarks,\n    clip: true,\n    animate: false\n  });\n}\nfunction abstractValue(values, scale, reverse) {\n  const [x, x1] = values;\n  const v = reverse ? d => 1 - d : d => d;\n  const d0 = invert(scale, v(x), true);\n  const d1 = invert(scale, v(x1), false);\n  return domainOf(scale, [d0, d1]);\n}\nfunction extentOf(domain) {\n  return [domain[0], domain[domain.length - 1]];\n}\n/**\n * @todo Support click to reset after fix click and dragend conflict.\n */\nexport function SliderFilter({\n  initDomain = {},\n  className = SLIDER_CLASS_NAME,\n  prefix = 'slider',\n  setValue = (component, values) => component.setValues(values),\n  hasState = false,\n  wait = 50,\n  leading = true,\n  trailing = false,\n  getInitValues = slider => {\n    var _a;\n    const values = (_a = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a === void 0 ? void 0 : _a.values;\n    if (values[0] !== 0 || values[1] !== 1) return values;\n  }\n}) {\n  return (context, _, emitter) => {\n    const {\n      container,\n      view,\n      update,\n      setState\n    } = context;\n    const sliders = container.getElementsByClassName(className);\n    if (!sliders.length) return () => {};\n    let filtering = false;\n    const {\n      scale,\n      coordinate,\n      layout\n    } = view;\n    const {\n      paddingLeft,\n      paddingTop,\n      paddingBottom,\n      paddingRight\n    } = layout;\n    const {\n      x: scaleX,\n      y: scaleY\n    } = scale;\n    const transposed = isTranspose(coordinate);\n    const channelOf = orientation => {\n      const channel0 = orientation === 'vertical' ? 'y' : 'x';\n      const channel1 = orientation === 'vertical' ? 'x' : 'y';\n      if (transposed) return [channel1, channel0];\n      return [channel0, channel1];\n    };\n    const sliderHandler = new Map();\n    const emitHandlers = new Set();\n    // Store current domain of x and y scale.\n    const channelDomain = {\n      x: initDomain.x || scaleX.getOptions().domain,\n      y: initDomain.y || scaleY.getOptions().domain\n    };\n    for (const slider of sliders) {\n      const {\n        orientation\n      } = slider.attributes;\n      const [channel0, channel1] = channelOf(orientation);\n      const eventName = `${prefix}${upperFirst(channel0)}:filter`;\n      const isX = channel0 === 'x';\n      const {\n        ratio: ratioX\n      } = scaleX.getOptions();\n      const {\n        ratio: ratioY\n      } = scaleY.getOptions();\n      const domainsOf = event => {\n        // From abstract values.\n        if (event.data) {\n          const {\n            selection\n          } = event.data;\n          const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;\n          return isX ? [domainOf(scaleX, X, ratioX), domainOf(scaleY, Y, ratioY)] : [domainOf(scaleY, Y, ratioY), domainOf(scaleX, X, ratioX)];\n        }\n        // From visual values.\n        const {\n          value: values\n        } = event.detail;\n        const scale0 = scale[channel0];\n        const domain0 = abstractValue(values, scale0, transposed && orientation === 'horizontal');\n        const domain1 = channelDomain[channel1];\n        return [domain0, domain1];\n      };\n      const onValueChange = throttle(event => __awaiter(this, void 0, void 0, function* () {\n        const {\n          initValue = false\n        } = event;\n        if (filtering && !initValue) return;\n        filtering = true;\n        const {\n          nativeEvent = true\n        } = event;\n        // The ordinal domain for each channel.\n        const scaleXOptions = scaleX.getOptions();\n        if (get(scaleXOptions, 'domain.length') !== get(scaleXOptions, 'expectedDomain.length')) {\n          scaleX.update({\n            domain: scaleXOptions.expectedDomain\n          });\n        }\n        const scaleYOptions = scaleY.getOptions();\n        if (get(scaleYOptions, 'domain.length') !== get(scaleYOptions, 'expectedDomain.length')) {\n          scaleY.update({\n            domain: scaleYOptions.expectedDomain\n          });\n        }\n        // Get and update domain.\n        const [domain0, domain1] = domainsOf(event);\n        channelDomain[channel0] = domain0;\n        channelDomain[channel1] = domain1;\n        if (nativeEvent) {\n          // Emit events.\n          const X = isX ? domain0 : domain1;\n          const Y = isX ? domain1 : domain0;\n          emitter.emit(eventName, Object.assign(Object.assign({}, event), {\n            nativeEvent,\n            data: {\n              selection: [extentOf(X), extentOf(Y)]\n            }\n          }));\n        }\n        setState(slider, options => Object.assign(Object.assign({}, filterDataByDomain(options,\n        // Set nice to false to avoid modify domain.\n        // Only update domain of current slider / scrollbar.\n        {\n          [channel0]: {\n            domain: domain0,\n            nice: false\n          }\n        }, prefix, hasState, channel0, channel1)), {\n          paddingLeft,\n          paddingTop,\n          paddingBottom,\n          paddingRight\n        }));\n        yield update();\n        filtering = false;\n      }), wait, {\n        leading,\n        trailing\n      });\n      const emitHandler = event => {\n        const {\n          nativeEvent\n        } = event;\n        if (nativeEvent) return;\n        const {\n          data\n        } = event;\n        const {\n          selection\n        } = data;\n        const [X, Y] = selection;\n        // Update data.\n        slider.dispatchEvent(new CustomEvent('valuechange', {\n          data,\n          nativeEvent: false\n        }));\n        // Update slider.\n        const V = isX ? abstractOf(X, scaleX) : abstractOf(Y, scaleY);\n        setValue(slider, V);\n      };\n      emitter.on(eventName, emitHandler);\n      slider.addEventListener('valuechange', onValueChange);\n      sliderHandler.set(slider, onValueChange);\n      emitHandlers.add([eventName, emitHandler]);\n      const values = getInitValues(slider);\n      if (values) {\n        // Init values.\n        slider.dispatchEvent(new CustomEvent('valuechange', {\n          detail: {\n            value: values\n          },\n          nativeEvent: false,\n          initValue: true\n        }));\n      }\n    }\n    return () => {\n      for (const [slider, handler] of sliderHandler) {\n        slider.removeEventListener('valuechange', handler);\n      }\n      for (const [name, handler] of emitHandlers) {\n        emitter.off(name, handler);\n      }\n    };\n  };\n}","map":{"version":3,"names":["deepMix","throttle","upperFirst","get","CustomEvent","isTranspose","invert","domainOf","abstractOf","SLIDER_CLASS_NAME","filterDataByDomain","options","scaleOptions","prefix","hasState","channel0","channel1","marks","newMarks","map","mark","axis","x","transform","type","y","scale","Object","assign","_a","preserve","ratio","_b","animate","clip","abstractValue","values","reverse","x1","v","d","d0","d1","extentOf","domain","length","SliderFilter","initDomain","className","setValue","component","setValues","wait","leading","trailing","getInitValues","slider","attributes","context","_","emitter","container","view","update","setState","sliders","getElementsByClassName","filtering","coordinate","layout","paddingLeft","paddingTop","paddingBottom","paddingRight","scaleX","scaleY","transposed","channelOf","orientation","sliderHandler","Map","emitHandlers","Set","channelDomain","getOptions","eventName","isX","ratioX","ratioY","domainsOf","event","data","selection","X","Y","value","detail","scale0","domain0","domain1","onValueChange","__awaiter","initValue","nativeEvent","scaleXOptions","expectedDomain","scaleYOptions","emit","nice","emitHandler","dispatchEvent","V","on","addEventListener","set","add","handler","removeEventListener","name","off"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/interaction/sliderFilter.ts"],"sourcesContent":["import { deepMix, throttle, upperFirst, get } from '@antv/util';\nimport { CustomEvent } from '@antv/g';\nimport { isTranspose } from '../utils/coordinate';\nimport { invert, domainOf, abstractOf } from '../utils/scale';\n\nexport const SLIDER_CLASS_NAME = 'slider';\n\nfunction filterDataByDomain(\n  options,\n  scaleOptions,\n  prefix,\n  hasState = false,\n  channel0 = 'x',\n  channel1 = 'y',\n) {\n  const { marks } = options;\n  const newMarks = marks.map((mark) =>\n    deepMix(\n      {\n        // Hide label to keep smooth transition.\n        axis: {\n          x: { transform: [{ type: 'hide' }] },\n          y: { transform: [{ type: 'hide' }] },\n        },\n      },\n      mark,\n      {\n        scale: scaleOptions,\n        // Don't rerender sliders.\n        [prefix]: {\n          ...(mark[prefix]?.[channel0] && {\n            [channel0]: { preserve: true, ...(hasState && { ratio: null }) },\n          }),\n          // Only remove ratio state with filtered channel.\n          ...(mark[prefix]?.[channel1] && {\n            [channel1]: { preserve: true },\n          }),\n        },\n        animate: false,\n      },\n    ),\n  );\n\n  // Rerender and update view.\n  return {\n    ...options,\n    marks: newMarks,\n    clip: true, // Clip shapes out of plot area.\n    animate: false,\n  };\n}\n\nfunction abstractValue(values, scale, reverse) {\n  const [x, x1] = values;\n  const v = reverse ? (d) => 1 - d : (d) => d;\n  const d0 = invert(scale, v(x), true);\n  const d1 = invert(scale, v(x1), false);\n  return domainOf(scale, [d0, d1]);\n}\n\nfunction extentOf(domain) {\n  return [domain[0], domain[domain.length - 1]];\n}\n\n/**\n * @todo Support click to reset after fix click and dragend conflict.\n */\nexport function SliderFilter({\n  initDomain = {},\n  className = SLIDER_CLASS_NAME,\n  prefix = 'slider',\n  setValue = (component, values) => component.setValues(values),\n  hasState = false,\n  wait = 50,\n  leading = true,\n  trailing = false,\n  getInitValues = (slider) => {\n    const values = slider?.attributes?.values;\n    if (values[0] !== 0 || values[1] !== 1) return values;\n  },\n}: any) {\n  return (context, _, emitter) => {\n    const { container, view, update, setState } = context;\n    const sliders = container.getElementsByClassName(className);\n    if (!sliders.length) return () => {};\n\n    let filtering = false;\n    const { scale, coordinate, layout } = view;\n    const { paddingLeft, paddingTop, paddingBottom, paddingRight } = layout;\n    const { x: scaleX, y: scaleY } = scale;\n    const transposed = isTranspose(coordinate);\n\n    const channelOf = (orientation) => {\n      const channel0 = orientation === 'vertical' ? 'y' : 'x';\n      const channel1 = orientation === 'vertical' ? 'x' : 'y';\n      if (transposed) return [channel1, channel0];\n      return [channel0, channel1];\n    };\n\n    const sliderHandler = new Map();\n    const emitHandlers = new Set<[string, (event: any) => void]>();\n\n    // Store current domain of x and y scale.\n    const channelDomain = {\n      x: initDomain.x || scaleX.getOptions().domain,\n      y: initDomain.y || scaleY.getOptions().domain,\n    };\n\n    for (const slider of sliders) {\n      const { orientation } = slider.attributes;\n      const [channel0, channel1] = channelOf(orientation);\n      const eventName = `${prefix}${upperFirst(channel0)}:filter`;\n      const isX = channel0 === 'x';\n      const { ratio: ratioX } = scaleX.getOptions();\n      const { ratio: ratioY } = scaleY.getOptions();\n      const domainsOf = (event) => {\n        // From abstract values.\n        if (event.data) {\n          const { selection } = event.data;\n          const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] =\n            selection;\n          return isX\n            ? [domainOf(scaleX, X, ratioX), domainOf(scaleY, Y, ratioY)]\n            : [domainOf(scaleY, Y, ratioY), domainOf(scaleX, X, ratioX)];\n        }\n\n        // From visual values.\n        const { value: values } = event.detail;\n        const scale0 = scale[channel0];\n        const domain0 = abstractValue(\n          values,\n          scale0,\n          transposed && orientation === 'horizontal',\n        );\n        const domain1 = channelDomain[channel1];\n        return [domain0, domain1];\n      };\n\n      const onValueChange = throttle(\n        async (event) => {\n          const { initValue = false } = event;\n          if (filtering && !initValue) return;\n          filtering = true;\n\n          const { nativeEvent = true } = event;\n\n          // The ordinal domain for each channel.\n          const scaleXOptions = scaleX.getOptions();\n          if (\n            get(scaleXOptions, 'domain.length') !==\n            get(scaleXOptions, 'expectedDomain.length')\n          ) {\n            scaleX.update({ domain: scaleXOptions.expectedDomain });\n          }\n\n          const scaleYOptions = scaleY.getOptions();\n          if (\n            get(scaleYOptions, 'domain.length') !==\n            get(scaleYOptions, 'expectedDomain.length')\n          ) {\n            scaleY.update({ domain: scaleYOptions.expectedDomain });\n          }\n\n          // Get and update domain.\n          const [domain0, domain1] = domainsOf(event);\n          channelDomain[channel0] = domain0;\n          channelDomain[channel1] = domain1;\n\n          if (nativeEvent) {\n            // Emit events.\n            const X = isX ? domain0 : domain1;\n            const Y = isX ? domain1 : domain0;\n            emitter.emit(eventName, {\n              ...event,\n              nativeEvent,\n              data: { selection: [extentOf(X), extentOf(Y)] },\n            });\n          }\n\n          setState(slider, (options) => ({\n            ...filterDataByDomain(\n              options,\n              // Set nice to false to avoid modify domain.\n              // Only update domain of current slider / scrollbar.\n              { [channel0]: { domain: domain0, nice: false } },\n              prefix,\n              hasState,\n              channel0,\n              channel1,\n            ),\n            paddingLeft,\n            paddingTop,\n            paddingBottom,\n            paddingRight,\n          }));\n\n          await update();\n          filtering = false;\n        },\n        wait,\n        { leading, trailing },\n      );\n\n      const emitHandler = (event) => {\n        const { nativeEvent } = event;\n        if (nativeEvent) return;\n\n        const { data } = event;\n        const { selection } = data;\n        const [X, Y] = selection;\n\n        // Update data.\n        slider.dispatchEvent(\n          new CustomEvent('valuechange', {\n            data,\n            nativeEvent: false,\n          }),\n        );\n\n        // Update slider.\n        const V = isX ? abstractOf(X, scaleX) : abstractOf(Y, scaleY);\n        setValue(slider, V);\n      };\n\n      emitter.on(eventName, emitHandler);\n\n      slider.addEventListener('valuechange', onValueChange);\n      sliderHandler.set(slider, onValueChange);\n      emitHandlers.add([eventName, emitHandler]);\n\n      const values = getInitValues(slider);\n\n      if (values) {\n        // Init values.\n        slider.dispatchEvent(\n          new CustomEvent('valuechange', {\n            detail: {\n              value: values,\n            },\n            nativeEvent: false,\n            initValue: true,\n          }),\n        );\n      }\n    }\n\n    return () => {\n      for (const [slider, handler] of sliderHandler) {\n        slider.removeEventListener('valuechange', handler);\n      }\n      for (const [name, handler] of emitHandlers) {\n        emitter.off(name, handler);\n      }\n    };\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}