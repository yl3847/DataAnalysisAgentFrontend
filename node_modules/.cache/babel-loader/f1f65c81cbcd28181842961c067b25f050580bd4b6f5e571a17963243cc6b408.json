{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { get } from '@antv/util';\n/**\n * <zh/> 合并两个 节点/边/Combo 的数据\n *\n * <en/> Merge the data of two nodes/edges/combos\n * @param original - <zh/> 原始数据 | <en/> original data\n * @param modified - <zh/> 待合并的数据 | <en/> data to be merged\n * @returns <zh/> 合并后的数据 | <en/> merged data\n * @remarks\n * <zh/> 只会合并第一层的数据，data、style 下的二级数据会被覆盖\n *\n * <en/> Only the first level of data will be merged, the second level of data under data and style will be overwritten\n */\nexport function mergeElementsData(original, modified) {\n  const {\n      data: originalData,\n      style: originalStyle\n    } = original,\n    originalAttrs = __rest(original, [\"data\", \"style\"]);\n  const {\n      data: modifiedData,\n      style: modifiedStyle\n    } = modified,\n    modifiedAttrs = __rest(modified, [\"data\", \"style\"]);\n  const result = Object.assign(Object.assign({}, originalAttrs), modifiedAttrs);\n  if (originalData || modifiedData) {\n    Object.assign(result, {\n      data: Object.assign(Object.assign({}, originalData), modifiedData)\n    });\n  }\n  if (originalStyle || modifiedStyle) {\n    Object.assign(result, {\n      style: Object.assign(Object.assign({}, originalStyle), modifiedStyle)\n    });\n  }\n  return result;\n}\n/**\n * <zh/> 克隆元素数据\n *\n * <en/> Clone clement data\n * @param data - <zh/> 待克隆的数据 | <en/> data to be cloned\n * @returns <zh/> 克隆后的数据 | <en/> cloned data\n * @remarks\n * <zh/> 只会克隆到第二层（data、style）\n *\n * <en/> Only clone to the second level (data, style)\n */\nexport function cloneElementData(data) {\n  const {\n      data: customData,\n      style\n    } = data,\n    restAttrs = __rest(data, [\"data\", \"style\"]);\n  const clonedData = restAttrs;\n  if (customData) clonedData.data = Object.assign({}, customData);\n  if (style) clonedData.style = Object.assign({}, style);\n  return clonedData;\n}\n/**\n * <zh/> 判断数据是否为空\n *\n * <en/> Determine if the data is empty\n * @param data - <zh/> 图数据 | <en/> graph data\n * @returns <zh/> 是否为空 | <en/> is empty\n */\nexport function isEmptyData(data) {\n  return !get(data, ['nodes', 'length']) && !get(data, ['edges', 'length']) && !get(data, ['combos', 'length']);\n}\n/**\n * <zh/> 判断两个元素数据是否相等\n *\n * <en/> Determine if two element data are equal\n * @param original - <zh/> 原始数据 | <en/> original data\n * @param modified - <zh/> 修改后的数据 | <en/> modified data\n * @returns <zh/> 是否相等 | <en/> is equal\n * @remarks\n * <zh/> 相比于 isEqual，这个方法不会比较更下层的数据\n *\n * <en/> Compared to isEqual, this method does not compare data at a lower level\n */\nexport function isElementDataEqual(original = {}, modified = {}) {\n  const {\n      states: originalStates = [],\n      data: originalData = {},\n      style: originalStyle = {},\n      children: originalChildren = []\n    } = original,\n    originalAttrs = __rest(original, [\"states\", \"data\", \"style\", \"children\"]);\n  const {\n      states: modifiedStates = [],\n      data: modifiedData = {},\n      style: modifiedStyle = {},\n      children: modifiedChildren = []\n    } = modified,\n    modifiedAttrs = __rest(modified, [\"states\", \"data\", \"style\", \"children\"]);\n  const isArrayEqual = (arr1, arr2) => {\n    if (arr1.length !== arr2.length) return false;\n    return arr1.every((item, index) => item === arr2[index]);\n  };\n  const isObjectEqual = (obj1, obj2) => {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every(key => obj1[key] === obj2[key]);\n  };\n  if (!isObjectEqual(originalAttrs, modifiedAttrs)) return false;\n  if (!isArrayEqual(originalChildren, modifiedChildren)) return false;\n  if (!isArrayEqual(originalStates, modifiedStates)) return false;\n  if (!isObjectEqual(originalData, modifiedData)) return false;\n  if (!isObjectEqual(originalStyle, modifiedStyle)) return false;\n  return true;\n}","map":{"version":3,"names":["get","mergeElementsData","original","modified","data","originalData","style","originalStyle","originalAttrs","__rest","modifiedData","modifiedStyle","modifiedAttrs","result","Object","assign","cloneElementData","customData","restAttrs","clonedData","isEmptyData","isElementDataEqual","states","originalStates","children","originalChildren","modifiedStates","modifiedChildren","isArrayEqual","arr1","arr2","length","every","item","index","isObjectEqual","obj1","obj2","keys1","keys","keys2","key"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/utils/data.ts"],"sourcesContent":["import { get } from '@antv/util';\nimport type { ComboData, EdgeData, GraphData, NodeData } from '../spec';\nimport type { ElementDatum, ID } from '../types';\n\n/**\n * <zh/> 合并两个 节点/边/Combo 的数据\n *\n * <en/> Merge the data of two nodes/edges/combos\n * @param original - <zh/> 原始数据 | <en/> original data\n * @param modified - <zh/> 待合并的数据 | <en/> data to be merged\n * @returns <zh/> 合并后的数据 | <en/> merged data\n * @remarks\n * <zh/> 只会合并第一层的数据，data、style 下的二级数据会被覆盖\n *\n * <en/> Only the first level of data will be merged, the second level of data under data and style will be overwritten\n */\nexport function mergeElementsData<T extends NodeData | EdgeData | ComboData>(original: T, modified: Partial<T>): T {\n  const { data: originalData, style: originalStyle, ...originalAttrs } = original;\n  const { data: modifiedData, style: modifiedStyle, ...modifiedAttrs } = modified;\n\n  const result = {\n    ...originalAttrs,\n    ...modifiedAttrs,\n  };\n\n  if (originalData || modifiedData) {\n    Object.assign(result, { data: { ...originalData, ...modifiedData } });\n  }\n\n  if (originalStyle || modifiedStyle) {\n    Object.assign(result, { style: { ...originalStyle, ...modifiedStyle } });\n  }\n\n  return result as T;\n}\n\n/**\n * <zh/> 克隆元素数据\n *\n * <en/> Clone clement data\n * @param data - <zh/> 待克隆的数据 | <en/> data to be cloned\n * @returns <zh/> 克隆后的数据 | <en/> cloned data\n * @remarks\n * <zh/> 只会克隆到第二层（data、style）\n *\n * <en/> Only clone to the second level (data, style)\n */\nexport function cloneElementData<T extends NodeData | EdgeData | ComboData>(data: T): T {\n  const { data: customData, style, ...restAttrs } = data;\n  const clonedData = restAttrs as T;\n  if (customData) clonedData.data = { ...customData };\n  if (style) clonedData.style = { ...style };\n  return clonedData;\n}\n\n/**\n * <zh/> 判断数据是否为空\n *\n * <en/> Determine if the data is empty\n * @param data - <zh/> 图数据 | <en/> graph data\n * @returns <zh/> 是否为空 | <en/> is empty\n */\nexport function isEmptyData(data: GraphData) {\n  return !get(data, ['nodes', 'length']) && !get(data, ['edges', 'length']) && !get(data, ['combos', 'length']);\n}\n\n/**\n * <zh/> 判断两个元素数据是否相等\n *\n * <en/> Determine if two element data are equal\n * @param original - <zh/> 原始数据 | <en/> original data\n * @param modified - <zh/> 修改后的数据 | <en/> modified data\n * @returns <zh/> 是否相等 | <en/> is equal\n * @remarks\n * <zh/> 相比于 isEqual，这个方法不会比较更下层的数据\n *\n * <en/> Compared to isEqual, this method does not compare data at a lower level\n */\nexport function isElementDataEqual(original: Partial<ElementDatum> = {}, modified: Partial<ElementDatum> = {}) {\n  const {\n    states: originalStates = [],\n    data: originalData = {},\n    style: originalStyle = {},\n    children: originalChildren = [],\n    ...originalAttrs\n  } = original;\n  const {\n    states: modifiedStates = [],\n    data: modifiedData = {},\n    style: modifiedStyle = {},\n    children: modifiedChildren = [],\n    ...modifiedAttrs\n  } = modified;\n\n  const isArrayEqual = (arr1: unknown[], arr2: unknown[]) => {\n    if (arr1.length !== arr2.length) return false;\n    return arr1.every((item, index) => item === arr2[index]);\n  };\n  const isObjectEqual = (obj1: Record<string, unknown>, obj2: Record<string, unknown>) => {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key) => obj1[key] === obj2[key]);\n  };\n\n  if (!isObjectEqual(originalAttrs, modifiedAttrs)) return false;\n  if (!isArrayEqual(originalChildren as ID[], modifiedChildren as ID[])) return false;\n  if (!isArrayEqual(originalStates, modifiedStates)) return false;\n  if (!isObjectEqual(originalData, modifiedData)) return false;\n  if (!isObjectEqual(originalStyle, modifiedStyle)) return false;\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}