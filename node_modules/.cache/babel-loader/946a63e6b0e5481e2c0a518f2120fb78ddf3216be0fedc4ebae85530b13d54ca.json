{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { deepMix, isEqual } from '@antv/util';\nimport { groups, max, sum } from '@antv/vendor/d3-array';\nimport { format } from '@antv/vendor/d3-format';\nimport { DisplayObject, Text } from '@antv/g';\nimport { getPolarOptions, getRadialOptions } from '../coordinate';\nimport { combine } from '../utils/array';\nimport { prettyNumber } from '../utils/number';\nimport { capitalizeFirst, defined, subObject } from '../utils/helper';\nimport { LEGEND_INFER_STRATEGIES } from '../component/constant';\nimport { coordOf, isHelix, isParallel, isPolar, isRadar, isRadial, isReflect, isReflectY, isTheta, isTranspose } from './coordinate';\nimport { useLibrary } from './library';\nimport { isValidScale } from './scale';\nimport { ConstantScale, ContinuousScale, DiscreteScale, DistributionScale } from './types/scale';\nexport function inferComponent(scales, partialOptions, library) {\n  const {\n    coordinates = [],\n    title\n  } = partialOptions;\n  const [, createGuideComponent] = useLibrary('component', library);\n  const displayedScales = scales.filter(({\n    guide\n  }) => {\n    if (guide === null) return false;\n    return true;\n  });\n  const components = [];\n  // Sliders and scrollbar component.\n  const sliders = inferScrollableComponents(partialOptions, scales, library);\n  components.push(...sliders);\n  // Title components.\n  if (title) {\n    const {\n      props\n    } = createGuideComponent('title');\n    const {\n      defaultPosition,\n      defaultOrientation,\n      defaultOrder,\n      defaultSize,\n      defaultCrossPadding\n    } = props;\n    const titleOptions = typeof title === 'string' ? {\n      title\n    } : title;\n    components.push(Object.assign({\n      type: 'title',\n      position: defaultPosition,\n      orientation: defaultOrientation,\n      order: defaultOrder,\n      crossPadding: defaultCrossPadding[0],\n      defaultSize\n    }, titleOptions));\n  }\n  // Axis and legends.\n  const inferredComponents = inferComponentsType(displayedScales, coordinates);\n  inferredComponents.forEach(([type, relativeScales]) => {\n    const {\n      props\n    } = createGuideComponent(type);\n    const {\n      defaultPosition,\n      defaultPlane = 'xy',\n      defaultOrientation,\n      defaultSize,\n      defaultOrder,\n      defaultLength,\n      defaultPadding: DP = [0, 0],\n      defaultCrossPadding: DCP = [0, 0]\n    } = props;\n    // @todo to be confirm if the scale can be merged.\n    // const scale: G2ScaleOptions = Object.assign({}, ...relativeScales);\n    const scale = deepMix({}, ...relativeScales);\n    const {\n      guide: guideOptions,\n      field\n    } = scale;\n    // A scale may have multiple guides.\n    const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];\n    for (const partialGuide of guides) {\n      const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);\n      // Skip if position and orientation are not specified.\n      // @example the last axis of radar chart\n      if (!position && !orientation) continue;\n      const isVertical = position === 'left' || position === 'right';\n      const defaultPadding = isVertical ? DP[1] : DP[0];\n      const defaultCrossPadding = isVertical ? DCP[1] : DCP[0];\n      const {\n        size,\n        order = defaultOrder,\n        length = defaultLength,\n        padding = defaultPadding,\n        crossPadding = defaultCrossPadding\n      } = partialGuide;\n      components.push(Object.assign(Object.assign({\n        title: field\n      }, partialGuide), {\n        defaultSize,\n        length,\n        position,\n        plane: defaultPlane,\n        orientation,\n        padding,\n        order,\n        crossPadding,\n        size,\n        type,\n        scales: relativeScales\n      }));\n    }\n  });\n  return components;\n}\nexport function renderComponent(component, coordinate, theme, library, markState) {\n  const [useGuideComponent] = useLibrary('component', library);\n  const {\n      scaleInstances: scales,\n      scale,\n      bbox\n    } = component,\n    options = __rest(component, [\"scaleInstances\", \"scale\", \"bbox\"]);\n  const value = {\n    bbox,\n    library\n  };\n  const render = useGuideComponent(options);\n  return render({\n    coordinate,\n    library,\n    markState,\n    scales,\n    theme,\n    value,\n    scale\n  });\n}\nexport function normalizeComponents(components) {\n  return components.map(d => {\n    const component = deepMix(d, d.style);\n    delete component.style;\n    return component;\n  });\n}\nexport function flatComponents(components) {\n  return components.flatMap(d => d.type == 'group' ? d.children : d);\n}\n// Wrap legends into a group component.\nexport function groupComponents(components, crossSize) {\n  // Group components by key.\n  const P = ['left', 'right', 'bottom', 'top'];\n  const key = ({\n    type,\n    position,\n    group\n  }) => {\n    if (!P.includes(position)) return Symbol('independent');\n    if (group === undefined) {\n      if (type.startsWith('legend')) return `legend-${position}`;\n      return Symbol('independent');\n    }\n    if (group === 'independent') return Symbol('independent');\n    return group;\n  };\n  const grouped = groups(components, key);\n  // Update attributes of group components,\n  // and maybe flatten group components without enough room.\n  return grouped.flatMap(([, components]) => {\n    if (components.length === 1) return components[0];\n    // If crossSize defined, group components only when has\n    // enough room.\n    if (crossSize !== undefined) {\n      // Compute total length.\n      const DL = components.filter(d => d.length !== undefined).map(d => d.length);\n      const totalLength = sum(DL);\n      // If there is no enough room for components,\n      // do not group.\n      if (totalLength > crossSize) {\n        components.forEach(d => d.group = Symbol('independent'));\n        return components;\n      }\n      // Group legends and update legend length.\n      const emptyLength = crossSize - totalLength;\n      const emptyCount = components.length - DL.length;\n      const length = emptyLength / emptyCount;\n      components.forEach(d => {\n        if (d.length !== undefined) return;\n        d.length = length;\n      });\n    }\n    // Create a group component.\n    const size = max(components, d => d.size);\n    const order = max(components, d => d.order);\n    const crossPadding = max(components, d => d.crossPadding);\n    const position = components[0].position;\n    return {\n      type: 'group',\n      size,\n      order,\n      position,\n      children: components,\n      crossPadding\n    };\n  });\n}\nfunction inferLegendComponentType(scales, coordinates) {\n  // Filter accepts scales.\n  const channels = ['shape', 'size', 'color', 'opacity'];\n  const isConstantSize = (type, name) => type === 'constant' && name === 'size';\n  const accepts = scales.filter(({\n    type,\n    name\n  }) => typeof type === 'string' && channels.includes(name) && !isConstantSize(type, name));\n  // Group scales by fields.\n  const constants = accepts.filter(({\n    type\n  }) => type === 'constant');\n  const nonConstants = accepts.filter(({\n    type\n  }) => type !== 'constant');\n  const groupKey = d => d.field ? d.field : Symbol('independent');\n  const fieldScales = groups(nonConstants, groupKey).map(([key, scales]) => [key, [...scales, ...constants]]).filter(([, scales]) => scales.some(scale => scale.type !== 'constant'));\n  const scalesByField = new Map(fieldScales);\n  // Skip empty scales.\n  if (scalesByField.size === 0) return [];\n  // Infer components.\n  const sort = arr => arr.sort(([a], [b]) => a.localeCompare(b));\n  const components = Array.from(scalesByField).map(([, scs]) => {\n    const combinations = combine(scs).sort((a, b) => b.length - a.length);\n    const options = combinations.map(combination => ({\n      combination,\n      option: combination.map(scale => [scale.name, getScaleType(scale)])\n    }));\n    // For category legend.\n    for (const {\n      option,\n      combination\n    } of options) {\n      // If every scale is constant, do not display legend.\n      if (option.every(d => d[1] === 'constant')) continue;\n      if (option.every(d => d[1] === 'discrete' || d[1] === 'constant')) {\n        return ['legendCategory', combination];\n      }\n    }\n    // For reset legend.\n    // @todo Remove this.\n    for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {\n      for (const {\n        option,\n        combination\n      } of options) {\n        if (accords.some(accord => isEqual(sort(accord), sort(option)))) {\n          return [componentType, combination];\n        }\n      }\n    }\n    return null;\n  }).filter(defined);\n  return components;\n}\nfunction getScaleType(scale) {\n  const {\n    type\n  } = scale;\n  if (typeof type !== 'string') return null;\n  if (type in ContinuousScale) return 'continuous';\n  if (type in DiscreteScale) return 'discrete';\n  if (type in DistributionScale) return 'distribution';\n  if (type in ConstantScale) return 'constant';\n  return null;\n}\nfunction inferAxisComponentType(scales, coordinates) {\n  return scales.map(scale => {\n    const {\n      name\n    } = scale;\n    // todo wait for gui provide helix axis\n    if (isHelix(coordinates) || isTheta(coordinates)) return null;\n    if (isTranspose(coordinates) && (isPolar(coordinates) || isRadial(coordinates))) return null;\n    // infer axis\n    if (name.startsWith('x')) {\n      if (isPolar(coordinates)) return ['axisArc', [scale]];\n      if (isRadial(coordinates)) return ['axisLinear', [scale]];\n      return [isTranspose(coordinates) ? 'axisY' : 'axisX', [scale]];\n    }\n    if (name.startsWith('y')) {\n      if (isPolar(coordinates)) return ['axisLinear', [scale]];\n      if (isRadial(coordinates)) return ['axisArc', [scale]];\n      return [isTranspose(coordinates) ? 'axisX' : 'axisY', [scale]];\n    }\n    // Only support linear axis for z.\n    if (name.startsWith('z')) {\n      return ['axisZ', [scale]];\n    }\n    if (name.startsWith('position')) {\n      if (isRadar(coordinates)) return ['axisRadar', [scale]];\n      if (!isPolar(coordinates)) return ['axisY', [scale]];\n    }\n    return null;\n  }).filter(defined);\n}\nfunction inferComponentsType(scales, coordinates) {\n  const availableScales = scales.filter(scale => isValidScale(scale));\n  return [...inferLegendComponentType(availableScales, coordinates), ...inferAxisComponentType(availableScales, coordinates)];\n}\nfunction angleOf(coordinates) {\n  const polar = coordOf(coordinates, 'polar');\n  if (polar.length) {\n    const lastPolar = polar[polar.length - 1];\n    const {\n      startAngle,\n      endAngle\n    } = getPolarOptions(lastPolar);\n    return [startAngle, endAngle];\n  }\n  const radial = coordOf(coordinates, 'radial');\n  if (radial.length) {\n    const lastRadial = radial[radial.length - 1];\n    const {\n      startAngle,\n      endAngle\n    } = getRadialOptions(lastRadial);\n    return [startAngle, endAngle];\n  }\n  return [-Math.PI / 2, Math.PI / 2 * 3];\n}\n/**\n * match index of position\n */\nfunction matchPosition(name) {\n  const match = /position(\\d*)/g.exec(name);\n  if (!match) return null;\n  return +match[1];\n}\nfunction inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {\n  // a axis only has one scale\n  const {\n    name\n  } = relativeScales[0];\n  // todo, in current resolution, the radar chart is implement by parallel + polar coordinate.\n  // implementation plan to be confirmed.\n  // in current implementation, it must to add the first position encode to it's last.\n  // so we won't render the last axis repeatably.\n  if (type === 'axisRadar') {\n    const positions = scales.filter(scale => scale.name.startsWith('position'));\n    const index = matchPosition(name);\n    if (index === null) return [null, null];\n    // infer radar axis orientation\n    const [startAngle, endAngle] = angleOf(coordinates);\n    const positionLength = isRadar(coordinates) ? positions.length : positions.length - 1;\n    const angle = (endAngle - startAngle) / positionLength * index + startAngle;\n    return ['center', angle];\n  }\n  if (type === 'axisY' && isParallel(coordinates)) {\n    return isTranspose(coordinates) ? ['center', 'horizontal'] : ['center', 'vertical'];\n  }\n  // in non-cartesian coordinate systems, infer the arc axis angle\n  if (type === 'axisLinear') {\n    const [startAngle] = angleOf(coordinates);\n    return ['center', startAngle];\n  }\n  if (type === 'axisArc') {\n    if (ordinalPosition[0] === 'inner') return ['inner', null];\n    return ['outer', null];\n  }\n  if (isPolar(coordinates)) return ['center', null];\n  if (isRadial(coordinates)) return ['center', null];\n  if (type === 'axisX' && isReflect(coordinates) || type === 'axisX' && isReflectY(coordinates)) {\n    return ['top', null];\n  }\n  // if (type === 'axisX') return ['bottom', null];\n  return ordinalPosition;\n}\n// @todo Infer position by coordinates.\nfunction inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {\n  const [startAngle] = angleOf(coordinates);\n  const ordinalPositionAndOrientation = [guide.position || defaultPosition, startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation];\n  if (typeof type === 'string' && type.startsWith('axis')) {\n    return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);\n  }\n  if (typeof type === 'string' && type.startsWith('legend') && isPolar(coordinates)) {\n    if (guide.position === 'center') return ['center', 'vertical'];\n  }\n  // for general component, use default position\n  return ordinalPositionAndOrientation;\n}\nfunction inferScrollableType(name, type, coordinates = []) {\n  if (name === 'x') return isTranspose(coordinates) ? `${type}Y` : `${type}X`;\n  if (name === 'y') return isTranspose(coordinates) ? `${type}X` : `${type}Y`;\n  return null;\n}\n/**\n * Infer scrollable components, such as slider and scrollbar.\n */\nfunction inferScrollableComponents(partialOptions, scales, library) {\n  const [, createGuideComponent] = useLibrary('component', library);\n  const {\n    coordinates\n  } = partialOptions;\n  function normalized(type, channelName, scale, options) {\n    const componentType = inferScrollableType(channelName, type, coordinates);\n    if (!options || !componentType) return;\n    const {\n      props\n    } = createGuideComponent(componentType);\n    const {\n      defaultPosition,\n      defaultSize,\n      defaultOrder,\n      defaultCrossPadding: [crossPadding]\n    } = props;\n    return Object.assign(Object.assign({\n      position: defaultPosition,\n      defaultSize,\n      order: defaultOrder,\n      type: componentType,\n      crossPadding\n    }, options), {\n      scales: [scale]\n    });\n  }\n  return scales.filter(d => d.slider || d.scrollbar).flatMap(scale => {\n    const {\n      slider,\n      scrollbar,\n      name: channelName\n    } = scale;\n    return [normalized('slider', channelName, scale, slider), normalized('scrollbar', channelName, scale, scrollbar)];\n  }).filter(d => !!d);\n}\n// !!! Note Mutate component.size and component.\nexport function computeComponentSize(component, crossSize, crossPadding, position, theme, library) {\n  // Only compute and update size of components in padding area.\n  const {\n    type\n  } = component;\n  const paddingAreas = ['left', 'right', 'bottom', 'top'];\n  if (!paddingAreas.includes(position)) return;\n  if (typeof type !== 'string') return;\n  const t = type;\n  const createCompute = () => {\n    if (t.startsWith('axis')) return computeAxisSize;\n    if (t.startsWith('group')) return computeGroupSize;\n    if (t.startsWith('legendContinuous')) return computeContinuousLegendSize;\n    if (t === 'legendCategory') return computeCategoryLegendSize;\n    if (t.startsWith('slider')) return computeSliderSize;\n    if (t === 'title') return computeTitleSize;\n    if (t.startsWith('scrollbar')) return computeScrollbarSize;\n    return () => {};\n  };\n  return createCompute()(component, crossSize, crossPadding, position, theme, library);\n}\nfunction computeGroupSize(component, crossSize, crossPadding, position, theme, library) {\n  const {\n    children\n  } = component;\n  const maxCrossPadding = max(children, d => d.crossPadding);\n  children.forEach(d => d.crossPadding = maxCrossPadding);\n  children.forEach(child => computeComponentSize(child, crossSize, crossPadding, position, theme, library));\n  const maxSize = max(children, d => d.size);\n  component.size = maxSize;\n  children.forEach(d => d.size = maxSize);\n}\nfunction computeScrollbarSize(component, crossSize, crossPadding, position, theme, library) {\n  const {\n    trackSize = 6\n  } = deepMix({}, theme.scrollbar, component);\n  component.size = trackSize;\n}\nfunction computeTitleSize(component, crossSize, crossPadding, position, theme, library) {\n  const _a = deepMix({}, theme.title, component),\n    {\n      title,\n      subtitle,\n      spacing = 0\n    } = _a,\n    style = __rest(_a, [\"title\", \"subtitle\", \"spacing\"]);\n  if (title) {\n    const titleStyle = subObject(style, 'title');\n    const titleBBox = computeLabelSize(title, titleStyle);\n    component.size = titleBBox.height;\n  }\n  if (subtitle) {\n    const subtitleStyle = subObject(style, 'subtitle');\n    const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);\n    component.size += spacing + subtitleBBox.height;\n  }\n}\nfunction computeSliderSize(component, crossSize, crossPadding, position, theme, library) {\n  const styleOf = () => {\n    const {\n      slider\n    } = theme;\n    return deepMix({}, slider, component);\n  };\n  const {\n    trackSize,\n    handleIconSize\n  } = styleOf();\n  const size = Math.max(trackSize, handleIconSize * 2.4);\n  component.size = size;\n}\nfunction computeAxisSize(component, crossSize, crossPadding, position, theme, library) {\n  var _a;\n  // If padding is auto, use hide as the labelTransform by default\n  // to avoid overlap between labels.\n  component.transform = component.transform || [{\n    type: 'hide'\n  }];\n  // Vertical or horizontal.\n  const isVertical = position === 'left' || position === 'right';\n  // Get styles to be applied.\n  const style = styleOf(component, position, theme);\n  const {\n      tickLength = 0,\n      labelSpacing = 0,\n      titleSpacing = 0,\n      labelAutoRotate\n    } = style,\n    rest = __rest(style, [\"tickLength\", \"labelSpacing\", \"titleSpacing\", \"labelAutoRotate\"]);\n  // Compute Labels.\n  const scale = createScale(component, library);\n  const labelBBoxes = computeLabelsBBox(rest, scale);\n  const paddingTick = tickLength + labelSpacing;\n  if (labelBBoxes && labelBBoxes.length) {\n    const maxLabelWidth = max(labelBBoxes, d => d.width);\n    const maxLabelHeight = max(labelBBoxes, d => d.height);\n    if (isVertical) {\n      component.size = maxLabelWidth + paddingTick;\n    } else {\n      const {\n        tickFilter,\n        labelTransform\n      } = component;\n      // If the labels can't be placed horizontally, and labelTransform is unset,\n      // rotate 90 deg to display them.\n      if (overflowX(scale, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {\n        component.labelTransform = 'rotate(90)';\n        component.size = maxLabelWidth + paddingTick;\n      } else {\n        component.labelTransform = (_a = component.labelTransform) !== null && _a !== void 0 ? _a : 'rotate(0)';\n        component.size = maxLabelHeight + paddingTick;\n      }\n    }\n  } else {\n    component.size = tickLength;\n  }\n  // Compute title.\n  const titleBBox = computeTitleBBox(rest);\n  if (titleBBox) {\n    if (isVertical) {\n      component.size += titleSpacing + titleBBox.width;\n    } else {\n      component.size += titleSpacing + titleBBox.height;\n    }\n  }\n}\nfunction computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library) {\n  // Get styles.\n  const styleOf = () => {\n    const {\n      legendContinuous\n    } = theme;\n    return deepMix({}, legendContinuous, component);\n  };\n  const _a = styleOf(),\n    {\n      labelSpacing = 0,\n      titleSpacing = 0\n    } = _a,\n    rest = __rest(_a, [\"labelSpacing\", \"titleSpacing\"]);\n  // Vertical or horizontal.\n  const isVertical = position === 'left' || position === 'right';\n  // Ribbon styles.\n  const ribbonStyles = subObject(rest, 'ribbon');\n  const {\n    size: ribbonSize\n  } = ribbonStyles;\n  const handleIconStyles = subObject(rest, 'handleIcon');\n  const {\n    size: handleIconSize\n  } = handleIconStyles;\n  const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);\n  component.size = mainSize;\n  // Compute labels.\n  const scale = createScale(component, library);\n  const labelBBoxes = computeLabelsBBox(rest, scale);\n  if (labelBBoxes) {\n    const key = isVertical ? 'width' : 'height';\n    const size = max(labelBBoxes, d => d[key]);\n    component.size += size + labelSpacing;\n  }\n  // Compute title.\n  const titleBBox = computeTitleBBox(rest);\n  if (titleBBox) {\n    if (isVertical) {\n      component.size = Math.max(component.size, titleBBox.width);\n    } else {\n      component.size += titleSpacing + titleBBox.height;\n    }\n  }\n}\nfunction computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library) {\n  const styleOf = () => {\n    const {\n      legendCategory\n    } = theme;\n    const {\n      title\n    } = component;\n    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, undefined] : [undefined, title];\n    return deepMix({\n      title: defaultTitle\n    }, legendCategory, Object.assign(Object.assign({}, component), {\n      title: specifiedTitle\n    }));\n  };\n  const _a = styleOf(),\n    {\n      itemSpacing,\n      itemMarkerSize,\n      titleSpacing,\n      rowPadding,\n      colPadding,\n      maxCols = Infinity,\n      maxRows = Infinity\n    } = _a,\n    rest = __rest(_a, [\"itemSpacing\", \"itemMarkerSize\", \"titleSpacing\", \"rowPadding\", \"colPadding\", \"maxCols\", \"maxRows\"]);\n  const {\n    cols,\n    length\n  } = component;\n  const getRows = rows => Math.min(rows, maxRows);\n  const getCols = cols => Math.min(cols, maxCols);\n  // Vertical or horizontal.\n  const isVertical = position === 'left' || position === 'right';\n  const crossSize = length === undefined ? crossSize0 + (isVertical ? 0 : crossPadding[0] + crossPadding[1]) : length;\n  // Compute title.\n  const titleBBox = computeTitleBBox(rest);\n  const scale = createScale(component, library);\n  const labelBBoxes = computeLabelsBBox(rest, scale, 'itemLabel');\n  const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;\n  const widthOf = (w, padding = 0) => itemMarkerSize + w + itemSpacing[0] + padding;\n  // Only support grid layout for vertical area.\n  const computeVerticalSize = () => {\n    let maxSize = -Infinity;\n    let pos = 0;\n    let cols = 1;\n    let rows = 0;\n    let maxRows = -Infinity;\n    let maxPos = -Infinity;\n    const titleHeight = titleBBox ? titleBBox.height : 0;\n    const maxHeight = crossSize - titleHeight;\n    for (const {\n      width\n    } of labelBBoxes) {\n      const w = widthOf(width, colPadding);\n      maxSize = Math.max(maxSize, w);\n      if (pos + height > maxHeight) {\n        cols++;\n        maxRows = Math.max(maxRows, rows);\n        maxPos = Math.max(maxPos, pos);\n        rows = 1;\n        pos = height;\n      } else {\n        pos += height;\n        rows++;\n      }\n    }\n    if (cols <= 1) {\n      maxRows = rows;\n      maxPos = pos;\n    }\n    component.size = maxSize * getCols(cols);\n    component.length = maxPos + titleHeight;\n    deepMix(component, {\n      cols: getCols(cols),\n      gridRow: maxRows\n    });\n  };\n  // Horizontal grid layout.\n  const computeHorizontalGrid = () => {\n    const rows = Math.ceil(labelBBoxes.length / cols);\n    const maxWidth = max(labelBBoxes, d => widthOf(d.width)) * cols;\n    component.size = height * getRows(rows) - rowPadding;\n    component.length = Math.min(maxWidth, crossSize);\n  };\n  // Horizontal flex layout.\n  const computeHorizontalFlex = () => {\n    let rows = 1;\n    let pos = 0;\n    let maxPos = -Infinity;\n    for (const {\n      width\n    } of labelBBoxes) {\n      const w = widthOf(width, colPadding);\n      if (pos + w > crossSize) {\n        maxPos = Math.max(maxPos, pos);\n        pos = w;\n        rows++;\n      } else {\n        pos += w;\n      }\n    }\n    if (rows === 1) maxPos = pos;\n    component.size = height * getRows(rows) - rowPadding;\n    component.length = maxPos;\n  };\n  if (isVertical) computeVerticalSize();else if (typeof cols === 'number') computeHorizontalGrid();else computeHorizontalFlex();\n  // Compute titles.\n  if (titleBBox) {\n    if (isVertical) {\n      component.size = Math.max(component.size, titleBBox.width);\n    } else {\n      component.size += titleSpacing + titleBBox.height;\n    }\n  }\n}\nexport function createScale(component, library) {\n  const [useScale] = useLibrary('scale', library);\n  // Init scale, the tickCount of axis has higher priority than scale.\n  const {\n    scales,\n    tickCount,\n    tickMethod\n  } = component;\n  const scaleOptions = scales.find(d => d.type !== 'constant' && d.type !== 'identity');\n  if (tickCount !== undefined) scaleOptions.tickCount = tickCount;\n  if (tickMethod !== undefined) scaleOptions.tickMethod = tickMethod;\n  return useScale(scaleOptions);\n}\nexport function computeLabelsBBox(component, scale, key = 'label') {\n  const {\n      labelFormatter,\n      tickFilter,\n      label = true\n    } = component,\n    style = __rest(component, [\"labelFormatter\", \"tickFilter\", \"label\"]);\n  if (!label) return null;\n  // Get labels to be rendered.\n  const labels = labelsOf(scale, labelFormatter, tickFilter);\n  const labelStyle = subObject(style, key);\n  const labelStyles = labels.map((d, i) => Object.fromEntries(Object.entries(labelStyle).map(([key, value]) => [key, typeof value === 'function' ? value(d, i) : value])));\n  const labelBBoxes = labels.map((d, i) => {\n    const normalizeStyle = labelStyles[i];\n    return computeLabelSize(d, normalizeStyle);\n  });\n  // Cache boxes to avoid computed twice.\n  // @todo GUI use untransformed bbox, so it can't cache if\n  // label.style has transform attributes.\n  const hasTransform = labelStyles.some(d => d.transform);\n  if (!hasTransform) {\n    const I = labels.map((_, i) => i);\n    component.indexBBox = new Map(I.map(i => [i, [labels[i], labelBBoxes[i]]]));\n  }\n  return labelBBoxes;\n}\nexport function computeTitleBBox(component) {\n  const isFalsy = x => x === false || x === null;\n  const {\n      title\n    } = component,\n    style = __rest(component, [\"title\"]);\n  if (isFalsy(title) || title === undefined) return null;\n  const titleStyle = subObject(style, 'title');\n  const {\n    direction,\n    transform\n  } = titleStyle;\n  const titleText = Array.isArray(title) ? title.join(',') : title;\n  if (typeof titleText !== 'string') return null;\n  const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), {\n    transform: transform || (direction === 'vertical' ? 'rotate(-90)' : '')\n  }));\n  return titleBBox;\n}\nexport function styleOf(axis, position, theme) {\n  const {\n    title\n  } = axis;\n  const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, undefined] : [undefined, title];\n  const {\n    axis: baseStyle,\n    // @ts-ignore\n    [`axis${capitalizeFirst(position)}`]: positionStyle\n  } = theme;\n  return deepMix({\n    title: defaultTitle\n  }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), {\n    title: specifiedTitle\n  }));\n}\nfunction ticksOf(scale, tickFilter) {\n  const ticks = scale.getTicks ? scale.getTicks() : scale.getOptions().domain;\n  if (!tickFilter) return ticks;\n  return ticks.filter(tickFilter);\n}\nfunction labelsOf(scale, labelFormatter, tickFilter) {\n  const T = ticksOf(scale, tickFilter);\n  const ticks = T.map(d => typeof d === 'number' ? prettyNumber(d) : d);\n  const formatter = labelFormatter ? typeof labelFormatter === 'string' ? format(labelFormatter) : labelFormatter : scale.getFormatter ? scale.getFormatter() : d => `${d}`;\n  return ticks.map(formatter);\n}\nfunction offsetOf(scale, d) {\n  if (!scale.getBandWidth) return 0;\n  const offset = scale.getBandWidth(d) / 2;\n  return offset;\n}\nfunction overflowX(scale, labelBBoxes, crossSize, crossPadding, tickFilter) {\n  // If actual size bigger than container size, overflow.\n  const totalSize = sum(labelBBoxes, d => d.width);\n  if (totalSize > crossSize) return true;\n  // Clone scale to get visual position for labels.\n  const scaleX = scale.clone();\n  scaleX.update({\n    range: [0, crossSize]\n  });\n  const ticks = ticksOf(scale, tickFilter);\n  const X = ticks.map(d => scaleX.map(d) + offsetOf(scaleX, d));\n  const I = ticks.map((_, i) => i);\n  const startX = -crossPadding[0];\n  const endX = crossSize + crossPadding[1];\n  const extent = (x, bbox) => {\n    const {\n      width\n    } = bbox;\n    return [x - width / 2, x + width / 2];\n  };\n  // Collision detection.\n  for (let i = 0; i < I.length; i++) {\n    const x = X[i];\n    const [x0, x1] = extent(x, labelBBoxes[i]);\n    // If a label is out of plot area, overflow.\n    if (x0 < startX || x1 > endX) return true;\n    const y = X[i + 1];\n    if (y) {\n      // If two labels intersect, overflow.\n      const [y0] = extent(y, labelBBoxes[i + 1]);\n      if (x1 > y0) return true;\n    }\n  }\n  return false;\n}\nfunction computeLabelSize(d, style) {\n  const shape = normalizeLabel(d);\n  const {\n      filter\n    } = style,\n    rest = __rest(style, [\"filter\"]);\n  shape.attr(Object.assign(Object.assign({}, rest), {\n    visibility: 'none'\n  }));\n  const bbox = shape.getBBox();\n  return bbox;\n}\nfunction normalizeLabel(d) {\n  if (d instanceof DisplayObject) return d;\n  return new Text({\n    style: {\n      text: `${d}`\n    }\n  });\n}","map":{"version":3,"names":["deepMix","isEqual","groups","max","sum","format","DisplayObject","Text","getPolarOptions","getRadialOptions","combine","prettyNumber","capitalizeFirst","defined","subObject","LEGEND_INFER_STRATEGIES","coordOf","isHelix","isParallel","isPolar","isRadar","isRadial","isReflect","isReflectY","isTheta","isTranspose","useLibrary","isValidScale","ConstantScale","ContinuousScale","DiscreteScale","DistributionScale","inferComponent","scales","partialOptions","library","coordinates","title","createGuideComponent","displayedScales","filter","guide","components","sliders","inferScrollableComponents","push","props","defaultPosition","defaultOrientation","defaultOrder","defaultSize","defaultCrossPadding","titleOptions","Object","assign","type","position","orientation","order","crossPadding","inferredComponents","inferComponentsType","forEach","relativeScales","defaultPlane","defaultLength","defaultPadding","DP","DCP","scale","guideOptions","field","guides","Array","isArray","partialGuide","inferComponentPositionAndOrientation","isVertical","size","length","padding","plane","renderComponent","component","coordinate","theme","markState","useGuideComponent","scaleInstances","bbox","options","__rest","value","render","normalizeComponents","map","d","style","flatComponents","flatMap","children","groupComponents","crossSize","P","key","group","includes","Symbol","undefined","startsWith","grouped","DL","totalLength","emptyLength","emptyCount","inferLegendComponentType","channels","isConstantSize","name","accepts","constants","nonConstants","groupKey","fieldScales","some","scalesByField","Map","sort","arr","a","b","localeCompare","from","scs","combinations","combination","option","getScaleType","every","componentType","accords","accord","inferAxisComponentType","availableScales","angleOf","polar","lastPolar","startAngle","endAngle","radial","lastRadial","Math","PI","matchPosition","match","exec","inferAxisPositionAndOrientation","ordinalPosition","positions","index","positionLength","angle","ordinalPositionAndOrientation","inferScrollableType","normalized","channelName","slider","scrollbar","computeComponentSize","paddingAreas","t","createCompute","computeAxisSize","computeGroupSize","computeContinuousLegendSize","computeCategoryLegendSize","computeSliderSize","computeTitleSize","computeScrollbarSize","maxCrossPadding","child","maxSize","trackSize","_a","subtitle","spacing","titleStyle","titleBBox","computeLabelSize","height","subtitleStyle","subtitleBBox","styleOf","handleIconSize","transform","tickLength","labelSpacing","titleSpacing","labelAutoRotate","rest","createScale","labelBBoxes","computeLabelsBBox","paddingTick","maxLabelWidth","width","maxLabelHeight","tickFilter","labelTransform","overflowX","computeTitleBBox","legendContinuous","ribbonStyles","ribbonSize","handleIconStyles","mainSize","crossSize0","legendCategory","defaultTitle","specifiedTitle","itemSpacing","itemMarkerSize","rowPadding","colPadding","maxCols","Infinity","maxRows","cols","getRows","rows","min","getCols","widthOf","w","computeVerticalSize","pos","maxPos","titleHeight","maxHeight","gridRow","computeHorizontalGrid","ceil","maxWidth","computeHorizontalFlex","useScale","tickCount","tickMethod","scaleOptions","find","labelFormatter","label","labels","labelsOf","labelStyle","labelStyles","i","fromEntries","entries","normalizeStyle","hasTransform","I","_","indexBBox","isFalsy","x","direction","titleText","join","axis","baseStyle","positionStyle","ticksOf","ticks","getTicks","getOptions","domain","T","formatter","getFormatter","offsetOf","getBandWidth","offset","totalSize","scaleX","clone","update","range","X","startX","endX","extent","x0","x1","y","y0","shape","normalizeLabel","attr","visibility","getBBox","text"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/runtime/component.ts"],"sourcesContent":["/**\n * @see https://github.com/antvis/G2/discussions/4557\n */\nimport { Coordinate } from '@antv/coord';\nimport { deepMix, isEqual } from '@antv/util';\nimport { groups, max, sum } from '@antv/vendor/d3-array';\nimport { format } from '@antv/vendor/d3-format';\nimport { DisplayObject, Text } from '@antv/g';\nimport {\n  getPolarOptions,\n  getRadialOptions,\n  type PolarOptions,\n  type RadialOptions,\n} from '../coordinate';\nimport { combine } from '../utils/array';\nimport { prettyNumber } from '../utils/number';\nimport { capitalizeFirst, defined, subObject } from '../utils/helper';\nimport { LEGEND_INFER_STRATEGIES } from '../component/constant';\nimport {\n  coordOf,\n  isHelix,\n  isParallel,\n  isPolar,\n  isRadar,\n  isRadial,\n  isReflect,\n  isReflectY,\n  isTheta,\n  isTranspose,\n} from './coordinate';\nimport { useLibrary } from './library';\nimport { isValidScale } from './scale';\nimport {\n  G2MarkState,\n  G2Theme,\n  GuideComponentOrientation as GCO,\n  GuideComponentPosition as GCP,\n} from './types/common';\nimport {\n  GuideComponent,\n  GuideComponentComponent as GCC,\n  ScaleComponent,\n  Scale,\n} from './types/component';\nimport {\n  G2CoordinateOptions,\n  G2GuideComponentOptions,\n  G2Library,\n  G2Mark,\n  G2ScaleOptions,\n  G2View,\n} from './types/options';\nimport {\n  ConstantScale,\n  ContinuousScale,\n  DiscreteScale,\n  DistributionScale,\n} from './types/scale';\n\nexport function inferComponent(\n  scales: G2ScaleOptions[],\n  partialOptions: G2View,\n  library: G2Library,\n): G2GuideComponentOptions[] {\n  const { coordinates = [], title } = partialOptions;\n  const [, createGuideComponent] = useLibrary<\n    G2GuideComponentOptions,\n    GCC,\n    GuideComponent\n  >('component', library);\n\n  const displayedScales = scales.filter(({ guide }) => {\n    if (guide === null) return false;\n    return true;\n  });\n\n  const components = [];\n\n  // Sliders and scrollbar component.\n  const sliders = inferScrollableComponents(partialOptions, scales, library);\n  components.push(...sliders);\n\n  // Title components.\n  if (title) {\n    const { props } = createGuideComponent('title');\n    const {\n      defaultPosition,\n      defaultOrientation,\n      defaultOrder,\n      defaultSize,\n      defaultCrossPadding,\n    } = props;\n    const titleOptions = typeof title === 'string' ? { title } : title;\n    components.push({\n      type: 'title',\n      position: defaultPosition,\n      orientation: defaultOrientation,\n      order: defaultOrder,\n      crossPadding: defaultCrossPadding[0],\n      defaultSize,\n      ...titleOptions,\n    });\n  }\n\n  // Axis and legends.\n  const inferredComponents = inferComponentsType(displayedScales, coordinates);\n\n  inferredComponents.forEach(([type, relativeScales]) => {\n    const { props } = createGuideComponent(type);\n    const {\n      defaultPosition,\n      defaultPlane = 'xy',\n      defaultOrientation,\n      defaultSize,\n      defaultOrder,\n      defaultLength,\n      defaultPadding: DP = [0, 0],\n      defaultCrossPadding: DCP = [0, 0],\n    } = props;\n    // @todo to be confirm if the scale can be merged.\n    // const scale: G2ScaleOptions = Object.assign({}, ...relativeScales);\n    const scale: G2ScaleOptions = deepMix({}, ...relativeScales);\n    const { guide: guideOptions, field } = scale;\n    // A scale may have multiple guides.\n    const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];\n    for (const partialGuide of guides) {\n      const [position, orientation] = inferComponentPositionAndOrientation(\n        type,\n        defaultPosition,\n        defaultOrientation,\n        partialGuide,\n        relativeScales,\n        displayedScales,\n        coordinates,\n      );\n\n      // Skip if position and orientation are not specified.\n      // @example the last axis of radar chart\n      if (!position && !orientation) continue;\n\n      const isVertical = position === 'left' || position === 'right';\n      const defaultPadding = isVertical ? DP[1] : DP[0];\n      const defaultCrossPadding = isVertical ? DCP[1] : DCP[0];\n\n      const {\n        size,\n        order = defaultOrder,\n        length = defaultLength,\n        padding = defaultPadding,\n        crossPadding = defaultCrossPadding,\n      } = partialGuide;\n\n      components.push({\n        title: field,\n        ...partialGuide,\n        defaultSize,\n        length,\n        position,\n        plane: defaultPlane,\n        orientation,\n        padding,\n        order,\n        crossPadding,\n        size,\n        type,\n        scales: relativeScales,\n      });\n    }\n  });\n\n  return components;\n}\n\nexport function renderComponent(\n  component: G2GuideComponentOptions,\n  coordinate: Coordinate,\n  theme: G2Theme,\n  library: G2Library,\n  markState: Map<G2Mark, G2MarkState>,\n) {\n  const [useGuideComponent] = useLibrary<\n    G2GuideComponentOptions,\n    GCC,\n    GuideComponent\n  >('component', library);\n  const { scaleInstances: scales, scale, bbox, ...options } = component;\n  const value = { bbox, library };\n  const render = useGuideComponent(options);\n  return render({\n    coordinate,\n    library,\n    markState,\n    scales,\n    theme,\n    value,\n    scale,\n  });\n}\n\nexport function normalizeComponents(components: G2GuideComponentOptions[]) {\n  return components.map((d) => {\n    const component = deepMix(d, d.style);\n    delete component.style;\n    return component;\n  });\n}\n\nexport function flatComponents(\n  components: G2GuideComponentOptions[],\n): G2GuideComponentOptions[] {\n  return components.flatMap((d) => (d.type == 'group' ? d.children : d));\n}\n\n// Wrap legends into a group component.\nexport function groupComponents(\n  components: G2GuideComponentOptions[],\n  crossSize?: number,\n): G2GuideComponentOptions[] {\n  // Group components by key.\n  const P = ['left', 'right', 'bottom', 'top'];\n  const key = ({ type, position, group }) => {\n    if (!P.includes(position)) return Symbol('independent');\n    if (group === undefined) {\n      if (type.startsWith('legend')) return `legend-${position}`;\n      return Symbol('independent');\n    }\n    if (group === 'independent') return Symbol('independent');\n    return group;\n  };\n  const grouped = groups(components, key);\n\n  // Update attributes of group components,\n  // and maybe flatten group components without enough room.\n  return grouped.flatMap(([, components]) => {\n    if (components.length === 1) return components[0];\n\n    // If crossSize defined, group components only when has\n    // enough room.\n    if (crossSize !== undefined) {\n      // Compute total length.\n      const DL = components\n        .filter((d) => d.length !== undefined)\n        .map((d) => d.length);\n      const totalLength = sum(DL);\n\n      // If there is no enough room for components,\n      // do not group.\n      if (totalLength > crossSize) {\n        components.forEach((d) => (d.group = Symbol('independent')));\n        return components;\n      }\n\n      // Group legends and update legend length.\n      const emptyLength = crossSize - totalLength;\n      const emptyCount = components.length - DL.length;\n      const length = emptyLength / emptyCount;\n      components.forEach((d) => {\n        if (d.length !== undefined) return;\n        d.length = length;\n      });\n    }\n\n    // Create a group component.\n    const size = max(components, (d) => d.size);\n    const order = max(components, (d) => d.order);\n    const crossPadding = max(components, (d) => d.crossPadding);\n    const position = components[0].position;\n    return {\n      type: 'group',\n      size,\n      order,\n      position,\n      children: components,\n      crossPadding,\n    };\n  });\n}\n\nfunction inferLegendComponentType(\n  scales: G2ScaleOptions[],\n  coordinates: G2CoordinateOptions[],\n) {\n  // Filter accepts scales.\n  const channels = ['shape', 'size', 'color', 'opacity'];\n  const isConstantSize = (type, name) => type === 'constant' && name === 'size';\n  const accepts = scales.filter(\n    ({ type, name }) =>\n      typeof type === 'string' &&\n      channels.includes(name) &&\n      !isConstantSize(type, name), // Do not support constant size scale.\n  );\n\n  // Group scales by fields.\n  const constants = accepts.filter(({ type }) => type === 'constant');\n  const nonConstants = accepts.filter(({ type }) => type !== 'constant');\n  const groupKey = (d) => (d.field ? d.field : Symbol('independent'));\n  const fieldScales = groups(nonConstants, groupKey)\n    .map(([key, scales]) => [key, [...scales, ...constants]] as const)\n    .filter(([, scales]) => scales.some((scale) => scale.type !== 'constant'));\n  const scalesByField = new Map(fieldScales) as Map<string, G2ScaleOptions[]>;\n\n  // Skip empty scales.\n  if (scalesByField.size === 0) return [];\n\n  // Infer components.\n  const sort = (arr: string[][]) => arr.sort(([a], [b]) => a.localeCompare(b));\n  const components = Array.from(scalesByField)\n    .map(([, scs]) => {\n      const combinations = combine(scs).sort((a, b) => b.length - a.length);\n      const options = combinations.map((combination) => ({\n        combination,\n        option: combination.map((scale) => [scale.name, getScaleType(scale)]),\n      }));\n\n      // For category legend.\n      for (const { option, combination } of options) {\n        // If every scale is constant, do not display legend.\n        if (option.every((d) => d[1] === 'constant')) continue;\n        if (option.every((d) => d[1] === 'discrete' || d[1] === 'constant')) {\n          return ['legendCategory', combination] as [string, G2ScaleOptions[]];\n        }\n      }\n\n      // For reset legend.\n      // @todo Remove this.\n      for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {\n        for (const { option, combination } of options) {\n          if (accords.some((accord) => isEqual(sort(accord), sort(option)))) {\n            return [componentType, combination] as [string, G2ScaleOptions[]];\n          }\n        }\n      }\n      return null;\n    })\n    .filter(defined);\n\n  return components;\n}\n\nfunction getScaleType(scale: G2ScaleOptions): string {\n  const { type } = scale;\n  if (typeof type !== 'string') return null;\n  if (type in ContinuousScale) return 'continuous';\n  if (type in DiscreteScale) return 'discrete';\n  if (type in DistributionScale) return 'distribution';\n  if (type in ConstantScale) return 'constant';\n  return null;\n}\n\nfunction inferAxisComponentType(\n  scales: G2ScaleOptions[],\n  coordinates: G2CoordinateOptions[],\n) {\n  return scales\n    .map((scale) => {\n      const { name } = scale;\n      // todo wait for gui provide helix axis\n      if (isHelix(coordinates) || isTheta(coordinates)) return null;\n      if (\n        isTranspose(coordinates) &&\n        (isPolar(coordinates) || isRadial(coordinates))\n      )\n        return null;\n      // infer axis\n      if (name.startsWith('x')) {\n        if (isPolar(coordinates)) return ['axisArc', [scale]];\n        if (isRadial(coordinates)) return ['axisLinear', [scale]];\n        return [isTranspose(coordinates) ? 'axisY' : 'axisX', [scale]];\n      }\n      if (name.startsWith('y')) {\n        if (isPolar(coordinates)) return ['axisLinear', [scale]];\n        if (isRadial(coordinates)) return ['axisArc', [scale]];\n        return [isTranspose(coordinates) ? 'axisX' : 'axisY', [scale]];\n      }\n      // Only support linear axis for z.\n      if (name.startsWith('z')) {\n        return ['axisZ', [scale]];\n      }\n      if (name.startsWith('position')) {\n        if (isRadar(coordinates)) return ['axisRadar', [scale]];\n        if (!isPolar(coordinates)) return ['axisY', [scale]];\n      }\n      return null;\n    })\n    .filter(defined) as [string | GCC, G2ScaleOptions[]][];\n}\n\nfunction inferComponentsType(\n  scales: G2ScaleOptions[],\n  coordinates: G2CoordinateOptions[],\n): [string | GCC, G2ScaleOptions[]][] {\n  const availableScales = scales.filter((scale) => isValidScale(scale));\n  return [\n    ...inferLegendComponentType(availableScales, coordinates),\n    ...inferAxisComponentType(availableScales, coordinates),\n  ];\n}\n\nfunction angleOf(coordinates: G2CoordinateOptions[]) {\n  const polar = coordOf(coordinates, 'polar');\n  if (polar.length) {\n    const lastPolar = polar[polar.length - 1] as PolarOptions;\n    const { startAngle, endAngle } = getPolarOptions(lastPolar);\n    return [startAngle, endAngle];\n  }\n  const radial = coordOf(coordinates, 'radial') as RadialOptions[];\n  if (radial.length) {\n    const lastRadial = radial[radial.length - 1];\n    const { startAngle, endAngle } = getRadialOptions(lastRadial);\n    return [startAngle, endAngle];\n  }\n  return [-Math.PI / 2, (Math.PI / 2) * 3];\n}\n\n/**\n * match index of position\n */\nfunction matchPosition(name: string) {\n  const match = /position(\\d*)/g.exec(name);\n  if (!match) return null;\n  return +match[1];\n}\n\nfunction inferAxisPositionAndOrientation(\n  type: string,\n  ordinalPosition: [GCP, GCO],\n  relativeScales: G2ScaleOptions[],\n  scales: G2ScaleOptions[],\n  coordinates: G2CoordinateOptions[],\n): [GCP, GCO] {\n  // a axis only has one scale\n  const { name } = relativeScales[0];\n  // todo, in current resolution, the radar chart is implement by parallel + polar coordinate.\n  // implementation plan to be confirmed.\n  // in current implementation, it must to add the first position encode to it's last.\n  // so we won't render the last axis repeatably.\n  if (type === 'axisRadar') {\n    const positions = scales.filter((scale) =>\n      scale.name.startsWith('position'),\n    );\n    const index = matchPosition(name);\n    if (index === null) return [null, null];\n    // infer radar axis orientation\n    const [startAngle, endAngle] = angleOf(coordinates);\n    const positionLength = isRadar(coordinates)\n      ? positions.length\n      : positions.length - 1;\n    const angle =\n      ((endAngle - startAngle) / positionLength) * index + startAngle;\n    return ['center', angle];\n  }\n\n  if (type === 'axisY' && isParallel(coordinates)) {\n    return isTranspose(coordinates)\n      ? ['center', 'horizontal']\n      : ['center', 'vertical'];\n  }\n\n  // in non-cartesian coordinate systems, infer the arc axis angle\n  if (type === 'axisLinear') {\n    const [startAngle] = angleOf(coordinates);\n    return ['center', startAngle];\n  }\n\n  if (type === 'axisArc') {\n    if (ordinalPosition[0] === 'inner') return ['inner', null];\n    return ['outer', null];\n  }\n\n  if (isPolar(coordinates)) return ['center', null];\n  if (isRadial(coordinates)) return ['center', null];\n  if (\n    (type === 'axisX' && isReflect(coordinates)) ||\n    (type === 'axisX' && isReflectY(coordinates))\n  ) {\n    return ['top', null];\n  }\n\n  // if (type === 'axisX') return ['bottom', null];\n  return ordinalPosition;\n}\n\n// @todo Infer position by coordinates.\nfunction inferComponentPositionAndOrientation(\n  type: string | GCC,\n  defaultPosition: GCP,\n  defaultOrientation: GCO,\n  guide: G2GuideComponentOptions,\n  relativeScales: G2ScaleOptions[],\n  scales: G2ScaleOptions[],\n  coordinates: G2CoordinateOptions[],\n): [GCP, GCO] {\n  const [startAngle] = angleOf(coordinates);\n  const ordinalPositionAndOrientation: [GCP, GCO] = [\n    guide.position || defaultPosition,\n    startAngle ?? defaultOrientation,\n  ];\n\n  if (typeof type === 'string' && type.startsWith('axis')) {\n    return inferAxisPositionAndOrientation(\n      type,\n      ordinalPositionAndOrientation,\n      relativeScales,\n      scales,\n      coordinates,\n    );\n  }\n\n  if (\n    typeof type === 'string' &&\n    type.startsWith('legend') &&\n    isPolar(coordinates)\n  ) {\n    if (guide.position === 'center') return ['center', 'vertical'];\n  }\n  // for general component, use default position\n  return ordinalPositionAndOrientation;\n}\n\nfunction inferScrollableType(name: string, type: string, coordinates = []) {\n  if (name === 'x') return isTranspose(coordinates) ? `${type}Y` : `${type}X`;\n  if (name === 'y') return isTranspose(coordinates) ? `${type}X` : `${type}Y`;\n  return null;\n}\n\n/**\n * Infer scrollable components, such as slider and scrollbar.\n */\nfunction inferScrollableComponents(\n  partialOptions: G2View,\n  scales: G2ScaleOptions[],\n  library: G2Library,\n): G2GuideComponentOptions[] {\n  const [, createGuideComponent] = useLibrary<\n    G2GuideComponentOptions,\n    GCC,\n    GuideComponent\n  >('component', library);\n\n  const { coordinates } = partialOptions;\n\n  function normalized(\n    type: string,\n    channelName: string,\n    scale: G2ScaleOptions,\n    options: Record<string, any>,\n  ) {\n    const componentType = inferScrollableType(channelName, type, coordinates);\n    if (!options || !componentType) return;\n\n    const { props } = createGuideComponent(componentType);\n    const {\n      defaultPosition,\n      defaultSize,\n      defaultOrder,\n      defaultCrossPadding: [crossPadding],\n    } = props;\n    return {\n      position: defaultPosition,\n      defaultSize,\n      order: defaultOrder,\n      type: componentType,\n      crossPadding,\n      ...options,\n      scales: [scale],\n    };\n  }\n  return scales\n    .filter((d) => d.slider || d.scrollbar)\n    .flatMap((scale) => {\n      const { slider, scrollbar, name: channelName } = scale;\n      return [\n        normalized('slider', channelName, scale, slider),\n        normalized('scrollbar', channelName, scale, scrollbar),\n      ];\n    })\n    .filter((d) => !!d);\n}\n\n// !!! Note Mutate component.size and component.\nexport function computeComponentSize(\n  component: G2GuideComponentOptions,\n  crossSize: number,\n  crossPadding: [number, number],\n  position: GCP,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  // Only compute and update size of components in padding area.\n  const { type } = component;\n  const paddingAreas = ['left', 'right', 'bottom', 'top'];\n  if (!paddingAreas.includes(position)) return;\n  if (typeof type !== 'string') return;\n  const t = type as unknown as string;\n  const createCompute = () => {\n    if (t.startsWith('axis')) return computeAxisSize;\n    if (t.startsWith('group')) return computeGroupSize;\n    if (t.startsWith('legendContinuous')) return computeContinuousLegendSize;\n    if (t === 'legendCategory') return computeCategoryLegendSize;\n    if (t.startsWith('slider')) return computeSliderSize;\n    if (t === 'title') return computeTitleSize;\n    if (t.startsWith('scrollbar')) return computeScrollbarSize;\n    return () => {};\n  };\n  return createCompute()(\n    component,\n    crossSize,\n    crossPadding,\n    position,\n    theme,\n    library,\n  );\n}\n\nfunction computeGroupSize(\n  component: G2GuideComponentOptions,\n  crossSize: number,\n  crossPadding: [number, number],\n  position: GCP,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const { children } = component;\n  const maxCrossPadding = max(\n    children,\n    (d: G2GuideComponentOptions) => d.crossPadding,\n  );\n  children.forEach((d) => (d.crossPadding = maxCrossPadding));\n  children.forEach((child) =>\n    computeComponentSize(\n      child,\n      crossSize,\n      crossPadding,\n      position,\n      theme,\n      library,\n    ),\n  );\n  const maxSize = max(children, (d: G2GuideComponentOptions) => d.size);\n  component.size = maxSize;\n  children.forEach((d) => (d.size = maxSize));\n}\n\nfunction computeScrollbarSize(\n  component: G2GuideComponentOptions,\n  crossSize: number,\n  crossPadding: [number, number],\n  position: GCP,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const { trackSize = 6 } = deepMix({}, theme.scrollbar, component);\n  component.size = trackSize;\n}\n\nfunction computeTitleSize(\n  component: G2GuideComponentOptions,\n  crossSize: number,\n  crossPadding: [number, number],\n  position: GCP,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const {\n    title,\n    subtitle,\n    spacing = 0,\n    ...style\n  } = deepMix({}, theme.title, component);\n  if (title) {\n    const titleStyle = subObject(style, 'title');\n    const titleBBox = computeLabelSize(title, titleStyle);\n    component.size = titleBBox.height;\n  }\n  if (subtitle) {\n    const subtitleStyle = subObject(style, 'subtitle');\n    const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);\n    component.size += spacing + subtitleBBox.height;\n  }\n}\n\nfunction computeSliderSize(\n  component: G2GuideComponentOptions,\n  crossSize: number,\n  crossPadding: [number, number],\n  position: GCP,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const styleOf = () => {\n    const { slider } = theme;\n    return deepMix({}, slider, component);\n  };\n  const { trackSize, handleIconSize } = styleOf();\n  const size = Math.max(trackSize, handleIconSize * 2.4);\n  component.size = size;\n}\n\nfunction computeAxisSize(\n  component: G2GuideComponentOptions,\n  crossSize: number,\n  crossPadding: [number, number],\n  position: GCP,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  // If padding is auto, use hide as the labelTransform by default\n  // to avoid overlap between labels.\n  component.transform = component.transform || [{ type: 'hide' }];\n\n  // Vertical or horizontal.\n  const isVertical = position === 'left' || position === 'right';\n\n  // Get styles to be applied.\n  const style = styleOf(component, position, theme);\n  const {\n    tickLength = 0,\n    labelSpacing = 0,\n    titleSpacing = 0,\n    labelAutoRotate,\n    ...rest\n  } = style;\n\n  // Compute Labels.\n  const scale = createScale(component, library);\n  const labelBBoxes = computeLabelsBBox(rest, scale);\n  const paddingTick = tickLength + labelSpacing;\n  if (labelBBoxes && labelBBoxes.length) {\n    const maxLabelWidth = max(labelBBoxes, (d) => d.width);\n    const maxLabelHeight = max(labelBBoxes, (d) => d.height);\n    if (isVertical) {\n      component.size = maxLabelWidth + paddingTick;\n    } else {\n      const { tickFilter, labelTransform } = component;\n      // If the labels can't be placed horizontally, and labelTransform is unset,\n      // rotate 90 deg to display them.\n      if (\n        overflowX(scale, labelBBoxes, crossSize, crossPadding, tickFilter) &&\n        !labelTransform &&\n        labelAutoRotate !== false &&\n        labelAutoRotate !== null\n      ) {\n        component.labelTransform = 'rotate(90)';\n        component.size = maxLabelWidth + paddingTick;\n      } else {\n        component.labelTransform = component.labelTransform ?? 'rotate(0)';\n        component.size = maxLabelHeight + paddingTick;\n      }\n    }\n  } else {\n    component.size = tickLength;\n  }\n\n  // Compute title.\n  const titleBBox = computeTitleBBox(rest);\n  if (titleBBox) {\n    if (isVertical) {\n      component.size += titleSpacing + titleBBox.width;\n    } else {\n      component.size += titleSpacing + titleBBox.height;\n    }\n  }\n}\n\nfunction computeContinuousLegendSize(\n  component: G2GuideComponentOptions,\n  crossSize: number,\n  crossPadding: [number, number],\n  position: GCP,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  // Get styles.\n  const styleOf = () => {\n    const { legendContinuous } = theme;\n    return deepMix({}, legendContinuous, component);\n  };\n  const { labelSpacing = 0, titleSpacing = 0, ...rest } = styleOf();\n\n  // Vertical or horizontal.\n  const isVertical = position === 'left' || position === 'right';\n\n  // Ribbon styles.\n  const ribbonStyles = subObject(rest, 'ribbon');\n  const { size: ribbonSize } = ribbonStyles;\n\n  const handleIconStyles = subObject(rest, 'handleIcon');\n  const { size: handleIconSize } = handleIconStyles;\n\n  const mainSize = Math.max(\n    ribbonSize,\n    handleIconSize * 2.4, // height = width * 2.4\n  );\n\n  component.size = mainSize;\n\n  // Compute labels.\n  const scale = createScale(component, library);\n  const labelBBoxes = computeLabelsBBox(rest, scale);\n  if (labelBBoxes) {\n    const key = isVertical ? 'width' : 'height';\n    const size = max(labelBBoxes, (d) => d[key]);\n    component.size += size + labelSpacing;\n  }\n\n  // Compute title.\n  const titleBBox = computeTitleBBox(rest);\n  if (titleBBox) {\n    if (isVertical) {\n      component.size = Math.max(component.size, titleBBox.width);\n    } else {\n      component.size += titleSpacing + titleBBox.height;\n    }\n  }\n}\n\nfunction computeCategoryLegendSize(\n  component: G2GuideComponentOptions,\n  crossSize0: number,\n  crossPadding: [number, number],\n  position: GCP,\n  theme: G2Theme,\n  library: G2Library,\n) {\n  const styleOf = () => {\n    const { legendCategory } = theme;\n    const { title } = component;\n    const [defaultTitle, specifiedTitle] = Array.isArray(title)\n      ? [title, undefined]\n      : [undefined, title];\n    return deepMix({ title: defaultTitle }, legendCategory, {\n      ...component,\n      title: specifiedTitle,\n    });\n  };\n\n  const {\n    itemSpacing,\n    itemMarkerSize,\n    titleSpacing,\n    rowPadding,\n    colPadding,\n    maxCols = Infinity,\n    maxRows = Infinity,\n    ...rest\n  } = styleOf();\n\n  const { cols, length } = component;\n\n  const getRows = (rows) => Math.min(rows, maxRows);\n  const getCols = (cols) => Math.min(cols, maxCols);\n\n  // Vertical or horizontal.\n  const isVertical = position === 'left' || position === 'right';\n\n  const crossSize =\n    length === undefined\n      ? crossSize0 + (isVertical ? 0 : crossPadding[0] + crossPadding[1])\n      : length;\n\n  // Compute title.\n  const titleBBox = computeTitleBBox(rest);\n\n  const scale = createScale(component, library);\n  const labelBBoxes = computeLabelsBBox(rest, scale, 'itemLabel');\n\n  const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;\n  const widthOf = (w, padding = 0) =>\n    itemMarkerSize + w + itemSpacing[0] + padding;\n\n  // Only support grid layout for vertical area.\n  const computeVerticalSize = () => {\n    let maxSize = -Infinity;\n    let pos = 0;\n    let cols = 1;\n    let rows = 0;\n    let maxRows = -Infinity;\n    let maxPos = -Infinity;\n    const titleHeight = titleBBox ? titleBBox.height : 0;\n    const maxHeight = crossSize - titleHeight;\n    for (const { width } of labelBBoxes) {\n      const w = widthOf(width, colPadding);\n      maxSize = Math.max(maxSize, w);\n      if (pos + height > maxHeight) {\n        cols++;\n        maxRows = Math.max(maxRows, rows);\n        maxPos = Math.max(maxPos, pos);\n        rows = 1;\n        pos = height;\n      } else {\n        pos += height;\n        rows++;\n      }\n    }\n    if (cols <= 1) {\n      maxRows = rows;\n      maxPos = pos;\n    }\n    component.size = maxSize * getCols(cols);\n    component.length = maxPos + titleHeight;\n    deepMix(component, { cols: getCols(cols), gridRow: maxRows });\n  };\n\n  // Horizontal grid layout.\n  const computeHorizontalGrid = () => {\n    const rows = Math.ceil(labelBBoxes.length / cols);\n    const maxWidth = max(labelBBoxes, (d) => widthOf(d.width)) * cols;\n    component.size = height * getRows(rows) - rowPadding;\n    component.length = Math.min(maxWidth, crossSize);\n  };\n\n  // Horizontal flex layout.\n  const computeHorizontalFlex = () => {\n    let rows = 1;\n    let pos = 0;\n    let maxPos = -Infinity;\n    for (const { width } of labelBBoxes) {\n      const w = widthOf(width, colPadding);\n      if (pos + w > crossSize) {\n        maxPos = Math.max(maxPos, pos);\n        pos = w;\n        rows++;\n      } else {\n        pos += w;\n      }\n    }\n    if (rows === 1) maxPos = pos;\n    component.size = height * getRows(rows) - rowPadding;\n    component.length = maxPos;\n  };\n\n  if (isVertical) computeVerticalSize();\n  else if (typeof cols === 'number') computeHorizontalGrid();\n  else computeHorizontalFlex();\n\n  // Compute titles.\n  if (titleBBox) {\n    if (isVertical) {\n      component.size = Math.max(component.size, titleBBox.width);\n    } else {\n      component.size += titleSpacing + titleBBox.height;\n    }\n  }\n}\n\nexport function createScale(\n  component: G2GuideComponentOptions,\n  library: G2Library,\n): Scale {\n  const [useScale] = useLibrary<G2ScaleOptions, ScaleComponent, Scale>(\n    'scale',\n    library,\n  );\n  // Init scale, the tickCount of axis has higher priority than scale.\n  const { scales, tickCount, tickMethod } = component;\n  const scaleOptions = scales.find(\n    (d) => d.type !== 'constant' && d.type !== 'identity',\n  );\n  if (tickCount !== undefined) scaleOptions.tickCount = tickCount;\n  if (tickMethod !== undefined) scaleOptions.tickMethod = tickMethod;\n  return useScale(scaleOptions);\n}\n\nexport function computeLabelsBBox(\n  component: G2GuideComponentOptions,\n  scale: Scale,\n  key = 'label',\n) {\n  const { labelFormatter, tickFilter, label = true, ...style } = component;\n  if (!label) return null;\n\n  // Get labels to be rendered.\n  const labels = labelsOf(scale, labelFormatter, tickFilter);\n  const labelStyle = subObject(style, key);\n  const labelStyles = labels.map((d, i) =>\n    Object.fromEntries(\n      Object.entries(labelStyle).map(([key, value]) => [\n        key,\n        typeof value === 'function' ? value(d, i) : value,\n      ]),\n    ),\n  );\n  const labelBBoxes = labels.map((d, i) => {\n    const normalizeStyle = labelStyles[i];\n    return computeLabelSize(d, normalizeStyle);\n  });\n\n  // Cache boxes to avoid computed twice.\n  // @todo GUI use untransformed bbox, so it can't cache if\n  // label.style has transform attributes.\n  const hasTransform = labelStyles.some((d) => d.transform);\n  if (!hasTransform) {\n    const I = labels.map((_, i) => i);\n    component.indexBBox = new Map(\n      I.map((i) => [i, [labels[i], labelBBoxes[i]]]),\n    );\n  }\n\n  return labelBBoxes;\n}\n\nexport function computeTitleBBox(component: G2GuideComponentOptions) {\n  const isFalsy = (x) => x === false || x === null;\n  const { title, ...style } = component;\n  if (isFalsy(title) || title === undefined) return null;\n  const titleStyle = subObject(style, 'title');\n  const { direction, transform } = titleStyle;\n  const titleText = Array.isArray(title) ? title.join(',') : title;\n  if (typeof titleText !== 'string') return null;\n  const titleBBox = computeLabelSize(titleText, {\n    ...titleStyle,\n    transform: transform || (direction === 'vertical' ? 'rotate(-90)' : ''),\n  });\n  return titleBBox;\n}\n\nexport function styleOf(\n  axis: G2GuideComponentOptions,\n  position: GCP,\n  theme: G2Theme,\n): Record<string, any> {\n  const { title } = axis;\n  const [defaultTitle, specifiedTitle] = Array.isArray(title)\n    ? [title, undefined]\n    : [undefined, title];\n  const {\n    axis: baseStyle,\n    // @ts-ignore\n    [`axis${capitalizeFirst(position)}`]: positionStyle,\n  } = theme;\n  return deepMix({ title: defaultTitle }, baseStyle, positionStyle, {\n    ...axis,\n    title: specifiedTitle,\n  });\n}\n\nfunction ticksOf(scale: Scale, tickFilter: (d: any) => boolean): any[] {\n  const ticks = scale.getTicks ? scale.getTicks() : scale.getOptions().domain;\n  if (!tickFilter) return ticks;\n  return ticks.filter(tickFilter);\n}\n\nfunction labelsOf(\n  scale: Scale,\n  labelFormatter: (d: any) => string | DisplayObject,\n  tickFilter,\n): (string | DisplayObject)[] {\n  const T = ticksOf(scale, tickFilter);\n  const ticks = T.map((d) => (typeof d === 'number' ? prettyNumber(d) : d));\n  const formatter = labelFormatter\n    ? typeof labelFormatter === 'string'\n      ? format(labelFormatter)\n      : labelFormatter\n    : scale.getFormatter\n    ? scale.getFormatter()\n    : (d) => `${d}`;\n  return ticks.map(formatter);\n}\n\nfunction offsetOf(scale: Scale, d: any): number {\n  if (!scale.getBandWidth) return 0;\n  const offset = scale.getBandWidth(d) / 2;\n  return offset;\n}\n\nfunction overflowX(\n  scale: Scale,\n  labelBBoxes: DOMRect[],\n  crossSize: number,\n  crossPadding: [number, number],\n  tickFilter: (d: any) => boolean,\n): boolean {\n  // If actual size bigger than container size, overflow.\n  const totalSize = sum(labelBBoxes, (d) => d.width);\n  if (totalSize > crossSize) return true;\n\n  // Clone scale to get visual position for labels.\n  const scaleX = scale.clone();\n  scaleX.update({ range: [0, crossSize] });\n  const ticks = ticksOf(scale, tickFilter);\n  const X = ticks.map((d) => scaleX.map(d) + offsetOf(scaleX, d));\n\n  const I = ticks.map((_, i) => i);\n  const startX = -crossPadding[0];\n  const endX = crossSize + crossPadding[1];\n  const extent = (x, bbox) => {\n    const { width } = bbox;\n    return [x - width / 2, x + width / 2];\n  };\n\n  // Collision detection.\n  for (let i = 0; i < I.length; i++) {\n    const x = X[i];\n    const [x0, x1] = extent(x, labelBBoxes[i]);\n    // If a label is out of plot area, overflow.\n    if (x0 < startX || x1 > endX) return true;\n    const y = X[i + 1];\n    if (y) {\n      // If two labels intersect, overflow.\n      const [y0] = extent(y, labelBBoxes[i + 1]);\n      if (x1 > y0) return true;\n    }\n  }\n  return false;\n}\n\nfunction computeLabelSize(\n  d: string | DisplayObject,\n  style: Record<string, any>,\n): DOMRect {\n  const shape = normalizeLabel(d);\n  const { filter, ...rest } = style;\n  shape.attr({ ...rest, visibility: 'none' });\n  const bbox = shape.getBBox();\n  return bbox;\n}\n\nfunction normalizeLabel(d: string | DisplayObject): DisplayObject {\n  if (d instanceof DisplayObject) return d;\n  return new Text({ style: { text: `${d}` } });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}