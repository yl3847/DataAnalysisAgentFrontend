{"ast":null,"code":"import { Band } from '@antv/scale';\nimport { deepMix } from '@antv/util';\nimport { column, columnOf } from './utils/helper';\nimport { domainOf } from './utils/order';\nexport function rangeOf(value, scaleOptions, padding) {\n  if (value === null) return [-0.5, 0.5];\n  const domain = domainOf(value, scaleOptions);\n  const scale = new Band({\n    domain,\n    range: [0, 1],\n    padding\n  });\n  const step = scale.getBandWidth();\n  return [-step / 2, step / 2];\n}\nexport function interpolate(t, a, b) {\n  return a * (1 - t) + b * t;\n}\n/**\n * The jitter transform produce dx and dy channels for marks (especially for point)\n * with ordinal x and y dimension, say to make them jitter in their own space.\n */\nexport const Jitter = (options = {}) => {\n  const {\n    padding = 0,\n    paddingX = padding,\n    paddingY = padding,\n    random = Math.random\n  } = options;\n  return (I, mark) => {\n    const {\n      encode,\n      scale\n    } = mark;\n    const {\n      x: scaleX,\n      y: scaleY\n    } = scale;\n    const [X] = columnOf(encode, 'x');\n    const [Y] = columnOf(encode, 'y');\n    const rangeX = rangeOf(X, scaleX, paddingX);\n    const rangeY = rangeOf(Y, scaleY, paddingY);\n    const DY = I.map(() => interpolate(random(), ...rangeY));\n    const DX = I.map(() => interpolate(random(), ...rangeX));\n    return [I, deepMix({\n      scale: {\n        x: {\n          padding: 0.5\n        },\n        y: {\n          padding: 0.5\n        }\n      }\n    }, mark, {\n      encode: {\n        dy: column(DY),\n        dx: column(DX)\n      }\n    })];\n  };\n};\nJitter.props = {};","map":{"version":3,"names":["Band","deepMix","column","columnOf","domainOf","rangeOf","value","scaleOptions","padding","domain","scale","range","step","getBandWidth","interpolate","t","a","b","Jitter","options","paddingX","paddingY","random","Math","I","mark","encode","x","scaleX","y","scaleY","X","Y","rangeX","rangeY","DY","map","DX","dy","dx","props"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/transform/jitter.ts"],"sourcesContent":["import { Band } from '@antv/scale';\nimport { deepMix } from '@antv/util';\nimport { Primitive, TransformComponent as TC } from '../runtime';\nimport { JitterTransform } from '../spec';\nimport { column, columnOf } from './utils/helper';\nimport { domainOf } from './utils/order';\n\nexport type JitterOptions = Omit<JitterTransform, 'type'>;\n\nexport function rangeOf(\n  value: Primitive[],\n  scaleOptions: Record<string, any>,\n  padding: number,\n): [number, number] {\n  if (value === null) return [-0.5, 0.5];\n  const domain = domainOf(value, scaleOptions);\n  const scale = new Band({ domain, range: [0, 1], padding });\n  const step = scale.getBandWidth();\n  return [-step / 2, step / 2];\n}\n\nexport function interpolate(t: number, a: number, b: number): number {\n  return a * (1 - t) + b * t;\n}\n\n/**\n * The jitter transform produce dx and dy channels for marks (especially for point)\n * with ordinal x and y dimension, say to make them jitter in their own space.\n */\nexport const Jitter: TC<JitterOptions> = (options = {}) => {\n  const {\n    padding = 0,\n    paddingX = padding,\n    paddingY = padding,\n    random = Math.random,\n  } = options;\n  return (I, mark) => {\n    const { encode, scale } = mark;\n    const { x: scaleX, y: scaleY } = scale;\n    const [X] = columnOf(encode, 'x');\n    const [Y] = columnOf(encode, 'y');\n    const rangeX = rangeOf(X, scaleX, paddingX);\n    const rangeY = rangeOf(Y, scaleY, paddingY);\n    const DY = I.map(() => interpolate(random(), ...rangeY));\n    const DX = I.map(() => interpolate(random(), ...rangeX));\n    return [\n      I,\n      deepMix(\n        {\n          scale: {\n            x: { padding: 0.5 },\n            y: { padding: 0.5 },\n          },\n        },\n        mark,\n        {\n          encode: { dy: column(DY), dx: column(DX) },\n        },\n      ),\n    ];\n  };\n};\n\nJitter.props = {};\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,aAAa;AAClC,SAASC,OAAO,QAAQ,YAAY;AAGpC,SAASC,MAAM,EAAEC,QAAQ,QAAQ,gBAAgB;AACjD,SAASC,QAAQ,QAAQ,eAAe;AAIxC,OAAM,SAAUC,OAAOA,CACrBC,KAAkB,EAClBC,YAAiC,EACjCC,OAAe;EAEf,IAAIF,KAAK,KAAK,IAAI,EAAE,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC;EACtC,MAAMG,MAAM,GAAGL,QAAQ,CAACE,KAAK,EAAEC,YAAY,CAAC;EAC5C,MAAMG,KAAK,GAAG,IAAIV,IAAI,CAAC;IAAES,MAAM;IAAEE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAAEH;EAAO,CAAE,CAAC;EAC1D,MAAMI,IAAI,GAAGF,KAAK,CAACG,YAAY,EAAE;EACjC,OAAO,CAAC,CAACD,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG,CAAC,CAAC;AAC9B;AAEA,OAAM,SAAUE,WAAWA,CAACC,CAAS,EAAEC,CAAS,EAAEC,CAAS;EACzD,OAAOD,CAAC,IAAI,CAAC,GAAGD,CAAC,CAAC,GAAGE,CAAC,GAAGF,CAAC;AAC5B;AAEA;;;;AAIA,OAAO,MAAMG,MAAM,GAAsBA,CAACC,OAAO,GAAG,EAAE,KAAI;EACxD,MAAM;IACJX,OAAO,GAAG,CAAC;IACXY,QAAQ,GAAGZ,OAAO;IAClBa,QAAQ,GAAGb,OAAO;IAClBc,MAAM,GAAGC,IAAI,CAACD;EAAM,CACrB,GAAGH,OAAO;EACX,OAAO,CAACK,CAAC,EAAEC,IAAI,KAAI;IACjB,MAAM;MAAEC,MAAM;MAAEhB;IAAK,CAAE,GAAGe,IAAI;IAC9B,MAAM;MAAEE,CAAC,EAAEC,MAAM;MAAEC,CAAC,EAAEC;IAAM,CAAE,GAAGpB,KAAK;IACtC,MAAM,CAACqB,CAAC,CAAC,GAAG5B,QAAQ,CAACuB,MAAM,EAAE,GAAG,CAAC;IACjC,MAAM,CAACM,CAAC,CAAC,GAAG7B,QAAQ,CAACuB,MAAM,EAAE,GAAG,CAAC;IACjC,MAAMO,MAAM,GAAG5B,OAAO,CAAC0B,CAAC,EAAEH,MAAM,EAAER,QAAQ,CAAC;IAC3C,MAAMc,MAAM,GAAG7B,OAAO,CAAC2B,CAAC,EAAEF,MAAM,EAAET,QAAQ,CAAC;IAC3C,MAAMc,EAAE,GAAGX,CAAC,CAACY,GAAG,CAAC,MAAMtB,WAAW,CAACQ,MAAM,EAAE,EAAE,GAAGY,MAAM,CAAC,CAAC;IACxD,MAAMG,EAAE,GAAGb,CAAC,CAACY,GAAG,CAAC,MAAMtB,WAAW,CAACQ,MAAM,EAAE,EAAE,GAAGW,MAAM,CAAC,CAAC;IACxD,OAAO,CACLT,CAAC,EACDvB,OAAO,CACL;MACES,KAAK,EAAE;QACLiB,CAAC,EAAE;UAAEnB,OAAO,EAAE;QAAG,CAAE;QACnBqB,CAAC,EAAE;UAAErB,OAAO,EAAE;QAAG;;KAEpB,EACDiB,IAAI,EACJ;MACEC,MAAM,EAAE;QAAEY,EAAE,EAAEpC,MAAM,CAACiC,EAAE,CAAC;QAAEI,EAAE,EAAErC,MAAM,CAACmC,EAAE;MAAC;KACzC,CACF,CACF;EACH,CAAC;AACH,CAAC;AAEDnB,MAAM,CAACsB,KAAK,GAAG,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}