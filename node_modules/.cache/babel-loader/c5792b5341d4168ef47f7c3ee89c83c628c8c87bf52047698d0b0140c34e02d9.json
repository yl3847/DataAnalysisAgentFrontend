{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Slider as SliderComponent } from '@antv/component';\nimport { format } from '@antv/vendor/d3-format';\nimport { isArray } from '@antv/util';\nimport { isTranspose } from '../utils/coordinate';\nimport { invert } from '../utils/scale';\nfunction inferPosition(bbox, position, trackSize) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bbox;\n  if (position === 'left') return [x + width - trackSize, y];\n  if (position === 'right') return [x, y];\n  if (position === 'bottom') return [x, y];\n  if (position === 'top') return [x, y + height - trackSize];\n}\n/**\n * Slider component.\n */\nexport const Slider = options => {\n  // do not pass size.\n  const {\n      orientation,\n      labelFormatter,\n      size,\n      style = {},\n      position\n    } = options,\n    rest = __rest(options, [\"orientation\", \"labelFormatter\", \"size\", \"style\", \"position\"]);\n  return context => {\n    var _a;\n    const {\n      scales: [scale],\n      value,\n      theme,\n      coordinate\n    } = context;\n    const {\n      bbox\n    } = value;\n    const {\n      width,\n      height\n    } = bbox;\n    const {\n      slider: sliderTheme = {}\n    } = theme;\n    const defaultFormatter = ((_a = scale.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale)) || (v => v + '');\n    const formatter = typeof labelFormatter === 'string' ? format(labelFormatter) : labelFormatter;\n    const isHorizontal = orientation === 'horizontal';\n    const reverse = isTranspose(coordinate) && isHorizontal;\n    const {\n      trackSize = sliderTheme.trackSize\n    } = style;\n    const [x0, y0] = inferPosition(bbox, position, trackSize);\n    return new SliderComponent({\n      className: 'slider',\n      style: Object.assign({}, sliderTheme, Object.assign(Object.assign({\n        x: x0,\n        y: y0,\n        trackLength: isHorizontal ? width : height,\n        orientation,\n        formatter: v => {\n          const f = formatter || defaultFormatter;\n          const v1 = reverse ? 1 - v : v;\n          const tick = invert(scale, v1, true);\n          return f(tick);\n        },\n        sparklineData: inferSparklineData(options, context)\n      }, style), rest))\n    });\n  };\n};\nfunction markValue(markState, channels) {\n  const [value] = Array.from(markState.entries()).filter(([mark]) => mark.type === 'line' || mark.type === 'area').filter(([mark]) => mark.slider).map(([mark]) => {\n    const {\n      encode,\n      slider\n    } = mark;\n    if (slider === null || slider === void 0 ? void 0 : slider.x) {\n      const channel = name => {\n        const channel = encode[name];\n        return [name, channel ? channel.value : undefined];\n      };\n      return Object.fromEntries(channels.map(channel));\n    }\n  });\n  if (!(value === null || value === void 0 ? void 0 : value.series)) return value === null || value === void 0 ? void 0 : value.y;\n  const result = value.series.reduce((acc, curr, index) => {\n    acc[curr] = acc[curr] || [];\n    acc[curr].push(value.y[index]);\n    return acc;\n  }, {});\n  return Object.values(result);\n}\nfunction inferSparklineData(options, context) {\n  const {\n    markState\n  } = context;\n  if (isArray(options.sparklineData)) return options.sparklineData;\n  return markValue(markState, ['y', 'series']);\n}\nSlider.props = {\n  defaultPosition: 'bottom',\n  defaultSize: 24,\n  defaultOrder: 1,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12]\n};","map":{"version":3,"names":["Slider","SliderComponent","format","isArray","isTranspose","invert","inferPosition","bbox","position","trackSize","x","y","width","height","options","orientation","labelFormatter","size","style","rest","__rest","context","scales","scale","value","theme","coordinate","slider","sliderTheme","defaultFormatter","_a","getFormatter","call","v","formatter","isHorizontal","reverse","x0","y0","className","Object","assign","trackLength","f","v1","tick","sparklineData","inferSparklineData","markValue","markState","channels","Array","from","entries","filter","mark","type","map","encode","channel","name","undefined","fromEntries","series","result","reduce","acc","curr","index","push","values","props","defaultPosition","defaultSize","defaultOrder","defaultCrossPadding","defaultPadding"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/component/slider.ts"],"sourcesContent":["import { Slider as SliderComponent } from '@antv/component';\nimport { format } from '@antv/vendor/d3-format';\nimport { DisplayObject } from '@antv/g';\nimport { isArray } from '@antv/util';\nimport { isTranspose } from '../utils/coordinate';\nimport {\n  GuideComponentComponent as GCC,\n  GuideComponentContext,\n} from '../runtime';\nimport { invert } from '../utils/scale';\n\nexport type SliderOptions = {\n  orientation: 'horizontal' | 'vertical';\n  showHandle?: boolean;\n  showLabel?: boolean;\n  showLabelOnInteraction?: boolean;\n  autoFitLabel?: boolean;\n  [key: string]: any;\n};\n\nfunction inferPosition(bbox, position, trackSize) {\n  const { x, y, width, height } = bbox;\n  if (position === 'left') return [x + width - trackSize, y];\n  if (position === 'right') return [x, y];\n  if (position === 'bottom') return [x, y];\n  if (position === 'top') return [x, y + height - trackSize];\n}\n\n/**\n * Slider component.\n */\nexport const Slider: GCC<SliderOptions> = (options) => {\n  // do not pass size.\n  const {\n    orientation,\n    labelFormatter,\n    size,\n    style = {},\n    position,\n    ...rest\n  } = options;\n\n  return (context) => {\n    const {\n      scales: [scale],\n      value,\n      theme,\n      coordinate,\n    } = context;\n    const { bbox } = value;\n\n    const { width, height } = bbox;\n    const { slider: sliderTheme = {} } = theme;\n    const defaultFormatter = scale.getFormatter?.() || ((v) => v + '');\n    const formatter =\n      typeof labelFormatter === 'string'\n        ? format(labelFormatter)\n        : labelFormatter;\n\n    const isHorizontal = orientation === 'horizontal';\n    const reverse = isTranspose(coordinate) && isHorizontal;\n    const { trackSize = sliderTheme.trackSize } = style;\n    const [x0, y0] = inferPosition(bbox, position, trackSize);\n    return new SliderComponent({\n      className: 'slider',\n      style: Object.assign({}, sliderTheme, {\n        x: x0,\n        y: y0,\n        trackLength: isHorizontal ? width : height,\n        orientation,\n        formatter: (v) => {\n          const f = formatter || defaultFormatter;\n          const v1 = reverse ? 1 - v : v;\n          const tick = invert(scale, v1, true);\n          return f(tick);\n        },\n        sparklineData: inferSparklineData(options, context),\n        ...style,\n        ...rest,\n      }),\n    }) as unknown as DisplayObject;\n  };\n};\n\nfunction markValue(markState, channels: string[]) {\n  const [value] = Array.from(markState.entries())\n    .filter(([mark]) => mark.type === 'line' || mark.type === 'area')\n    .filter(([mark]) => mark.slider)\n    .map(([mark]) => {\n      const { encode, slider } = mark;\n      if (slider?.x) {\n        const channel = (name) => {\n          const channel = encode[name];\n          return [name, channel ? channel.value : undefined];\n        };\n        return Object.fromEntries(channels.map(channel));\n      }\n    });\n\n  if (!value?.series) return value?.y;\n  const result = value.series.reduce((acc, curr, index) => {\n    acc[curr] = acc[curr] || [];\n    acc[curr].push(value.y[index]);\n    return acc;\n  }, {});\n  return Object.values(result);\n}\n\nfunction inferSparklineData(options, context: GuideComponentContext) {\n  const { markState } = context;\n  if (isArray(options.sparklineData)) return options.sparklineData;\n  return markValue(markState, ['y', 'series']);\n}\n\nSlider.props = {\n  defaultPosition: 'bottom',\n  defaultSize: 24,\n  defaultOrder: 1,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12],\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}