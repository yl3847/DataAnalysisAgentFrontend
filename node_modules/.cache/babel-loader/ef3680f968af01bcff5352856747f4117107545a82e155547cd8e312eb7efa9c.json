{"ast":null,"code":"import { clone } from '@antv/util';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot } from './utils/data-preprocessing';\nimport cosineSimilarity from './cosine-similarity';\n/**\n *  nodes-cosine-similarity算法 基于节点属性计算余弦相似度(基于种子节点寻找相似节点)\n * @param nodes 图节点数据\n * @param seedNode 种子节点\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n */\nvar nodesCosineSimilarity = function nodesCosineSimilarity(nodes, seedNode, propertyKey, involvedKeys, uninvolvedKeys) {\n  if (nodes === void 0) {\n    nodes = [];\n  }\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = [];\n  }\n  var similarNodes = clone(nodes.filter(function (node) {\n    return node.id !== seedNode.id;\n  }));\n  var seedNodeIndex = nodes.findIndex(function (node) {\n    return node.id === seedNode.id;\n  });\n  // 所有节点属性集合\n  var properties = getAllProperties(nodes, propertyKey);\n  // 所有节点属性one-hot特征向量集合\n  var allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  // 种子节点属性\n  var seedNodeProperties = allPropertiesWeight[seedNodeIndex];\n  var allCosineSimilarity = [];\n  similarNodes.forEach(function (node, index) {\n    if (node.id !== seedNode.id) {\n      // 节点属性\n      var nodeProperties = allPropertiesWeight[index];\n      // 计算节点向量和种子节点向量的余弦相似度\n      var cosineSimilarityValue = cosineSimilarity(nodeProperties, seedNodeProperties);\n      allCosineSimilarity.push(cosineSimilarityValue);\n      node.cosineSimilarity = cosineSimilarityValue;\n    }\n  });\n  // 将返回的节点按照余弦相似度大小排序\n  similarNodes.sort(function (a, b) {\n    return b.cosineSimilarity - a.cosineSimilarity;\n  });\n  return {\n    allCosineSimilarity: allCosineSimilarity,\n    similarNodes: similarNodes\n  };\n};\nexport default nodesCosineSimilarity;","map":{"version":3,"names":["clone","getAllProperties","oneHot","cosineSimilarity","nodesCosineSimilarity","nodes","seedNode","propertyKey","involvedKeys","uninvolvedKeys","undefined","similarNodes","filter","node","id","seedNodeIndex","findIndex","properties","allPropertiesWeight","seedNodeProperties","allCosineSimilarity","forEach","index","nodeProperties","cosineSimilarityValue","push","sort","a","b"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/algorithm/es/nodes-cosine-similarity.js"],"sourcesContent":["import { clone } from '@antv/util';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot } from './utils/data-preprocessing';\nimport cosineSimilarity from './cosine-similarity';\n/**\n *  nodes-cosine-similarity算法 基于节点属性计算余弦相似度(基于种子节点寻找相似节点)\n * @param nodes 图节点数据\n * @param seedNode 种子节点\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n */\nvar nodesCosineSimilarity = function nodesCosineSimilarity(nodes, seedNode, propertyKey, involvedKeys, uninvolvedKeys) {\n  if (nodes === void 0) {\n    nodes = [];\n  }\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = [];\n  }\n  var similarNodes = clone(nodes.filter(function (node) {\n    return node.id !== seedNode.id;\n  }));\n  var seedNodeIndex = nodes.findIndex(function (node) {\n    return node.id === seedNode.id;\n  });\n  // 所有节点属性集合\n  var properties = getAllProperties(nodes, propertyKey);\n  // 所有节点属性one-hot特征向量集合\n  var allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  // 种子节点属性\n  var seedNodeProperties = allPropertiesWeight[seedNodeIndex];\n  var allCosineSimilarity = [];\n  similarNodes.forEach(function (node, index) {\n    if (node.id !== seedNode.id) {\n      // 节点属性\n      var nodeProperties = allPropertiesWeight[index];\n      // 计算节点向量和种子节点向量的余弦相似度\n      var cosineSimilarityValue = cosineSimilarity(nodeProperties, seedNodeProperties);\n      allCosineSimilarity.push(cosineSimilarityValue);\n      node.cosineSimilarity = cosineSimilarityValue;\n    }\n  });\n  // 将返回的节点按照余弦相似度大小排序\n  similarNodes.sort(function (a, b) {\n    return b.cosineSimilarity - a.cosineSimilarity;\n  });\n  return {\n    allCosineSimilarity: allCosineSimilarity,\n    similarNodes: similarNodes\n  };\n};\nexport default nodesCosineSimilarity;"],"mappings":"AAAA,SAASA,KAAK,QAAQ,YAAY;AAClC,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,SAASC,MAAM,QAAQ,4BAA4B;AACnD,OAAOC,gBAAgB,MAAM,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,qBAAqB,GAAG,SAASA,qBAAqBA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,YAAY,EAAEC,cAAc,EAAE;EACrH,IAAIJ,KAAK,KAAK,KAAK,CAAC,EAAE;IACpBA,KAAK,GAAG,EAAE;EACZ;EACA,IAAIE,WAAW,KAAK,KAAK,CAAC,EAAE;IAC1BA,WAAW,GAAGG,SAAS;EACzB;EACA,IAAIF,YAAY,KAAK,KAAK,CAAC,EAAE;IAC3BA,YAAY,GAAG,EAAE;EACnB;EACA,IAAIC,cAAc,KAAK,KAAK,CAAC,EAAE;IAC7BA,cAAc,GAAG,EAAE;EACrB;EACA,IAAIE,YAAY,GAAGX,KAAK,CAACK,KAAK,CAACO,MAAM,CAAC,UAAUC,IAAI,EAAE;IACpD,OAAOA,IAAI,CAACC,EAAE,KAAKR,QAAQ,CAACQ,EAAE;EAChC,CAAC,CAAC,CAAC;EACH,IAAIC,aAAa,GAAGV,KAAK,CAACW,SAAS,CAAC,UAAUH,IAAI,EAAE;IAClD,OAAOA,IAAI,CAACC,EAAE,KAAKR,QAAQ,CAACQ,EAAE;EAChC,CAAC,CAAC;EACF;EACA,IAAIG,UAAU,GAAGhB,gBAAgB,CAACI,KAAK,EAAEE,WAAW,CAAC;EACrD;EACA,IAAIW,mBAAmB,GAAGhB,MAAM,CAACe,UAAU,EAAET,YAAY,EAAEC,cAAc,CAAC;EAC1E;EACA,IAAIU,kBAAkB,GAAGD,mBAAmB,CAACH,aAAa,CAAC;EAC3D,IAAIK,mBAAmB,GAAG,EAAE;EAC5BT,YAAY,CAACU,OAAO,CAAC,UAAUR,IAAI,EAAES,KAAK,EAAE;IAC1C,IAAIT,IAAI,CAACC,EAAE,KAAKR,QAAQ,CAACQ,EAAE,EAAE;MAC3B;MACA,IAAIS,cAAc,GAAGL,mBAAmB,CAACI,KAAK,CAAC;MAC/C;MACA,IAAIE,qBAAqB,GAAGrB,gBAAgB,CAACoB,cAAc,EAAEJ,kBAAkB,CAAC;MAChFC,mBAAmB,CAACK,IAAI,CAACD,qBAAqB,CAAC;MAC/CX,IAAI,CAACV,gBAAgB,GAAGqB,qBAAqB;IAC/C;EACF,CAAC,CAAC;EACF;EACAb,YAAY,CAACe,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;IAChC,OAAOA,CAAC,CAACzB,gBAAgB,GAAGwB,CAAC,CAACxB,gBAAgB;EAChD,CAAC,CAAC;EACF,OAAO;IACLiB,mBAAmB,EAAEA,mBAAmB;IACxCT,YAAY,EAAEA;EAChB,CAAC;AACH,CAAC;AACD,eAAeP,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}