{"ast":null,"code":"import { midPoint } from './mid-point';\nimport { segmentCubicFactory } from './segment-cubic-factory';\nvar MAX_RECURSION_DEPTH = 50;\nfunction splitCubic(pts, t) {\n  if (t === void 0) {\n    t = 0.5;\n  }\n  var p0 = pts.slice(0, 2);\n  var p1 = pts.slice(2, 4);\n  var p2 = pts.slice(4, 6);\n  var p3 = pts.slice(6, 8);\n  var p4 = midPoint(p0, p1, t);\n  var p5 = midPoint(p1, p2, t);\n  var p6 = midPoint(p2, p3, t);\n  var p7 = midPoint(p4, p5, t);\n  var p8 = midPoint(p5, p6, t);\n  var p9 = midPoint(p7, p8, t);\n  return [\n  // @ts-ignore\n  ['C'].concat(p4, p7, p9),\n  // @ts-ignore\n  ['C'].concat(p8, p6, p3)];\n}\nfunction getCurveArray(segments) {\n  return segments.map(function (segment, i, pathArray) {\n    // @ts-ignore\n    var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));\n    // @ts-ignore\n    var curveLength = i ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], {\n      bbox: false\n    }).length : 0;\n    var subsegs;\n    if (i) {\n      // must be [segment,segment]\n      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];\n    } else {\n      subsegs = [segment];\n    }\n    return {\n      s: segment,\n      ss: subsegs,\n      l: curveLength\n    };\n  });\n}\nexport function equalizeSegments(path1, path2, TL, depth) {\n  if (depth === void 0) {\n    depth = 0;\n  }\n  if (depth > MAX_RECURSION_DEPTH) {\n    console.warn('Maximum recursion depth reached in equalizeSegments');\n    return [path1, path2];\n  }\n  var c1 = getCurveArray(path1);\n  var c2 = getCurveArray(path2);\n  var L1 = c1.length;\n  var L2 = c2.length;\n  var l1 = c1.filter(function (x) {\n    return x.l;\n  }).length;\n  var l2 = c2.filter(function (x) {\n    return x.l;\n  }).length;\n  var m1 = c1.filter(function (x) {\n    return x.l;\n  }).reduce(function (a, _a) {\n    var l = _a.l;\n    return a + l;\n  }, 0) / l1 || 0;\n  var m2 = c2.filter(function (x) {\n    return x.l;\n  }).reduce(function (a, _a) {\n    var l = _a.l;\n    return a + l;\n  }, 0) / l2 || 0;\n  var tl = TL || Math.max(L1, L2);\n  var mm = [m1, m2];\n  var dif = [tl - L1, tl - L2];\n  var canSplit = 0;\n  var result = [c1, c2].map(function (x, i) {\n    // @ts-ignore\n    return x.l === tl ? x.map(function (y) {\n      return y.s;\n    }) : x.map(function (y, j) {\n      canSplit = j && dif[i] && y.l >= mm[i];\n      dif[i] -= canSplit ? 1 : 0;\n      return canSplit ? y.ss : [y.s];\n    }).flat();\n  });\n  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl, depth + 1);\n}","map":{"version":3,"names":["midPoint","segmentCubicFactory","MAX_RECURSION_DEPTH","splitCubic","pts","t","p0","slice","p1","p2","p3","p4","p5","p6","p7","p8","p9","concat","getCurveArray","segments","map","segment","i","pathArray","segmentData","curveLength","bbox","length","subsegs","s","ss","l","equalizeSegments","path1","path2","TL","depth","console","warn","c1","c2","L1","L2","l1","filter","x","l2","m1","reduce","a","_a","m2","tl","Math","max","mm","dif","canSplit","result","y","j","flat"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/util/src/path/util/equalize-segments.ts"],"sourcesContent":["import type { CurveArray, PathArray } from '../types';\nimport { midPoint } from './mid-point';\nimport { segmentCubicFactory } from './segment-cubic-factory';\n\ntype SplitArray = [number, number, number, number, number, number, number, number, number];\n\nconst MAX_RECURSION_DEPTH = 50;\n\nfunction splitCubic(pts: SplitArray, t = 0.5): [CurveArray, CurveArray] {\n  const p0 = pts.slice(0, 2) as [number, number];\n  const p1 = pts.slice(2, 4) as [number, number];\n  const p2 = pts.slice(4, 6) as [number, number];\n  const p3 = pts.slice(6, 8) as [number, number];\n  const p4 = midPoint(p0, p1, t);\n  const p5 = midPoint(p1, p2, t);\n  const p6 = midPoint(p2, p3, t);\n  const p7 = midPoint(p4, p5, t);\n  const p8 = midPoint(p5, p6, t);\n  const p9 = midPoint(p7, p8, t);\n\n  return [\n    // @ts-ignore\n    ['C'].concat(p4, p7, p9),\n    // @ts-ignore\n    ['C'].concat(p8, p6, p3),\n  ];\n}\n\nfunction getCurveArray(segments: PathArray) {\n  return segments.map((segment, i, pathArray) => {\n    // @ts-ignore\n    const segmentData = i && (pathArray[i - 1].slice(-2).concat(segment.slice(1)) as SplitArray);\n\n    // @ts-ignore\n    const curveLength = i\n      ? segmentCubicFactory(\n          segmentData[0],\n          segmentData[1],\n          segmentData[2],\n          segmentData[3],\n          segmentData[4],\n          segmentData[5],\n          segmentData[6],\n          segmentData[7],\n          segmentData[8],\n          { bbox: false },\n        ).length\n      : 0;\n\n    let subsegs;\n    if (i) {\n      // must be [segment,segment]\n      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];\n    } else {\n      subsegs = [segment];\n    }\n\n    return {\n      s: segment,\n      ss: subsegs,\n      l: curveLength,\n    };\n  });\n}\n\nexport function equalizeSegments(path1: PathArray, path2: PathArray, TL?: number, depth = 0): CurveArray[] {\n  if (depth > MAX_RECURSION_DEPTH) {\n    console.warn('Maximum recursion depth reached in equalizeSegments');\n    return [path1, path2] as CurveArray[];\n  }\n  const c1 = getCurveArray(path1);\n  const c2 = getCurveArray(path2);\n  const L1 = c1.length;\n  const L2 = c2.length;\n  const l1 = c1.filter((x) => x.l).length;\n  const l2 = c2.filter((x) => x.l).length;\n  const m1 = c1.filter((x) => x.l).reduce((a, { l }) => a + l, 0) / l1 || 0;\n  const m2 = c2.filter((x) => x.l).reduce((a, { l }) => a + l, 0) / l2 || 0;\n  const tl = TL || Math.max(L1, L2);\n  const mm = [m1, m2];\n  const dif = [tl - L1, tl - L2];\n  let canSplit: number | boolean = 0;\n  const result = [c1, c2].map((x, i) =>\n    // @ts-ignore\n    x.l === tl\n      ? x.map((y) => y.s)\n      : x\n          .map((y, j) => {\n            canSplit = j && dif[i] && y.l >= mm[i];\n            dif[i] -= canSplit ? 1 : 0;\n            return canSplit ? y.ss : [y.s];\n          })\n          .flat(),\n  ) as CurveArray[];\n\n  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl, depth + 1);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}