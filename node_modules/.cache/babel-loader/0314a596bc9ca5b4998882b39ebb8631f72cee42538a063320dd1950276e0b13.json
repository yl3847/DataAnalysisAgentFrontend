{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { AABB } from '@antv/g';\nimport { clamp, isNumber, pick } from '@antv/util';\nimport { AnimationType, GraphEvent } from '../constants';\nimport { getAnimationOptions } from '../utils/animation';\nimport { getBBoxSize, getCombinedBBox, getExpandedBBox, isBBoxInside, isPointInBBox } from '../utils/bbox';\nimport { AnimateEvent, ViewportEvent, emit } from '../utils/event';\nimport { isPoint } from '../utils/is';\nimport { parsePadding } from '../utils/padding';\nimport { add, divide, subtract } from '../utils/vector';\nexport class ViewportController {\n  get padding() {\n    return parsePadding(this.context.options.padding);\n  }\n  get paddingOffset() {\n    const [top, right, bottom, left] = this.padding;\n    const [offsetX, offsetY, offsetZ] = [(left - right) / 2, (top - bottom) / 2, 0];\n    return [offsetX, offsetY, offsetZ];\n  }\n  constructor(context) {\n    this.landmarkCounter = 0;\n    this.context = context;\n    const [px, py] = this.paddingOffset;\n    const {\n      zoom,\n      rotation,\n      x = px,\n      y = py\n    } = context.options;\n    this.transform({\n      mode: 'absolute',\n      scale: zoom,\n      translate: [x, y],\n      rotate: rotation\n    }, false);\n  }\n  get camera() {\n    const {\n      canvas\n    } = this.context;\n    return new Proxy(canvas.getCamera(), {\n      get: (target, prop) => {\n        const layers = Object.entries(canvas.getLayers()).filter(([name]) => !['main'].includes(name));\n        const cameras = layers.map(([, layer]) => layer.getCamera());\n        const value = target[prop];\n        if (typeof value === 'function') {\n          return (...args) => {\n            const result = value.apply(target, args);\n            cameras.forEach(camera => {\n              camera[prop].apply(camera, args);\n            });\n            return result;\n          };\n        }\n      }\n    });\n  }\n  createLandmark(options) {\n    return this.camera.createLandmark(`landmark-${this.landmarkCounter++}`, options);\n  }\n  getAnimation(animation) {\n    const finalAnimation = getAnimationOptions(this.context.options, animation);\n    if (!finalAnimation) return false;\n    return pick(Object.assign({}, finalAnimation), ['easing', 'duration']);\n  }\n  getCanvasSize() {\n    const {\n      canvas\n    } = this.context;\n    const {\n      width = 0,\n      height = 0\n    } = canvas.getConfig();\n    return [width, height];\n  }\n  /**\n   * <zh/> 获取画布中心坐标\n   *\n   * <en/> Get the center coordinates of the canvas\n   * @returns - <zh/> 画布中心坐标 | <en/> Center coordinates of the canvas\n   * @remarks\n   * <zh/> 基于画布的宽高计算中心坐标，不受视口变换影响\n   *\n   * <en/> Calculate the center coordinates based on the width and height of the canvas, not affected by the viewport transformation\n   */\n  getCanvasCenter() {\n    const {\n      canvas\n    } = this.context;\n    const {\n      width = 0,\n      height = 0\n    } = canvas.getConfig();\n    return [width / 2, height / 2, 0];\n  }\n  /**\n   * <zh/> 当前视口中心坐标\n   *\n   * <en/> Current viewport center coordinates\n   * @returns - <zh/> 视口中心坐标 | <en/> Viewport center coordinates\n   * @remarks\n   * <zh/> 以画布原点为原点，受到视口变换影响\n   *\n   * <en/> With the origin of the canvas as the origin, affected by the viewport transformation\n   */\n  getViewportCenter() {\n    // 理论上应该通过 camera.getFocalPoint() 获取\n    // 但在 2D 场景下，通过 pan 操作时，focalPoint 不会变化\n    const [x, y] = this.camera.getPosition();\n    return [x, y, 0];\n  }\n  getGraphCenter() {\n    return this.context.graph.getViewportByCanvas(this.getCanvasCenter());\n  }\n  getZoom() {\n    return this.camera.getZoom();\n  }\n  getRotation() {\n    return this.camera.getRoll();\n  }\n  getTranslateOptions(options) {\n    const {\n      camera\n    } = this;\n    const {\n      mode,\n      translate = []\n    } = options;\n    const currentZoom = this.getZoom();\n    const position = camera.getPosition();\n    const focalPoint = camera.getFocalPoint();\n    const [cx, cy] = this.getCanvasCenter();\n    const [x = 0, y = 0, z = 0] = translate;\n    const delta = divide([-x, -y, -z], currentZoom);\n    return mode === 'relative' ? {\n      position: add(position, delta),\n      focalPoint: add(focalPoint, delta)\n    } : {\n      position: add([cx, cy, position[2]], delta),\n      focalPoint: add([cx, cy, focalPoint[2]], delta)\n    };\n  }\n  getRotateOptions(options) {\n    const {\n      mode,\n      rotate = 0\n    } = options;\n    const roll = mode === 'relative' ? this.camera.getRoll() + rotate : rotate;\n    return {\n      roll\n    };\n  }\n  getZoomOptions(options) {\n    const {\n      zoomRange\n    } = this.context.options;\n    const currentZoom = this.camera.getZoom();\n    const {\n      mode,\n      scale = 1\n    } = options;\n    return clamp(mode === 'relative' ? currentZoom * scale : scale, ...zoomRange);\n  }\n  transform(options, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        graph\n      } = this.context;\n      const {\n        translate,\n        rotate,\n        scale,\n        origin\n      } = options;\n      this.cancelAnimation();\n      const _animation = this.getAnimation(animation);\n      emit(graph, new ViewportEvent(GraphEvent.BEFORE_TRANSFORM, options));\n      // 针对缩放操作，且不涉及平移、旋转、中心点、动画时，直接调用 setZoomByViewportPoint\n      // For zoom operations, and no translation, rotation, center point, and animation involved, call setZoomByViewportPoint directly\n      if (!rotate && scale && !translate && origin && !_animation) {\n        this.camera.setZoomByViewportPoint(this.getZoomOptions(options), origin);\n        emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));\n        return;\n      }\n      const landmarkOptions = {};\n      if (translate) Object.assign(landmarkOptions, this.getTranslateOptions(options));\n      if (isNumber(rotate)) Object.assign(landmarkOptions, this.getRotateOptions(options));\n      if (isNumber(scale)) Object.assign(landmarkOptions, {\n        zoom: this.getZoomOptions(options)\n      });\n      if (_animation) {\n        emit(graph, new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.TRANSFORM, null, options));\n        return new Promise(resolve => {\n          this.transformResolver = resolve;\n          this.camera.gotoLandmark(this.createLandmark(landmarkOptions), Object.assign(Object.assign({}, _animation), {\n            onfinish: () => {\n              emit(graph, new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.TRANSFORM, null, options));\n              emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));\n              this.transformResolver = undefined;\n              resolve();\n            }\n          }));\n        });\n      } else {\n        this.camera.gotoLandmark(this.createLandmark(landmarkOptions), {\n          duration: 0\n        });\n        emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));\n      }\n    });\n  }\n  fitView(options, animation) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const [top, right, bottom, left] = this.padding;\n      const {\n        when = 'always',\n        direction = 'both'\n      } = options || {};\n      const [width, height] = this.context.canvas.getSize();\n      const innerWidth = width - left - right;\n      const innerHeight = height - top - bottom;\n      const canvasBounds = this.context.canvas.getBounds();\n      const bboxInViewPort = this.getBBoxInViewport(canvasBounds);\n      const [contentWidth, contentHeight] = getBBoxSize(bboxInViewPort);\n      const isOverflow = direction === 'x' && contentWidth >= innerWidth || direction === 'y' && contentHeight >= innerHeight || direction === 'both' && contentWidth >= innerWidth && contentHeight >= innerHeight;\n      if (when === 'overflow' && !isOverflow) return yield this.fitCenter({\n        animation\n      });\n      const scaleX = innerWidth / contentWidth;\n      const scaleY = innerHeight / contentHeight;\n      const scale = direction === 'x' ? scaleX : direction === 'y' ? scaleY : Math.min(scaleX, scaleY);\n      const _animation = this.getAnimation(animation);\n      yield this.transform({\n        mode: 'relative',\n        scale,\n        translate: add(subtract(this.getCanvasCenter(), this.getBBoxInViewport(canvasBounds).center), divide(this.paddingOffset, scale))\n      }, _animation);\n    });\n  }\n  fitCenter(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const canvasBounds = this.context.canvas.getBounds();\n      yield this.focus(canvasBounds, options);\n    });\n  }\n  focusElements(ids_1) {\n    return __awaiter(this, arguments, void 0, function* (ids, options = {}) {\n      const {\n        element\n      } = this.context;\n      if (!element) return;\n      const getBoundsOf = el => options.shapes ? el.getShape(options.shapes).getRenderBounds() : el.getRenderBounds();\n      const elementsBounds = getCombinedBBox(ids.map(id => getBoundsOf(element.getElement(id))));\n      yield this.focus(elementsBounds, options);\n    });\n  }\n  focus(bbox, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const center = this.context.graph.getViewportByCanvas(bbox.center);\n      const position = options.position || this.getCanvasCenter();\n      const delta = subtract(position, center);\n      yield this.transform({\n        mode: 'relative',\n        translate: add(delta, this.paddingOffset)\n      }, options.animation);\n    });\n  }\n  /**\n   * <zh/> 获取画布元素在视口中的包围盒\n   *\n   * <en/> Get the bounding box of the canvas element in the viewport\n   * @param bbox - <zh/> 画布元素包围盒 | <en/> Canvas element bounding box\n   * @returns - <zh/> 视口中的包围盒 | <en/> Bounding box in the viewport\n   */\n  getBBoxInViewport(bbox) {\n    const {\n      min,\n      max\n    } = bbox;\n    const {\n      graph\n    } = this.context;\n    const [x1, y1] = graph.getViewportByCanvas(min);\n    const [x2, y2] = graph.getViewportByCanvas(max);\n    const bboxInViewport = new AABB();\n    bboxInViewport.setMinMax([x1, y1, 0], [x2, y2, 0]);\n    return bboxInViewport;\n  }\n  /**\n   * <zh/> 判断点或包围盒是否在视口中\n   *\n   * <en/> Determine whether the point or bounding box is in the viewport\n   * @param target - <zh/> 点或包围盒 | <en/> Point or bounding box\n   * @param complete - <zh/> 是否完全在视口中 | <en/> Whether it is completely in the viewport\n   * @param tolerance - <zh/> 视口外的容差 | <en/> Tolerance outside the viewport\n   * @returns - <zh/> 是否在视口中 | <en/> Whether it is in the viewport\n   */\n  isInViewport(target, complete = false, tolerance = 0) {\n    const {\n      graph\n    } = this.context;\n    const size = this.getCanvasSize();\n    const [x1, y1] = graph.getCanvasByViewport([0, 0]);\n    const [x2, y2] = graph.getCanvasByViewport(size);\n    let viewportBBox = new AABB();\n    viewportBBox.setMinMax([x1, y1, 0], [x2, y2, 0]);\n    if (tolerance) {\n      viewportBBox = getExpandedBBox(viewportBBox, tolerance);\n    }\n    return isPoint(target) ? isPointInBBox(target, viewportBBox) : !complete ? viewportBBox.intersects(target) : isBBoxInside(target, viewportBBox);\n  }\n  cancelAnimation() {\n    var _a, _b;\n    // @ts-expect-error landmarks is private\n    if ((_a = this.camera.landmarks) === null || _a === void 0 ? void 0 : _a.length) {\n      this.camera.cancelLandmarkAnimation();\n    }\n    (_b = this.transformResolver) === null || _b === void 0 ? void 0 : _b.call(this);\n  }\n}","map":{"version":3,"names":["AABB","clamp","isNumber","pick","AnimationType","GraphEvent","getAnimationOptions","getBBoxSize","getCombinedBBox","getExpandedBBox","isBBoxInside","isPointInBBox","AnimateEvent","ViewportEvent","emit","isPoint","parsePadding","add","divide","subtract","ViewportController","padding","context","options","paddingOffset","top","right","bottom","left","offsetX","offsetY","offsetZ","constructor","landmarkCounter","px","py","zoom","rotation","x","y","transform","mode","scale","translate","rotate","camera","canvas","Proxy","getCamera","get","target","prop","layers","Object","entries","getLayers","filter","name","includes","cameras","map","layer","value","args","result","apply","forEach","createLandmark","getAnimation","animation","finalAnimation","assign","getCanvasSize","width","height","getConfig","getCanvasCenter","getViewportCenter","getPosition","getGraphCenter","graph","getViewportByCanvas","getZoom","getRotation","getRoll","getTranslateOptions","currentZoom","position","focalPoint","getFocalPoint","cx","cy","z","delta","getRotateOptions","roll","getZoomOptions","zoomRange","origin","cancelAnimation","_animation","BEFORE_TRANSFORM","setZoomByViewportPoint","AFTER_TRANSFORM","landmarkOptions","BEFORE_ANIMATE","TRANSFORM","Promise","resolve","transformResolver","gotoLandmark","onfinish","AFTER_ANIMATE","undefined","duration","fitView","when","direction","getSize","innerWidth","innerHeight","canvasBounds","getBounds","bboxInViewPort","getBBoxInViewport","contentWidth","contentHeight","isOverflow","fitCenter","scaleX","scaleY","Math","min","center","focus","focusElements","ids_1","ids","element","getBoundsOf","el","shapes","getShape","getRenderBounds","elementsBounds","id","getElement","bbox","max","x1","y1","x2","y2","bboxInViewport","setMinMax","isInViewport","complete","tolerance","size","getCanvasByViewport","viewportBBox","intersects","_a","landmarks","length","cancelLandmarkAnimation","_b","call"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g6/src/runtime/viewport.ts"],"sourcesContent":["import { AABB, ICamera } from '@antv/g';\nimport { clamp, isNumber, pick } from '@antv/util';\nimport { AnimationType, GraphEvent } from '../constants';\nimport type { FitViewOptions, ID, Point, TransformOptions, Vector2, ViewportAnimationEffectTiming } from '../types';\nimport type { Element } from '../types/element';\nimport { getAnimationOptions } from '../utils/animation';\nimport { getBBoxSize, getCombinedBBox, getExpandedBBox, isBBoxInside, isPointInBBox } from '../utils/bbox';\nimport { AnimateEvent, ViewportEvent, emit } from '../utils/event';\nimport { isPoint } from '../utils/is';\nimport { parsePadding } from '../utils/padding';\nimport { add, divide, subtract } from '../utils/vector';\nimport type { RuntimeContext } from './types';\n\nexport class ViewportController {\n  private context: RuntimeContext;\n\n  private get padding() {\n    return parsePadding(this.context.options.padding);\n  }\n\n  private get paddingOffset(): Point {\n    const [top, right, bottom, left] = this.padding;\n    const [offsetX, offsetY, offsetZ] = [(left - right) / 2, (top - bottom) / 2, 0];\n    return [offsetX, offsetY, offsetZ];\n  }\n\n  constructor(context: RuntimeContext) {\n    this.context = context;\n    const [px, py] = this.paddingOffset;\n    const { zoom, rotation, x = px, y = py } = context.options;\n    this.transform({ mode: 'absolute', scale: zoom, translate: [x, y], rotate: rotation }, false);\n  }\n\n  private get camera() {\n    const { canvas } = this.context;\n    return new Proxy(canvas.getCamera(), {\n      get: (target, prop: keyof ICamera) => {\n        const layers = Object.entries(canvas.getLayers()).filter(([name]) => !['main'].includes(name));\n        const cameras = layers.map(([, layer]) => layer.getCamera());\n\n        const value = target[prop];\n        if (typeof value === 'function') {\n          return (...args: any[]) => {\n            const result = (value as (...args: any[]) => any).apply(target, args);\n            cameras.forEach((camera) => {\n              (camera[prop] as (...args: any[]) => any).apply(camera, args);\n            });\n\n            return result;\n          };\n        }\n      },\n    });\n  }\n\n  private landmarkCounter = 0;\n\n  private createLandmark(options: Parameters<typeof this.camera.createLandmark>[1]) {\n    return this.camera.createLandmark(`landmark-${this.landmarkCounter++}`, options);\n  }\n\n  private getAnimation(animation?: ViewportAnimationEffectTiming) {\n    const finalAnimation = getAnimationOptions(this.context.options, animation);\n    if (!finalAnimation) return false;\n    return pick({ ...finalAnimation }, ['easing', 'duration']) as Exclude<ViewportAnimationEffectTiming, boolean>;\n  }\n\n  public getCanvasSize(): [number, number] {\n    const { canvas } = this.context;\n    const { width = 0, height = 0 } = canvas.getConfig();\n    return [width, height];\n  }\n\n  /**\n   * <zh/> 获取画布中心坐标\n   *\n   * <en/> Get the center coordinates of the canvas\n   * @returns - <zh/> 画布中心坐标 | <en/> Center coordinates of the canvas\n   * @remarks\n   * <zh/> 基于画布的宽高计算中心坐标，不受视口变换影响\n   *\n   * <en/> Calculate the center coordinates based on the width and height of the canvas, not affected by the viewport transformation\n   */\n  public getCanvasCenter(): Point {\n    const { canvas } = this.context;\n    const { width = 0, height = 0 } = canvas.getConfig();\n    return [width / 2, height / 2, 0];\n  }\n\n  /**\n   * <zh/> 当前视口中心坐标\n   *\n   * <en/> Current viewport center coordinates\n   * @returns - <zh/> 视口中心坐标 | <en/> Viewport center coordinates\n   * @remarks\n   * <zh/> 以画布原点为原点，受到视口变换影响\n   *\n   * <en/> With the origin of the canvas as the origin, affected by the viewport transformation\n   */\n  public getViewportCenter(): Point {\n    // 理论上应该通过 camera.getFocalPoint() 获取\n    // 但在 2D 场景下，通过 pan 操作时，focalPoint 不会变化\n    const [x, y] = this.camera.getPosition();\n    return [x, y, 0];\n  }\n\n  public getGraphCenter(): Point {\n    return this.context.graph.getViewportByCanvas(this.getCanvasCenter());\n  }\n\n  public getZoom() {\n    return this.camera.getZoom();\n  }\n\n  public getRotation() {\n    return this.camera.getRoll();\n  }\n\n  private getTranslateOptions(options: TransformOptions) {\n    const { camera } = this;\n    const { mode, translate = [] } = options;\n    const currentZoom = this.getZoom();\n\n    const position = camera.getPosition();\n    const focalPoint = camera.getFocalPoint();\n    const [cx, cy] = this.getCanvasCenter();\n\n    const [x = 0, y = 0, z = 0] = translate;\n\n    const delta = divide([-x, -y, -z], currentZoom);\n\n    return mode === 'relative'\n      ? {\n          position: add(position, delta),\n          focalPoint: add(focalPoint, delta),\n        }\n      : {\n          position: add([cx, cy, position[2]], delta),\n          focalPoint: add([cx, cy, focalPoint[2]], delta),\n        };\n  }\n\n  private getRotateOptions(options: TransformOptions) {\n    const { mode, rotate = 0 } = options;\n    const roll = mode === 'relative' ? this.camera.getRoll() + rotate : rotate;\n    return { roll };\n  }\n\n  private getZoomOptions(options: TransformOptions) {\n    const { zoomRange } = this.context.options;\n    const currentZoom = this.camera.getZoom();\n    const { mode, scale = 1 } = options;\n    return clamp(mode === 'relative' ? currentZoom * scale : scale, ...zoomRange!);\n  }\n\n  private transformResolver?: () => void;\n\n  public async transform(options: TransformOptions, animation?: ViewportAnimationEffectTiming): Promise<void> {\n    const { graph } = this.context;\n    const { translate, rotate, scale, origin } = options;\n    this.cancelAnimation();\n\n    const _animation = this.getAnimation(animation);\n\n    emit(graph, new ViewportEvent(GraphEvent.BEFORE_TRANSFORM, options));\n\n    // 针对缩放操作，且不涉及平移、旋转、中心点、动画时，直接调用 setZoomByViewportPoint\n    // For zoom operations, and no translation, rotation, center point, and animation involved, call setZoomByViewportPoint directly\n    if (!rotate && scale && !translate && origin && !_animation) {\n      this.camera.setZoomByViewportPoint(this.getZoomOptions(options), origin as Vector2);\n      emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));\n      return;\n    }\n\n    const landmarkOptions: Parameters<typeof this.camera.createLandmark>[1] = {};\n    if (translate) Object.assign(landmarkOptions, this.getTranslateOptions(options));\n    if (isNumber(rotate)) Object.assign(landmarkOptions, this.getRotateOptions(options));\n    if (isNumber(scale)) Object.assign(landmarkOptions, { zoom: this.getZoomOptions(options) });\n\n    if (_animation) {\n      emit(graph, new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.TRANSFORM, null, options));\n\n      return new Promise<void>((resolve) => {\n        this.transformResolver = resolve;\n        this.camera.gotoLandmark(this.createLandmark(landmarkOptions), {\n          ..._animation,\n          onfinish: () => {\n            emit(graph, new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.TRANSFORM, null, options));\n            emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));\n            this.transformResolver = undefined;\n            resolve();\n          },\n        });\n      });\n    } else {\n      this.camera.gotoLandmark(this.createLandmark(landmarkOptions), {\n        duration: 0,\n      });\n\n      emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));\n    }\n  }\n\n  public async fitView(options?: FitViewOptions, animation?: ViewportAnimationEffectTiming): Promise<void> {\n    const [top, right, bottom, left] = this.padding;\n    const { when = 'always', direction = 'both' } = options || {};\n\n    const [width, height] = this.context.canvas.getSize();\n    const innerWidth = width - left - right;\n    const innerHeight = height - top - bottom;\n\n    const canvasBounds = this.context.canvas.getBounds();\n    const bboxInViewPort = this.getBBoxInViewport(canvasBounds);\n    const [contentWidth, contentHeight] = getBBoxSize(bboxInViewPort);\n\n    const isOverflow =\n      (direction === 'x' && contentWidth >= innerWidth) ||\n      (direction === 'y' && contentHeight >= innerHeight) ||\n      (direction === 'both' && contentWidth >= innerWidth && contentHeight >= innerHeight);\n\n    if (when === 'overflow' && !isOverflow) return await this.fitCenter({ animation });\n\n    const scaleX = innerWidth / contentWidth;\n    const scaleY = innerHeight / contentHeight;\n    const scale = direction === 'x' ? scaleX : direction === 'y' ? scaleY : Math.min(scaleX, scaleY);\n\n    const _animation = this.getAnimation(animation);\n    await this.transform(\n      {\n        mode: 'relative',\n        scale,\n        translate: add(\n          subtract(this.getCanvasCenter(), this.getBBoxInViewport(canvasBounds).center),\n          divide(this.paddingOffset, scale),\n        ),\n      },\n      _animation,\n    );\n  }\n\n  public async fitCenter(options: FocusOptions): Promise<void> {\n    const canvasBounds = this.context.canvas.getBounds();\n    await this.focus(canvasBounds, options);\n  }\n\n  public async focusElements(ids: ID[], options: FocusOptions = {}): Promise<void> {\n    const { element } = this.context;\n    if (!element) return;\n\n    const getBoundsOf = (el: Element) =>\n      options.shapes ? el.getShape(options.shapes).getRenderBounds() : el.getRenderBounds();\n\n    const elementsBounds = getCombinedBBox(ids.map((id) => getBoundsOf(element.getElement(id)!)));\n    await this.focus(elementsBounds, options);\n  }\n\n  private async focus(bbox: AABB, options: FocusOptions) {\n    const center = this.context.graph.getViewportByCanvas(bbox.center);\n    const position = options.position || this.getCanvasCenter();\n    const delta = subtract(position, center);\n    await this.transform({ mode: 'relative', translate: add(delta, this.paddingOffset) }, options.animation);\n  }\n\n  /**\n   * <zh/> 获取画布元素在视口中的包围盒\n   *\n   * <en/> Get the bounding box of the canvas element in the viewport\n   * @param bbox - <zh/> 画布元素包围盒 | <en/> Canvas element bounding box\n   * @returns - <zh/> 视口中的包围盒 | <en/> Bounding box in the viewport\n   */\n  public getBBoxInViewport(bbox: AABB) {\n    const { min, max } = bbox;\n    const { graph } = this.context;\n    const [x1, y1] = graph.getViewportByCanvas(min);\n    const [x2, y2] = graph.getViewportByCanvas(max);\n\n    const bboxInViewport = new AABB();\n    bboxInViewport.setMinMax([x1, y1, 0], [x2, y2, 0]);\n    return bboxInViewport;\n  }\n\n  /**\n   * <zh/> 判断点或包围盒是否在视口中\n   *\n   * <en/> Determine whether the point or bounding box is in the viewport\n   * @param target - <zh/> 点或包围盒 | <en/> Point or bounding box\n   * @param complete - <zh/> 是否完全在视口中 | <en/> Whether it is completely in the viewport\n   * @param tolerance - <zh/> 视口外的容差 | <en/> Tolerance outside the viewport\n   * @returns - <zh/> 是否在视口中 | <en/> Whether it is in the viewport\n   */\n  public isInViewport(target: Point | AABB, complete = false, tolerance = 0) {\n    const { graph } = this.context;\n    const size = this.getCanvasSize();\n\n    const [x1, y1] = graph.getCanvasByViewport([0, 0]);\n    const [x2, y2] = graph.getCanvasByViewport(size);\n\n    let viewportBBox = new AABB();\n    viewportBBox.setMinMax([x1, y1, 0], [x2, y2, 0]);\n\n    if (tolerance) {\n      viewportBBox = getExpandedBBox(viewportBBox, tolerance);\n    }\n\n    return isPoint(target)\n      ? isPointInBBox(target, viewportBBox)\n      : !complete\n        ? viewportBBox.intersects(target)\n        : isBBoxInside(target, viewportBBox);\n  }\n\n  public cancelAnimation() {\n    // @ts-expect-error landmarks is private\n    if (this.camera.landmarks?.length) {\n      this.camera.cancelLandmarkAnimation();\n    }\n    this.transformResolver?.();\n  }\n}\n\nexport interface FocusOptions {\n  /**\n   * <zh/> 动画配置\n   *\n   * <en/> Animation configuration\n   */\n  animation?: ViewportAnimationEffectTiming;\n  /**\n   * <zh/> 使用子图形计算包围盒\n   *\n   * <en/> Calculate the bounding box by using sub-shapes\n   */\n  shapes?: string;\n  /**\n   * <zh/> 对齐位置，默认为画布中心\n   *\n   * <en/> Alignment position, default is the center of the canvas\n   */\n  position?: Point;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,IAAI,QAAiB,SAAS;AACvC,SAASC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,QAAQ,YAAY;AAClD,SAASC,aAAa,EAAEC,UAAU,QAAQ,cAAc;AAGxD,SAASC,mBAAmB,QAAQ,oBAAoB;AACxD,SAASC,WAAW,EAAEC,eAAe,EAAEC,eAAe,EAAEC,YAAY,EAAEC,aAAa,QAAQ,eAAe;AAC1G,SAASC,YAAY,EAAEC,aAAa,EAAEC,IAAI,QAAQ,gBAAgB;AAClE,SAASC,OAAO,QAAQ,aAAa;AACrC,SAASC,YAAY,QAAQ,kBAAkB;AAC/C,SAASC,GAAG,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,iBAAiB;AAGvD,OAAM,MAAOC,kBAAkB;EAG7B,IAAYC,OAAOA,CAAA;IACjB,OAAOL,YAAY,CAAC,IAAI,CAACM,OAAO,CAACC,OAAO,CAACF,OAAO,CAAC;EACnD;EAEA,IAAYG,aAAaA,CAAA;IACvB,MAAM,CAACC,GAAG,EAAEC,KAAK,EAAEC,MAAM,EAAEC,IAAI,CAAC,GAAG,IAAI,CAACP,OAAO;IAC/C,MAAM,CAACQ,OAAO,EAAEC,OAAO,EAAEC,OAAO,CAAC,GAAG,CAAC,CAACH,IAAI,GAAGF,KAAK,IAAI,CAAC,EAAE,CAACD,GAAG,GAAGE,MAAM,IAAI,CAAC,EAAE,CAAC,CAAC;IAC/E,OAAO,CAACE,OAAO,EAAEC,OAAO,EAAEC,OAAO,CAAC;EACpC;EAEAC,YAAYV,OAAuB;IA6B3B,KAAAW,eAAe,GAAG,CAAC;IA5BzB,IAAI,CAACX,OAAO,GAAGA,OAAO;IACtB,MAAM,CAACY,EAAE,EAAEC,EAAE,CAAC,GAAG,IAAI,CAACX,aAAa;IACnC,MAAM;MAAEY,IAAI;MAAEC,QAAQ;MAAEC,CAAC,GAAGJ,EAAE;MAAEK,CAAC,GAAGJ;IAAE,CAAE,GAAGb,OAAO,CAACC,OAAO;IAC1D,IAAI,CAACiB,SAAS,CAAC;MAAEC,IAAI,EAAE,UAAU;MAAEC,KAAK,EAAEN,IAAI;MAAEO,SAAS,EAAE,CAACL,CAAC,EAAEC,CAAC,CAAC;MAAEK,MAAM,EAAEP;IAAQ,CAAE,EAAE,KAAK,CAAC;EAC/F;EAEA,IAAYQ,MAAMA,CAAA;IAChB,MAAM;MAAEC;IAAM,CAAE,GAAG,IAAI,CAACxB,OAAO;IAC/B,OAAO,IAAIyB,KAAK,CAACD,MAAM,CAACE,SAAS,EAAE,EAAE;MACnCC,GAAG,EAAEA,CAACC,MAAM,EAAEC,IAAmB,KAAI;QACnC,MAAMC,MAAM,GAAGC,MAAM,CAACC,OAAO,CAACR,MAAM,CAACS,SAAS,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAACC,QAAQ,CAACD,IAAI,CAAC,CAAC;QAC9F,MAAME,OAAO,GAAGP,MAAM,CAACQ,GAAG,CAAC,CAAC,GAAGC,KAAK,CAAC,KAAKA,KAAK,CAACb,SAAS,EAAE,CAAC;QAE5D,MAAMc,KAAK,GAAGZ,MAAM,CAACC,IAAI,CAAC;QAC1B,IAAI,OAAOW,KAAK,KAAK,UAAU,EAAE;UAC/B,OAAO,CAAC,GAAGC,IAAW,KAAI;YACxB,MAAMC,MAAM,GAAIF,KAAiC,CAACG,KAAK,CAACf,MAAM,EAAEa,IAAI,CAAC;YACrEJ,OAAO,CAACO,OAAO,CAAErB,MAAM,IAAI;cACxBA,MAAM,CAACM,IAAI,CAA6B,CAACc,KAAK,CAACpB,MAAM,EAAEkB,IAAI,CAAC;YAC/D,CAAC,CAAC;YAEF,OAAOC,MAAM;UACf,CAAC;QACH;MACF;KACD,CAAC;EACJ;EAIQG,cAAcA,CAAC5C,OAAyD;IAC9E,OAAO,IAAI,CAACsB,MAAM,CAACsB,cAAc,CAAC,YAAY,IAAI,CAAClC,eAAe,EAAE,EAAE,EAAEV,OAAO,CAAC;EAClF;EAEQ6C,YAAYA,CAACC,SAAyC;IAC5D,MAAMC,cAAc,GAAGhE,mBAAmB,CAAC,IAAI,CAACgB,OAAO,CAACC,OAAO,EAAE8C,SAAS,CAAC;IAC3E,IAAI,CAACC,cAAc,EAAE,OAAO,KAAK;IACjC,OAAOnE,IAAI,CAAAkD,MAAA,CAAAkB,MAAA,KAAMD,cAAc,GAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAoD;EAC/G;EAEOE,aAAaA,CAAA;IAClB,MAAM;MAAE1B;IAAM,CAAE,GAAG,IAAI,CAACxB,OAAO;IAC/B,MAAM;MAAEmD,KAAK,GAAG,CAAC;MAAEC,MAAM,GAAG;IAAC,CAAE,GAAG5B,MAAM,CAAC6B,SAAS,EAAE;IACpD,OAAO,CAACF,KAAK,EAAEC,MAAM,CAAC;EACxB;EAEA;;;;;;;;;;EAUOE,eAAeA,CAAA;IACpB,MAAM;MAAE9B;IAAM,CAAE,GAAG,IAAI,CAACxB,OAAO;IAC/B,MAAM;MAAEmD,KAAK,GAAG,CAAC;MAAEC,MAAM,GAAG;IAAC,CAAE,GAAG5B,MAAM,CAAC6B,SAAS,EAAE;IACpD,OAAO,CAACF,KAAK,GAAG,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;EACnC;EAEA;;;;;;;;;;EAUOG,iBAAiBA,CAAA;IACtB;IACA;IACA,MAAM,CAACvC,CAAC,EAAEC,CAAC,CAAC,GAAG,IAAI,CAACM,MAAM,CAACiC,WAAW,EAAE;IACxC,OAAO,CAACxC,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC;EAClB;EAEOwC,cAAcA,CAAA;IACnB,OAAO,IAAI,CAACzD,OAAO,CAAC0D,KAAK,CAACC,mBAAmB,CAAC,IAAI,CAACL,eAAe,EAAE,CAAC;EACvE;EAEOM,OAAOA,CAAA;IACZ,OAAO,IAAI,CAACrC,MAAM,CAACqC,OAAO,EAAE;EAC9B;EAEOC,WAAWA,CAAA;IAChB,OAAO,IAAI,CAACtC,MAAM,CAACuC,OAAO,EAAE;EAC9B;EAEQC,mBAAmBA,CAAC9D,OAAyB;IACnD,MAAM;MAAEsB;IAAM,CAAE,GAAG,IAAI;IACvB,MAAM;MAAEJ,IAAI;MAAEE,SAAS,GAAG;IAAE,CAAE,GAAGpB,OAAO;IACxC,MAAM+D,WAAW,GAAG,IAAI,CAACJ,OAAO,EAAE;IAElC,MAAMK,QAAQ,GAAG1C,MAAM,CAACiC,WAAW,EAAE;IACrC,MAAMU,UAAU,GAAG3C,MAAM,CAAC4C,aAAa,EAAE;IACzC,MAAM,CAACC,EAAE,EAAEC,EAAE,CAAC,GAAG,IAAI,CAACf,eAAe,EAAE;IAEvC,MAAM,CAACtC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEqD,CAAC,GAAG,CAAC,CAAC,GAAGjD,SAAS;IAEvC,MAAMkD,KAAK,GAAG3E,MAAM,CAAC,CAAC,CAACoB,CAAC,EAAE,CAACC,CAAC,EAAE,CAACqD,CAAC,CAAC,EAAEN,WAAW,CAAC;IAE/C,OAAO7C,IAAI,KAAK,UAAU,GACtB;MACE8C,QAAQ,EAAEtE,GAAG,CAACsE,QAAQ,EAAEM,KAAK,CAAC;MAC9BL,UAAU,EAAEvE,GAAG,CAACuE,UAAU,EAAEK,KAAK;KAClC,GACD;MACEN,QAAQ,EAAEtE,GAAG,CAAC,CAACyE,EAAE,EAAEC,EAAE,EAAEJ,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAEM,KAAK,CAAC;MAC3CL,UAAU,EAAEvE,GAAG,CAAC,CAACyE,EAAE,EAAEC,EAAE,EAAEH,UAAU,CAAC,CAAC,CAAC,CAAC,EAAEK,KAAK;KAC/C;EACP;EAEQC,gBAAgBA,CAACvE,OAAyB;IAChD,MAAM;MAAEkB,IAAI;MAAEG,MAAM,GAAG;IAAC,CAAE,GAAGrB,OAAO;IACpC,MAAMwE,IAAI,GAAGtD,IAAI,KAAK,UAAU,GAAG,IAAI,CAACI,MAAM,CAACuC,OAAO,EAAE,GAAGxC,MAAM,GAAGA,MAAM;IAC1E,OAAO;MAAEmD;IAAI,CAAE;EACjB;EAEQC,cAAcA,CAACzE,OAAyB;IAC9C,MAAM;MAAE0E;IAAS,CAAE,GAAG,IAAI,CAAC3E,OAAO,CAACC,OAAO;IAC1C,MAAM+D,WAAW,GAAG,IAAI,CAACzC,MAAM,CAACqC,OAAO,EAAE;IACzC,MAAM;MAAEzC,IAAI;MAAEC,KAAK,GAAG;IAAC,CAAE,GAAGnB,OAAO;IACnC,OAAOtB,KAAK,CAACwC,IAAI,KAAK,UAAU,GAAG6C,WAAW,GAAG5C,KAAK,GAAGA,KAAK,EAAE,GAAGuD,SAAU,CAAC;EAChF;EAIazD,SAASA,CAACjB,OAAyB,EAAE8C,SAAyC;;MACzF,MAAM;QAAEW;MAAK,CAAE,GAAG,IAAI,CAAC1D,OAAO;MAC9B,MAAM;QAAEqB,SAAS;QAAEC,MAAM;QAAEF,KAAK;QAAEwD;MAAM,CAAE,GAAG3E,OAAO;MACpD,IAAI,CAAC4E,eAAe,EAAE;MAEtB,MAAMC,UAAU,GAAG,IAAI,CAAChC,YAAY,CAACC,SAAS,CAAC;MAE/CvD,IAAI,CAACkE,KAAK,EAAE,IAAInE,aAAa,CAACR,UAAU,CAACgG,gBAAgB,EAAE9E,OAAO,CAAC,CAAC;MAEpE;MACA;MACA,IAAI,CAACqB,MAAM,IAAIF,KAAK,IAAI,CAACC,SAAS,IAAIuD,MAAM,IAAI,CAACE,UAAU,EAAE;QAC3D,IAAI,CAACvD,MAAM,CAACyD,sBAAsB,CAAC,IAAI,CAACN,cAAc,CAACzE,OAAO,CAAC,EAAE2E,MAAiB,CAAC;QACnFpF,IAAI,CAACkE,KAAK,EAAE,IAAInE,aAAa,CAACR,UAAU,CAACkG,eAAe,EAAEhF,OAAO,CAAC,CAAC;QACnE;MACF;MAEA,MAAMiF,eAAe,GAAqD,EAAE;MAC5E,IAAI7D,SAAS,EAAEU,MAAM,CAACkB,MAAM,CAACiC,eAAe,EAAE,IAAI,CAACnB,mBAAmB,CAAC9D,OAAO,CAAC,CAAC;MAChF,IAAIrB,QAAQ,CAAC0C,MAAM,CAAC,EAAES,MAAM,CAACkB,MAAM,CAACiC,eAAe,EAAE,IAAI,CAACV,gBAAgB,CAACvE,OAAO,CAAC,CAAC;MACpF,IAAIrB,QAAQ,CAACwC,KAAK,CAAC,EAAEW,MAAM,CAACkB,MAAM,CAACiC,eAAe,EAAE;QAAEpE,IAAI,EAAE,IAAI,CAAC4D,cAAc,CAACzE,OAAO;MAAC,CAAE,CAAC;MAE3F,IAAI6E,UAAU,EAAE;QACdtF,IAAI,CAACkE,KAAK,EAAE,IAAIpE,YAAY,CAACP,UAAU,CAACoG,cAAc,EAAErG,aAAa,CAACsG,SAAS,EAAE,IAAI,EAAEnF,OAAO,CAAC,CAAC;QAEhG,OAAO,IAAIoF,OAAO,CAAQC,OAAO,IAAI;UACnC,IAAI,CAACC,iBAAiB,GAAGD,OAAO;UAChC,IAAI,CAAC/D,MAAM,CAACiE,YAAY,CAAC,IAAI,CAAC3C,cAAc,CAACqC,eAAe,CAAC,EAAAnD,MAAA,CAAAkB,MAAA,CAAAlB,MAAA,CAAAkB,MAAA,KACxD6B,UAAU;YACbW,QAAQ,EAAEA,CAAA,KAAK;cACbjG,IAAI,CAACkE,KAAK,EAAE,IAAIpE,YAAY,CAACP,UAAU,CAAC2G,aAAa,EAAE5G,aAAa,CAACsG,SAAS,EAAE,IAAI,EAAEnF,OAAO,CAAC,CAAC;cAC/FT,IAAI,CAACkE,KAAK,EAAE,IAAInE,aAAa,CAACR,UAAU,CAACkG,eAAe,EAAEhF,OAAO,CAAC,CAAC;cACnE,IAAI,CAACsF,iBAAiB,GAAGI,SAAS;cAClCL,OAAO,EAAE;YACX;UAAC,GACD;QACJ,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAI,CAAC/D,MAAM,CAACiE,YAAY,CAAC,IAAI,CAAC3C,cAAc,CAACqC,eAAe,CAAC,EAAE;UAC7DU,QAAQ,EAAE;SACX,CAAC;QAEFpG,IAAI,CAACkE,KAAK,EAAE,IAAInE,aAAa,CAACR,UAAU,CAACkG,eAAe,EAAEhF,OAAO,CAAC,CAAC;MACrE;IACF,CAAC;;EAEY4F,OAAOA,CAAC5F,OAAwB,EAAE8C,SAAyC;;MACtF,MAAM,CAAC5C,GAAG,EAAEC,KAAK,EAAEC,MAAM,EAAEC,IAAI,CAAC,GAAG,IAAI,CAACP,OAAO;MAC/C,MAAM;QAAE+F,IAAI,GAAG,QAAQ;QAAEC,SAAS,GAAG;MAAM,CAAE,GAAG9F,OAAO,IAAI,EAAE;MAE7D,MAAM,CAACkD,KAAK,EAAEC,MAAM,CAAC,GAAG,IAAI,CAACpD,OAAO,CAACwB,MAAM,CAACwE,OAAO,EAAE;MACrD,MAAMC,UAAU,GAAG9C,KAAK,GAAG7C,IAAI,GAAGF,KAAK;MACvC,MAAM8F,WAAW,GAAG9C,MAAM,GAAGjD,GAAG,GAAGE,MAAM;MAEzC,MAAM8F,YAAY,GAAG,IAAI,CAACnG,OAAO,CAACwB,MAAM,CAAC4E,SAAS,EAAE;MACpD,MAAMC,cAAc,GAAG,IAAI,CAACC,iBAAiB,CAACH,YAAY,CAAC;MAC3D,MAAM,CAACI,YAAY,EAAEC,aAAa,CAAC,GAAGvH,WAAW,CAACoH,cAAc,CAAC;MAEjE,MAAMI,UAAU,GACbV,SAAS,KAAK,GAAG,IAAIQ,YAAY,IAAIN,UAAU,IAC/CF,SAAS,KAAK,GAAG,IAAIS,aAAa,IAAIN,WAAY,IAClDH,SAAS,KAAK,MAAM,IAAIQ,YAAY,IAAIN,UAAU,IAAIO,aAAa,IAAIN,WAAY;MAEtF,IAAIJ,IAAI,KAAK,UAAU,IAAI,CAACW,UAAU,EAAE,OAAO,MAAM,IAAI,CAACC,SAAS,CAAC;QAAE3D;MAAS,CAAE,CAAC;MAElF,MAAM4D,MAAM,GAAGV,UAAU,GAAGM,YAAY;MACxC,MAAMK,MAAM,GAAGV,WAAW,GAAGM,aAAa;MAC1C,MAAMpF,KAAK,GAAG2E,SAAS,KAAK,GAAG,GAAGY,MAAM,GAAGZ,SAAS,KAAK,GAAG,GAAGa,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACH,MAAM,EAAEC,MAAM,CAAC;MAEhG,MAAM9B,UAAU,GAAG,IAAI,CAAChC,YAAY,CAACC,SAAS,CAAC;MAC/C,MAAM,IAAI,CAAC7B,SAAS,CAClB;QACEC,IAAI,EAAE,UAAU;QAChBC,KAAK;QACLC,SAAS,EAAE1B,GAAG,CACZE,QAAQ,CAAC,IAAI,CAACyD,eAAe,EAAE,EAAE,IAAI,CAACgD,iBAAiB,CAACH,YAAY,CAAC,CAACY,MAAM,CAAC,EAC7EnH,MAAM,CAAC,IAAI,CAACM,aAAa,EAAEkB,KAAK,CAAC;OAEpC,EACD0D,UAAU,CACX;IACH,CAAC;;EAEY4B,SAASA,CAACzG,OAAqB;;MAC1C,MAAMkG,YAAY,GAAG,IAAI,CAACnG,OAAO,CAACwB,MAAM,CAAC4E,SAAS,EAAE;MACpD,MAAM,IAAI,CAACY,KAAK,CAACb,YAAY,EAAElG,OAAO,CAAC;IACzC,CAAC;;EAEYgH,aAAaA,CAAAC,KAAA;yDAACC,GAAS,EAAElH,OAAA,GAAwB,EAAE;MAC9D,MAAM;QAAEmH;MAAO,CAAE,GAAG,IAAI,CAACpH,OAAO;MAChC,IAAI,CAACoH,OAAO,EAAE;MAEd,MAAMC,WAAW,GAAIC,EAAW,IAC9BrH,OAAO,CAACsH,MAAM,GAAGD,EAAE,CAACE,QAAQ,CAACvH,OAAO,CAACsH,MAAM,CAAC,CAACE,eAAe,EAAE,GAAGH,EAAE,CAACG,eAAe,EAAE;MAEvF,MAAMC,cAAc,GAAGxI,eAAe,CAACiI,GAAG,CAAC7E,GAAG,CAAEqF,EAAE,IAAKN,WAAW,CAACD,OAAO,CAACQ,UAAU,CAACD,EAAE,CAAE,CAAC,CAAC,CAAC;MAC7F,MAAM,IAAI,CAACX,KAAK,CAACU,cAAc,EAAEzH,OAAO,CAAC;IAC3C,CAAC;;EAEa+G,KAAKA,CAACa,IAAU,EAAE5H,OAAqB;;MACnD,MAAM8G,MAAM,GAAG,IAAI,CAAC/G,OAAO,CAAC0D,KAAK,CAACC,mBAAmB,CAACkE,IAAI,CAACd,MAAM,CAAC;MAClE,MAAM9C,QAAQ,GAAGhE,OAAO,CAACgE,QAAQ,IAAI,IAAI,CAACX,eAAe,EAAE;MAC3D,MAAMiB,KAAK,GAAG1E,QAAQ,CAACoE,QAAQ,EAAE8C,MAAM,CAAC;MACxC,MAAM,IAAI,CAAC7F,SAAS,CAAC;QAAEC,IAAI,EAAE,UAAU;QAAEE,SAAS,EAAE1B,GAAG,CAAC4E,KAAK,EAAE,IAAI,CAACrE,aAAa;MAAC,CAAE,EAAED,OAAO,CAAC8C,SAAS,CAAC;IAC1G,CAAC;;EAED;;;;;;;EAOOuD,iBAAiBA,CAACuB,IAAU;IACjC,MAAM;MAAEf,GAAG;MAAEgB;IAAG,CAAE,GAAGD,IAAI;IACzB,MAAM;MAAEnE;IAAK,CAAE,GAAG,IAAI,CAAC1D,OAAO;IAC9B,MAAM,CAAC+H,EAAE,EAAEC,EAAE,CAAC,GAAGtE,KAAK,CAACC,mBAAmB,CAACmD,GAAG,CAAC;IAC/C,MAAM,CAACmB,EAAE,EAAEC,EAAE,CAAC,GAAGxE,KAAK,CAACC,mBAAmB,CAACmE,GAAG,CAAC;IAE/C,MAAMK,cAAc,GAAG,IAAIzJ,IAAI,EAAE;IACjCyJ,cAAc,CAACC,SAAS,CAAC,CAACL,EAAE,EAAEC,EAAE,EAAE,CAAC,CAAC,EAAE,CAACC,EAAE,EAAEC,EAAE,EAAE,CAAC,CAAC,CAAC;IAClD,OAAOC,cAAc;EACvB;EAEA;;;;;;;;;EASOE,YAAYA,CAACzG,MAAoB,EAAE0G,QAAQ,GAAG,KAAK,EAAEC,SAAS,GAAG,CAAC;IACvE,MAAM;MAAE7E;IAAK,CAAE,GAAG,IAAI,CAAC1D,OAAO;IAC9B,MAAMwI,IAAI,GAAG,IAAI,CAACtF,aAAa,EAAE;IAEjC,MAAM,CAAC6E,EAAE,EAAEC,EAAE,CAAC,GAAGtE,KAAK,CAAC+E,mBAAmB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAClD,MAAM,CAACR,EAAE,EAAEC,EAAE,CAAC,GAAGxE,KAAK,CAAC+E,mBAAmB,CAACD,IAAI,CAAC;IAEhD,IAAIE,YAAY,GAAG,IAAIhK,IAAI,EAAE;IAC7BgK,YAAY,CAACN,SAAS,CAAC,CAACL,EAAE,EAAEC,EAAE,EAAE,CAAC,CAAC,EAAE,CAACC,EAAE,EAAEC,EAAE,EAAE,CAAC,CAAC,CAAC;IAEhD,IAAIK,SAAS,EAAE;MACbG,YAAY,GAAGvJ,eAAe,CAACuJ,YAAY,EAAEH,SAAS,CAAC;IACzD;IAEA,OAAO9I,OAAO,CAACmC,MAAM,CAAC,GAClBvC,aAAa,CAACuC,MAAM,EAAE8G,YAAY,CAAC,GACnC,CAACJ,QAAQ,GACPI,YAAY,CAACC,UAAU,CAAC/G,MAAM,CAAC,GAC/BxC,YAAY,CAACwC,MAAM,EAAE8G,YAAY,CAAC;EAC1C;EAEO7D,eAAeA,CAAA;;IACpB;IACA,IAAI,CAAA+D,EAAA,OAAI,CAACrH,MAAM,CAACsH,SAAS,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,MAAM,EAAE;MACjC,IAAI,CAACvH,MAAM,CAACwH,uBAAuB,EAAE;IACvC;IACA,CAAAC,EAAA,OAAI,CAACzD,iBAAiB,cAAAyD,EAAA,uBAAAA,EAAA,CAAAC,IAAA,MAAI;EAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}