{"ast":null,"code":"import { __assign, __extends, __read } from \"tslib\";\nimport { Band, Linear } from '@antv/scale';\nimport { clone, isArray, isFunction, isNumber } from '@antv/util';\nimport { Component } from '../../core';\nimport { maybeAppend, select, subStyleProps } from '../../util';\nimport { Columns } from './columns';\nimport { Lines } from './lines';\nimport { dataToLines, lineToCurvePath, lineToLinePath, linesToAreaPaths, linesToStackAreaPaths, linesToStackCurveAreaPaths } from './path';\nimport { getRange, getStackedData } from './utils';\nvar Sparkline = /** @class */function (_super) {\n  __extends(Sparkline, _super);\n  function Sparkline(options) {\n    return _super.call(this, options, {\n      type: 'line',\n      x: 0,\n      y: 0,\n      width: 200,\n      height: 20,\n      isStack: false,\n      color: ['#83daad', '#edbf45', '#d2cef9', '#e290b3', '#6f63f4'],\n      smooth: true,\n      lineLineWidth: 1,\n      areaOpacity: 0,\n      isGroup: false,\n      columnLineWidth: 1,\n      columnStroke: '#fff',\n      scale: 1,\n      spacing: 0\n    }) || this;\n  }\n  Object.defineProperty(Sparkline.prototype, \"rawData\", {\n    /**\n     * 将data统一格式化为数组形式\n     * 如果堆叠，则生成堆叠数据\n     */\n    get: function () {\n      var rawData = this.attributes.data;\n      if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0) return [[]];\n      var data = clone(rawData);\n      // number[] -> number[][]\n      return isNumber(data[0]) ? [data] : data;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sparkline.prototype, \"data\", {\n    get: function () {\n      if (this.attributes.isStack) return getStackedData(this.rawData);\n      return this.rawData;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sparkline.prototype, \"scales\", {\n    get: function () {\n      return this.createScales(this.data);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sparkline.prototype, \"baseline\", {\n    /**\n     * 基准线，默认为 0\n     */\n    get: function () {\n      var y = this.scales.y;\n      var _a = __read(y.getOptions().domain || [0, 0], 2),\n        y1 = _a[0],\n        y2 = _a[1];\n      if (y2 < 0) {\n        return y.map(y2);\n      }\n      return y.map(y1 < 0 ? 0 : y1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sparkline.prototype, \"containerShape\", {\n    get: function () {\n      var _a = this.attributes,\n        width = _a.width,\n        height = _a.height;\n      return {\n        width: width,\n        height: height\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sparkline.prototype, \"linesStyle\", {\n    get: function () {\n      var _this = this;\n      var _a = this.attributes,\n        type = _a.type,\n        isStack = _a.isStack,\n        smooth = _a.smooth;\n      if (type !== 'line') throw new Error('linesStyle can only be used in line type');\n      var areaStyle = subStyleProps(this.attributes, 'area');\n      var lineStyle = subStyleProps(this.attributes, 'line');\n      var width = this.containerShape.width;\n      var data = this.data;\n      if (data[0].length === 0) return {\n        lines: [],\n        areas: []\n      };\n      var _b = this.scales,\n        x = _b.x,\n        y = _b.y;\n      // 线条Path\n      var lines = dataToLines(data, {\n        type: 'line',\n        x: x,\n        y: y\n      });\n      // 生成区域path\n      var areas = [];\n      if (areaStyle) {\n        var baseline = this.baseline;\n        if (isStack) {\n          areas = smooth ? linesToStackCurveAreaPaths(lines, width, baseline) : linesToStackAreaPaths(lines, width, baseline);\n        } else {\n          areas = linesToAreaPaths(lines, smooth, width, baseline);\n        }\n      }\n      return {\n        lines: lines.map(function (line, idx) {\n          return __assign({\n            stroke: _this.getColor(idx),\n            d: smooth ? lineToCurvePath(line) : lineToLinePath(line)\n          }, lineStyle);\n        }),\n        areas: areas.map(function (path, idx) {\n          return __assign({\n            d: path,\n            fill: _this.getColor(idx)\n          }, areaStyle);\n        })\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sparkline.prototype, \"columnsStyle\", {\n    get: function () {\n      var _this = this;\n      var columnStyle = subStyleProps(this.attributes, 'column');\n      var _a = this.attributes,\n        isStack = _a.isStack,\n        type = _a.type,\n        scale = _a.scale;\n      if (type !== 'column') throw new Error('columnsStyle can only be used in column type');\n      var height = this.containerShape.height;\n      var data = this.rawData;\n      if (!data) return {\n        columns: []\n      };\n      if (isStack) data = getStackedData(data);\n      var _b = this.createScales(data),\n        x = _b.x,\n        y = _b.y;\n      var _c = __read(getRange(data), 2),\n        minVal = _c[0],\n        maxVal = _c[1];\n      var heightScale = new Linear({\n        domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],\n        range: [0, height * scale]\n      });\n      var bandWidth = x.getBandWidth();\n      var rawData = this.rawData;\n      return {\n        columns: data.map(function (column, i) {\n          return column.map(function (val, j) {\n            var barWidth = bandWidth / data.length;\n            var getShape = function () {\n              return {\n                x: x.map(j) + barWidth * i,\n                y: val >= 0 ? y.map(val) : y.map(0),\n                width: barWidth,\n                height: heightScale.map(Math.abs(val))\n              };\n            };\n            var getStackShape = function () {\n              return {\n                x: x.map(j),\n                y: y.map(val),\n                width: bandWidth,\n                height: heightScale.map(rawData[i][j])\n              };\n            };\n            return __assign(__assign({\n              fill: _this.getColor(i)\n            }, columnStyle), isStack ? getStackShape() : getShape());\n          });\n        })\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Sparkline.prototype.render = function (attributes, container) {\n    maybeAppend(container, '.container', 'rect').attr('className', 'container').node();\n    var type = attributes.type,\n      x = attributes.x,\n      y = attributes.y;\n    var className = \"spark\".concat(type);\n    var style = __assign({\n      x: x,\n      y: y\n    }, type === 'line' ? this.linesStyle : this.columnsStyle);\n    select(container).selectAll('.spark').data([type]).join(function (enter) {\n      return enter.append(function (type) {\n        if (type === 'line') return new Lines({\n          className: className,\n          style: style\n        });\n        return new Columns({\n          className: className,\n          style: style\n        });\n      }).attr('className', \"spark \".concat(className));\n    }, function (update) {\n      return update.update(style);\n    }, function (exit) {\n      return exit.remove();\n    });\n  };\n  /**\n   * 根据数据索引获取color\n   */\n  Sparkline.prototype.getColor = function (index) {\n    var color = this.attributes.color;\n    if (isArray(color)) {\n      return color[index % color.length];\n    }\n    if (isFunction(color)) {\n      return color.call(null, index);\n    }\n    return color;\n  };\n  /**\n   * 根据数据生成scale\n   */\n  Sparkline.prototype.createScales = function (data) {\n    var _a, _b;\n    var _c = this.attributes,\n      type = _c.type,\n      scale = _c.scale,\n      _d = _c.range,\n      range = _d === void 0 ? [] : _d,\n      spacing = _c.spacing;\n    var _e = this.containerShape,\n      width = _e.width,\n      height = _e.height;\n    var _f = __read(getRange(data), 2),\n      minVal = _f[0],\n      maxVal = _f[1];\n    var yScale = new Linear({\n      domain: [(_a = range[0]) !== null && _a !== void 0 ? _a : minVal, (_b = range[1]) !== null && _b !== void 0 ? _b : maxVal],\n      range: [height, height * (1 - scale)]\n    });\n    if (type === 'line') {\n      return {\n        type: type,\n        x: new Linear({\n          domain: [0, data[0].length - 1],\n          range: [0, width]\n        }),\n        y: yScale\n      };\n    }\n    return {\n      type: type,\n      x: new Band({\n        domain: data[0].map(function (val, idx) {\n          return idx;\n        }),\n        range: [0, width],\n        paddingInner: spacing,\n        paddingOuter: spacing / 2,\n        align: 0.5\n      }),\n      y: yScale\n    };\n  };\n  Sparkline.tag = 'sparkline';\n  return Sparkline;\n}(Component);\nexport { Sparkline };","map":{"version":3,"names":["Band","Linear","clone","isArray","isFunction","isNumber","Component","maybeAppend","select","subStyleProps","Columns","Lines","dataToLines","lineToCurvePath","lineToLinePath","linesToAreaPaths","linesToStackAreaPaths","linesToStackCurveAreaPaths","getRange","getStackedData","Sparkline","_super","__extends","options","call","type","x","y","width","height","isStack","color","smooth","lineLineWidth","areaOpacity","isGroup","columnLineWidth","columnStroke","scale","spacing","Object","defineProperty","prototype","get","rawData","attributes","data","length","createScales","scales","_a","__read","getOptions","domain","y1","y2","map","_this","Error","areaStyle","lineStyle","containerShape","lines","areas","_b","baseline","line","idx","__assign","stroke","getColor","d","path","fill","columnStyle","columns","_c","minVal","maxVal","heightScale","range","bandWidth","getBandWidth","column","i","val","j","barWidth","getShape","Math","abs","getStackShape","render","container","attr","node","className","concat","style","linesStyle","columnsStyle","selectAll","join","enter","append","update","exit","remove","index","_d","_e","_f","yScale","paddingInner","paddingOuter","align","tag"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/component/src/ui/sparkline/index.ts"],"sourcesContent":["import { Band, Linear } from '@antv/scale';\nimport { clone, isArray, isFunction, isNumber } from '@antv/util';\nimport { Component } from '../../core';\nimport { Group } from '../../shapes';\nimport { maybeAppend, select, subStyleProps } from '../../util';\nimport type { ColumnStyleProps, ColumnsStyleProps } from './columns';\nimport { Columns } from './columns';\nimport type { LinesStyleProps } from './lines';\nimport { Lines } from './lines';\nimport {\n  dataToLines,\n  lineToCurvePath,\n  lineToLinePath,\n  linesToAreaPaths,\n  linesToStackAreaPaths,\n  linesToStackCurveAreaPaths,\n} from './path';\nimport type { Data, SparklineOptions, SparklineStyleProps } from './types';\nimport { getRange, getStackedData } from './utils';\n\nexport type { SparklineOptions, SparklineStyleProps };\n\nexport class Sparkline extends Component<SparklineStyleProps> {\n  public static tag = 'sparkline';\n\n  /**\n   * 将data统一格式化为数组形式\n   * 如果堆叠，则生成堆叠数据\n   */\n  private get rawData(): Data {\n    const { data: rawData } = this.attributes;\n    if (!rawData || rawData?.length === 0) return [[]];\n    const data = clone(rawData);\n    // number[] -> number[][]\n    return isNumber(data[0]) ? [data] : data;\n  }\n\n  private get data(): Data {\n    if (this.attributes.isStack) return getStackedData(this.rawData);\n    return this.rawData;\n  }\n\n  private get scales(): { x: Linear | Band; y: Linear } {\n    return this.createScales(this.data);\n  }\n\n  /**\n   * 基准线，默认为 0\n   */\n  private get baseline(): number {\n    const { y } = this.scales;\n    const [y1, y2] = y.getOptions().domain || [0, 0];\n    if (y2 < 0) {\n      return y.map(y2);\n    }\n\n    return y.map(y1 < 0 ? 0 : y1);\n  }\n\n  private get containerShape() {\n    const { width, height } = this.attributes;\n    return { width, height } as { width: number; height: number };\n  }\n\n  private get linesStyle(): LinesStyleProps {\n    const { type, isStack, smooth } = this.attributes;\n    if (type !== 'line') throw new Error('linesStyle can only be used in line type');\n    const areaStyle = subStyleProps(this.attributes, 'area');\n    const lineStyle = subStyleProps(this.attributes, 'line');\n    const { width } = this.containerShape;\n    const { data } = this;\n    if (data[0].length === 0) return { lines: [], areas: [] };\n    const { x, y } = this.scales as { x: Linear; y: Linear };\n    // 线条Path\n    const lines = dataToLines(data, { type: 'line', x, y });\n\n    // 生成区域path\n    let areas: any[] = [];\n    if (areaStyle) {\n      const { baseline } = this;\n      if (isStack) {\n        areas = smooth\n          ? linesToStackCurveAreaPaths(lines, width, baseline)\n          : linesToStackAreaPaths(lines, width, baseline);\n      } else {\n        areas = linesToAreaPaths(lines, smooth!, width, baseline);\n      }\n    }\n    return {\n      lines: lines.map((line, idx) => {\n        return {\n          stroke: this.getColor(idx),\n          d: smooth ? lineToCurvePath(line) : lineToLinePath(line),\n          ...lineStyle,\n        };\n      }) as any,\n      areas: areas.map((path, idx) => {\n        return {\n          d: path,\n          fill: this.getColor(idx),\n          ...areaStyle,\n        };\n      }),\n    };\n  }\n\n  private get columnsStyle(): ColumnsStyleProps {\n    const columnStyle = subStyleProps(this.attributes, 'column');\n    const { isStack, type, scale } = this.attributes;\n    if (type !== 'column') throw new Error('columnsStyle can only be used in column type');\n    const { height } = this.containerShape;\n    let { rawData: data } = this;\n    if (!data) return { columns: [] };\n    if (isStack) data = getStackedData(data);\n    const { x, y } = this.createScales(data) as { x: Band; y: Linear };\n    const [minVal, maxVal] = getRange(data);\n    const heightScale = new Linear({\n      domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],\n      range: [0, height * scale],\n    });\n\n    const bandWidth = x.getBandWidth();\n    const { rawData } = this;\n    return {\n      columns: data.map((column, i) => {\n        return column.map((val, j) => {\n          const barWidth = bandWidth / data.length;\n          const getShape = () => {\n            return {\n              x: x.map(j) + barWidth * i,\n              y: val >= 0 ? y.map(val) : y.map(0),\n              width: barWidth,\n              height: heightScale.map(Math.abs(val)),\n            };\n          };\n          const getStackShape = () => {\n            return {\n              x: x.map(j),\n              y: y.map(val),\n              width: bandWidth,\n              height: heightScale.map(rawData[i][j]),\n            };\n          };\n\n          return {\n            fill: this.getColor(i),\n            ...columnStyle,\n            ...(isStack ? getStackShape() : getShape()),\n          } as ColumnStyleProps;\n        });\n      }),\n    };\n  }\n\n  constructor(options: SparklineOptions) {\n    super(options, {\n      type: 'line',\n      x: 0,\n      y: 0,\n      width: 200,\n      height: 20,\n      isStack: false,\n      color: ['#83daad', '#edbf45', '#d2cef9', '#e290b3', '#6f63f4'],\n      smooth: true,\n      lineLineWidth: 1,\n      areaOpacity: 0,\n      isGroup: false,\n      columnLineWidth: 1,\n      columnStroke: '#fff',\n      scale: 1,\n      spacing: 0,\n    });\n  }\n\n  public render(attributes: Required<SparklineStyleProps>, container: Group) {\n    maybeAppend(container, '.container', 'rect').attr('className', 'container').node();\n\n    const { type, x, y } = attributes;\n    const className = `spark${type}`;\n    const style: any = {\n      x,\n      y,\n      ...(type === 'line' ? this.linesStyle : this.columnsStyle),\n    };\n\n    select(container)\n      .selectAll('.spark')\n      .data([type])\n      .join(\n        (enter) =>\n          enter\n            .append((type) => {\n              if (type === 'line') return new Lines({ className, style });\n              return new Columns({ className, style });\n            })\n            .attr('className', `spark ${className}`),\n        (update) => update.update(style),\n        (exit) => exit.remove()\n      );\n  }\n\n  /**\n   * 根据数据索引获取color\n   */\n  private getColor(index: number) {\n    const { color } = this.attributes;\n    if (isArray(color)) {\n      return color[index % color.length];\n    }\n    if (isFunction(color)) {\n      return color.call(null, index);\n    }\n    return color;\n  }\n\n  /**\n   * 根据数据生成scale\n   */\n  private createScales(data: number[][]) {\n    const { type, scale, range = [], spacing } = this.attributes;\n    const { width, height } = this.containerShape;\n    const [minVal, maxVal] = getRange(data);\n\n    const yScale = new Linear({\n      domain: [range[0] ?? minVal, range[1] ?? maxVal],\n      range: [height, height * (1 - scale)],\n    });\n\n    if (type === 'line') {\n      return {\n        type,\n        x: new Linear({\n          domain: [0, data[0].length - 1],\n          range: [0, width],\n        }),\n        y: yScale,\n      };\n    }\n\n    return {\n      type,\n      x: new Band({\n        domain: data[0].map((val, idx) => idx),\n        range: [0, width],\n        paddingInner: spacing,\n        paddingOuter: spacing / 2,\n        align: 0.5,\n      }),\n      y: yScale,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}