{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Category } from '@antv/component';\nimport { last } from '@antv/util';\nimport { format } from '@antv/vendor/d3-format';\nimport { Identity } from '@antv/scale';\nimport { useMarker } from '../utils/marker';\nimport { adaptor, domainOf, LegendCategoryLayout, inferComponentLayout, inferComponentShape, scaleOf, titleContent } from './utils';\nfunction inferShape(scales, markState) {\n  const shapeScale = scaleOf(scales, 'shape');\n  const colorScale = scaleOf(scales, 'color');\n  // NOTE!!!\n  // scaleOrdinal.map will mute domain.\n  const shapeScale1 = shapeScale ? shapeScale.clone() : null;\n  // Infer the main shape if multiple marks are used.\n  const shapes = [];\n  for (const [mark, state] of markState) {\n    const namespace = mark.type;\n    const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;\n    const shape = domain.map((d, i) => {\n      var _a;\n      if (shapeScale1) return shapeScale1.map(d || 'point');\n      return ((_a = mark === null || mark === void 0 ? void 0 : mark.style) === null || _a === void 0 ? void 0 : _a.shape) || state.defaultShape || 'point';\n    });\n    if (typeof namespace === 'string') shapes.push([namespace, shape]);\n  }\n  if (shapes.length === 0) return ['point', ['point']];\n  if (shapes.length === 1) return shapes[0];\n  if (!shapeScale) return shapes[0];\n  // Evaluate the maximum likelihood of shape\n  const {\n    range\n  } = shapeScale.getOptions();\n  return shapes.map(([namespace, shape]) => {\n    let sum = 0;\n    for (let i = 0; i < shapes.length; i++) {\n      const targetShape = range[i % range.length];\n      if (shape[i] === targetShape) sum++;\n    }\n    return [sum / shape.length, [namespace, shape]];\n  }).sort((a, b) => b[0] - a[0])[0][1];\n}\nfunction inferItemMarker(options, context) {\n  const {\n    scales,\n    library,\n    markState\n  } = context;\n  const [mark, shapes] = inferShape(scales, markState);\n  const {\n    itemMarker,\n    itemMarkerSize: size\n  } = options;\n  const create = (name, d) => {\n    var _a, _b, _c;\n    const marker = ((_c = (_b = (_a = library[`mark.${mark}`]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.shape[name]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name.split('.'));\n    const radius = typeof size === 'function' ? size(d) : size;\n    return () => useMarker(marker, {\n      color: d.color\n    })(0, 0, radius);\n  };\n  const shapeOf = i => `${shapes[i]}`;\n  const shapeScale = scaleOf(scales, 'shape');\n  if (shapeScale && !itemMarker) return (d, i) => create(shapeOf(i), d);\n  if (typeof itemMarker === 'function') {\n    return (d, i) => {\n      // @todo Fix this in GUI.\n      // It should pass primitive value rather object.\n      const node = itemMarker(d.id, i);\n      if (typeof node === 'string') return create(node, d);\n      return node;\n    };\n  }\n  return (d, i) => create(itemMarker || shapeOf(i), d);\n}\nfunction inferItemMarkerOpacity(scales) {\n  const scale = scaleOf(scales, 'opacity');\n  if (scale) {\n    const {\n      range\n    } = scale.getOptions();\n    return (d, i) => range[i];\n  }\n  return undefined;\n}\nfunction inferItemMarkerSize(scales, defaults) {\n  const scale = scaleOf(scales, 'size');\n  if (scale instanceof Identity) return scale.map(NaN) * 2;\n  return defaults;\n}\nfunction inferItemMarkerLineWidth(options, context) {\n  const {\n    scales,\n    markState\n  } = context;\n  const [mark, shapes] = inferShape(scales, markState);\n  const {\n    itemMarker,\n    itemMarkerLineWidth\n  } = options;\n  // If user explicitly set itemMarkerLineWidth, use it\n  if (itemMarkerLineWidth !== undefined) {\n    return itemMarkerLineWidth;\n  }\n  // Define line-based shapes that should have thicker line width\n  const lineShapes = ['line', 'hyphen', 'dash', 'smooth', 'hv', 'hvh', 'vh', 'vhv'];\n  // If itemMarker is explicitly set to a line shape\n  if (typeof itemMarker === 'string' && lineShapes.includes(itemMarker)) {\n    return 4;\n  }\n  // If itemMarker is a function, we need to return a function that checks each shape\n  if (typeof itemMarker === 'function') {\n    return (d, i) => {\n      const markerShape = itemMarker(d.id, i);\n      if (typeof markerShape === 'string' && lineShapes.includes(markerShape)) {\n        return 4;\n      }\n      return undefined;\n    };\n  }\n  // Check if any of the inferred shapes are line-based\n  const shapesArray = Array.isArray(shapes) ? shapes : [shapes];\n  const hasLineShape = shapesArray.some(shape => lineShapes.includes(shape));\n  if (hasLineShape) {\n    return 4;\n  }\n  return undefined;\n}\nfunction inferCategoryStyle(options, context) {\n  const {\n    labelFormatter = d => `${d}`\n  } = options;\n  const {\n    scales,\n    theme\n  } = context;\n  const defaultSize = theme.legendCategory.itemMarkerSize;\n  const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);\n  const baseStyle = {\n    itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), {\n      itemMarkerSize\n    }), context),\n    itemMarkerSize: itemMarkerSize,\n    itemMarkerOpacity: inferItemMarkerOpacity(scales),\n    itemMarkerLineWidth: inferItemMarkerLineWidth(options, context)\n  };\n  const finalLabelFormatter = typeof labelFormatter === 'string' ? format(labelFormatter) : labelFormatter;\n  const colorScale = scaleOf(scales, 'color');\n  const domain = domainOf(scales);\n  const colorOf = colorScale ? d => colorScale.map(d) : () => context.theme.color;\n  return Object.assign(Object.assign({}, baseStyle), {\n    data: domain.map(d => ({\n      id: d,\n      label: finalLabelFormatter(d),\n      color: colorOf(d)\n    }))\n  });\n}\nfunction inferLegendShape(value, options, component) {\n  const {\n    position\n  } = options;\n  if (position === 'center') {\n    const {\n      bbox\n    } = value;\n    // to be confirm: if position is center, we should use the width and height of user definition.\n    const {\n      width,\n      height\n    } = bbox;\n    return {\n      width,\n      height\n    };\n  }\n  const {\n    width,\n    height\n  } = inferComponentShape(value, options, component);\n  return {\n    width,\n    height\n  };\n}\nfunction filterEmptyIds(legendStyle) {\n  return Object.assign(Object.assign({}, legendStyle), {\n    data: (legendStyle === null || legendStyle === void 0 ? void 0 : legendStyle.data.filter(item => item.id !== '')) || []\n  });\n}\n/**\n * Guide Component for ordinal color scale.\n */\nexport const LegendCategory = options => {\n  const {\n      labelFormatter,\n      layout,\n      order,\n      orientation,\n      position,\n      size,\n      title,\n      cols,\n      itemMarker\n    } = options,\n    style = __rest(options, [\"labelFormatter\", \"layout\", \"order\", \"orientation\", \"position\", \"size\", \"title\", \"cols\", \"itemMarker\"]);\n  const {\n    gridRow\n  } = style;\n  return context => {\n    const {\n      value,\n      theme\n    } = context;\n    const {\n      bbox\n    } = value;\n    const {\n      width,\n      height\n    } = inferLegendShape(value, options, LegendCategory);\n    const finalLayout = inferComponentLayout(position, layout);\n    const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({\n      orientation: ['right', 'left', 'center'].includes(position) ? 'vertical' : 'horizontal',\n      width,\n      height,\n      layout: cols !== undefined ? 'grid' : 'flex'\n    }, cols !== undefined && {\n      gridCol: cols\n    }), gridRow !== undefined && {\n      gridRow\n    }), {\n      titleText: titleContent(title)\n    }), inferCategoryStyle(options, context));\n    const {\n      legendCategory: legendTheme = {}\n    } = theme;\n    // Filter out the data items with empty string IDs in the wordCloud's data before generating the legend.\n    const categoryStyle = adaptor(Object.assign({}, legendTheme, filterEmptyIds(legendStyle), style));\n    const layoutWrapper = new LegendCategoryLayout({\n      style: Object.assign(Object.assign({\n        x: bbox.x,\n        y: bbox.y,\n        width: bbox.width,\n        height: bbox.height\n      }, finalLayout), {\n        // @ts-ignore\n        subOptions: categoryStyle\n      })\n    });\n    layoutWrapper.appendChild(new Category({\n      className: 'legend-category',\n      style: categoryStyle\n    }));\n    return layoutWrapper;\n  };\n};\nLegendCategory.props = {\n  defaultPosition: 'top',\n  defaultOrder: 1,\n  defaultSize: 40,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12]\n};","map":{"version":3,"names":["Category","last","format","Identity","useMarker","adaptor","domainOf","LegendCategoryLayout","inferComponentLayout","inferComponentShape","scaleOf","titleContent","inferShape","scales","markState","shapeScale","colorScale","shapeScale1","clone","shapes","mark","state","namespace","type","domain","getOptions","length","data","shape","map","d","i","_a","style","defaultShape","push","range","sum","targetShape","sort","a","b","inferItemMarker","options","context","library","itemMarker","itemMarkerSize","size","create","name","marker","_c","_b","props","defaultMarker","split","radius","color","shapeOf","node","id","inferItemMarkerOpacity","scale","undefined","inferItemMarkerSize","defaults","NaN","inferItemMarkerLineWidth","itemMarkerLineWidth","lineShapes","includes","markerShape","shapesArray","Array","isArray","hasLineShape","some","inferCategoryStyle","labelFormatter","theme","defaultSize","legendCategory","baseStyle","Object","assign","itemMarkerOpacity","finalLabelFormatter","colorOf","label","inferLegendShape","value","component","position","bbox","width","height","filterEmptyIds","legendStyle","filter","item","LegendCategory","layout","order","orientation","title","cols","__rest","gridRow","finalLayout","gridCol","titleText","legendTheme","categoryStyle","layoutWrapper","x","y","subOptions","appendChild","className","defaultPosition","defaultOrder","defaultCrossPadding","defaultPadding"],"sources":["/Users/yizelu/Desktop/mcp/frontend/node_modules/@antv/g2/src/component/legendCategory.ts"],"sourcesContent":["import type { DisplayObject } from '@antv/g';\nimport { Category } from '@antv/component';\nimport { last } from '@antv/util';\nimport { format } from '@antv/vendor/d3-format';\nimport { Identity } from '@antv/scale';\nimport type {\n  FlexLayout,\n  G2MarkState,\n  GuideComponentComponent as GCC,\n  GuideComponentOrientation as GCO,\n  GuideComponentPosition as GCP,\n  Scale,\n} from '../runtime';\nimport { GuideComponentContext } from '../runtime/types/component';\nimport type { G2Mark } from '../runtime/types/options';\nimport { useMarker } from '../utils/marker';\nimport {\n  adaptor,\n  domainOf,\n  LegendCategoryLayout,\n  inferComponentLayout,\n  inferComponentShape,\n  scaleOf,\n  titleContent,\n} from './utils';\n\nexport type LegendCategoryOptions = {\n  dx?: number;\n  dy?: number;\n  labelFormatter?: (d: any) => string;\n  layout?: FlexLayout;\n  orientation?: GCO;\n  position?: GCP;\n  title?: string | string[];\n  [key: string]: any;\n};\n\nfunction inferShape(scales: Scale[], markState: Map<G2Mark, G2MarkState>) {\n  const shapeScale = scaleOf(scales, 'shape');\n  const colorScale = scaleOf(scales, 'color');\n\n  // NOTE!!!\n  // scaleOrdinal.map will mute domain.\n  const shapeScale1 = shapeScale ? shapeScale.clone() : null;\n\n  // Infer the main shape if multiple marks are used.\n  const shapes: [string, string[]][] = [];\n  for (const [mark, state] of markState) {\n    const namespace = mark.type;\n    const domain =\n      colorScale?.getOptions().domain.length > 0\n        ? colorScale?.getOptions().domain\n        : state.data;\n    const shape: string[] = domain.map((d, i) => {\n      if (shapeScale1) return shapeScale1.map(d || 'point');\n      return mark?.style?.shape || state.defaultShape || 'point';\n    });\n    if (typeof namespace === 'string') shapes.push([namespace, shape]);\n  }\n\n  if (shapes.length === 0) return ['point', ['point']];\n  if (shapes.length === 1) return shapes[0];\n  if (!shapeScale) return shapes[0];\n  // Evaluate the maximum likelihood of shape\n  const { range } = shapeScale.getOptions();\n  return shapes\n    .map(([namespace, shape]) => {\n      let sum = 0;\n      for (let i = 0; i < shapes.length; i++) {\n        const targetShape = range[i % range.length];\n        if (shape[i] === targetShape) sum++;\n      }\n      return [sum / shape.length, [namespace, shape]] as const;\n    })\n    .sort((a, b) => b[0] - a[0])[0][1];\n}\n\nfunction inferItemMarker(\n  options,\n  context: GuideComponentContext,\n): ((datum: any, i: number, data: any) => () => DisplayObject) | undefined {\n  const { scales, library, markState } = context;\n  const [mark, shapes] = inferShape(scales, markState);\n  const { itemMarker, itemMarkerSize: size } = options;\n\n  const create = (name, d) => {\n    const marker =\n      (library[`mark.${mark}`]?.props?.shape[name]?.props\n        .defaultMarker as string) || last(name.split('.'));\n    const radius = typeof size === 'function' ? size(d) : size;\n    return () => useMarker(marker, { color: d.color })(0, 0, radius);\n  };\n\n  const shapeOf = (i) => `${shapes[i]}`;\n\n  const shapeScale = scaleOf(scales, 'shape');\n  if (shapeScale && !itemMarker) return (d, i) => create(shapeOf(i), d);\n  if (typeof itemMarker === 'function') {\n    return (d, i) => {\n      // @todo Fix this in GUI.\n      // It should pass primitive value rather object.\n      const node = itemMarker(d.id, i);\n      if (typeof node === 'string') return create(node, d);\n      return node;\n    };\n  }\n  return (d, i) => create(itemMarker || shapeOf(i), d);\n}\n\nfunction inferItemMarkerOpacity(scales: Scale[]) {\n  const scale = scaleOf(scales, 'opacity');\n  if (scale) {\n    const { range } = scale.getOptions();\n    return (d, i) => range[i];\n  }\n  return undefined;\n}\n\nfunction inferItemMarkerSize(scales: Scale[], defaults: number) {\n  const scale = scaleOf(scales, 'size');\n  if (scale instanceof Identity) return scale.map(NaN) * 2;\n  return defaults;\n}\n\nfunction inferItemMarkerLineWidth(options, context: GuideComponentContext) {\n  const { scales, markState } = context;\n  const [mark, shapes] = inferShape(scales, markState);\n  const { itemMarker, itemMarkerLineWidth } = options;\n\n  // If user explicitly set itemMarkerLineWidth, use it\n  if (itemMarkerLineWidth !== undefined) {\n    return itemMarkerLineWidth;\n  }\n\n  // Define line-based shapes that should have thicker line width\n  const lineShapes = [\n    'line',\n    'hyphen',\n    'dash',\n    'smooth',\n    'hv',\n    'hvh',\n    'vh',\n    'vhv',\n  ];\n\n  // If itemMarker is explicitly set to a line shape\n  if (typeof itemMarker === 'string' && lineShapes.includes(itemMarker)) {\n    return 4;\n  }\n\n  // If itemMarker is a function, we need to return a function that checks each shape\n  if (typeof itemMarker === 'function') {\n    return (d, i) => {\n      const markerShape = itemMarker(d.id, i);\n      if (typeof markerShape === 'string' && lineShapes.includes(markerShape)) {\n        return 4;\n      }\n      return undefined;\n    };\n  }\n\n  // Check if any of the inferred shapes are line-based\n  const shapesArray = Array.isArray(shapes) ? shapes : [shapes];\n  const hasLineShape = shapesArray.some((shape) => lineShapes.includes(shape));\n  if (hasLineShape) {\n    return 4;\n  }\n\n  return undefined;\n}\n\nfunction inferCategoryStyle(options, context: GuideComponentContext) {\n  const { labelFormatter = (d) => `${d}` } = options;\n  const { scales, theme } = context;\n  const defaultSize = theme.legendCategory.itemMarkerSize;\n  const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);\n  const baseStyle = {\n    itemMarker: inferItemMarker({ ...options, itemMarkerSize }, context),\n    itemMarkerSize: itemMarkerSize,\n    itemMarkerOpacity: inferItemMarkerOpacity(scales),\n    itemMarkerLineWidth: inferItemMarkerLineWidth(options, context),\n  };\n\n  const finalLabelFormatter =\n    typeof labelFormatter === 'string'\n      ? format(labelFormatter)\n      : labelFormatter;\n\n  const colorScale = scaleOf(scales, 'color');\n  const domain = domainOf(scales);\n  const colorOf = colorScale\n    ? (d) => colorScale.map(d)\n    : () => context.theme.color;\n\n  return {\n    ...baseStyle,\n    data: domain.map((d) => ({\n      id: d,\n      label: finalLabelFormatter(d),\n      color: colorOf(d),\n    })),\n  };\n}\n\nfunction inferLegendShape(\n  value: Record<string, any>,\n  options: LegendCategoryOptions,\n  component: GCC,\n) {\n  const { position } = options;\n  if (position === 'center') {\n    const { bbox } = value;\n    // to be confirm: if position is center, we should use the width and height of user definition.\n    const { width, height } = bbox;\n    return { width, height };\n  }\n  const { width, height } = inferComponentShape(value, options, component);\n  return { width, height };\n}\n\nfunction filterEmptyIds(legendStyle) {\n  return {\n    ...legendStyle,\n    data: legendStyle?.data.filter((item) => item.id !== '') || [],\n  };\n}\n\n/**\n * Guide Component for ordinal color scale.\n */\nexport const LegendCategory: GCC<LegendCategoryOptions> = (options) => {\n  const {\n    labelFormatter,\n    layout,\n    order,\n    orientation,\n    position,\n    size,\n    title,\n    cols,\n    itemMarker,\n    ...style\n  } = options;\n\n  const { gridRow } = style;\n\n  return (context) => {\n    const { value, theme } = context;\n    const { bbox } = value;\n    const { width, height } = inferLegendShape(value, options, LegendCategory);\n\n    const finalLayout = inferComponentLayout(position, layout);\n\n    const legendStyle = {\n      orientation: ['right', 'left', 'center'].includes(position)\n        ? 'vertical'\n        : 'horizontal',\n      width,\n      height,\n      layout: cols !== undefined ? 'grid' : 'flex',\n      ...(cols !== undefined && { gridCol: cols }),\n      ...(gridRow !== undefined && { gridRow }),\n      titleText: titleContent(title),\n      ...inferCategoryStyle(options, context),\n    };\n\n    const { legendCategory: legendTheme = {} } = theme;\n\n    // Filter out the data items with empty string IDs in the wordCloud's data before generating the legend.\n    const categoryStyle = adaptor(\n      Object.assign({}, legendTheme, filterEmptyIds(legendStyle), style),\n    );\n\n    const layoutWrapper = new LegendCategoryLayout({\n      style: {\n        x: bbox.x,\n        y: bbox.y,\n        width: bbox.width,\n        height: bbox.height,\n        ...finalLayout,\n        // @ts-ignore\n        subOptions: categoryStyle,\n      },\n    });\n\n    layoutWrapper.appendChild(\n      new Category({\n        className: 'legend-category',\n        style: categoryStyle,\n      }),\n    );\n\n    return layoutWrapper as unknown as DisplayObject;\n  };\n};\n\nLegendCategory.props = {\n  defaultPosition: 'top',\n  defaultOrder: 1,\n  defaultSize: 40,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12],\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}